--
-- PostgreSQL database dump
--

-- Dumped from database version 9.6.5
-- Dumped by pg_dump version 9.6.5

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: pgagent; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA pgagent;


ALTER SCHEMA pgagent OWNER TO postgres;

--
-- Name: SCHEMA pgagent; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA pgagent IS 'pgAgent system tables';


--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = public, pg_catalog;

--
-- Name: gbtreekey16; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gbtreekey16;


--
-- Name: gbtreekey16_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbtreekey16_in(cstring) RETURNS gbtreekey16
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_in';


ALTER FUNCTION public.gbtreekey16_in(cstring) OWNER TO postgres;

--
-- Name: gbtreekey16_out(gbtreekey16); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbtreekey16_out(gbtreekey16) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_out';


ALTER FUNCTION public.gbtreekey16_out(gbtreekey16) OWNER TO postgres;

--
-- Name: gbtreekey16; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gbtreekey16 (
    INTERNALLENGTH = 16,
    INPUT = gbtreekey16_in,
    OUTPUT = gbtreekey16_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE gbtreekey16 OWNER TO postgres;

--
-- Name: gbtreekey32; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gbtreekey32;


--
-- Name: gbtreekey32_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbtreekey32_in(cstring) RETURNS gbtreekey32
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_in';


ALTER FUNCTION public.gbtreekey32_in(cstring) OWNER TO postgres;

--
-- Name: gbtreekey32_out(gbtreekey32); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbtreekey32_out(gbtreekey32) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_out';


ALTER FUNCTION public.gbtreekey32_out(gbtreekey32) OWNER TO postgres;

--
-- Name: gbtreekey32; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gbtreekey32 (
    INTERNALLENGTH = 32,
    INPUT = gbtreekey32_in,
    OUTPUT = gbtreekey32_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE gbtreekey32 OWNER TO postgres;

--
-- Name: gbtreekey4; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gbtreekey4;


--
-- Name: gbtreekey4_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbtreekey4_in(cstring) RETURNS gbtreekey4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_in';


ALTER FUNCTION public.gbtreekey4_in(cstring) OWNER TO postgres;

--
-- Name: gbtreekey4_out(gbtreekey4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbtreekey4_out(gbtreekey4) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_out';


ALTER FUNCTION public.gbtreekey4_out(gbtreekey4) OWNER TO postgres;

--
-- Name: gbtreekey4; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gbtreekey4 (
    INTERNALLENGTH = 4,
    INPUT = gbtreekey4_in,
    OUTPUT = gbtreekey4_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE gbtreekey4 OWNER TO postgres;

--
-- Name: gbtreekey8; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gbtreekey8;


--
-- Name: gbtreekey8_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbtreekey8_in(cstring) RETURNS gbtreekey8
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_in';


ALTER FUNCTION public.gbtreekey8_in(cstring) OWNER TO postgres;

--
-- Name: gbtreekey8_out(gbtreekey8); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbtreekey8_out(gbtreekey8) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_out';


ALTER FUNCTION public.gbtreekey8_out(gbtreekey8) OWNER TO postgres;

--
-- Name: gbtreekey8; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gbtreekey8 (
    INTERNALLENGTH = 8,
    INPUT = gbtreekey8_in,
    OUTPUT = gbtreekey8_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE gbtreekey8 OWNER TO postgres;

--
-- Name: gbtreekey_var; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gbtreekey_var;


--
-- Name: gbtreekey_var_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbtreekey_var_in(cstring) RETURNS gbtreekey_var
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_in';


ALTER FUNCTION public.gbtreekey_var_in(cstring) OWNER TO postgres;

--
-- Name: gbtreekey_var_out(gbtreekey_var); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbtreekey_var_out(gbtreekey_var) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_out';


ALTER FUNCTION public.gbtreekey_var_out(gbtreekey_var) OWNER TO postgres;

--
-- Name: gbtreekey_var; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE gbtreekey_var (
    INTERNALLENGTH = variable,
    INPUT = gbtreekey_var_in,
    OUTPUT = gbtreekey_var_out,
    ALIGNMENT = int4,
    STORAGE = extended
);


ALTER TYPE gbtreekey_var OWNER TO postgres;

--
-- Name: ip4; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE ip4;


--
-- Name: ip4_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_in(cstring) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_in';


ALTER FUNCTION public.ip4_in(cstring) OWNER TO postgres;

--
-- Name: ip4_out(ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_out(ip4) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_out';


ALTER FUNCTION public.ip4_out(ip4) OWNER TO postgres;

--
-- Name: ip4_recv(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_recv(internal) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_recv';


ALTER FUNCTION public.ip4_recv(internal) OWNER TO postgres;

--
-- Name: ip4_send(ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_send(ip4) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_send';


ALTER FUNCTION public.ip4_send(ip4) OWNER TO postgres;

--
-- Name: ip4; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE ip4 (
    INTERNALLENGTH = 4,
    INPUT = ip4_in,
    OUTPUT = ip4_out,
    RECEIVE = ip4_recv,
    SEND = ip4_send,
    ALIGNMENT = int4,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE ip4 OWNER TO postgres;

--
-- Name: TYPE ip4; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE ip4 IS 'IPv4 address ''#.#.#.#''';


--
-- Name: ip4r; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE ip4r;


--
-- Name: ip4r_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_in(cstring) RETURNS ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_in';


ALTER FUNCTION public.ip4r_in(cstring) OWNER TO postgres;

--
-- Name: ip4r_out(ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_out(ip4r) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_out';


ALTER FUNCTION public.ip4r_out(ip4r) OWNER TO postgres;

--
-- Name: ip4r_recv(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_recv(internal) RETURNS ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_recv';


ALTER FUNCTION public.ip4r_recv(internal) OWNER TO postgres;

--
-- Name: ip4r_send(ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_send(ip4r) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_send';


ALTER FUNCTION public.ip4r_send(ip4r) OWNER TO postgres;

--
-- Name: ip4r; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE ip4r (
    INTERNALLENGTH = 8,
    INPUT = ip4r_in,
    OUTPUT = ip4r_out,
    RECEIVE = ip4r_recv,
    SEND = ip4r_send,
    ELEMENT = ip4,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE ip4r OWNER TO postgres;

--
-- Name: TYPE ip4r; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE ip4r IS 'IPv4 range ''#.#.#.#-#.#.#.#'' or ''#.#.#.#/#'' or ''#.#.#.#''';


--
-- Name: numtype; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE numtype AS (
	num numeric,
	count integer
);


ALTER TYPE numtype OWNER TO postgres;

--
-- Name: prefix_range; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE prefix_range;


--
-- Name: prefix_range_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_in(cstring) RETURNS prefix_range
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_in';


ALTER FUNCTION public.prefix_range_in(cstring) OWNER TO postgres;

--
-- Name: prefix_range_out(prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_out(prefix_range) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_out';


ALTER FUNCTION public.prefix_range_out(prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_recv(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_recv(internal) RETURNS prefix_range
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_recv';


ALTER FUNCTION public.prefix_range_recv(internal) OWNER TO postgres;

--
-- Name: prefix_range_send(prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_send(prefix_range) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_send';


ALTER FUNCTION public.prefix_range_send(prefix_range) OWNER TO postgres;

--
-- Name: prefix_range; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE prefix_range (
    INTERNALLENGTH = variable,
    INPUT = prefix_range_in,
    OUTPUT = prefix_range_out,
    RECEIVE = prefix_range_recv,
    SEND = prefix_range_send,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE prefix_range OWNER TO postgres;

--
-- Name: TYPE prefix_range; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE prefix_range IS 'prefix range: (prefix)?([a-b])?';


--
-- Name: summmaryreporttype; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE summmaryreporttype AS (
	acd_24h bigint,
	pdd_24h bigint,
	asr_24h numeric,
	ca_24h bigint,
	res_id text
);


ALTER TYPE summmaryreporttype OWNER TO postgres;

--
-- Name: TYPE summmaryreporttype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE summmaryreporttype IS 'ç»Ÿè®¡æŠ¥è¡¨ç±»åž‹';


--
-- Name: sumtype; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE sumtype AS (
	year integer,
	month integer,
	day integer,
	hour integer,
	minute integer,
	callvalue numeric,
	cpsvalue numeric
);


ALTER TYPE sumtype OWNER TO postgres;

--
-- Name: tablefunc_crosstab_2; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE tablefunc_crosstab_2 AS (
	row_name text,
	category_1 text,
	category_2 text
);


ALTER TYPE tablefunc_crosstab_2 OWNER TO postgres;

--
-- Name: tablefunc_crosstab_3; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE tablefunc_crosstab_3 AS (
	row_name text,
	category_1 text,
	category_2 text,
	category_3 text
);


ALTER TYPE tablefunc_crosstab_3 OWNER TO postgres;

--
-- Name: tablefunc_crosstab_4; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE tablefunc_crosstab_4 AS (
	row_name text,
	category_1 text,
	category_2 text,
	category_3 text,
	category_4 text
);


ALTER TYPE tablefunc_crosstab_4 OWNER TO postgres;

SET search_path = pgagent, pg_catalog;

--
-- Name: pga_exception_trigger(); Type: FUNCTION; Schema: pgagent; Owner: postgres
--

CREATE FUNCTION pga_exception_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE

    jobid int4 := 0;

BEGIN

     IF TG_OP = 'DELETE' THEN

        SELECT INTO jobid jscjobid FROM pgagent.pga_schedule WHERE jscid = OLD.jexscid;

        -- update pga_job from remaining schedules
        -- the actual calculation of jobnextrun will be performed in the trigger
        UPDATE pgagent.pga_job
           SET jobnextrun = NULL
         WHERE jobenabled AND jobid=jobid;
        RETURN OLD;
    ELSE

        SELECT INTO jobid jscjobid FROM pgagent.pga_schedule WHERE jscid = NEW.jexscid;

        UPDATE pgagent.pga_job
           SET jobnextrun = NULL
         WHERE jobenabled AND jobid=jobid;
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION pgagent.pga_exception_trigger() OWNER TO postgres;

--
-- Name: FUNCTION pga_exception_trigger(); Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON FUNCTION pga_exception_trigger() IS 'Update the job''s next run time whenever an exception changes';


--
-- Name: pga_is_leap_year(smallint); Type: FUNCTION; Schema: pgagent; Owner: postgres
--

CREATE FUNCTION pga_is_leap_year(smallint) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
BEGIN
    IF $1 % 4 != 0 THEN
        RETURN FALSE;
    END IF;

    IF $1 % 100 != 0 THEN
        RETURN TRUE;
    END IF;

    RETURN $1 % 400 = 0;
END;
$_$;


ALTER FUNCTION pgagent.pga_is_leap_year(smallint) OWNER TO postgres;

--
-- Name: FUNCTION pga_is_leap_year(smallint); Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON FUNCTION pga_is_leap_year(smallint) IS 'Returns TRUE is $1 is a leap year';


--
-- Name: pga_job_trigger(); Type: FUNCTION; Schema: pgagent; Owner: postgres
--

CREATE FUNCTION pga_job_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.jobenabled THEN
        IF NEW.jobnextrun IS NULL THEN
             SELECT INTO NEW.jobnextrun
                    MIN(pgagent.pga_next_schedule(jscid, jscstart, jscend, jscminutes, jschours, jscweekdays, jscmonthdays, jscmonths))
               FROM pgagent.pga_schedule
              WHERE jscenabled AND jscjobid=OLD.jobid;
        END IF;
    ELSE
        NEW.jobnextrun := NULL;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION pgagent.pga_job_trigger() OWNER TO postgres;

--
-- Name: FUNCTION pga_job_trigger(); Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON FUNCTION pga_job_trigger() IS 'Update the job''s next run time.';


--
-- Name: pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]); Type: FUNCTION; Schema: pgagent; Owner: postgres
--

CREATE FUNCTION pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
DECLARE
    jscid           ALIAS FOR $1;
    jscstart        ALIAS FOR $2;
    jscend          ALIAS FOR $3;
    jscminutes      ALIAS FOR $4;
    jschours        ALIAS FOR $5;
    jscweekdays     ALIAS FOR $6;
    jscmonthdays    ALIAS FOR $7;
    jscmonths       ALIAS FOR $8;

    nextrun         timestamp := '1970-01-01 00:00:00-00';
    runafter        timestamp := '1970-01-01 00:00:00-00';

    bingo            bool := FALSE;
    gotit            bool := FALSE;
    foundval        bool := FALSE;
    daytweak        bool := FALSE;
    minutetweak        bool := FALSE;

    i                int2 := 0;
    d                int2 := 0;

    nextminute        int2 := 0;
    nexthour        int2 := 0;
    nextday            int2 := 0;
    nextmonth       int2 := 0;
    nextyear        int2 := 0;


BEGIN
    -- No valid start date has been specified
    IF jscstart IS NULL THEN RETURN NULL; END IF;

    -- The schedule is past its end date
    IF jscend IS NOT NULL AND jscend < now() THEN RETURN NULL; END IF;

    -- Get the time to find the next run after. It will just be the later of
    -- now() + 1m and the start date for the time being, however, we might want to
    -- do more complex things using this value in the future.
    IF date_trunc('MINUTE', jscstart) > date_trunc('MINUTE', (now() + '1 Minute'::interval)) THEN
        runafter := date_trunc('MINUTE', jscstart);
    ELSE
        runafter := date_trunc('MINUTE', (now() + '1 Minute'::interval));
    END IF;

    --
    -- Enter a loop, generating next run timestamps until we find one
    -- that falls on the required weekday, and is not matched by an exception
    --

    WHILE bingo = FALSE LOOP

        --
        -- Get the next run year
        --
        nextyear := date_part('YEAR', runafter);

        --
        -- Get the next run month
        --
        nextmonth := date_part('MONTH', runafter);
        gotit := FALSE;
        FOR i IN (nextmonth) .. 12 LOOP
            IF jscmonths[i] = TRUE THEN
                nextmonth := i;
                gotit := TRUE;
                foundval := TRUE;
                EXIT;
            END IF;
        END LOOP;
        IF gotit = FALSE THEN
            FOR i IN 1 .. (nextmonth - 1) LOOP
                IF jscmonths[i] = TRUE THEN
                    nextmonth := i;

                    -- Wrap into next year
                    nextyear := nextyear + 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
           END LOOP;
        END IF;

        --
        -- Get the next run day
        --
        -- If the year, or month have incremented, get the lowest day,
        -- otherwise look for the next day matching or after today.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter)) THEN
            nextday := 1;
            FOR i IN 1 .. 32 LOOP
                IF jscmonthdays[i] = TRUE THEN
                    nextday := i;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nextday := date_part('DAY', runafter);
            gotit := FALSE;
            FOR i IN nextday .. 32 LOOP
                IF jscmonthdays[i] = TRUE THEN
                    nextday := i;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. (nextday - 1) LOOP
                    IF jscmonthdays[i] = TRUE THEN
                        nextday := i;

                        -- Wrap into next month
                        IF nextmonth = 12 THEN
                            nextyear := nextyear + 1;
                            nextmonth := 1;
                        ELSE
                            nextmonth := nextmonth + 1;
                        END IF;
                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        -- Was the last day flag selected?
        IF nextday = 32 THEN
            IF nextmonth = 1 THEN
                nextday := 31;
            ELSIF nextmonth = 2 THEN
                IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                    nextday := 29;
                ELSE
                    nextday := 28;
                END IF;
            ELSIF nextmonth = 3 THEN
                nextday := 31;
            ELSIF nextmonth = 4 THEN
                nextday := 30;
            ELSIF nextmonth = 5 THEN
                nextday := 31;
            ELSIF nextmonth = 6 THEN
                nextday := 30;
            ELSIF nextmonth = 7 THEN
                nextday := 31;
            ELSIF nextmonth = 8 THEN
                nextday := 31;
            ELSIF nextmonth = 9 THEN
                nextday := 30;
            ELSIF nextmonth = 10 THEN
                nextday := 31;
            ELSIF nextmonth = 11 THEN
                nextday := 30;
            ELSIF nextmonth = 12 THEN
                nextday := 31;
            END IF;
        END IF;

        --
        -- Get the next run hour
        --
        -- If the year, month or day have incremented, get the lowest hour,
        -- otherwise look for the next hour matching or after the current one.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter) OR nextday > date_part('DAY', runafter) OR daytweak = TRUE) THEN
            nexthour := 0;
            FOR i IN 1 .. 24 LOOP
                IF jschours[i] = TRUE THEN
                    nexthour := i - 1;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nexthour := date_part('HOUR', runafter);
            gotit := FALSE;
            FOR i IN (nexthour + 1) .. 24 LOOP
                IF jschours[i] = TRUE THEN
                    nexthour := i - 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. nexthour LOOP
                    IF jschours[i] = TRUE THEN
                        nexthour := i - 1;

                        -- Wrap into next month
                        IF (nextmonth = 1 OR nextmonth = 3 OR nextmonth = 5 OR nextmonth = 7 OR nextmonth = 8 OR nextmonth = 10 OR nextmonth = 12) THEN
                            d = 31;
                        ELSIF (nextmonth = 4 OR nextmonth = 6 OR nextmonth = 9 OR nextmonth = 11) THEN
                            d = 30;
                        ELSE
                            IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                                d := 29;
                            ELSE
                                d := 28;
                            END IF;
                        END IF;

                        IF nextday = d THEN
                            nextday := 1;
                            IF nextmonth = 12 THEN
                                nextyear := nextyear + 1;
                                nextmonth := 1;
                            ELSE
                                nextmonth := nextmonth + 1;
                            END IF;
                        ELSE
                            nextday := nextday + 1;
                        END IF;

                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        --
        -- Get the next run minute
        --
        -- If the year, month day or hour have incremented, get the lowest minute,
        -- otherwise look for the next minute matching or after the current one.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter) OR nextday > date_part('DAY', runafter) OR nexthour > date_part('HOUR', runafter) OR daytweak = TRUE) THEN
            nextminute := 0;
            IF minutetweak = TRUE THEN
        d := 1;
            ELSE
        d := date_part('YEAR', runafter)::int2;
            END IF;
            FOR i IN d .. 60 LOOP
                IF jscminutes[i] = TRUE THEN
                    nextminute := i - 1;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nextminute := date_part('MINUTE', runafter);
            gotit := FALSE;
            FOR i IN (nextminute + 1) .. 60 LOOP
                IF jscminutes[i] = TRUE THEN
                    nextminute := i - 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. nextminute LOOP
                    IF jscminutes[i] = TRUE THEN
                        nextminute := i - 1;

                        -- Wrap into next hour
                        IF (nextmonth = 1 OR nextmonth = 3 OR nextmonth = 5 OR nextmonth = 7 OR nextmonth = 8 OR nextmonth = 10 OR nextmonth = 12) THEN
                            d = 31;
                        ELSIF (nextmonth = 4 OR nextmonth = 6 OR nextmonth = 9 OR nextmonth = 11) THEN
                            d = 30;
                        ELSE
                            IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                                d := 29;
                            ELSE
                                d := 28;
                            END IF;
                        END IF;

                        IF nexthour = 23 THEN
                            nexthour = 0;
                            IF nextday = d THEN
                                nextday := 1;
                                IF nextmonth = 12 THEN
                                    nextyear := nextyear + 1;
                                    nextmonth := 1;
                                ELSE
                                    nextmonth := nextmonth + 1;
                                END IF;
                            ELSE
                                nextday := nextday + 1;
                            END IF;
                        ELSE
                            nexthour := nexthour + 1;
                        END IF;

                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        -- Build the result, and check it is not the same as runafter - this may
        -- happen if all array entries are set to false. In this case, add a minute.

        nextrun := (nextyear::varchar || '-'::varchar || nextmonth::varchar || '-' || nextday::varchar || ' ' || nexthour::varchar || ':' || nextminute::varchar)::timestamptz;

        IF nextrun = runafter AND foundval = FALSE THEN
                nextrun := nextrun + INTERVAL '1 Minute';
        END IF;

        -- If the result is past the end date, exit.
        IF nextrun > jscend THEN
            RETURN NULL;
        END IF;

        -- Check to ensure that the nextrun time is actually still valid. Its
        -- possible that wrapped values may have carried the nextrun onto an
        -- invalid time or date.
        IF ((jscminutes = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jscminutes[date_part('MINUTE', nextrun) + 1] = TRUE) AND
            (jschours = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jschours[date_part('HOUR', nextrun) + 1] = TRUE) AND
            (jscmonthdays = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jscmonthdays[date_part('DAY', nextrun)] = TRUE OR
            (jscmonthdays = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,t}' AND
             ((date_part('MONTH', nextrun) IN (1,3,5,7,8,10,12) AND date_part('DAY', nextrun) = 31) OR
              (date_part('MONTH', nextrun) IN (4,6,9,11) AND date_part('DAY', nextrun) = 30) OR
              (date_part('MONTH', nextrun) = 2 AND ((pgagent.pga_is_leap_year(date_part('DAY', nextrun)::int2) AND date_part('DAY', nextrun) = 29) OR date_part('DAY', nextrun) = 28))))) AND
            (jscmonths = '{f,f,f,f,f,f,f,f,f,f,f,f}' OR jscmonths[date_part('MONTH', nextrun)] = TRUE)) THEN


            -- Now, check to see if the nextrun time found is a) on an acceptable
            -- weekday, and b) not matched by an exception. If not, set
            -- runafter = nextrun and try again.

            -- Check for a wildcard weekday
            gotit := FALSE;
            FOR i IN 1 .. 7 LOOP
                IF jscweekdays[i] = TRUE THEN
                    gotit := TRUE;
                    EXIT;
                END IF;
            END LOOP;

            -- OK, is the correct weekday selected, or a wildcard?
            IF (jscweekdays[date_part('DOW', nextrun) + 1] = TRUE OR gotit = FALSE) THEN

                -- Check for exceptions
                SELECT INTO d jexid FROM pgagent.pga_exception WHERE jexscid = jscid AND ((jexdate = nextrun::date AND jextime = nextrun::time) OR (jexdate = nextrun::date AND jextime IS NULL) OR (jexdate IS NULL AND jextime = nextrun::time));
                IF FOUND THEN
                    -- Nuts - found an exception. Increment the time and try again
                    runafter := nextrun + INTERVAL '1 Minute';
                    bingo := FALSE;
                    minutetweak := TRUE;
            daytweak := FALSE;
                ELSE
                    bingo := TRUE;
                END IF;
            ELSE
                -- We're on the wrong week day - increment a day and try again.
                runafter := nextrun + INTERVAL '1 Day';
                bingo := FALSE;
                minutetweak := FALSE;
                daytweak := TRUE;
            END IF;

        ELSE
            runafter := nextrun + INTERVAL '1 Minute';
            bingo := FALSE;
            minutetweak := TRUE;
        daytweak := FALSE;
        END IF;

    END LOOP;

    RETURN nextrun;
END;
$_$;


ALTER FUNCTION pgagent.pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]) OWNER TO postgres;

--
-- Name: FUNCTION pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]); Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON FUNCTION pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]) IS 'Calculates the next runtime for a given schedule';


--
-- Name: pga_schedule_trigger(); Type: FUNCTION; Schema: pgagent; Owner: postgres
--

CREATE FUNCTION pga_schedule_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        -- update pga_job from remaining schedules
        -- the actual calculation of jobnextrun will be performed in the trigger
        UPDATE pgagent.pga_job
           SET jobnextrun = NULL
         WHERE jobenabled AND jobid=OLD.jscjobid;
        RETURN OLD;
    ELSE
        UPDATE pgagent.pga_job
           SET jobnextrun = NULL
         WHERE jobenabled AND jobid=NEW.jscjobid;
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION pgagent.pga_schedule_trigger() OWNER TO postgres;

--
-- Name: FUNCTION pga_schedule_trigger(); Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON FUNCTION pga_schedule_trigger() IS 'Update the job''s next run time whenever a schedule changes';


SET search_path = public, pg_catalog;

--
-- Name: actual_trans(timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION actual_trans(timestamp with time zone, timestamp with time zone, integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	start_time alias for $1;
	end_time alias for $2;
	id_client alias for $3;
	trans_type alias for $4;
	r record;
	invoice_start_time timestamp with time zone;
	invoice_end_time timestamp with time zone;
	cdr_start_time timestamp with time zone;
	cdr_end_time timestamp with time zone;

begin

	--if id_client > 0 then
		--invoice_start_time := 0;
		--invoice_end_time := 0;
		--cdr_start_time := 0;
		--cdr_end_time := 0;
	--end if;

	if trans_type = 0 then --all

	if id_client = 0 then
		for r in
		select
		payment_time::text,
		(case payment_type
		when 4 then 1
		when 5 then 1
		when 3 then 2
		when 6 then 2
		when 7 then 5
		when 8 then 6
		when 9 then 9
		when 11 then 7
		when 12 then 8
		when 15 then 12
		end)::text as t_type,
		client_id::text,
		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
		from client_payment
		where payment_type in (3,4,5,6,7,8,9,11,12,15) and
		payment_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--(case type
		--when 0 then 4
		--when 2 then 4
		--end)::text as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where state=9 and type in (0,2) and
		--invoice_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--'3' as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where type = 3 and
		--invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select
		payment_time::text,
		(case payment_type
		when 4 then 1
		when 5 then 1
		when 3 then 2
		when 6 then 2
		when 7 then 5
		when 8 then 6
		when 9 then 9
		when 11 then 7
		when 12 then 8
		when 15 then 12
		end)::text as t_type,
		client_id::text,
		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
		from client_payment
		where payment_type in (3,4,5,6,7,8,9,11,12,15) and client_id=id_client and
		payment_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--(case type
		--when 0 then 4
		--when 2 then 4
		--end)::text as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where state=9 and type in (0,2) and client_id=id_client and
		--invoice_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--'3' as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where type = 3 and client_id=id_client and
		--invoice_time between start_time and end_time
		--union
		--select time::date::text,10::text,id_client::text,sum(egress_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client::text group by time::date
		--union
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client::text group by time::date
		union
		--select time::date::text,10::text,id_client::text,sum(egress_cost)::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client group by time::date
		select to_char(report_time, 'YYYY-MM-DD 23:59:59')::text,10::text,id_client::text,sum(egress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and egress_client_id=id_client group by to_char(report_time, 'YYYY-MM-DD 23:59:59')
		union
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost)::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client group by time::date
		select to_char(report_time, 'YYYY-MM-DD 23:59:59')::text,11::text,id_client::text,sum(ingress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and ingress_client_id=id_client group by to_char(report_time, 'YYYY-MM-DD 23:59:59')
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 12 then --scc cost

	if id_client=0 then
		for r in
		select payment_time::text,12::text,client_id::text,amount::text from client_payment where (payment_type=15)
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,12::text,client_id::text,amount::text from client_payment where (payment_type=15)
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 1 then --payment received

	if id_client=0 then
		for r in
		select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 2 then --payment sent

	if id_client=0 then
		for r in
		select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	--elsif trans_type = 3 then --invoice received

	--if id_client=0 then
	--	for r in
	--	select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
	--	and invoice_time between start_time and end_time
	--	loop
	--		return next r;
	--	end loop;
	--else
	--	for r in
	--	select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
	--	and invoice_time between start_time and end_time and client_id=id_client
	--	loop
	--		return next r;
	--	end loop;
	--end if;
	--elsif trans_type = 4 then --invoice sent

	--if id_client=0 then
	--	for r in
	--	select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
	--	and invoice_time between start_time and end_time
	--	loop
	--		return next r;
	--	end loop;
	--else
	--	for r in
	--	select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
	--	and invoice_time between start_time and end_time and client_id=id_client
	--	loop
	--		return next r;
	--	end loop;
	--end if;
	elsif trans_type = 5 then --credit note received

	if id_client=0 then
		for r in
		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 6 then --credit note sent

	if id_client=0 then
		for r in
		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 7 then --debit note received

	if id_client=0 then
		for r in
		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 8 then --debit note sent

	if id_client=0 then
		for r in
		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 9 then --reset

	if id_client=0 then
		for r in
		select payment_time::text,9::text,client_id::text,(coalesce(amount,0)+coalesce(egress_amount,0))::text from client_payment where payment_type=9
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,9::text,client_id::text,(coalesce(amount,0)+coalesce(egress_amount,0))::text from client_payment where payment_type=9
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 10 then --egress cdr cost

	if id_client=0 then
		return;
	else
		for r in
		--select time::date::text,10::text,id_client::text,sum(egress_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client::text group by time::date
		--select time::date::text,10::text,id_client::text,sum(egress_cost)::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client group by time::date
		select to_char(report_time, 'YYYY-MM-DD 23:59:59')::text,10::text,id_client::text,sum(egress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and egress_client_id=id_client group by to_char(report_time, 'YYYY-MM-DD 23:59:59')
-- 		select to_char(transaction_time, 'YYYY-MM-DD 23:59:59')::text,10::text,id_client::text,sum(amount)::text
-- 		from client_finance_transaction
-- 		where transaction_time between start_time and end_time
-- 		and client_id=id_client
-- 		and transaction_type=2
-- 		group by to_char(transaction_time, 'YYYY-MM-DD 23:59:59')
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 11 then --ingress cdr cost

	if id_client=0 then
		return;
	else
		for r in
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client::text group by time::date
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost)::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client group by time::date
		select to_char(report_time, 'YYYY-MM-DD 23:59:59')::text,11::text,id_client::text,sum(ingress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and ingress_client_id=id_client group by to_char(report_time, 'YYYY-MM-DD 23:59:59')
-- 		select to_char(transaction_time, 'YYYY-MM-DD 23:59:59')::text,11::text,id_client::text,sum(amount)::text
-- 		from client_finance_transaction
-- 		where transaction_time between start_time and end_time
-- 		and client_id=id_client
-- 		and transaction_type=1
-- 		group by to_char(transaction_time, 'YYYY-MM-DD 23:59:59')
		loop
			return next r;
		end loop;
	end if;
	end if;

	return;

end;
$_$;


ALTER FUNCTION public.actual_trans(timestamp with time zone, timestamp with time zone, integer, integer) OWNER TO postgres;

--
-- Name: actual_trans_exchange(timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION actual_trans_exchange(timestamp with time zone, timestamp with time zone, integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	start_time alias for $1;
	end_time alias for $2;
	id_client alias for $3;
	trans_type alias for $4;
	r record;
	invoice_start_time timestamp with time zone;
	invoice_end_time timestamp with time zone;
	cdr_start_time timestamp with time zone;
	cdr_end_time timestamp with time zone;

begin

	--if id_client > 0 then
		--invoice_start_time := 0;
		--invoice_end_time := 0;
		--cdr_start_time := 0;
		--cdr_end_time := 0;
	--end if;

	if trans_type = 0 then --all

	if id_client = 0 then
		for r in
		select
		action_time::text,
		(case action_type
		when 2 then 1
		when 1 then 2
		end)::text as t_type,
		client_id::text,
		actual_amount::text
		from exchange_finance
		where ((action_type=1 and status=4) or (action_type=2 and status=2))
		and action_time between start_time and end_time and client_id=id_client

-- 		select
-- 		payment_time::text,
-- 		(case payment_type
-- 		when 4 then 1
-- 		when 5 then 1
-- 		when 3 then 2
-- 		when 6 then 2
-- 		when 7 then 5
-- 		when 8 then 6
-- 		when 9 then 9
-- 		when 11 then 7
-- 		when 12 then 8
-- 		end)::text as t_type,
-- 		client_id::text,
-- 		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
-- 		from client_payment
-- 		where payment_type in (3,4,5,6,7,8,9,11,12) and
-- 		payment_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--(case type
		--when 0 then 4
		--when 2 then 4
		--end)::text as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where state=9 and type in (0,2) and
		--invoice_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--'3' as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where type = 3 and
		--invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select
		action_time::text,
		(case action_type
		when 2 then 1
		when 1 then 2
		end)::text as t_type,
		client_id::text,
		actual_amount::text
		from exchange_finance
		where ((action_type=1 and status=4) or (action_type=2 and status=2))
		and action_time between start_time and end_time and client_id=id_client

-- 		select
-- 		payment_time::text,
-- 		(case payment_type
-- 		when 4 then 1
-- 		when 5 then 1
-- 		when 3 then 2
-- 		when 6 then 2
-- 		when 7 then 5
-- 		when 8 then 6
-- 		when 9 then 9
-- 		when 11 then 7
-- 		when 12 then 8
-- 		end)::text as t_type,
-- 		client_id::text,
-- 		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
-- 		from client_payment
-- 		where payment_type in (3,4,5,6,7,8,9,11,12) and client_id=id_client and
-- 		payment_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--(case type
		--when 0 then 4
		--when 2 then 4
		--end)::text as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where state=9 and type in (0,2) and client_id=id_client and
		--invoice_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--'3' as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where type = 3 and client_id=id_client and
		--invoice_time between start_time and end_time
		--union
		--select time::date::text,10::text,id_client::text,sum(egress_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client::text group by time::date
		--union
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client::text group by time::date
		union
		--select time::date::text,10::text,id_client::text,sum(egress_cost)::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client group by time::date
		select report_time::date::text,10::text,id_client::text,sum(egress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and egress_client_id=id_client group by report_time::date
		union
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost)::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client group by time::date
		select report_time::date::text,11::text,id_client::text,sum(ingress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and ingress_client_id=id_client group by report_time::date
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 1 then --payment received

	if id_client=0 then
		for r in
		--select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		--and payment_time between start_time and end_time
		select action_time::text,1::text,client_id::text,actual_amount::text from exchange_finance where action_type=2 and status=2
		and action_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		--select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		--and payment_time between start_time and end_time and client_id=id_client
		select action_time::text,1::text,client_id::text,actual_amount::text from exchange_finance where action_type=2 and status=2
		and action_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 2 then --payment sent

	if id_client=0 then
		for r in
		--select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		--and payment_time between start_time and end_time
		select action_time::text,1::text,client_id::text,actual_amount::text from exchange_finance where action_type=1 and status=4
		and action_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		--select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		--and payment_time between start_time and end_time and client_id=id_client
		select action_time::text,1::text,client_id::text,actual_amount::text from exchange_finance where action_type=1 and status=4
		and action_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	--elsif trans_type = 3 then --invoice received

	--if id_client=0 then
	--	for r in
	--	select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
	--	and invoice_time between start_time and end_time
	--	loop
	--		return next r;
	--	end loop;
	--else
	--	for r in
	--	select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
	--	and invoice_time between start_time and end_time and client_id=id_client
	--	loop
	--		return next r;
	--	end loop;
	--end if;
	--elsif trans_type = 4 then --invoice sent

	--if id_client=0 then
	--	for r in
	--	select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
	--	and invoice_time between start_time and end_time
	--	loop
	--		return next r;
	--	end loop;
	--else
	--	for r in
	--	select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
	--	and invoice_time between start_time and end_time and client_id=id_client
	--	loop
	--		return next r;
	--	end loop;
	--end if;
-- 	elsif trans_type = 5 then --credit note received
--
-- 	if id_client=0 then
-- 		for r in
-- 		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
-- 		and payment_time between start_time and end_time
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	else
-- 		for r in
-- 		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
-- 		and payment_time between start_time and end_time and client_id=id_client
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	end if;
-- 	elsif trans_type = 6 then --credit note sent
--
-- 	if id_client=0 then
-- 		for r in
-- 		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
-- 		and payment_time between start_time and end_time
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	else
-- 		for r in
-- 		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
-- 		and payment_time between start_time and end_time and client_id=id_client
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	end if;
-- 	elsif trans_type = 7 then --debit note received
--
-- 	if id_client=0 then
-- 		for r in
-- 		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
-- 		and payment_time between start_time and end_time
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	else
-- 		for r in
-- 		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
-- 		and payment_time between start_time and end_time and client_id=id_client
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	end if;
-- 	elsif trans_type = 8 then --debit note sent
--
-- 	if id_client=0 then
-- 		for r in
-- 		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
-- 		and payment_time between start_time and end_time
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	else
-- 		for r in
-- 		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
-- 		and payment_time between start_time and end_time and client_id=id_client
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	end if;
-- 	elsif trans_type = 9 then --reset
--
-- 	if id_client=0 then
-- 		for r in
-- 		select payment_time::text,9::text,client_id::text,(coalesce(amount,0)+coalesce(egress_amount,0))::text from client_payment where payment_type=9
-- 		and payment_time between start_time and end_time
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	else
-- 		for r in
-- 		select payment_time::text,9::text,client_id::text,(coalesce(amount,0)+coalesce(egress_amount,0))::text from client_payment where payment_type=9
-- 		and payment_time between start_time and end_time and client_id=id_client
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	end if;
	elsif trans_type = 10 then --egress cdr cost

	if id_client=0 then
		return;
	else
		for r in
		--select time::date::text,10::text,id_client::text,sum(egress_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client::text group by time::date
		--select time::date::text,10::text,id_client::text,sum(egress_cost)::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client group by time::date
		select report_time::date::text,10::text,id_client::text,sum(egress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and egress_client_id=id_client group by report_time::date
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 11 then --ingress cdr cost

	if id_client=0 then
		return;
	else
		for r in
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client::text group by time::date
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost)::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client group by time::date
		select report_time::date::text,11::text,id_client::text,sum(ingress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and ingress_client_id=id_client group by report_time::date
		loop
			return next r;
		end loop;
	end if;
	end if;

	return;

end;
$_$;


ALTER FUNCTION public.actual_trans_exchange(timestamp with time zone, timestamp with time zone, integer, integer) OWNER TO postgres;

--
-- Name: approve_client_payment(integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION approve_client_payment(integer[]) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	a alias for $1;
	a_u integer;
	r record;
	now_balance numeric;

begin
	select into a_u array_upper(a,1);
	if a_u is null then
		for r in select client_payment_id,amount,client_id from client_payment order by client_payment_id asc
		loop
			select into now_balance balance from client_balance where client_id = r.client_id::text order by client_balance_id desc limit 1;
			if now_balance is null then
				now_balance := 0;
			end if;
			insert into client_balance(client_id,balance,client_payment_id,type)
			select r.client_id::text,(now_balance+r.amount)::text,r.client_payment_id::text,'5';
			update client_payment set approved = true where client_payment_id = r.client_payment_id;
		end loop;
	else
		for i in 1..a_u
		loop
		select into r amount,client_id from client_payment where client_payment_id = a[i];
		select into now_balance balance from client_balance where client_id = r.client_id::text order by client_balance_id desc limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;
		insert into client_balance(client_id,balance,client_payment_id,type)
		select r.client_id::text,(now_balance+r.amount)::text,a[i]::text,'5';
		update client_payment set approved = true where client_payment_id = a[i];
		end loop;
	end if;
	return 'true';
end;
$_$;


ALTER FUNCTION public.approve_client_payment(integer[]) OWNER TO postgres;

--
-- Name: balance_detail(integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION balance_detail(client integer, balance_date text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
today date := CURRENT_DATE;
start_date timestamp with time zone = balance_date::text || ' 00:00:00+00';
end_date timestamp with time zone = balance_date::text || ' 23:59:59+00';
my_array numeric(20, 5)[] := '{0,0,0,0,0,0,0,0,0,0,0,0,0}';
actual_ingress_balance numeric(20, 5) := 0;
actual_egress_balance numeric(20, 5) := 0;
actual_total_balance numeric(20, 5) := 0;
mutual_ingress_balance numeric(20, 5) := 0;
mutual_egress_balance numeric(20, 5) := 0;
mutual_total_balance numeric(20, 5) := 0;
r record;
result record;
BEGIN
for r in
SELECT COALESCE(sum(amount), 0) as amount, 0 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (4,5) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 1 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 8 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 2 as type FROM client_payment
WHERE payment_time between start_date and end_date
and  payment_type = 12 AND client_id = client
UNION

select COALESCE(amount, 0) as amount, 3 as type FROM
ingress_cost(client, start_date, end_date) as (amount numeric)

--SELECT COALESCE(sum(ingress_client_cost::numeric(10,4)), 0), 3 as type FROM client_cdr
--WHERE time BETWEEN start_date and end_date  AND ingress_client_id = client and is_final_call=1

UNION
SELECT COALESCE(sum(amount), 0) as amount, 4 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 15 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 5 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (3,6) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 6 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 7 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 7 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 11 AND client_id = client
UNION

select COALESCE(amount, 0) as amount, 8 as type FROM
egress_cost(client, start_date, end_date) as (amount numeric)

--SELECT COALESCE(sum(egress_cost), 0) as amount, 8 as type
--from client_cdr where time between start_date and end_date
--and egress_client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount, 9 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
state != -1 AND type = 0 AND client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount,10 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
type = 3 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 11 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 2 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 12 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 1 AND client_id = client

loop
my_array[r.type] = r.amount;
end loop;

my_array[0] = my_array[0] + my_array[11];
my_array[5] = my_array[5] + my_array[12];

actual_ingress_balance = my_array[0] + my_array[1] - my_array[2] - my_array[3] -my_array[4];
actual_egress_balance = -my_array[5] - my_array[6] + my_array[7] + my_array[8];
actual_total_balance = actual_ingress_balance + actual_egress_balance;

mutual_ingress_balance = -my_array[9] + my_array[0] + my_array[1] - my_array[2];
mutual_egress_balance = my_array[10] - my_array[5] - my_array[6] + my_array[7];
mutual_total_balance = mutual_ingress_balance+mutual_egress_balance;

select into r * from balance_history_actual where client_id = client and date < start_date order by date desc;

if FOUND THEN
actual_ingress_balance = actual_ingress_balance + r.actual_ingress_balance;
actual_egress_balance = actual_egress_balance + r.actual_egress_balance;
actual_total_balance = actual_total_balance + r.actual_balance;
end if;

select into r * from balance_history where client_id = client and date < start_date order by date desc;

if FOUND THEN
mutual_ingress_balance = mutual_ingress_balance + r.mutual_ingress_balance;
mutual_egress_balance = mutual_egress_balance + r.mutual_egress_balance;
mutual_total_balance = mutual_total_balance + r.mutual_balance;
end if;

select into result actual_ingress_balance,actual_egress_balance,actual_total_balance,mutual_ingress_balance,mutual_egress_balance,mutual_total_balance,
my_array[0], my_array[1], my_array[2], my_array[3], my_array[4], my_array[5], my_array[6], my_array[7],
my_array[8], my_array[9], my_array[10];
return next result;
return;

END;
$$;


ALTER FUNCTION public.balance_detail(client integer, balance_date text) OWNER TO postgres;

--
-- Name: c4_client_balance_trigfun_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION c4_client_balance_trigfun_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT' and NEW.client_id='87')then
                insert into c4_client_balance_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE' and NEW.client_id='87')then
                insert into c4_client_balance_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE' and NEW.client_id='87')then
                insert into c4_client_balance_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into c4_client_balance_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.c4_client_balance_trigfun_record() OWNER TO postgres;

--
-- Name: c4_livecall_user_trigfun_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION c4_livecall_user_trigfun_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into c4_livecall_user_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into c4_livecall_user_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into c4_livecall_user_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into c4_livecall_user_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.c4_livecall_user_trigfun_record() OWNER TO postgres;

--
-- Name: c4_spam_traffic_ip_trigfun_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION c4_spam_traffic_ip_trigfun_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into c4_spam_traffic_ip_trig_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into c4_spam_traffic_ip_trig_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into c4_spam_traffic_ip_trig_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into c4_spam_traffic_ip_trig_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.c4_spam_traffic_ip_trigfun_record() OWNER TO postgres;

--
-- Name: cidr(ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION cidr(ip4) RETURNS cidr
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_to_cidr';


ALTER FUNCTION public.cidr(ip4) OWNER TO postgres;

--
-- Name: cidr(ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION cidr(ip4r) RETURNS cidr
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cast_to_cidr';


ALTER FUNCTION public.cidr(ip4r) OWNER TO postgres;

--
-- Name: class4_func_mismatch_report(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_func_mismatch_report(character varying, character varying, OUT org2_call integer, OUT org2_notzero_call integer, OUT org2_call_duration integer, OUT term2_call integer, OUT term2_notzero_call integer, OUT term2_call_duration integer, OUT org3_call integer, OUT org3_notzero_call integer, OUT org3_call_duration integer, OUT term3_call integer, OUT term3_notzero_call integer, OUT term3_call_duration integer, OUT org4_call integer, OUT org4_notzero_call integer, OUT org4_call_duration integer, OUT term4_call integer, OUT term4_notzero_call integer, OUT term4_call_duration integer) RETURNS record
    LANGUAGE plpgsql
    AS $_$

   DECLARE
      r RECORD;
      reseller_package  numeric;
      starts character varying:=$1;
      ends character varying:=$2;
   BEGIN

--Calls with unknown clients   origination
       select    count(ingress_client_id) as  org_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60 as call_duration
       into  r     from  client_cdr   where   ingress_client_bill_result='2' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 org2_call_duration :=0;
else
org2_call_duration :=r.call_duration;
end if;


if r.org_call  is null then
 org2_call :=0;
else
org2_call :=r.org_call;
end if;

   select    count(ingress_client_id) as  org_not_zero_call
       into  r     from  client_cdr   where   ingress_client_bill_result='2'   and case when call_duration='' then '0' ELSE call_duration end::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.org_not_zero_call  is null then
 org2_notzero_call :=0;
else
org2_notzero_call :=r.org_not_zero_call;
end if;

--Calls with unknown clients    termination
       select    count(egress_client_id) as  term_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60 as call_duration
       into  r     from  client_cdr   where   egress_bill_result='2' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 term2_call_duration :=0;
else
term2_call_duration :=r.call_duration;
end if;


if r.term_call  is null then
 term2_call :=0;
else
term2_call :=r.term_call;
end if;


   select  count(egress_client_id) as term_not_zero_call
       into  r     from  client_cdr   where    egress_bill_result='2'   and case when call_duration='' then '0' ELSE call_duration end ::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.term_not_zero_call  is null then
term2_notzero_call :=0;
else
term2_notzero_call :=r.term_not_zero_call;
end if;




--è´¹çŽ‡æ¨¡æ¿æ‰¾ä¸åˆ°     origination
       select    count(ingress_client_id) as  org_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60 as call_duration
       into  r     from  client_cdr   where   ingress_client_bill_result='3' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 org3_call_duration :=0;
else
org3_call_duration :=r.call_duration;
end if;


if r.org_call  is null then
 org3_call :=0;
else
org3_call :=r.org_call;
end if;

   select    count(ingress_client_id) as  org_not_zero_call
       into  r     from  client_cdr   where   ingress_client_bill_result='3'   and case when call_duration='' then '0' ELSE call_duration end ::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.org_not_zero_call  is null then
 org3_notzero_call :=0;
else
org3_notzero_call :=r.org_not_zero_call;
end if;

--è´¹çŽ‡æ¨¡æ¿æ‰¾ä¸åˆ°    termination
       select    count(egress_client_id) as  term_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60 as call_duration
       into  r     from  client_cdr   where   egress_bill_result='3' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 term3_call_duration :=0;
else
term3_call_duration :=r.call_duration;
end if;


if r.term_call  is null then
 term3_call :=0;
else
term3_call :=r.term_call;
end if;


   select  count(egress_client_id) as term_not_zero_call
       into  r     from  client_cdr   where    egress_bill_result='3'   and case when call_duration='' then '0' ELSE call_duration end ::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.term_not_zero_call  is null then
term3_notzero_call :=0;
else
term3_notzero_call :=r.term_not_zero_call;
end if;








--è´¹çŽ‡æ‰¾ä¸åˆ°     origination
       select    count(ingress_client_id) as  org_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60  as call_duration
       into  r     from  client_cdr   where   ingress_client_bill_result='4' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 org4_call_duration :=0;
else
org4_call_duration :=r.call_duration;
end if;


if r.org_call  is null then
 org4_call :=0;
else
org4_call :=r.org_call;
end if;

   select    count(ingress_client_id) as  org_not_zero_call
       into  r     from  client_cdr   where   ingress_client_bill_result='4'   and case when call_duration='' then '0' ELSE call_duration end ::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.org_not_zero_call  is null then
 org4_notzero_call :=0;
else
org4_notzero_call :=r.org_not_zero_call;
end if;

--è´¹çŽ‡æ¨¡æ¿æ‰¾ä¸åˆ°    termination
       select    count(egress_client_id) as  term_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60  as call_duration
       into  r     from  client_cdr   where   egress_bill_result='4' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 term4_call_duration :=0;
else
term4_call_duration :=r.call_duration;
end if;


if r.term_call  is null then
 term4_call :=0;
else
term4_call :=r.term_call;
end if;


   select  count(egress_client_id) as term_not_zero_call
       into  r     from  client_cdr   where    egress_bill_result='4'   and case when call_duration='' then '0' ELSE call_duration end ::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.term_not_zero_call  is null then
term4_notzero_call :=0;
else
term4_notzero_call :=r.term_not_zero_call;
end if;
   END;
$_$;


ALTER FUNCTION public.class4_func_mismatch_report(character varying, character varying, OUT org2_call integer, OUT org2_notzero_call integer, OUT org2_call_duration integer, OUT term2_call integer, OUT term2_notzero_call integer, OUT term2_call_duration integer, OUT org3_call integer, OUT org3_notzero_call integer, OUT org3_call_duration integer, OUT term3_call integer, OUT term3_notzero_call integer, OUT term3_call_duration integer, OUT org4_call integer, OUT org4_notzero_call integer, OUT org4_call_duration integer, OUT term4_call integer, OUT term4_notzero_call integer, OUT term4_call_duration integer) OWNER TO postgres;

--
-- Name: class4_func_monitor_ip_report(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_func_monitor_ip_report(character varying, OUT acd_15min numeric, OUT pdd_15min numeric, OUT asr_15min numeric, OUT ca_15min numeric, OUT acd_1h numeric, OUT pdd_1h numeric, OUT asr_1h numeric, OUT ca_1h numeric, OUT acd_24h numeric, OUT pdd_24h numeric, OUT asr_24h numeric, OUT ca_24h numeric) RETURNS record
    LANGUAGE plpgsql
    AS $_$
   DECLARE
      r RECORD;
      host_ip character varying:=$1;
   BEGIN

--15 min
       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,
       (sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::real) / NULLIF(sum(call_count::integer),0)) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where ip=host_ip and   time::bigint between extract(epoch from now())::bigint-(60*15)      and  extract(epoch from now())::bigint;

if r.asr  is null then
 asr_15min :=0;
else
asr_15min :=r.asr::numeric(20,2);
end if;
if r.acd  is null then
 acd_15min :=0;
else
acd_15min :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_15min :=0;
else
pdd_15min :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_15min :=0;
else
ca_15min :=r.ca;
end if;



--1 h

       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,(sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::integer) / NULLIF(sum(call_count::integer),0)) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where ip=host_ip and  time::bigint between extract(epoch from now())::bigint-(3600)      and  extract(epoch from now())::bigint;

if r.asr  is null then
 asr_1h :=0;
else
asr_1h :=r.asr::numeric(20,2);
end if;


if r.acd  is null then
 acd_1h :=0;
else
acd_1h :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_1h :=0;
else
pdd_1h :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_1h :=0;
else
ca_1h :=r.ca;
end if;




--24 h

       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,(sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::integer) / NULLIF(sum(call_count::integer),0)) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where ip=host_ip and  time::bigint between extract(epoch from now())::bigint-(3600*24)      and  extract(epoch from now())::bigint;

if r.asr  is null then
 asr_24h :=0;
else
asr_24h :=r.asr::numeric(20,2);
end if;

if r.acd  is null then
 acd_24h :=0;
else
acd_24h :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_24h :=0;
else
pdd_24h :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_24h :=0;
else
ca_24h :=r.ca;
end if;






   END;
$_$;


ALTER FUNCTION public.class4_func_monitor_ip_report(character varying, OUT acd_15min numeric, OUT pdd_15min numeric, OUT asr_15min numeric, OUT ca_15min numeric, OUT acd_1h numeric, OUT pdd_1h numeric, OUT asr_1h numeric, OUT ca_1h numeric, OUT acd_24h numeric, OUT pdd_24h numeric, OUT asr_24h numeric, OUT ca_24h numeric) OWNER TO postgres;

--
-- Name: class4_func_monitor_report(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_func_monitor_report(OUT acd_15min numeric, OUT pdd_15min numeric, OUT asr_15min numeric, OUT ca_15min numeric, OUT acd_1h numeric, OUT pdd_1h numeric, OUT asr_1h numeric, OUT ca_1h numeric, OUT acd_24h numeric, OUT pdd_24h numeric, OUT asr_24h numeric, OUT ca_24h numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
   DECLARE
      r RECORD;
      r2 RECORD;
   BEGIN

--15 min
       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,
       (sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::real) / NULLIF(sum(call_count::integer),0)    ) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where   time::bigint between extract(epoch from now())::bigint-(60*15)      and  extract(epoch from now())::bigint
       and direction='0'
;


if r.asr  is null then
 asr_15min :=0;
else
asr_15min :=r.asr::numeric(20,2);
end if;
if r.acd  is null then
 acd_15min :=0;
else
acd_15min :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_15min :=0;
else
pdd_15min :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_15min :=0;
else
ca_15min :=r.ca;
end if;



--1 h

       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,(sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::integer) / NULLIF(sum(call_count::integer),0   )) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where   time::bigint between extract(epoch from now())::bigint-(3600)      and  extract(epoch from now())::bigint
	and direction='0'
;


if r.asr  is null then
 asr_1h :=0;
else
asr_1h :=r.asr::numeric(20,2);
end if;


if r.acd  is null then
 acd_1h :=0;
else
acd_1h :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_1h :=0;
else
pdd_1h :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_1h :=0;
else
ca_1h :=r.ca;
end if;




--24 h

       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,
(sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::integer) / NULLIF(sum(call_count::integer),0)) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where   time::bigint between extract(epoch from now())::bigint-(3600*24)      and  extract(epoch from now())::bigint
	and direction='0'
;


if r.asr  is null then
 asr_24h :=0;
else
asr_24h :=r.asr::numeric(20,2);
end if;

if r.acd  is null then
 acd_24h :=0;
else
acd_24h :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_24h :=0;
else
pdd_24h :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_24h :=0;
else
ca_24h :=r.ca;
end if;






   END;
$$;


ALTER FUNCTION public.class4_func_monitor_report(OUT acd_15min numeric, OUT pdd_15min numeric, OUT asr_15min numeric, OUT ca_15min numeric, OUT acd_1h numeric, OUT pdd_1h numeric, OUT asr_1h numeric, OUT ca_1h numeric, OUT acd_24h numeric, OUT pdd_24h numeric, OUT asr_24h numeric, OUT ca_24h numeric) OWNER TO postgres;

--
-- Name: class4_trigfun_cdr_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_cdr_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ DECLARE t timestamp with time zone;
BEGIN
	select into t TIMESTAMP WITH TIME ZONE 'epoch' + (NEW.start_time_of_date::bigint/1000000) * INTERVAL '1 second';
	NEW.time := t;
	if t >= '2017-06-07 00:00:00+00' and t < '2017-06-08 00:00:00+00' then insert into client_cdr20170607 select NEW.*;
	elsif t >= '2017-06-06 00:00:00+00' and t< '2017-06-07 00:00:00+00' then insert into client_cdr20170606 select NEW.*;
	elsif t >= '2016-12-09 00:00:00+00' and t< '2016-12-10 00:00:00+00' then insert into client_cdr20161209 select NEW.*;
	elsif t >= '2016-12-10 00:00:00+00' and t< '2016-12-11 00:00:00+00' then insert into client_cdr20161210 select NEW.*;
	elsif t >= '2016-12-11 00:00:00+00' and t< '2016-12-12 00:00:00+00' then insert into client_cdr20161211 select NEW.*;
	elsif t >= '2016-12-12 00:00:00+00' and t< '2016-12-13 00:00:00+00' then insert into client_cdr20161212 select NEW.*;
	elsif t >= '2016-12-13 00:00:00+00' and t< '2016-12-14 00:00:00+00' then insert into client_cdr20161213 select NEW.*;
	elsif t >= '2016-12-14 00:00:00+00' and t< '2016-12-15 00:00:00+00' then insert into client_cdr20161214 select NEW.*;
	elsif t >= '2016-12-15 00:00:00+00' and t< '2016-12-16 00:00:00+00' then insert into client_cdr20161215 select NEW.*;
	elsif t >= '2016-12-16 00:00:00+00' and t< '2016-12-17 00:00:00+00' then insert into client_cdr20161216 select NEW.*;
	elsif t >= '2016-12-17 00:00:00+00' and t< '2016-12-18 00:00:00+00' then insert into client_cdr20161217 select NEW.*;
	elsif t >= '2016-12-18 00:00:00+00' and t< '2016-12-19 00:00:00+00' then insert into client_cdr20161218 select NEW.*;
	elsif t >= '2016-12-19 00:00:00+00' and t< '2016-12-20 00:00:00+00' then insert into client_cdr20161219 select NEW.*;
	elsif t >= '2016-12-20 00:00:00+00' and t< '2016-12-21 00:00:00+00' then insert into client_cdr20161220 select NEW.*;
	elsif t >= '2016-12-21 00:00:00+00' and t< '2016-12-22 00:00:00+00' then insert into client_cdr20161221 select NEW.*;
	elsif t >= '2016-12-22 00:00:00+00' and t< '2016-12-23 00:00:00+00' then insert into client_cdr20161222 select NEW.*;
	elsif t >= '2016-12-23 00:00:00+00' and t< '2016-12-24 00:00:00+00' then insert into client_cdr20161223 select NEW.*;
	elsif t >= '2016-12-24 00:00:00+00' and t< '2016-12-25 00:00:00+00' then insert into client_cdr20161224 select NEW.*;
	elsif t >= '2016-12-25 00:00:00+00' and t< '2016-12-26 00:00:00+00' then insert into client_cdr20161225 select NEW.*;
	elsif t >= '2016-12-26 00:00:00+00' and t< '2016-12-27 00:00:00+00' then insert into client_cdr20161226 select NEW.*;
	elsif t >= '2016-12-27 00:00:00+00' and t< '2016-12-28 00:00:00+00' then insert into client_cdr20161227 select NEW.*;
	elsif t >= '2016-12-28 00:00:00+00' and t< '2016-12-29 00:00:00+00' then insert into client_cdr20161228 select NEW.*;
	elsif t >= '2016-12-29 00:00:00+00' and t< '2016-12-30 00:00:00+00' then insert into client_cdr20161229 select NEW.*;
	elsif t >= '2016-12-30 00:00:00+00' and t< '2016-12-31 00:00:00+00' then insert into client_cdr20161230 select NEW.*;
	elsif t >= '2016-12-31 00:00:00+00' and t< '2017-01-01 00:00:00+00' then insert into client_cdr20161231 select NEW.*;
	else
		raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.start_time_of_date;
		return NEW;
	end if;
	return NULL;
END;
$$;


ALTER FUNCTION public.class4_trigfun_cdr_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_client_active(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_client_active() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
low_cost numeric;
res integer;
new_balance real;
client_offset_balance boolean;

begin
if exists(select 1 from client where unlimited_credit is true and client_id = NEW.client_id::integer) then
return null;
end if;

select into low_cost, client_offset_balance allowed_credit, offset_balance from client where client_id = NEW.client_id::integer;

if client_offset_balance then
	new_balance := NEW.balance::real;
else
	new_balance := NEW.ingress_balance::real;
end if;

if new_balance::real <= low_cost then
if not exists (select 1 from client where client_id = NEW.client_id::integer and enough_balance = false) then
--insert into event_log(type,message,action_date,sender) values(1,'set enough balance false for client '|| NEW.client_id|| ' client balance id %'|| NEW.client_balance_id,current_timestamp(0),2);
update client set enough_balance = false where client_id = NEW.client_id::integer;
update resource set enough_balance = false where client_id = NEW.client_id::integer and ingress = true;
end if;
elsif NEW.balance::real > low_cost then
if not exists (select 1 from client where client_id = NEW.client_id::integer and enough_balance = true) then
--insert into event_log(type,message,action_date,sender) values(1,'set enough balance true for client '|| NEW.client_id|| ' client balance id %'|| NEW.client_balance_id,current_timestamp(0),2);
update client set enough_balance = true where client_id = NEW.client_id::integer;
update resource set enough_balance = true where client_id = NEW.client_id::integer and ingress = true;
end if;
end if;

return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_client_active() OWNER TO postgres;

--
-- Name: class4_trigfun_did_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_did_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        DECLARE
                t timestamp with time zone;
        BEGIN
                t:= NEW.report_time;

                if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
                        insert into did_report20161201 select NEW.*;
                elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
                        insert into did_report20161202 select NEW.*;
                elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
                        insert into did_report20161130 select NEW.*;
                elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into did_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into did_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into did_report20161202 select NEW.*;

                else
                        raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
                        return NEW;
                end if;


                return NULL;
        END
        $$;


ALTER FUNCTION public.class4_trigfun_did_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_host_based_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_host_based_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ DECLARE t timestamp with time zone;
BEGIN
	t:= NEW.report_time;
	if t >= '2017-06-07 00:00:00+00' and t < '2017-06-08 00:00:00+00' then insert into host_based_report20170607 select NEW.*;
	elsif t >= '2017-06-06 00:00:00+00' and t< '2017-06-07 00:00:00+00' then insert into host_based_report20170606 select NEW.*;
	elsif t >= '2016-12-09 00:00:00+00' and t< '2016-12-10 00:00:00+00' then insert into host_based_report20161209 select NEW.*;
	elsif t >= '2016-12-10 00:00:00+00' and t< '2016-12-11 00:00:00+00' then insert into host_based_report20161210 select NEW.*;
	elsif t >= '2016-12-11 00:00:00+00' and t< '2016-12-12 00:00:00+00' then insert into host_based_report20161211 select NEW.*;
	elsif t >= '2016-12-12 00:00:00+00' and t< '2016-12-13 00:00:00+00' then insert into host_based_report20161212 select NEW.*;
	elsif t >= '2016-12-13 00:00:00+00' and t< '2016-12-14 00:00:00+00' then insert into host_based_report20161213 select NEW.*;
	elsif t >= '2016-12-14 00:00:00+00' and t< '2016-12-15 00:00:00+00' then insert into host_based_report20161214 select NEW.*;
	elsif t >= '2016-12-15 00:00:00+00' and t< '2016-12-16 00:00:00+00' then insert into host_based_report20161215 select NEW.*;
	elsif t >= '2016-12-16 00:00:00+00' and t< '2016-12-17 00:00:00+00' then insert into host_based_report20161216 select NEW.*;
	elsif t >= '2016-12-17 00:00:00+00' and t< '2016-12-18 00:00:00+00' then insert into host_based_report20161217 select NEW.*;
	elsif t >= '2016-12-18 00:00:00+00' and t< '2016-12-19 00:00:00+00' then insert into host_based_report20161218 select NEW.*;
	elsif t >= '2016-12-19 00:00:00+00' and t< '2016-12-20 00:00:00+00' then insert into host_based_report20161219 select NEW.*;
	elsif t >= '2016-12-20 00:00:00+00' and t< '2016-12-21 00:00:00+00' then insert into host_based_report20161220 select NEW.*;
	elsif t >= '2016-12-21 00:00:00+00' and t< '2016-12-22 00:00:00+00' then insert into host_based_report20161221 select NEW.*;
	elsif t >= '2016-12-22 00:00:00+00' and t< '2016-12-23 00:00:00+00' then insert into host_based_report20161222 select NEW.*;
	elsif t >= '2016-12-23 00:00:00+00' and t< '2016-12-24 00:00:00+00' then insert into host_based_report20161223 select NEW.*;
	elsif t >= '2016-12-24 00:00:00+00' and t< '2016-12-25 00:00:00+00' then insert into host_based_report20161224 select NEW.*;
	elsif t >= '2016-12-25 00:00:00+00' and t< '2016-12-26 00:00:00+00' then insert into host_based_report20161225 select NEW.*;
	elsif t >= '2016-12-26 00:00:00+00' and t< '2016-12-27 00:00:00+00' then insert into host_based_report20161226 select NEW.*;
	elsif t >= '2016-12-27 00:00:00+00' and t< '2016-12-28 00:00:00+00' then insert into host_based_report20161227 select NEW.*;
	elsif t >= '2016-12-28 00:00:00+00' and t< '2016-12-29 00:00:00+00' then insert into host_based_report20161228 select NEW.*;
	elsif t >= '2016-12-29 00:00:00+00' and t< '2016-12-30 00:00:00+00' then insert into host_based_report20161229 select NEW.*;
	elsif t >= '2016-12-30 00:00:00+00' and t< '2016-12-31 00:00:00+00' then insert into host_based_report20161230 select NEW.*;
	elsif t >= '2016-12-31 00:00:00+00' and t< '2017-01-01 00:00:00+00' then insert into host_based_report20161231 select NEW.*;
	else
		raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
		return NEW;
	end if;
	return NULL;
END;
$$;


ALTER FUNCTION public.class4_trigfun_host_based_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_info_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_info_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        DECLARE
        BEGIN
		return NULL;

        END
        $$;


ALTER FUNCTION public.class4_trigfun_info_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_record_agent_client_client(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_agent_client_client() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into agent_client_client_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into agent_client_client_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into agent_client_client_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into agent_client_client_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_agent_client_client() OWNER TO postgres;

--
-- Name: class4_trigfun_record_allowed_sendto_ip(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_allowed_sendto_ip() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into allowed_sendto_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into allowed_sendto_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into allowed_sendto_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into allowed_sendto_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_allowed_sendto_ip() OWNER TO postgres;

--
-- Name: class4_trigfun_record_buy_order(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_buy_order() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into buy_order_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into buy_order_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into buy_order_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into buy_order_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_buy_order() OWNER TO postgres;

--
-- Name: class4_trigfun_record_c4_lrn(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_c4_lrn() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into c4_lrn_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into c4_lrn_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into c4_lrn_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into c4_lrn_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_c4_lrn() OWNER TO postgres;

--
-- Name: class4_trigfun_record_client(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_client() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into client_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into client_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into client_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into client_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_client() OWNER TO postgres;

--
-- Name: class4_trigfun_record_client_balance(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_client_balance() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into client_balance_record_tmp select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into client_balance_record_tmp select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into client_balance_record_tmp select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'U';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_client_balance() OWNER TO postgres;

--
-- Name: class4_trigfun_record_client_commit_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_client_commit_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into client_commit_code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into client_commit_code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into client_commit_code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into client_commit_code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_client_commit_code() OWNER TO postgres;

--
-- Name: class4_trigfun_record_client_commit_minutes(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_client_commit_minutes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into client_commit_minutes_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into client_commit_minutes_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into client_commit_minutes_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into client_commit_minutes_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_client_commit_minutes() OWNER TO postgres;

--
-- Name: class4_trigfun_record_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_code() OWNER TO postgres;

--
-- Name: class4_trigfun_record_contract(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_contract() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into contract_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into contract_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into contract_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into contract_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_contract() OWNER TO postgres;

--
-- Name: class4_trigfun_record_currency(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_currency() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into currency_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into currency_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into currency_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into currency_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_currency() OWNER TO postgres;

--
-- Name: class4_trigfun_record_currency_updates(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_currency_updates() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into currency_updates_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into currency_updates_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into currency_updates_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into currency_updates_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_currency_updates() OWNER TO postgres;

--
-- Name: class4_trigfun_record_dynamic_route(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_dynamic_route() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into dynamic_route_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into dynamic_route_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into dynamic_route_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into dynamic_route_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_dynamic_route() OWNER TO postgres;

--
-- Name: class4_trigfun_record_dynamic_route_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_dynamic_route_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into dynamic_route_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into dynamic_route_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into dynamic_route_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into dynamic_route_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_dynamic_route_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_dynamic_route_override(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_dynamic_route_override() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into dynamic_route_override_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into dynamic_route_override_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into dynamic_route_override_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into dynamic_route_override_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_dynamic_route_override() OWNER TO postgres;

--
-- Name: class4_trigfun_record_dynamic_route_pri(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_dynamic_route_pri() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into dynamic_route_pri_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into dynamic_route_pri_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into dynamic_route_pri_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into dynamic_route_pri_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_dynamic_route_pri() OWNER TO postgres;

--
-- Name: class4_trigfun_record_dynamic_route_qos(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_dynamic_route_qos() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into dynamic_route_qos_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into dynamic_route_qos_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into dynamic_route_qos_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into dynamic_route_qos_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_dynamic_route_qos() OWNER TO postgres;

--
-- Name: class4_trigfun_record_egress_profile(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_egress_profile() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into egress_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into egress_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into egress_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into egress_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_egress_profile() OWNER TO postgres;

--
-- Name: class4_trigfun_record_exchange_par_account(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_exchange_par_account() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into exchange_par_account_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into exchange_par_account_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into exchange_par_account_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into exchange_par_account_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_exchange_par_account() OWNER TO postgres;

--
-- Name: class4_trigfun_record_global_route_error(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_global_route_error() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into global_route_error_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into global_route_error_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into global_route_error_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into global_route_error_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_global_route_error() OWNER TO postgres;

--
-- Name: class4_trigfun_record_jurisdiction_prefix(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_jurisdiction_prefix() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into jurisdiction_prefix_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into jurisdiction_prefix_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into jurisdiction_prefix_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into jurisdiction_prefix_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_jurisdiction_prefix() OWNER TO postgres;

--
-- Name: class4_trigfun_record_livecall_user(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_livecall_user() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into livecall_user_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into livecall_user_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into livecall_user_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into livecall_user_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_livecall_user() OWNER TO postgres;

--
-- Name: class4_trigfun_record_lrn_groups(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_lrn_groups() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into lrn_groups_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into lrn_groups_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into lrn_groups_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into lrn_groups_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_lrn_groups() OWNER TO postgres;

--
-- Name: class4_trigfun_record_lrn_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_lrn_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into lrn_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into lrn_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into lrn_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into lrn_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_lrn_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_origination_global_failover(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_origination_global_failover() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into origination_global_failover_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into origination_global_failover_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into origination_global_failover_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into origination_global_failover_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_origination_global_failover() OWNER TO postgres;

--
-- Name: class4_trigfun_record_partition_gateway_ref(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_partition_gateway_ref() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into partition_gateway_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into partition_gateway_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into partition_gateway_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into partition_gateway_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_partition_gateway_ref() OWNER TO postgres;

--
-- Name: class4_trigfun_record_payment_term(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_payment_term() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into payment_term_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into payment_term_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into payment_term_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into payment_term_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_payment_term() OWNER TO postgres;

--
-- Name: class4_trigfun_record_product(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_product() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into product_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into product_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into product_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into product_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_product() OWNER TO postgres;

--
-- Name: class4_trigfun_record_product_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_product_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into product_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into product_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into product_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into product_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_product_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_product_items_resource(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_product_items_resource() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into product_items_resource_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into product_items_resource_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into product_items_resource_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into product_items_resource_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_product_items_resource() OWNER TO postgres;

--
-- Name: class4_trigfun_record_product_rout_rate_table(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_product_rout_rate_table() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into product_rout_rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into product_rout_rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into product_rout_rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into product_rout_rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_product_rout_rate_table() OWNER TO postgres;

--
-- Name: class4_trigfun_record_random_ani_generation(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_random_ani_generation() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into random_ani_generation_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into random_ani_generation_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into random_ani_generation_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into random_ani_generation_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_random_ani_generation() OWNER TO postgres;

--
-- Name: class4_trigfun_record_rate(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_rate() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into rate_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into rate_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into rate_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into rate_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_rate() OWNER TO postgres;

--
-- Name: class4_trigfun_record_rate_table(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_rate_table() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_rate_table() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_block(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_block() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_block_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_block_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_block_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_block_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_block() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_block_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_block_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_block_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_block_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_block_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_block_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_block_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_capacity(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_capacity() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_capacity_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_capacity_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_capacity_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_capacity_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_capacity() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_codecs_ref(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_codecs_ref() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_codecs_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_codecs_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_codecs_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_codecs_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_codecs_ref() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_direction(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_direction() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_direction_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_direction_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_direction_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_direction_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_direction() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_ip(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_ip() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_ip() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_ip_limit(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_ip_limit() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_ip_limit_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_ip_limit_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_ip_limit_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_ip_limit_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_ip_limit() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_lrn_action(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_lrn_action() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_lrn_action_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_lrn_action_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_lrn_action_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_lrn_action_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_lrn_action() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_next_route_rule(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_next_route_rule() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_next_route_rule_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_next_route_rule_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_next_route_rule_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_next_route_rule_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_next_route_rule() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_prefix(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_prefix() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_prefix_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_prefix_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_prefix_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_prefix_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_prefix() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_rate(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_rate() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_rate_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_rate_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_rate_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_rate_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_rate() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_rate_table_ref(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_rate_table_ref() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_rate_table_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_rate_table_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_rate_table_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'U';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_rate_table_ref() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_replace_action(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_replace_action() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_replace_action_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_replace_action_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_replace_action_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_replace_action_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_replace_action() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_translation_ref(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_resource_translation_ref() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_translation_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_translation_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_translation_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_translation_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_translation_ref() OWNER TO postgres;

--
-- Name: class4_trigfun_record_route(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_route() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into route_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into route_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into route_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into route_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_route() OWNER TO postgres;

--
-- Name: class4_trigfun_record_sell_order(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_sell_order() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into sell_order_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into sell_order_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into sell_order_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into sell_order_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_sell_order() OWNER TO postgres;

--
-- Name: class4_trigfun_record_service_charge_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_service_charge_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into service_charge_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into service_charge_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into service_charge_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into service_charge_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_service_charge_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_sip_error_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_sip_error_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into sip_error_code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into sip_error_code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into sip_error_code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into sip_error_code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_sip_error_code() OWNER TO postgres;

--
-- Name: class4_trigfun_record_spam_traffic_ip(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_spam_traffic_ip() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if(TG_OP='INSERT')then
               insert into spam_traffic_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
       elseif(TG_OP='DELETE')then
               insert into spam_traffic_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
       elseif(TG_OP='UPDATE')then
               insert into spam_traffic_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
               insert into spam_traffic_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
       end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_spam_traffic_ip() OWNER TO postgres;

--
-- Name: class4_trigfun_record_switch_profile(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_switch_profile() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into switch_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into switch_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into switch_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into switch_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_switch_profile() OWNER TO postgres;

--
-- Name: class4_trigfun_record_termination_global_failover(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_termination_global_failover() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into termination_global_failover_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into termination_global_failover_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into termination_global_failover_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into termination_global_failover_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_termination_global_failover() OWNER TO postgres;

--
-- Name: class4_trigfun_record_time_profile(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_time_profile() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into time_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into time_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into time_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into time_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_time_profile() OWNER TO postgres;

--
-- Name: class4_trigfun_record_transaction_fee_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_transaction_fee_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into transaction_fee_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into transaction_fee_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into transaction_fee_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into transaction_fee_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_transaction_fee_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_translation_item(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_translation_item() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into translation_item_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into translation_item_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into translation_item_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into translation_item_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_translation_item() OWNER TO postgres;

--
-- Name: class4_trigfun_record_trunk_pstn_header(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_record_trunk_pstn_header() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

        if(TG_OP='INSERT')then
                insert into trunk_pstn_header_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into trunk_pstn_header_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into trunk_pstn_header_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into trunk_pstn_header_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_trunk_pstn_header() OWNER TO postgres;

--
-- Name: class4_trigfun_report_detail_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_report_detail_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ DECLARE t timestamp with time zone;
BEGIN
	t:= NEW.report_time;
	if t >= '2017-06-07 00:00:00+00' and t < '2017-06-08 00:00:00+00' then insert into cdr_report_detail20170607 select NEW.*;
	elsif t >= '2017-06-06 00:00:00+00' and t< '2017-06-07 00:00:00+00' then insert into cdr_report_detail20170606 select NEW.*;
	elsif t >= '2016-12-09 00:00:00+00' and t< '2016-12-10 00:00:00+00' then insert into cdr_report_detail20161209 select NEW.*;
	elsif t >= '2016-12-14 00:00:00+00' and t< '2016-12-15 00:00:00+00' then insert into cdr_report_detail20161214 select NEW.*;
	elsif t >= '2016-12-15 00:00:00+00' and t< '2016-12-16 00:00:00+00' then insert into cdr_report_detail20161215 select NEW.*;
	elsif t >= '2016-12-18 00:00:00+00' and t< '2016-12-19 00:00:00+00' then insert into cdr_report_detail20161218 select NEW.*;
	elsif t >= '2016-12-27 00:00:00+00' and t< '2016-12-28 00:00:00+00' then insert into cdr_report_detail20161227 select NEW.*;
	elsif t >= '2016-12-31 00:00:00+00' and t< '2017-01-01 00:00:00+00' then insert into cdr_report_detail20161231 select NEW.*;
	elsif t >= '2016-12-10 00:00:00+00' and t< '2016-12-11 00:00:00+00' then insert into cdr_report_detail20161210 select NEW.*;
	elsif t >= '2016-12-11 00:00:00+00' and t< '2016-12-12 00:00:00+00' then insert into cdr_report_detail20161211 select NEW.*;
	elsif t >= '2016-12-12 00:00:00+00' and t< '2016-12-13 00:00:00+00' then insert into cdr_report_detail20161212 select NEW.*;
	elsif t >= '2016-12-13 00:00:00+00' and t< '2016-12-14 00:00:00+00' then insert into cdr_report_detail20161213 select NEW.*;
	elsif t >= '2016-12-16 00:00:00+00' and t< '2016-12-17 00:00:00+00' then insert into cdr_report_detail20161216 select NEW.*;
	elsif t >= '2016-12-17 00:00:00+00' and t< '2016-12-18 00:00:00+00' then insert into cdr_report_detail20161217 select NEW.*;
	elsif t >= '2016-12-19 00:00:00+00' and t< '2016-12-20 00:00:00+00' then insert into cdr_report_detail20161219 select NEW.*;
	elsif t >= '2016-12-20 00:00:00+00' and t< '2016-12-21 00:00:00+00' then insert into cdr_report_detail20161220 select NEW.*;
	elsif t >= '2016-12-21 00:00:00+00' and t< '2016-12-22 00:00:00+00' then insert into cdr_report_detail20161221 select NEW.*;
	elsif t >= '2016-12-22 00:00:00+00' and t< '2016-12-23 00:00:00+00' then insert into cdr_report_detail20161222 select NEW.*;
	elsif t >= '2016-12-23 00:00:00+00' and t< '2016-12-24 00:00:00+00' then insert into cdr_report_detail20161223 select NEW.*;
	elsif t >= '2016-12-24 00:00:00+00' and t< '2016-12-25 00:00:00+00' then insert into cdr_report_detail20161224 select NEW.*;
	elsif t >= '2016-12-25 00:00:00+00' and t< '2016-12-26 00:00:00+00' then insert into cdr_report_detail20161225 select NEW.*;
	elsif t >= '2016-12-26 00:00:00+00' and t< '2016-12-27 00:00:00+00' then insert into cdr_report_detail20161226 select NEW.*;
	elsif t >= '2016-12-28 00:00:00+00' and t< '2016-12-29 00:00:00+00' then insert into cdr_report_detail20161228 select NEW.*;
	elsif t >= '2016-12-29 00:00:00+00' and t< '2016-12-30 00:00:00+00' then insert into cdr_report_detail20161229 select NEW.*;
	elsif t >= '2016-12-30 00:00:00+00' and t< '2016-12-31 00:00:00+00' then insert into cdr_report_detail20161230 select NEW.*;
	else
		raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
		return NEW;
	end if;
	return NULL;
END;
$$;


ALTER FUNCTION public.class4_trigfun_report_detail_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        DECLARE
		t timestamp with time zone;
        BEGIN
		t:= NEW.report_time;

                if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
                        insert into cdr_report20161201 select NEW.*;
                elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
                        insert into cdr_report20161202 select NEW.*;
                elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
                        insert into cdr_report20161130 select NEW.*;
				elsif t >= '2016-10-16 00:00:00' and t< '2016-10-17 00:00:00' then insert into cdr_report20161016 select NEW.*;
elsif t >= '2016-10-17 00:00:00' and t< '2016-10-18 00:00:00' then insert into cdr_report20161017 select NEW.*;
elsif t >= '2016-10-18 00:00:00' and t< '2016-10-19 00:00:00' then insert into cdr_report20161018 select NEW.*;
elsif t >= '2016-10-19 00:00:00' and t< '2016-10-20 00:00:00' then insert into cdr_report20161019 select NEW.*;
elsif t >= '2016-10-20 00:00:00' and t< '2016-10-21 00:00:00' then insert into cdr_report20161020 select NEW.*;
elsif t >= '2016-10-21 00:00:00' and t< '2016-10-22 00:00:00' then insert into cdr_report20161021 select NEW.*;
elsif t >= '2016-10-22 00:00:00' and t< '2016-10-23 00:00:00' then insert into cdr_report20161022 select NEW.*;
elsif t >= '2016-10-23 00:00:00' and t< '2016-10-24 00:00:00' then insert into cdr_report20161023 select NEW.*;
elsif t >= '2016-10-24 00:00:00' and t< '2016-10-25 00:00:00' then insert into cdr_report20161024 select NEW.*;
elsif t >= '2016-10-25 00:00:00' and t< '2016-10-26 00:00:00' then insert into cdr_report20161025 select NEW.*;
elsif t >= '2016-10-26 00:00:00' and t< '2016-10-27 00:00:00' then insert into cdr_report20161026 select NEW.*;
elsif t >= '2016-10-27 00:00:00' and t< '2016-10-28 00:00:00' then insert into cdr_report20161027 select NEW.*;
elsif t >= '2016-10-28 00:00:00' and t< '2016-10-29 00:00:00' then insert into cdr_report20161028 select NEW.*;
elsif t >= '2016-10-29 00:00:00' and t< '2016-10-30 00:00:00' then insert into cdr_report20161029 select NEW.*;
elsif t >= '2016-10-30 00:00:00' and t< '2016-10-31 00:00:00' then insert into cdr_report20161030 select NEW.*;
elsif t >= '2016-10-31 00:00:00' and t< '2016-11-01 00:00:00' then insert into cdr_report20161031 select NEW.*;
elsif t >= '2016-11-01 00:00:00' and t< '2016-11-02 00:00:00' then insert into cdr_report20161101 select NEW.*;
elsif t >= '2016-11-02 00:00:00' and t< '2016-11-03 00:00:00' then insert into cdr_report20161102 select NEW.*;
elsif t >= '2016-11-03 00:00:00' and t< '2016-11-04 00:00:00' then insert into cdr_report20161103 select NEW.*;
elsif t >= '2016-11-04 00:00:00' and t< '2016-11-05 00:00:00' then insert into cdr_report20161104 select NEW.*;
elsif t >= '2016-11-05 00:00:00' and t< '2016-11-06 00:00:00' then insert into cdr_report20161105 select NEW.*;
elsif t >= '2016-11-06 00:00:00' and t< '2016-11-07 00:00:00' then insert into cdr_report20161106 select NEW.*;
elsif t >= '2016-11-07 00:00:00' and t< '2016-11-08 00:00:00' then insert into cdr_report20161107 select NEW.*;
elsif t >= '2016-11-08 00:00:00' and t< '2016-11-09 00:00:00' then insert into cdr_report20161108 select NEW.*;
elsif t >= '2016-11-09 00:00:00' and t< '2016-11-10 00:00:00' then insert into cdr_report20161109 select NEW.*;
elsif t >= '2016-11-10 00:00:00' and t< '2016-11-11 00:00:00' then insert into cdr_report20161110 select NEW.*;
elsif t >= '2016-11-11 00:00:00' and t< '2016-11-12 00:00:00' then insert into cdr_report20161111 select NEW.*;
elsif t >= '2016-11-12 00:00:00' and t< '2016-11-13 00:00:00' then insert into cdr_report20161112 select NEW.*;
elsif t >= '2016-11-13 00:00:00' and t< '2016-11-14 00:00:00' then insert into cdr_report20161113 select NEW.*;
elsif t >= '2016-11-14 00:00:00' and t< '2016-11-15 00:00:00' then insert into cdr_report20161114 select NEW.*;
elsif t >= '2016-11-15 00:00:00' and t< '2016-11-16 00:00:00' then insert into cdr_report20161115 select NEW.*;
elsif t >= '2016-11-16 00:00:00' and t< '2016-11-17 00:00:00' then insert into cdr_report20161116 select NEW.*;
elsif t >= '2016-11-17 00:00:00' and t< '2016-11-18 00:00:00' then insert into cdr_report20161117 select NEW.*;
elsif t >= '2016-11-18 00:00:00' and t< '2016-11-19 00:00:00' then insert into cdr_report20161118 select NEW.*;
elsif t >= '2016-11-19 00:00:00' and t< '2016-11-20 00:00:00' then insert into cdr_report20161119 select NEW.*;
elsif t >= '2016-11-20 00:00:00' and t< '2016-11-21 00:00:00' then insert into cdr_report20161120 select NEW.*;
elsif t >= '2016-11-21 00:00:00' and t< '2016-11-22 00:00:00' then insert into cdr_report20161121 select NEW.*;
elsif t >= '2016-11-22 00:00:00' and t< '2016-11-23 00:00:00' then insert into cdr_report20161122 select NEW.*;
elsif t >= '2016-11-23 00:00:00' and t< '2016-11-24 00:00:00' then insert into cdr_report20161123 select NEW.*;
elsif t >= '2016-11-24 00:00:00' and t< '2016-11-25 00:00:00' then insert into cdr_report20161124 select NEW.*;
elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into cdr_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into cdr_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into cdr_report20161202 select NEW.*;

                else
                        raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
                        return NEW;
                end if;


                return NULL;
        END
        $$;


ALTER FUNCTION public.class4_trigfun_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_upload(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_upload() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
declare
	table_type integer;
	table_name text;
	create_cmd text;
begin
	table_type := NEW.upload_type;
	table_name := NEW.upload_table;

	if table_type=1 then
	--upload ingress
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial,
		alias text NOT NULL,
		active text DEFAULT $$true$$,
		t38 text DEFAULT $$false$$,
		cps_limit text,
		capacity text,
		lnp text DEFAULT $$false$$,
		lrn_block text DEFAULT $$false$$,
		carrier_name text NOT NULL,
		rate_table_name text,
		route_plan_name text,
		media_type text DEFAULT $$1$$,--0ï¼ï¼Proxy Media + Transcoding,1ï¼ï¼Proxy Media,2ï¼ï¼Bypass Media
		proto text DEFAULT $$1$$,--1--sip,2--h323,0--all
		dnis_only text DEFAULT $$true$$,
		ring_timeout text,
		ignore_ring text DEFAULT $$false$$,
		ignore_early_media text DEFAULT $$false$$,
		codec text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=2 then
	--upload egress
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		alias text NOT NULL,
		active text DEFAULT $$true$$,
		t38 text DEFAULT $$false$$,
		res_strategy text DEFAULT $$1$$,--1ï¼ï¼top-down,2ï¼ï¼round-robin
		cps_limit text,
		capacity text,
		lnp text DEFAULT $$false$$,
		lrn_block text DEFAULT $$false$$,
		carrier_name text NOT NULL,
		rate_table_name text,
		route_plan_name text,
		media_type text DEFAULT $$1$$,--0ï¼ï¼Proxy Media + Transcoding,1ï¼ï¼Proxy Media,2ï¼ï¼Bypass Media
		proto text DEFAULT $$1$$,--1--sip,2--h323
		dnis_only text DEFAULT $$true$$,
		ring_timeout text,
		ignore_ring text DEFAULT $$false$$,
		ignore_early_media text DEFAULT $$false$$,
		codec text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=3 then
	--upload host
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		resource_name text NOT NULL,
		ip text NOT NULL,
		port text NOT NULL,
		time_profile_name text,
		cps text,
		capacity text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=4 then
	--upload resource_action
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		resource_name text NOT NULL,
		direction text NOT NULL,--1ï¼ï¼ingress,2ï¼ï¼egress
		"action" text NOT NULL,
		digits text NOT NULL,
		dnis text,
		time_profile_name text,
		"type" text NOT NULL,
		number_length text,
		number_type text DEFAULT $$0$$,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=5 then
	--upload resource digit mapping
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		resource_name text NOT NULL,
		translation_name text NOT NULL,
		time_profile_name text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=6 then
	--upload digit translation
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		ani text,
		dnis text,
		action_ani text NOT NULL,
		action_dnis text NOT NULL,
		ani_method text NOT NULL,--0ï¼ï¼ignore,1ï¼ï¼compare,2ï¼ï¼replace
		dnis_method text NOT NULL,--0ï¼ï¼ignore,1ï¼ï¼compare,2ï¼ï¼replace
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=7 then
	--upload resource block
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		ingress_name text NOT NULL,
		engress_name text NOT NULL,
		digit text,
		time_profile_name text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=8 then
	--upload jurisdiction
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		--alias text ,
		prefix text NOT NULL,
		state text NOT NULL,
		jurisdiction_name text NOT NULL,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=9 then
	--upload code
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		code text NOT NULL,
		country text NOT NULL,
		"name" text NOT NULL,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=10 then
	--upload rate
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		code text NOT NULL,
		rate text NOT NULL DEFAULT $$0$$,
		setup_fee text DEFAULT $$0$$,
		effective_date text DEFAULT current_timestamp(0)::text,
		end_date text,
		min_time text DEFAULT $$0$$,
		grace_time text DEFAULT $$0$$,
		"interval" text DEFAULT $$1$$,
		time_profile_name text,
		seconds text DEFAULT $$60$$,
		code_name text,
		intra_rate text DEFAULT $$0$$,
		inter_rate text DEFAULT $$0$$,
		local_rate text DEFAULT $$0$$,
		country text,
		zone text DEFAULT $$0$$,
		error_info text,
		is_duplicate boolean
		)';
		return null;
	elsif table_type=11 then
	--upload static route
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		digits text NOT NULL,
		strategy text NOT NULL,
		resource_alias text NOT NULL,
		percentage text,
		time_profile_name text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=12 then
	--upload route plan
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		digits text,
		route_type text NOT NULL,
		dynamic_route_name text,
		static_route_name text,
		error_info text,
		is_duplicate boolean
		)';
	else return null;
	end if;

	execute create_cmd;

	return null;

end;
$_$;


ALTER FUNCTION public.class4_trigfun_upload() OWNER TO postgres;

--
-- Name: class4_trigfun_us_frequent_number_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_us_frequent_number_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
		DECLARE
		t timestamp with time zone;
		BEGIN
		t:= NEW.report_time;

				if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
						insert into us_frequent_number_report20161201 select NEW.*;
				elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
						insert into us_frequent_number_report20161202 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
						insert into us_frequent_number_report20161130 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into us_frequent_number_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into us_frequent_number_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into us_frequent_number_report20161202 select NEW.*;

				else
						raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
						return NEW;
				end if;


				return NULL;
		END
		$$;


ALTER FUNCTION public.class4_trigfun_us_frequent_number_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_us_lcr_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_us_lcr_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
		DECLARE
		t timestamp with time zone;
		BEGIN
		t:= NEW.report_time;

				if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
						insert into us_lcr_report20161201 select NEW.*;
				elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
						insert into us_lcr_report20161202 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
						insert into us_lcr_report20161130 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into us_lcr_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into us_lcr_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into us_lcr_report20161202 select NEW.*;

				else
						raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
						return NEW;
				end if;


				return NULL;
		END
		$$;


ALTER FUNCTION public.class4_trigfun_us_lcr_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_us_lcr_vendor_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_us_lcr_vendor_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
		DECLARE
		t timestamp with time zone;
		BEGIN
		t:= NEW.report_time;

				if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
						insert into us_lcr_vendor_report20161201 select NEW.*;
				elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
						insert into us_lcr_vendor_report20161202 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
						insert into us_lcr_vendor_report20161130 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into us_lcr_vendor_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into us_lcr_vendor_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into us_lcr_vendor_report20161202 select NEW.*;

				else
						raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
						return NEW;
				end if;


				return NULL;
		END
		$$;


ALTER FUNCTION public.class4_trigfun_us_lcr_vendor_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_us_return_code_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_us_return_code_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
		DECLARE
		t timestamp with time zone;
		BEGIN
		t:= NEW.report_time;

				if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
						insert into us_return_code_report20161201 select NEW.*;
				elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
						insert into us_return_code_report20161202 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
						insert into us_return_code_report20161130 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into us_return_code_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into us_return_code_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into us_return_code_report20161202 select NEW.*;

				else
						raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
						return NEW;
				end if;


				return NULL;
		END
		$$;


ALTER FUNCTION public.class4_trigfun_us_return_code_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_us_termination_vendor_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4_trigfun_us_termination_vendor_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
		DECLARE
		t timestamp with time zone;
		BEGIN
		t:= NEW.report_time;

				if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
						insert into us_termination_vendor_report20161201 select NEW.*;
				elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
						insert into us_termination_vendor_report20161202 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
						insert into us_termination_vendor_report20161130 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into us_termination_vendor_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into us_termination_vendor_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into us_termination_vendor_report20161202 select NEW.*;

				else
						raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
						return NEW;
				end if;


				return NULL;
		END
		$$;


ALTER FUNCTION public.class4_trigfun_us_termination_vendor_report_insert() OWNER TO postgres;

--
-- Name: class4fun_rate_dynamic2static(integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4fun_rate_dynamic2static(integer, integer, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$

declare
	id_rate_table alias for $1;
	id_rate alias for $2;
	code_rate alias for $3;
	action alias for $4;
        rate_prefix prefix_range;
        id_static_product integer;
        id_dynamic_route integer;
        old_code text;
        new_code text;
        r record;
        route_rule integer;
        id_profile integer;
        res record;
        sql_text text;
        new_res_1 integer;
        new_res_2 integer;
        new_res_3 integer;
        new_res_4 integer;
        new_res_5 integer;
        new_res_6 integer;
        new_res_7 integer;
        new_res_8 integer;
	prefix_count integer;

begin
        if(action='INSERT') then
			select into new_code COALESCE(code_rate,'');
-- 			select into prefix_count count(1) from rate where rate_table_id=id_rate_table and code::text=new_code;
-- 			if prefix_count>1 then
-- 				--raise notice 'code % exists in rate table %',new_code,NEW.rate_table_id;
-- 				return null;
-- 			end if;
                        for id_dynamic_route in select dynamic_route_id from dynamic_route where
                        resource_id_1 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_2 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_3 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_4 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_5 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_6 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_7 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_8 in (select resource_id from resource where rate_table_id = id_rate_table)
                        loop
                                select into route_rule routing_rule from dynamic_route where dynamic_route_id = id_dynamic_route;
                                select into id_profile time_profile_id from dynamic_route where dynamic_route_id = id_dynamic_route;
                                select into id_static_product product_id from product where dynamic_route_id = id_dynamic_route;

                                select into res resource_id_1,resource_id_2,resource_id_3,resource_id_4,
                                resource_id_5,resource_id_6,resource_id_7,resource_id_8 from dynamic_route where dynamic_route_id=id_dynamic_route;

                                select into new_res_1 COALESCE(res.resource_id_1,-1);
                                select into new_res_2 COALESCE(res.resource_id_2,-1);
                                select into new_res_3 COALESCE(res.resource_id_3,-1);
                                select into new_res_4 COALESCE(res.resource_id_4,-1);
                                select into new_res_5 COALESCE(res.resource_id_5,-1);
                                select into new_res_6 COALESCE(res.resource_id_6,-1);
                                select into new_res_7 COALESCE(res.resource_id_7,-1);
                                select into new_res_8 COALESCE(res.resource_id_8,-1);

				PERFORM dynamic2static(id_dynamic_route,id_static_product,
				new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8,route_rule,id_profile,new_code);

                        end loop;
        end if;

        if(action='DELETE') then
                        select into old_code COALESCE(code_rate,'');
-- 			if exists(select 1 from rate where rate_table_id=OLD.rate_table_id and code::text=old_code) then
-- 				--raise notice 'code % exists in rate table %',old_code,OLD.rate_table_id;
-- 				return null;
-- 			end if;
                        for id_dynamic_route in select dynamic_route_id from dynamic_route where
                        resource_id_1 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_2 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_3 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_4 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_5 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_6 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_7 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_8 in (select resource_id from resource where rate_table_id = id_rate_table)
                        loop
                                select into route_rule routing_rule from dynamic_route where dynamic_route_id = id_dynamic_route;
                                select into id_profile time_profile_id from dynamic_route where dynamic_route_id = id_dynamic_route;
                                select into id_static_product product_id from product where dynamic_route_id = id_dynamic_route;

                                select into res resource_id_1,resource_id_2,resource_id_3,resource_id_4,
                                resource_id_5,resource_id_6,resource_id_7,resource_id_8 from dynamic_route where dynamic_route_id=id_dynamic_route;

                                select into new_res_1 COALESCE(res.resource_id_1,-1);
                                select into new_res_2 COALESCE(res.resource_id_2,-1);
                                select into new_res_3 COALESCE(res.resource_id_3,-1);
                                select into new_res_4 COALESCE(res.resource_id_4,-1);
                                select into new_res_5 COALESCE(res.resource_id_5,-1);
                                select into new_res_6 COALESCE(res.resource_id_6,-1);
                                select into new_res_7 COALESCE(res.resource_id_7,-1);
                                select into new_res_8 COALESCE(res.resource_id_8,-1);

				PERFORM dynamic2static(id_dynamic_route,id_static_product,
				new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8,route_rule,id_profile,old_code);

                        end loop;
        end if;

        return null;

end;

$_$;


ALTER FUNCTION public.class4fun_rate_dynamic2static(integer, integer, text, text) OWNER TO postgres;

--
-- Name: class4fun_rate_table_dynamic2static(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4fun_rate_table_dynamic2static(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$

declare
	id_rate_table alias for $1;
        rate_prefix prefix_range;
        id_static_product integer;
        id_dynamic_route integer;
        old_rt integer;
        new_rt integer;
        r record;
        route_rule integer;
        id_profile integer;
        res record;
        new_res_1 integer;
        new_res_2 integer;
        new_res_3 integer;
        new_res_4 integer;
        new_res_5 integer;
        new_res_6 integer;
        new_res_7 integer;
        new_res_8 integer;
        sql_text text;

begin
	for id_dynamic_route in select dynamic_route_id from dynamic_route where
	resource_id_1 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_2 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_3 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_4 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_5 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_6 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_7 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_8 in (select resource_id from resource where rate_table_id = id_rate_table)
	loop
		select into route_rule routing_rule from dynamic_route where dynamic_route_id = id_dynamic_route;
		select into id_profile time_profile_id from dynamic_route where dynamic_route_id = id_dynamic_route;
		select into id_static_product product_id from product where dynamic_route_id = id_dynamic_route;

		select into res resource_id_1,resource_id_2,resource_id_3,resource_id_4,
		resource_id_5,resource_id_6,resource_id_7,resource_id_8 from dynamic_route where dynamic_route_id=id_dynamic_route;

		select into new_res_1 COALESCE(res.resource_id_1,-1);
		select into new_res_2 COALESCE(res.resource_id_2,-1);
		select into new_res_3 COALESCE(res.resource_id_3,-1);
		select into new_res_4 COALESCE(res.resource_id_4,-1);
		select into new_res_5 COALESCE(res.resource_id_5,-1);
		select into new_res_6 COALESCE(res.resource_id_6,-1);
		select into new_res_7 COALESCE(res.resource_id_7,-1);
		select into new_res_8 COALESCE(res.resource_id_8,-1);

		PERFORM dynamic2static(id_dynamic_route,id_static_product,
		new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8,route_rule,id_profile);

	end loop;

        return null;

end;

$_$;


ALTER FUNCTION public.class4fun_rate_table_dynamic2static(integer) OWNER TO postgres;

--
-- Name: class4fun_rate_update_dynamic2static(integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION class4fun_rate_update_dynamic2static(integer, integer, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$

declare
	id_rate_table alias for $1;
	id_rate alias for $2;
	code_rate alias for $3;
	old_code_rate alias for $4;
        rate_prefix prefix_range;
        id_static_product integer;
        id_dynamic_route integer;
        old_code text;
        new_code text;
        r record;
        route_rule integer;
        id_profile integer;
        res record;
        sql_text text;
        new_res_1 integer;
        new_res_2 integer;
        new_res_3 integer;
        new_res_4 integer;
        new_res_5 integer;
        new_res_6 integer;
        new_res_7 integer;
        new_res_8 integer;
	prefix_count integer;

begin
	--if(TG_OP='UPDATE') then
		select into old_code COALESCE(old_code_rate,'');
		select into new_code COALESCE(code_rate,'');
		if old_code != new_code then
			for id_dynamic_route in
			select dynamic_route_id from dynamic_route where
			resource_id_1 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_2 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_3 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_4 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_5 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_6 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_7 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_8 in (select resource_id from resource where rate_table_id = id_rate_table)
			loop
				select into route_rule routing_rule from dynamic_route where dynamic_route_id = id_dynamic_route;
				select into id_profile time_profile_id from dynamic_route where dynamic_route_id = id_dynamic_route;
				select into id_static_product product_id from product where dynamic_route_id = id_dynamic_route;

				select into res resource_id_1,resource_id_2,resource_id_3,resource_id_4,
				resource_id_5,resource_id_6,resource_id_7,resource_id_8 from dynamic_route where dynamic_route_id=id_dynamic_route;

				select into new_res_1 COALESCE(res.resource_id_1,-1);
				select into new_res_2 COALESCE(res.resource_id_2,-1);
				select into new_res_3 COALESCE(res.resource_id_3,-1);
				select into new_res_4 COALESCE(res.resource_id_4,-1);
				select into new_res_5 COALESCE(res.resource_id_5,-1);
				select into new_res_6 COALESCE(res.resource_id_6,-1);
				select into new_res_7 COALESCE(res.resource_id_7,-1);
				select into new_res_8 COALESCE(res.resource_id_8,-1);

				--if not exists(select 1 from rate where rate_table_id=OLD.rate_table_id and code::text=old_code) then
					PERFORM dynamic2static(id_dynamic_route,id_static_product,
					new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8,route_rule,id_profile,old_code);
-- 				else
-- 					raise notice 'code % exists in rate table %',old_code,OLD.rate_table_id;
				--end if;
				--select into prefix_count count(1) from rate where rate_table_id=NEW.rate_table_id and code::text=new_code;
				--if prefix_count=1 then
					PERFORM dynamic2static(id_dynamic_route,id_static_product,
					new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8,route_rule,id_profile,new_code);
-- 				else
-- 					raise notice 'code % exists in rate table %',new_code,NEW.rate_table_id;
				--end if;
			end loop;
		end if;
	--end if;

        return null;

end;

$_$;


ALTER FUNCTION public.class4fun_rate_update_dynamic2static(integer, integer, text, text) OWNER TO postgres;

--
-- Name: clean_rate(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION clean_rate() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
	clean_days integer;
begin

	select into clean_days rate_clean_days from system_parameter;
	delete from rate where end_date-now()>clean_days::text::interval;
end;

$$;


ALTER FUNCTION public.clean_rate() OWNER TO postgres;

--
-- Name: client_enough_balance(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION client_enough_balance(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
	low_cost client.allowed_credit%type;
	now_balance numeric;
	id_client alias for $1;

begin
	select into low_cost allowed_credit from client where client_id = id_client;
	select into now_balance balance from client_balance where client_id = id_client::text
	order by client_balance_id desc limit 1;
	if not found then
		now_balance := 0;
	end if;
	if now_balance <= low_cost then
		return false;
	else
		return true;
	end if;

end;
$_$;


ALTER FUNCTION public.client_enough_balance(integer) OWNER TO postgres;

--
-- Name: code_stats(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION code_stats(timestamp with time zone, timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	time_start alias for $1;
	time_end alias for $2;
begin

	delete from code_stats;
	for r in
		select term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00') as s_time,
		count(*) as ca,
		count(case answer_time_of_date when '0' then null when '' then null else answer_time_of_date end) as success_calls,
		sum(call_duration::real)/60 as minutes
		from client_cdr
		where time between time_start and time_end
		group by term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00')
	loop
		insert into code_stats(country,code_name,code,call_duration,ca,success_calls,stat_time)
		select r.term_country,r.term_code_name,r.term_code,r.minutes,r.ca,r.success_calls,r.s_time::timestamp with time zone;
	end loop;
end;

$_$;


ALTER FUNCTION public.code_stats(timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION connectby(text, text, text, text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text';


ALTER FUNCTION public.connectby(text, text, text, text, integer) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION connectby(text, text, text, text, integer, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text';


ALTER FUNCTION public.connectby(text, text, text, text, integer, text) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION connectby(text, text, text, text, text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text_serial';


ALTER FUNCTION public.connectby(text, text, text, text, text, integer) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION connectby(text, text, text, text, text, integer, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text_serial';


ALTER FUNCTION public.connectby(text, text, text, text, text, integer, text) OWNER TO postgres;

--
-- Name: create_client_invoice(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION create_client_invoice() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
	last_date date;
	r record;
	pay_term_row record;
	in_total numeric := 0;
	in_amount numeric := 0;
	out_total numeric := 0;
	out_amount numeric := 0;
	in_minutes integer := 0;
	out_minutes integer := 0;
	due date;
	now_balance numeric;
	no_invoice text;
	r1 record;
	l_rate_minutes integer;
	gt_rate_minutes integer;
	gt_max_rate_minutes integer;
	charge_rate record;
	l_sell_rate_minutes integer;
	gt_sell_rate_minutes integer;
	gt_sell_max_rate_minutes integer;
	past_amount numeric := 0;
	pay_more_days integer;
	invoice_start_time timestamp with time zone;
	invoice_end_time timestamp with time zone;
	lrn_count integer := 0;
	lrn_call_rate numeric;
	lrn_call_cost numeric;

begin
	for r in select * from client where auto_invoicing = true
	loop
		in_total := 0;
		in_amount := 0;
		out_total := 0;
		out_amount := 0;
		l_rate_minutes := 0;
		gt_rate_minutes := 0;
		gt_max_rate_minutes := 0;
		l_sell_rate_minutes := 0;
		gt_sell_rate_minutes := 0;
		gt_sell_max_rate_minutes := 0;
		in_minutes := 0;
		out_minutes := 0;
		past_amount := 0;
		select into pay_term_row * from payment_term where payment_term_id = r.payment_term_id;

		select into last_date last_invoiced from client where client_id = r.client_id;
		if last_date is null then
			raise notice 'last invoice date is not found';
			continue;
		end if;
		if(last_date=current_date) then
			continue;
		end if;

		if(pay_term_row.type=1) then
		/*every days*/
			if(last_date + pay_term_row.days != current_date) then
				continue;
			end if;
		end if;
		if(pay_term_row.type=2) then
		/*every month*/
			if pay_term_row.days!=EXTRACT(DAY from now()) then
				if (to_char(now(),'DD') != to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) or (pay_term_row.days::text < to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) then
					continue;
				end if;
			end if;
		end if;
		if(pay_term_row.type=3) then
		/*every week*/
			if(pay_term_row.days != EXTRACT(DOW FROM now())) then
				continue;
			end if;
		end if;
		if(pay_term_row.type=4) then
		/*every month,more days*/
			for pay_more_days in select regexp_split_to_table(pay_term_row.more_days,',')
			loop
				if pay_more_days=EXTRACT(DAY from now()) then
					exit;
				elsif pay_more_days::text > to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD') and to_char(now(),'DD') = to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD') then
					exit;
				else
					continue;
				end if;
			end loop;
			if pay_more_days!=EXTRACT(DAY from now()) then
				if (to_char(now(),'DD') != to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) or (pay_more_days::text < to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) then
					continue;
				end if;
			end if;
		end if;

		raise notice 'create invoice for client %',r.client_id;
		select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;

		if r.invoice_zone is null or r.invoice_zone = '' or r.invoice_zone =' ' then
		select into invoice_start_time to_char(last_date,'YYYY-MM-DD 00:00:00')::timestamp with time zone;
		select into invoice_end_time to_char(current_date-1,'YYYY-MM-DD 23:59:59')::timestamp with time zone;
		else
		select into invoice_start_time (to_char(last_date,'YYYY-MM-DD 00:00:00')||r.invoice_zone)::timestamp with time zone;
		select into invoice_end_time (to_char(current_date-1,'YYYY-MM-DD 23:59:59')||r.invoice_zone)::timestamp with time zone;
		end if;

		if exists(select 1 from invoice where client_id=r.client_id and invoice_start=invoice_start_time and invoice_end=invoice_end_time) then
		raise notice 'exist invoice,continue';
		continue;
		end if;

		if r.auto_invoice_type=0 then
		--buy invoice

		------------------Ingress Invoice--------------
		select into lrn_count
		count(*)
		from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time
		and (lrn_number_vendor='2' or lrn_number_vendor='3') and is_final_call='1';
		if lrn_count is null then
			lrn_count := 0;
		end if;

		select into lrn_call_cost
		sum(case when lnp_dipping_cost is null then 0 when lnp_dipping_cost='' then 0 else lnp_dipping_cost::real end)
		from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if lrn_call_cost is null then
			lrn_call_cost := 0;
		end if;

		if lrn_count = 0 then
			lrn_call_rate :=0;
		else
			lrn_call_rate := lrn_call_cost/lrn_count;
		end if;

		select into in_total sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_total is null then
			in_total :=0;
		end if;

		if in_total = 0 and (r.invoice_zero is true or r.invoice_zero is null) then
		raise notice 'cost is 0,continue';
		continue;
		end if;

		select into in_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_minutes is null then
			in_minutes := 0;
		end if;

		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'buy total %,buy minutes %',in_total,in_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT trim(both ' ' from orig_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case ingress_rate_effective_date when '' then null else ingress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) as total_cost,
		case ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60)
		when 0 then 0
		else sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end)
		/
		(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where ingress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and ingress_client_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by trim(both ' ' from orig_code_name),ingress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,0,r1.effective_date::text;
		end loop;

		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type,lrn_numbers,lrn_rate,lrn_cost,invoice_zone)
		select
		in_total,in_total,null,in_minutes,null,0,0,0,r.client_id,current_timestamp(0),invoice_start_time,invoice_end_time,due,now_balance,no_invoice,0,null,null,null,r.invoice_zone;

		select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;

		elsif r.auto_invoice_type=1 then
		--sell invoice

		------------------Egress Invoice--------------
		select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_total is null then
			out_total :=0;
		end if;
		if out_total = 0 and (r.invoice_zero is true or r.invoice_zero is null) then
		raise notice 'cost is 0,continue';
                continue;
		end if;

		select into out_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case egress_bill_time when '' then 0 else egress_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_minutes is null then
			out_minutes := 0;
		end if;
		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'sell total %,sell minutes %',out_total,out_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT trim(both ' ' from term_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case egress_rate_effective_date when '' then null else egress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case egress_cost when '' then 0 else egress_cost::numeric end) as total_cost,
		case ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60)
		when 0 then 0
		else
		sum(case egress_cost when '' then 0 else egress_cost::numeric end)
		/
		(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where egress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and egress_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by trim(both ' ' from term_code_name),egress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,1,r1.effective_date::text;
		end loop;

		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type,invoice_zone)
		select
		out_total,null,out_total,null,out_minutes,0,0,0,r.client_id,current_timestamp(0),invoice_start_time,invoice_end_time,due,now_balance,no_invoice,1,r.invoice_zone;


		elsif r.auto_invoice_type=2 then
		--buy and sell invoice

		------------------Ingress Invoice--------------
		select into lrn_count
		count(*)
		from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time
		and (lrn_number_vendor='2' or lrn_number_vendor='3') and is_final_call='1';
		if lrn_count is null then
			lrn_count := 0;
		end if;

		select into lrn_call_cost
		sum(case when lnp_dipping_cost is null then 0 when lnp_dipping_cost='' then 0 else lnp_dipping_cost::real end)
		from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if lrn_call_cost is null then
			lrn_call_cost := 0;
		end if;

		if lrn_count = 0 then
			lrn_call_rate :=0;
		else
			lrn_call_rate := lrn_call_cost/lrn_count;
		end if;

		select into in_total sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_total is null then
			in_total :=0;
		end if;
                select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
                where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
                if out_total is null then
                        out_total :=0;
                end if;
		if in_total = 0 and out_total = 0 and (r.invoice_zero is true or r.invoice_zero is null) then
			raise notice 'cost is 0,continue';
			continue;
		end if;

		select into in_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_minutes is null then
			in_minutes := 0;
		end if;

		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'buy total %,buy minutes %',in_total,in_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT trim(both ' ' from orig_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case ingress_rate_effective_date when '' then null else ingress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) as total_cost,
		case ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60)
		when 0 then 0
		else sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end)
		/
		(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where ingress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and ingress_client_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by trim(both ' ' from orig_code_name),ingress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,0,r1.effective_date::text;
		end loop;

		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type,lrn_numbers,lrn_rate,lrn_cost,invoice_zone)
		select
		in_total,in_total,null,in_minutes,null,0,0,0,r.client_id,current_timestamp(0),invoice_start_time,invoice_end_time,due,now_balance,no_invoice,0,null,null,null,r.invoice_zone;

		select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;

		------------------Egress Invoice--------------
		select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_total is null then
			out_total :=0;
		end if;
		select into out_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case egress_bill_time when '' then 0 else egress_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_minutes is null then
			out_minutes := 0;
		end if;
		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'sell total %,sell minutes %',out_total,out_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT trim(both ' ' from term_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case egress_rate_effective_date when '' then null else egress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case egress_cost when '' then 0 else egress_cost::numeric end) as total_cost,
		case ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60)
		when 0 then 0
		else
		sum(case egress_cost when '' then 0 else egress_cost::numeric end)
		/
		(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where egress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and egress_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by trim(both ' ' from term_code_name),egress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,1,r1.effective_date::text;
		end loop;

		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type,invoice_zone)
		select
		out_total,null,out_total,null,out_minutes,0,0,0,r.client_id,current_timestamp(0),invoice_start_time,invoice_end_time,due,now_balance,no_invoice,1,r.invoice_zone;

		end if;

		update client set last_invoiced = current_timestamp(0) where client_id = r.client_id;

		end loop;

	return null;

end;
$$;


ALTER FUNCTION public.create_client_invoice() OWNER TO postgres;

--
-- Name: create_client_invoice(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION create_client_invoice(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, integer, timestamp with time zone) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	last_date date;
	r record;
	pay_term_row record;
	in_total numeric := 0;
	in_amount numeric := 0;
	out_total numeric := 0;
	out_amount numeric := 0;
	in_minutes integer := 0;
	out_minutes integer := 0;
	due date;
	now_balance numeric;
	no_invoice text;
	r1 record;
	l_rate_minutes integer;
	gt_rate_minutes integer;
	gt_max_rate_minutes integer;
	charge_rate record;
	l_sell_rate_minutes integer;
	gt_sell_rate_minutes integer;
	gt_sell_max_rate_minutes integer;
	past_amount numeric := 0;

	id_client alias for $1;
	time_start alias for $2;
	time_end alias for $3;
	number_invoice alias for $4;
	date_due alias for $5;
	type_invoice alias for $6;
	date_invoice alias for $7;
	lrn_count integer :=0;
	lrn_call_rate numeric;
	lrn_call_cost numeric :=0;

begin
		in_total := 0;
		in_amount := 0;
		out_total := 0;
		out_amount := 0;
		l_rate_minutes := 0;
		gt_rate_minutes := 0;
		gt_max_rate_minutes := 0;
		l_sell_rate_minutes := 0;
		gt_sell_rate_minutes := 0;
		gt_sell_max_rate_minutes := 0;
		in_minutes := 0;
		out_minutes := 0;
		past_amount := 0;

		raise notice 'create invoice for client %',id_client;
		if number_invoice='' then
			select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;
		else
			no_invoice := number_invoice;
		end if;
		raise notice 'invoice number is %',no_invoice;

		if type_invoice =0 then
		------------------Ingress Invoice--------------
		select into lrn_count
		count(*)
		from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone
		and (lrn_number_vendor='2' or lrn_number_vendor='3') and is_final_call='1';
		if lrn_count is null then
			lrn_count := 0;
		end if;

		select into lrn_call_cost
		sum(case when lnp_dipping_cost is null then 0 when lnp_dipping_cost='' then 0 else lnp_dipping_cost::real end)
		from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if lrn_call_cost is null then
			lrn_call_cost := 0;
		end if;

		if lrn_count = 0 then
			lrn_call_rate :=0;
		else
			lrn_call_rate := lrn_call_cost/lrn_count;
		end if;

		select into in_total sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if in_total is null then
			in_total :=0;
		end if;

		select into in_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if in_minutes is null then
			in_minutes := 0;
		end if;

		due := date_due;

		select into now_balance balance from client_balance where client_id = id_client::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'buy total %,buy minutes %',in_total,in_minutes;

		for r1 in
		SELECT trim(both ' ' from orig_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case ingress_rate_effective_date when '' then null else ingress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) as total_cost,
		case ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60)
		when 0 then 0
		else sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end)
		/
		(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where ingress_client_id = id_client::text
		and answer_time_of_date != '0'
		and ingress_client_bill_result ='1'
		and time between time_start::timestamp with time zone and time_end::timestamp with time zone
		group by trim(both ' ' from orig_code_name),ingress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,0,r1.effective_date::text;
		end loop;
		end if;

		if type_invoice =0 then
		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type,lrn_numbers,lrn_rate,lrn_cost)
		select
		in_total,in_total,null,in_minutes,null,0,0,0,id_client,date_invoice,time_start,time_end,date_due,now_balance,no_invoice,0,null,null,null;
		end if;

		if type_invoice =1 then
		------------------Egress Invoice--------------
		select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
		where egress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if out_total is null then
			out_total :=0;
		end if;
		select into out_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case egress_bill_time when '' then 0 else egress_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where egress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if out_minutes is null then
			out_minutes := 0;
		end if;
		due := date_due;

		select into now_balance balance from client_balance where client_id = id_client::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'sell total %,sell minutes %',out_total,out_minutes;

		for r1 in
		SELECT trim(both ' ' from term_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case egress_rate_effective_date when '' then null else egress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case egress_cost when '' then 0 else egress_cost::numeric end) as total_cost,
		case ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60)
		when 0 then 0
		else
		sum(case egress_cost when '' then 0 else egress_cost::numeric end)
		/
		(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where egress_client_id = id_client::text
		and answer_time_of_date != '0'
		and egress_bill_result ='1'
		and time between time_start::timestamp with time zone and time_end::timestamp with time zone
		group by trim(both ' ' from term_code_name),egress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,1,r1.effective_date::text;
		end loop;
		end if;

		if type_invoice =1 then
		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type)
		select
		out_total,null,out_total,null,out_minutes,0,0,0,id_client,date_invoice,time_start,time_end,date_due,now_balance,no_invoice,1;
		end if;

		update client set last_invoiced = date_invoice where client_id = id_client;
		update invoice set create_type=1 where invoice_number=no_invoice;

		select into no_invoice invoice_number from invoice where invoice_number=no_invoice;
		if not found then
			return '';
		else
			return no_invoice;
		end if;

end;
$_$;


ALTER FUNCTION public.create_client_invoice(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, integer, timestamp with time zone) OWNER TO postgres;

--
-- Name: create_client_invoice_exchange(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION create_client_invoice_exchange() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
	last_date date;
	r record;
	pay_term_row record;
	in_total numeric := 0;
	in_amount numeric := 0;
	out_total numeric := 0;
	out_amount numeric := 0;
	in_minutes integer := 0;
	out_minutes integer := 0;
	due date;
	now_balance numeric;
	no_invoice text;
	r1 record;
	l_rate_minutes integer;
	gt_rate_minutes integer;
	gt_max_rate_minutes integer;
	charge_rate record;
	l_sell_rate_minutes integer;
	gt_sell_rate_minutes integer;
	gt_sell_max_rate_minutes integer;
	past_amount numeric := 0;
	pay_more_days integer;
	invoice_start_time timestamp with time zone;
	invoice_end_time timestamp with time zone;
	lrn_count integer := 0;
	lrn_call_rate numeric;
	lrn_call_cost numeric;

begin
	for r in select * from client where auto_invoicing = true
	loop
		in_total := 0;
		in_amount := 0;
		out_total := 0;
		out_amount := 0;
		l_rate_minutes := 0;
		gt_rate_minutes := 0;
		gt_max_rate_minutes := 0;
		l_sell_rate_minutes := 0;
		gt_sell_rate_minutes := 0;
		gt_sell_max_rate_minutes := 0;
		in_minutes := 0;
		out_minutes := 0;
		past_amount := 0;
		select into pay_term_row * from payment_term where payment_term_id = r.payment_term_id;

		select into last_date last_invoiced from client where client_id = r.client_id;
		if last_date is null then
			raise notice 'last invoice date is not found';
			continue;
		end if;

		if(last_date=current_date) then
			continue;
		end if;

		if(pay_term_row.type=1) then
		/*every days*/
			if(last_date + pay_term_row.days != current_date) then
				continue;
			end if;
		end if;
		if(pay_term_row.type=2) then
		/*every month*/
			if pay_term_row.days!=EXTRACT(DAY from now()) then
				if (to_char(now(),'DD') != to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) or (pay_term_row.days::text < to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) then
					continue;
				end if;
			end if;
		end if;
		if(pay_term_row.type=3) then
		/*every week*/
			if(pay_term_row.days != EXTRACT(DOW FROM now())) then
				continue;
			end if;
		end if;
		if(pay_term_row.type=4) then
		/*every month,more days*/
			for pay_more_days in select regexp_split_to_table(pay_term_row.more_days,',')
			loop
				if pay_more_days=EXTRACT(DAY from now()) then
					exit;
				elsif pay_more_days::text > to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD') and to_char(now(),'DD') = to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD') then
					exit;
				else
					continue;
				end if;
			end loop;
			if pay_more_days!=EXTRACT(DAY from now()) then
				if (to_char(now(),'DD') != to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) or (pay_more_days::text < to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) then
					continue;
				end if;
			end if;
		end if;

		raise notice 'create invoice for client %',r.client_id;
		select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;
		raise notice 'invoice_number %',no_invoice;


		if r.invoice_zone is null or r.invoice_zone = '' or r.invoice_zone =' ' then
		select into invoice_start_time to_char(last_date,'YYYY-MM-DD 00:00:00')::timestamp with time zone;
		select into invoice_end_time to_char(current_date-1,'YYYY-MM-DD 23:59:59')::timestamp with time zone;
		else
		select into invoice_start_time (to_char(last_date,'YYYY-MM-DD 00:00:00')||r.invoice_zone)::timestamp with time zone;
		select into invoice_end_time (to_char(current_date-1,'YYYY-MM-DD 23:59:59')||r.invoice_zone)::timestamp with time zone;
		end if;

		if exists(select 1 from invoice where client_id=r.client_id and invoice_start=invoice_start_time and invoice_end=invoice_end_time) then
		raise notice 'exist invoice,continue';
		continue;
		end if;

		------------------Ingress Invoice--------------
		select into in_total sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_total is null then
			in_total :=0;
		end if;

		select into in_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_minutes is null then
			in_minutes := 0;
		end if;

		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'buy total %,buy minutes %',in_total,in_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT contract_id,trim(both ' ' from orig_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case ingress_rate_effective_date when '' then null else ingress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) as total_cost,
		case ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60)
		when 0 then 0
		else sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end)
		/
		(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where ingress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and ingress_client_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by contract_id,trim(both ' ' from orig_code_name),ingress_rate_effective_date
		loop
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date,contract_number)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,0,r1.effective_date::text,r1.contract_id;
		end loop;


		------------------Egress Invoice--------------
		select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_total is null then
			out_total :=0;
		end if;
		select into out_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case egress_bill_time when '' then 0 else egress_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_minutes is null then
			out_minutes := 0;
		end if;
		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'sell total %,sell minutes %',out_total,out_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT contract_id,trim(both ' ' from term_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case egress_rate_effective_date when '' then null else egress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case egress_cost when '' then 0 else egress_cost::numeric end) as total_cost,
		case ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60)
		when 0 then 0
		else
		sum(case egress_cost when '' then 0 else egress_cost::numeric end)
		/
		(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where egress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and egress_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by contract_id,trim(both ' ' from term_code_name),egress_rate_effective_date
		loop
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date,contract_number)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,1,r1.effective_date::text,r1.contract_id;
		end loop;
/*
		select into past_amount total_amount from invoice where paid=false and client_id=r.client_id order by invoice_id desc limit 1;
		if past_amount is null then
			past_amount := 0;
		end if;
		raise notice 'past due amount %',past_amount;
*/
		insert into invoice
(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number)
		select
in_total-out_total,in_total,out_total,in_minutes,out_minutes,0,0,0,r.client_id,current_timestamp(0),invoice_start_time,invoice_end_time,due,now_balance,no_invoice;


		update client set last_invoiced = current_timestamp(0) where client_id = r.client_id;

		end loop;

	return null;

end;
$$;


ALTER FUNCTION public.create_client_invoice_exchange() OWNER TO postgres;

--
-- Name: create_client_invoice_exchange(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION create_client_invoice_exchange(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, timestamp with time zone) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	last_date date;
	r record;
	pay_term_row record;
	in_total numeric := 0;
	in_amount numeric := 0;
	out_total numeric := 0;
	out_amount numeric := 0;
	in_minutes integer := 0;
	out_minutes integer := 0;
	due date;
	now_balance numeric;
	no_invoice text;
	r1 record;
	l_rate_minutes integer;
	gt_rate_minutes integer;
	gt_max_rate_minutes integer;
	charge_rate record;
	l_sell_rate_minutes integer;
	gt_sell_rate_minutes integer;
	gt_sell_max_rate_minutes integer;
	past_amount numeric := 0;

	id_client alias for $1;
	time_start alias for $2;
	time_end alias for $3;
	number_invoice alias for $4;
	date_due alias for $5;
	date_invoice alias for $6;
	lrn_count integer :=0;
	lrn_call_rate numeric;
	lrn_call_cost numeric :=0;

begin
		in_total := 0;
		in_amount := 0;
		out_total := 0;
		out_amount := 0;
		l_rate_minutes := 0;
		gt_rate_minutes := 0;
		gt_max_rate_minutes := 0;
		l_sell_rate_minutes := 0;
		gt_sell_rate_minutes := 0;
		gt_sell_max_rate_minutes := 0;
		in_minutes := 0;
		out_minutes := 0;
		past_amount := 0;

		raise notice 'create invoice for client %',id_client;
		if number_invoice='' then
			select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;
		else
			no_invoice := number_invoice;
		end if;
		raise notice 'invoice_number %',no_invoice;


		------------------Ingress Invoice--------------
		select into in_total sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if in_total is null then
			in_total :=0;
		end if;

		select into in_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if in_minutes is null then
			in_minutes := 0;
		end if;

		due := date_due;

		select into now_balance balance from client_balance where client_id = id_client::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'buy total %,buy minutes %',in_total,in_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT contract_id,trim(both ' ' from orig_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case ingress_rate_effective_date when '' then null else ingress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) as total_cost,
		case ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60)
		when 0 then 0
		else sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end)
		/
		(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where ingress_client_id = id_client::text
		and answer_time_of_date != '0'
		and ingress_client_bill_result ='1'
		and time between time_start::timestamp with time zone and time_end::timestamp with time zone
		group by contract_id,trim(both ' ' from orig_code_name),ingress_rate_effective_date
		loop
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date,contract_number)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,0,r1.effective_date::text,r1.contract_id;
		end loop;



		------------------Egress Invoice--------------
		select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
		where egress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if out_total is null then
			out_total :=0;
		end if;
		select into out_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case egress_bill_time when '' then 0 else egress_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where egress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if out_minutes is null then
			out_minutes := 0;
		end if;
		due := date_due;

		select into now_balance balance from client_balance where client_id = id_client::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'sell total %,sell minutes %',out_total,out_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT contract_id,trim(both ' ' from term_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case egress_rate_effective_date when '' then null else egress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case egress_cost when '' then 0 else egress_cost::numeric end) as total_cost,
		case ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60)
		when 0 then 0
		else
		sum(case egress_cost when '' then 0 else egress_cost::numeric end)
		/
		(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where egress_client_id = id_client::text
		and answer_time_of_date != '0'
		and egress_bill_result ='1'
		and time between time_start::timestamp with time zone and time_end::timestamp with time zone
		group by contract_id,trim(both ' ' from term_code_name),egress_rate_effective_date
		loop
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date,contract_number)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,1,r1.effective_date::text,r1.contract_id;
		end loop;
/*
		select into past_amount total_amount from invoice where paid=false and client_id=id_client order by invoice_id desc limit 1;
		if past_amount is null then
			past_amount := 0;
		end if;
		raise notice 'past due amount %',past_amount;
*/
		insert into invoice
(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number)
		select
in_total-out_total,in_total,out_total,in_minutes,out_minutes,0,0,0,id_client,date_invoice,time_start,time_end,due,now_balance,no_invoice;



		update client set last_invoiced = date_invoice where client_id = id_client;
		update invoice set create_type=1 where invoice_number=no_invoice;

		select into no_invoice invoice_number from invoice where invoice_number=no_invoice;
		if not found then
			return '';
		else
			return no_invoice;
		end if;

end;
$_$;


ALTER FUNCTION public.create_client_invoice_exchange(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: crosstab(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab(text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab(text) OWNER TO postgres;

--
-- Name: crosstab(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab(text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab(text, integer) OWNER TO postgres;

--
-- Name: crosstab(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab(text, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab_hash';


ALTER FUNCTION public.crosstab(text, text) OWNER TO postgres;

--
-- Name: crosstab2(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab2(text) RETURNS SETOF tablefunc_crosstab_2
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab2(text) OWNER TO postgres;

--
-- Name: crosstab3(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab3(text) RETURNS SETOF tablefunc_crosstab_3
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab3(text) OWNER TO postgres;

--
-- Name: crosstab4(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION crosstab4(text) RETURNS SETOF tablefunc_crosstab_4
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab4(text) OWNER TO postgres;

--
-- Name: current_balance(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION current_balance(client integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
today date := CURRENT_DATE;
start_date timestamp with time zone = today::text || ' 00:00:00+00';
end_date timestamp with time zone = today::text || ' 23:59:59+00';
my_array numeric(20, 5)[] := '{0,0,0,0,0,0,0,0,0,0,0,0,0}';
actual_ingress_balance numeric(20, 5) := 0;
actual_egress_balance numeric(20, 5) := 0;
actual_total_balance numeric(20, 5) := 0;
mutual_ingress_balance numeric(20, 5) := 0;
mutual_egress_balance numeric(20, 5) := 0;
mutual_total_balance numeric(20, 5) := 0;
r record;
result record;
BEGIN
	for r in
	SELECT COALESCE(sum(amount), 0) as amount, 0 as type FROM client_payment
	WHERE receiving_time between start_date and end_date
	and payment_type in (4,5) AND client_id = client
	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 1 as type FROM client_payment
	WHERE payment_time between start_date and end_date
	and payment_type = 8 AND client_id = client
	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 2 as type FROM client_payment
	WHERE payment_time between start_date and end_date
	and  payment_type = 12 AND client_id = client
	--UNION

	--SELECT COALESCE(sum(ingress_client_cost::numeric(10,4)), 0), 3 as type FROM client_cdr
	--WHERE time BETWEEN start_date and end_date  AND ingress_client_id = client and is_final_call=1

	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 4 as type FROM client_payment
	WHERE payment_time between start_date and end_date
	and payment_type = 15 AND client_id = client
	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 5 as type FROM client_payment
	WHERE receiving_time between start_date and end_date
	and payment_type in (3,6) AND client_id = client
	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 6 as type FROM client_payment
	WHERE payment_time between start_date and end_date
	and payment_type = 7 AND client_id = client
	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 7 as type FROM client_payment
	WHERE payment_time between start_date and end_date
	and payment_type = 11 AND client_id = client
	--UNION
	--SELECT COALESCE(sum(egress_cost), 0) as amount, 8 as type
	--from client_cdr where time between start_date and end_date
	--and egress_client_id = client
	UNION
	SELECT COALESCE(sum(total_amount), 0) as amount, 9 as type FROM invoice
	WHERE invoice_time between start_date and end_date   and
	state != -1 AND type = 0 AND client_id = client
	UNION
	SELECT COALESCE(sum(total_amount), 0) as amount,10 as type FROM invoice
	WHERE invoice_time between start_date and end_date   and
	type = 3 AND client_id = client
	UNION
	SELECT COALESCE(actual_amount, 0) as amount, 11 as type FROM exchange_finance
	WHERE complete_time between start_date and end_date and
	status = 2 and action_type = 2 AND client_id = client
	UNION
	SELECT COALESCE(actual_amount, 0) as amount, 12 as type FROM exchange_finance
	WHERE complete_time between start_date and end_date and
	status = 2 and action_type = 1 AND client_id = client

	loop
		my_array[r.type] =  r.amount;
	end loop;

	my_array[0] = my_array[0] + my_array[11];
	my_array[5] = my_array[5] + my_array[12];

	actual_ingress_balance = my_array[0]  + my_array[1] - my_array[2] - my_array[3] -my_array[4];
	actual_egress_balance = -my_array[5]  - my_array[6] + my_array[7] + my_array[8];
	actual_total_balance = actual_ingress_balance + actual_egress_balance;

	mutual_ingress_balance = -my_array[9] + my_array[0]  + my_array[1] - my_array[2];
	mutual_egress_balance = my_array[10] - my_array[5]  - my_array[6] + my_array[7];
	mutual_total_balance = mutual_ingress_balance+mutual_egress_balance;

	select into r * from balance_history_actual where client_id = client order by date desc;

	actual_ingress_balance = actual_ingress_balance + r.actual_ingress_balance;
	actual_egress_balance = actual_egress_balance + r.actual_egress_balance;
	actual_total_balance = actual_total_balance + r.actual_balance;

	select into r * from balance_history where client_id = client order by date desc;



	mutual_ingress_balance = mutual_ingress_balance + r.mutual_ingress_balance;
	mutual_egress_balance = mutual_egress_balance + r.mutual_egress_balance;
	mutual_total_balance = mutual_total_balance + r.mutual_balance;

	select into result actual_ingress_balance,actual_egress_balance,actual_total_balance,mutual_ingress_balance,mutual_egress_balance,mutual_total_balance;
	return next result;
	return;

END;
$$;


ALTER FUNCTION public.current_balance(client integer) OWNER TO postgres;

--
-- Name: current_balance_detail(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION current_balance_detail(client integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
today date := CURRENT_DATE;
start_date timestamp with time zone = today::text || ' 00:00:00+00';
end_date timestamp with time zone = today::text || ' 23:59:59+00';
my_array numeric(20, 5)[] := '{0,0,0,0,0,0,0,0,0,0,0,0,0}';
actual_ingress_balance numeric(20, 5) := 0;
actual_egress_balance numeric(20, 5) := 0;
actual_total_balance numeric(20, 5) := 0;
mutual_ingress_balance numeric(20, 5) := 0;
mutual_egress_balance numeric(20, 5) := 0;
mutual_total_balance numeric(20, 5) := 0;
r record;
result record;
BEGIN
for r in
SELECT COALESCE(sum(amount), 0) as amount, 0 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (4,5) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 1 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 8 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 2 as type FROM client_payment
WHERE payment_time between start_date and end_date
and  payment_type = 12 AND client_id = client
UNION

select COALESCE(amount, 0) as amount, 3 as type FROM
ingress_cost(client, start_date, end_date) as (amount numeric)

--SELECT COALESCE(sum(ingress_client_cost::numeric(10,4)), 0), 3 as type FROM client_cdr
--WHERE time BETWEEN start_date and end_date  AND ingress_client_id = client and is_final_call=1

UNION
SELECT COALESCE(sum(amount), 0) as amount, 4 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 15 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 5 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (3,6) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 6 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 7 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 7 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 11 AND client_id = client
UNION

select COALESCE(amount, 0) as amount, 8 as type FROM
egress_cost(client, start_date, end_date) as (amount numeric)

--SELECT COALESCE(sum(egress_cost), 0) as amount, 8 as type
--from client_cdr where time between start_date and end_date
--and egress_client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount, 9 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
state != -1 AND type = 0 AND client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount,10 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
type = 3 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 11 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 2 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 12 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 1 AND client_id = client

loop
my_array[r.type] = r.amount;
end loop;

my_array[0] = my_array[0] + my_array[11];
my_array[5] = my_array[5] + my_array[12];

actual_ingress_balance = my_array[0] + my_array[1] - my_array[2] - my_array[3] -my_array[4];
actual_egress_balance = -my_array[5] - my_array[6] + my_array[7] + my_array[8];
actual_total_balance = actual_ingress_balance + actual_egress_balance;

mutual_ingress_balance = -my_array[9] + my_array[0] + my_array[1] - my_array[2];
mutual_egress_balance = my_array[10] - my_array[5] - my_array[6] + my_array[7];
mutual_total_balance = mutual_ingress_balance+mutual_egress_balance;

select into r * from balance_history_actual where client_id = client order by date desc;

if FOUND THEN
actual_ingress_balance = actual_ingress_balance + r.actual_ingress_balance;
actual_egress_balance = actual_egress_balance + r.actual_egress_balance;
actual_total_balance = actual_total_balance + r.actual_balance;
end if;

select into r * from balance_history where client_id = client order by date desc;

if FOUND THEN
mutual_ingress_balance = mutual_ingress_balance + r.mutual_ingress_balance;
mutual_egress_balance = mutual_egress_balance + r.mutual_egress_balance;
mutual_total_balance = mutual_total_balance + r.mutual_balance;
end if;

select into result actual_ingress_balance,actual_egress_balance,actual_total_balance,mutual_ingress_balance,mutual_egress_balance,mutual_total_balance,
my_array[0], my_array[1], my_array[2], my_array[3], my_array[4], my_array[5], my_array[6], my_array[7],
my_array[8], my_array[9], my_array[10];
return next result;
return;

END;
$$;


ALTER FUNCTION public.current_balance_detail(client integer) OWNER TO postgres;

--
-- Name: current_balance_detail_not_last_data(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION current_balance_detail_not_last_data(client integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
today date := CURRENT_DATE;
start_date timestamp with time zone = today::text || ' 00:00:00+00';
end_date timestamp with time zone = today::text || ' 23:59:59+00';
my_array numeric(20, 5)[] := '{0,0,0,0,0,0,0,0,0,0,0,0,0}';
actual_ingress_balance numeric(20, 5) := 0;
actual_egress_balance numeric(20, 5) := 0;
actual_total_balance numeric(20, 5) := 0;
mutual_ingress_balance numeric(20, 5) := 0;
mutual_egress_balance numeric(20, 5) := 0;
mutual_total_balance numeric(20, 5) := 0;
r record;
result record;
BEGIN
for r in
SELECT COALESCE(sum(amount), 0) as amount, 0 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (4,5) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 1 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 8 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 2 as type FROM client_payment
WHERE payment_time between start_date and end_date
and  payment_type = 12 AND client_id = client
UNION

--select COALESCE(amount, 0) as amount, 3 as type FROM
--ingress_cost(client, start_date, end_date) as (amount numeric)

SELECT COALESCE(sum(ingress_call_cost::numeric(10,4)), 0), 3 as type FROM cdr_report
WHERE report_time BETWEEN start_date and end_date  AND ingress_client_id = client

UNION
SELECT COALESCE(sum(amount), 0) as amount, 4 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 15 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 5 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (3,6) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 6 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 7 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 7 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 11 AND client_id = client
UNION

--select COALESCE(amount, 0) as amount, 8 as type FROM
--egress_cost(client, start_date, end_date) as (amount numeric)

SELECT COALESCE(sum(egress_call_cost), 0) as amount, 8 as type
from cdr_report where report_time between start_date and end_date
and egress_client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount, 9 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
state != -1 AND type = 0 AND client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount,10 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
type = 3 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 11 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 2 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 12 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 1 AND client_id = client

loop
my_array[r.type] = r.amount;
end loop;

my_array[0] = my_array[0] + my_array[11];
my_array[5] = my_array[5] + my_array[12];

actual_ingress_balance = my_array[0] + my_array[1] - my_array[2] - my_array[3] -my_array[4];
actual_egress_balance = -my_array[5] - my_array[6] + my_array[7] + my_array[8];
actual_total_balance = actual_ingress_balance + actual_egress_balance;

mutual_ingress_balance = -my_array[9] + my_array[0] + my_array[1] - my_array[2];
mutual_egress_balance = my_array[10] - my_array[5] - my_array[6] + my_array[7];
mutual_total_balance = mutual_ingress_balance+mutual_egress_balance;

select into r * from balance_history_actual where client_id = client order by date desc;

if FOUND THEN
actual_ingress_balance = actual_ingress_balance + r.actual_ingress_balance;
actual_egress_balance = actual_egress_balance + r.actual_egress_balance;
actual_total_balance = actual_total_balance + r.actual_balance;
end if;

select into r * from balance_history where client_id = client order by date desc;

if FOUND THEN
mutual_ingress_balance = mutual_ingress_balance + r.mutual_ingress_balance;
mutual_egress_balance = mutual_egress_balance + r.mutual_egress_balance;
mutual_total_balance = mutual_total_balance + r.mutual_balance;
end if;

select into result actual_ingress_balance,actual_egress_balance,actual_total_balance,mutual_ingress_balance,mutual_egress_balance,mutual_total_balance,
my_array[0], my_array[1], my_array[2], my_array[3], my_array[4], my_array[5], my_array[6], my_array[7],
my_array[8], my_array[9], my_array[10];
return next result;
return;

END;
$$;


ALTER FUNCTION public.current_balance_detail_not_last_data(client integer) OWNER TO postgres;

--
-- Name: daily_origination_summary(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION daily_origination_summary(timestamp with time zone, timestamp with time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	time_start alias for $1;
	time_end alias for $2;
	exe_sql text;
	cdr_days integer;

begin
	SELECT into cdr_days time_end::date-time_start::date+1;
	exe_sql :=
	$c1$SELECT * FROM crosstab$c1$
	||cdr_days||
	$sql1$
	(
	'select client.name::text,cdr.cdr_date::text,cdr.mins::text from
	(
	SELECT ingress_client_id,time::date as cdr_date,sum(call_duration::integer)::real/60 as mins
	from client_cdr
	where time between ''
	$sql1$
	||time_start||'\'\''||
	$sql2$ and ''$sql2$
	||time_end||
	$sql3$''
	and ingress_client_id != ''''
	group by ingress_client_id,time::date order by 1,2
	) as cdr
	left join client on client.client_id::text=cdr.ingress_client_id
	')
	$sql3$;
	raise notice '%',exe_sql;
	for r in execute exe_sql
	loop
		return next r;
	end loop;

	return;
end;

$_$;


ALTER FUNCTION public.daily_origination_summary(timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: daily_termination_summary(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION daily_termination_summary(timestamp with time zone, timestamp with time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	time_start alias for $1;
	time_end alias for $2;
	exe_sql text;
	cdr_days integer;

begin
	SELECT into cdr_days time_end::date-time_start::date+1;
	exe_sql :=
	$c1$SELECT * FROM crosstab$c1$
	||cdr_days||
	$sql1$
	(
	'select client.name::text,cdr.cdr_date::text,cdr.mins::text from
	(
	SELECT egress_client_id,time::date as cdr_date,sum(call_duration::integer)::real/60 as mins
	from client_cdr
	where time between ''
	$sql1$
	||time_start||'\'\''||
	$sql2$ and ''$sql2$
	||time_end||
	$sql3$''
	and egress_client_id != ''''
	group by egress_client_id,time::date order by 1,2
	) as cdr
	left join client on client.client_id::text=cdr.egress_client_id
	')
	$sql3$;
	raise notice '%',exe_sql;
	for r in execute exe_sql
	loop
		return next r;
	end loop;

	return;
end;

$_$;


ALTER FUNCTION public.daily_termination_summary(timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: data_clean(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION data_clean() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

begin
	delete from time_profile_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from client_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from dynamic_route_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from dynamic_route_items_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from rate_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from route_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_ip_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_direction_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_codecs_ref_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_block_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from product_items_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from translation_item_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from product_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from product_items_resource_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from currency_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from rate_table_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_ip_limit_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_translation_ref_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from jurisdiction_prefix_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from sip_error_code_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_next_route_rule_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_prefix_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_lrn_action_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from dynamic_route_pri_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from dynamic_route_qos_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from dynamic_route_override_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);

	delete from host_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);
	delete from ip_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);
	delete from prefix_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);
	delete from product_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);
	delete from rate_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);
	delete from resource_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);

	--delete from real_cdr where ans_time_b::bigint/1000000 < EXTRACT(EPOCH from CURRENT_DATE-7);
end;

$$;


ALTER FUNCTION public.data_clean() OWNER TO postgres;

--
-- Name: dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$

declare
        id_static_product alias for $2;
        id_dynamic_route alias for $1;
        new_res_1 alias for $3;
        new_res_2 alias for $4;
        new_res_3 alias for $5;
        new_res_4 alias for $6;
        new_res_5 alias for $7;
        new_res_6 alias for $8;
        new_res_7 alias for $9;
        new_res_8 alias for $10;
        id_routing_rule alias for $11;
        id_time_profile alias for $12;
        r record;
        r1 record;
        r2 record;
        r3 record;
        r4 record;
        sql_text text;
	res text;

begin

	delete from product_items where product_id = id_static_product;

	sql_text := 'select code,max(rate_id),resource_id from resource join rate on rate.rate_table_id=resource.rate_table_id where resource_id in ('||
        new_res_1||','||
        new_res_2||','||
        new_res_3||','||
        new_res_4||','||
        new_res_5||','||
        new_res_6||','||
        new_res_7||','||
        new_res_8||') group by code,resource_id order by 1,2';

	select into res destroy_order_by_tree();
	for r1 in execute sql_text
	loop
		PERFORM create_order_by_tree(r1.code::text,r1.max::text,r1.resource_id::text);
		--insert into dynamic_route_tmp(code,maxid,resource_id)
		--select r1.code,r1.max,r1.resource_id;
	end loop;

	--copy (select code,max(rate_id),resource_id from resource join rate on rate.rate_table_id=resource.rate_table_id where resource_id in (106,105) group by code,resource_id order by 1,2) to '/tmp/aaa.csv';

	select into res execute_order_by_tree();
/*
	for r2 in select * from dynamic_route_tmp
	loop
		raise notice 'check prefix is %',r2.code;
		for r3 in select * from dynamic_route_tmp where code <@ r2.code and code != r2.code
		loop
			insert into dynamic_route_tmp(code,maxid,resource_id)
			select r3.code,r2.maxid,r2.resource_id;
		end loop;
	end loop;

        for r4 in select * from crosstab
	('select code,max(maxid),resource_id from dynamic_route_tmp group by code,resource_id order by 1,2')
        AS
        ct(code prefix_range, res_id_1 integer, res_id_2 integer, res_id_3 integer, res_id_4 integer, res_id_5 integer, res_id_6 integer, res_id_7 integer, res_id_8 integer)
        loop
		raise notice 'insert prefix is %',r4.code;
        	insert into product_items
(time_profile_id,product_id,strategy,digits,resource_id_1,resource_id_2,resource_id_3,resource_id_4,resource_id_5,resource_id_6,resource_id_7,resource_id_8)
                select id_time_profile,id_static_product,id_routing_rule,r4.code,r4.res_id_1,r4.res_id_2,r4.res_id_3,r4.res_id_4,r4.res_id_5,r4.res_id_6,r4.res_id_7,r4.res_id_8;
        end loop;
*/

        for r4 in select f1 as code,f2 as res_id_1,f3 as res_id_2,f4 as res_id_3,f5 as res_id_4,f6 as res_id_5,f7 as res_id_6,f8 as res_id_7,f9 as res_id_8 from record_order_by_tree(0)
        loop
		raise notice 'insert prefix is %',r4.code;
        	insert into product_items
(time_profile_id,product_id,strategy,digits,resource_id_1,resource_id_2,resource_id_3,resource_id_4,resource_id_5,resource_id_6,resource_id_7,resource_id_8)
                select id_time_profile,id_static_product,id_routing_rule,r4.code,
			case r4.res_id_1 when '' then null else r4.res_id_1::integer end,
			case r4.res_id_2 when '' then null else r4.res_id_2::integer end,
			case r4.res_id_3 when '' then null else r4.res_id_3::integer end,
			case r4.res_id_4 when '' then null else r4.res_id_4::integer end,
			case r4.res_id_5 when '' then null else r4.res_id_5::integer end,
			case r4.res_id_6 when '' then null else r4.res_id_6::integer end,
			case r4.res_id_7 when '' then null else r4.res_id_7::integer end,
			case r4.res_id_8 when '' then null else r4.res_id_8::integer end;
        end loop;

	select into res destroy_order_by_tree();


end;

$_$;


ALTER FUNCTION public.dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer) OWNER TO postgres;

--
-- Name: dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, text) RETURNS void
    LANGUAGE plpgsql
    AS $_$

declare
        id_static_product alias for $2;
        id_dynamic_route alias for $1;
        new_res_1 alias for $3;
        new_res_2 alias for $4;
        new_res_3 alias for $5;
        new_res_4 alias for $6;
        new_res_5 alias for $7;
        new_res_6 alias for $8;
        new_res_7 alias for $9;
        new_res_8 alias for $10;
        id_routing_rule alias for $11;
        id_time_profile alias for $12;
        rate_prefix alias for $13;
        r record;
        r1 record;
        r2 record;
        r3 record;
        r4 record;
        sql_text text;
	res text;

begin

	delete from product_items where product_id = id_static_product and digits <@ rate_prefix;

	if not exists(select 1 from rate where code <@ rate_prefix and rate_table_id in (select rate_table_id from resource where resource_id in (new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8))) then
		return;
	end if;

	if rate_prefix = '' then
	sql_text := '(select code::text,max(rate_id),resource_id from resource join rate on rate.rate_table_id=resource.rate_table_id where resource_id in ('||
        new_res_1||','||
        new_res_2||','||
        new_res_3||','||
        new_res_4||','||
        new_res_5||','||
        new_res_6||','||
        new_res_7||','||
        new_res_8||') group by code,resource_id order by 1,2)';
	else
	sql_text := '(select code::text,max(rate_id),resource_id from resource join rate on rate.rate_table_id=resource.rate_table_id where code <@ \''||rate_prefix||'\'::prefix_range and resource_id in ('||
        new_res_1||','||
        new_res_2||','||
        new_res_3||','||
        new_res_4||','||
        new_res_5||','||
        new_res_6||','||
        new_res_7||','||
        new_res_8||') group by code,resource_id order by 1,2)
	union
	(select \''||rate_prefix||'\',max(rate_id),resource_id from resource join rate on rate.rate_table_id=resource.rate_table_id where code @> \''||rate_prefix||'\'::prefix_range and resource_id in ('||
        new_res_1||','||
        new_res_2||','||
        new_res_3||','||
        new_res_4||','||
        new_res_5||','||
        new_res_6||','||
        new_res_7||','||
        new_res_8||') group by code,resource_id order by 1,2)';
        end if;
--raise notice 'SQL:-----------> %',sql_text;
	select into res destroy_order_by_tree();
	for r1 in execute sql_text
	loop
		PERFORM create_order_by_tree(r1.code::text,r1.max::text,r1.resource_id::text);
		--insert into dynamic_route_tmp(code,maxid,resource_id)
		--select r1.code,r1.max,r1.resource_id;
	end loop;
	select into res execute_order_by_tree();
/*
	for r2 in select * from dynamic_route_tmp
	loop
		raise notice 'check prefix is %',r2.code;
		for r3 in select * from dynamic_route_tmp where code <@ r2.code and code != r2.code
		loop
			insert into dynamic_route_tmp(code,maxid,resource_id)
			select r3.code,r2.maxid,r2.resource_id;
		end loop;
	end loop;

        for r4 in select * from crosstab
	('select code,max(maxid),resource_id from dynamic_route_tmp group by code,resource_id order by 1,2')
        AS
        ct(code prefix_range, res_id_1 integer, res_id_2 integer, res_id_3 integer, res_id_4 integer, res_id_5 integer, res_id_6 integer, res_id_7 integer, res_id_8 integer)
        loop
		raise notice 'insert prefix is %',r4.code;
        	insert into product_items
(time_profile_id,product_id,strategy,digits,resource_id_1,resource_id_2,resource_id_3,resource_id_4,resource_id_5,resource_id_6,resource_id_7,resource_id_8)
                select id_time_profile,id_static_product,id_routing_rule,r4.code,r4.res_id_1,r4.res_id_2,r4.res_id_3,r4.res_id_4,r4.res_id_5,r4.res_id_6,r4.res_id_7,r4.res_id_8;
        end loop;
*/
        for r4 in select f1 as code,f2 as res_id_1,f3 as res_id_2,f4 as res_id_3,f5 as res_id_4,f6 as res_id_5,f7 as res_id_6,f8 as res_id_7,f9 as res_id_8 from record_order_by_tree(0)
        loop
		raise notice 'insert prefix is %',r4.code;
        	insert into product_items
(time_profile_id,product_id,strategy,digits,resource_id_1,resource_id_2,resource_id_3,resource_id_4,resource_id_5,resource_id_6,resource_id_7,resource_id_8)
                select id_time_profile,id_static_product,id_routing_rule,r4.code,
			case r4.res_id_1 when '' then null else r4.res_id_1::integer end,
			case r4.res_id_2 when '' then null else r4.res_id_2::integer end,
			case r4.res_id_3 when '' then null else r4.res_id_3::integer end,
			case r4.res_id_4 when '' then null else r4.res_id_4::integer end,
			case r4.res_id_5 when '' then null else r4.res_id_5::integer end,
			case r4.res_id_6 when '' then null else r4.res_id_6::integer end,
			case r4.res_id_7 when '' then null else r4.res_id_7::integer end,
			case r4.res_id_8 when '' then null else r4.res_id_8::integer end;
        end loop;
	select into res destroy_order_by_tree();

end;

$_$;


ALTER FUNCTION public.dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, text) OWNER TO postgres;

--
-- Name: egress_cost(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION egress_cost(client integer, start_datetime timestamp with time zone, end_datetime timestamp with time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
total_datetime timestamp with time zone = CURRENT_TIMESTAMP(0);
r record;
BEGIN
	SELECT max(report_time) + interval '1 hour' as max_time into r FROM cdr_report WHERE report_time between start_datetime
	and end_datetime;

	total_datetime = r.max_time;


	if total_datetime is null then
		SELECT
sum(egress_cost) as call_cost  into r
from client_cdr where time between start_datetime and end_datetime and egress_client_id = client;


	elsif total_datetime > end_datetime then
		SELECT sum(egress_call_cost) as call_cost into r
		from cdr_report where report_time between start_datetime and end_datetime
		and egress_client_id = client;


	else

		SELECT
sum(call_cost) as call_cost into r FROM ( ( SELECT sum(egress_call_cost) as call_cost
from cdr_report
where report_time between start_datetime and total_datetime and egress_client_id = client ) union
(SELECT
sum(egress_cost) as call_cost
from client_cdr where time between total_datetime and end_datetime and  egress_client_id  = client ) ) as t;

	end if;

	return next r;
	return;

END;
$$;


ALTER FUNCTION public.egress_cost(client integer, start_datetime timestamp with time zone, end_datetime timestamp with time zone) OWNER TO postgres;

--
-- Name: egress_profit_fun(integer[], integer, integer, numeric, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION egress_profit_fun(integer[], integer, integer, numeric, text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
	a alias for $1;--exist rate table
	t alias for $2;--type 1-min;2-max;3-avg;4-max add x%;5-max add x
	id_rate_table alias for $3;
	add_num alias for $4;
	dup_action alias for $5;
	r record;

begin
	if not exists(select 1 from rate_table where rate_table_id=id_rate_table) then
		raise exception 'rate table id % not exist',id_rate_table;
	end if;

	if t=1 then
		for r in SELECT r1.* from
		(select * from rate where rate_table_id=any(a)) as r1
		right join (select code,min(rate) as rate from rate where rate_table_id=any(a) group by code) as r2
		on r1.code=r2.code and r1.rate=r2.rate
		loop

			if exists(select 1 from rate where rate_table_id=id_rate_table and code=r.code) then
				if dup_action='ignore' then
					continue;
				elsif dup_action='overwrite' then
					delete from rate where rate_table_id=id_rate_table and code=r.code;
				end if;
			end if;

			insert into rate(rate_table_id,code,rate,setup_fee,effective_date,end_date,min_time,grace_time,interval,time_profile_id,seconds,code_name,intra_rate,inter_rate)
			select id_rate_table,r.code,r.rate,r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.intra_rate,r.inter_rate;
		end loop;

	elsif t=2 then
		for r in SELECT r1.* from
		(select * from rate where rate_table_id=any(a)) as r1
		right join (select code,max(rate) as rate from rate where rate_table_id=any(a) group by code) as r2
		on r1.code=r2.code and r1.rate=r2.rate
		loop

			if exists(select 1 from rate where rate_table_id=id_rate_table and code=r.code) then
				if dup_action='ignore' then
					continue;
				elsif dup_action='overwrite' then
					delete from rate where rate_table_id=id_rate_table and code=r.code;
				end if;
			end if;

			insert into rate(rate_table_id,code,rate,setup_fee,effective_date,end_date,min_time,grace_time,interval,time_profile_id,seconds,code_name,intra_rate,inter_rate)
			select id_rate_table,r.code,r.rate,r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.intra_rate,r.inter_rate;
		end loop;

	elsif t=3 then
		raise exception 'i cant do that';
		for r in select
		code,avg(rate) as rate,max(setup_fee) as setup_fee,max(effective_date) as effective_date,max(end_date) as end_date,max(min_time) as min_time,max(grace_time) as grace_time,max(interval) as interval,max(time_profile_id) as time_profile_id,max(seconds) as seconds,max(code_name) as code_name,avg(intra_rate) as intra_rate,avg(inter_rate) as inter_rate
		from rate where rate_table_id=any(a)
		group by code
		loop

			if exists(select 1 from rate where rate_table_id=id_rate_table and code=r.code) then
				if dup_action='ignore' then
					continue;
				elsif dup_action='overwrite' then
					delete from rate where rate_table_id=id_rate_table and code=r.code;
				end if;
			end if;

			insert into rate(rate_table_id,code,rate,setup_fee,effective_date,end_date,min_time,grace_time,interval,time_profile_id,seconds,code_name,intra_rate,inter_rate)
			select id_rate_table,r.code,r.rate,r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.intra_rate,r.inter_rate;
		end loop;

	elsif t=4 then
		for r in SELECT r1.* from
		(select * from rate where rate_table_id=any(a)) as r1
		right join (select code,max(rate) as rate from rate where rate_table_id=any(a) group by code) as r2
		on r1.code=r2.code and r1.rate=r2.rate
		loop

			if exists(select 1 from rate where rate_table_id=id_rate_table and code=r.code) then
				if dup_action='ignore' then
					continue;
				elsif dup_action='overwrite' then
					delete from rate where rate_table_id=id_rate_table and code=r.code;
				end if;
			end if;

			insert into rate(rate_table_id,code,rate,setup_fee,effective_date,end_date,min_time,grace_time,interval,time_profile_id,seconds,code_name,intra_rate,inter_rate)
			select id_rate_table,r.code,r.rate*(1+add_num),r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.intra_rate,r.inter_rate;
		end loop;

	elsif t=5 then
		for r in SELECT r1.* from
		(select * from rate where rate_table_id=any(a)) as r1
		right join (select code,max(rate) as rate from rate where rate_table_id=any(a) group by code) as r2
		on r1.code=r2.code and r1.rate=r2.rate
		loop

			if exists(select 1 from rate where rate_table_id=id_rate_table and code=r.code) then
				if dup_action='ignore' then
					continue;
				elsif dup_action='overwrite' then
					delete from rate where rate_table_id=id_rate_table and code=r.code;
				end if;
			end if;

			insert into rate(rate_table_id,code,rate,setup_fee,effective_date,end_date,min_time,grace_time,interval,time_profile_id,seconds,code_name,intra_rate,inter_rate)
			select id_rate_table,r.code,r.rate+add_num,r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.intra_rate,r.inter_rate;
		end loop;
	end if;

end;
$_$;


ALTER FUNCTION public.egress_profit_fun(integer[], integer, integer, numeric, text) OWNER TO postgres;

--
-- Name: enable_block(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION enable_block() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
	r record;

begin

	for r in
		SELECT   block_ticket.id, block_ticket.egress, (select client_id from resource where resource_id = block_ticket.egress),block_ticket.dnis FROM block_ticket join (
			select alert_action.disable_duration,alert_rule.name from alert_rule
			join alert_action on alert_rule.alert_action_id = alert_action.id where alert_action.disable_duration != 0 and alert_rule.monitor_type = 1
			) as t on block_ticket.rule_name = t.name where CURRENT_TIMESTAMP - block_ticket.blocked_time > t.disable_duration*60::varchar::interval and block_ticket.block = true
	loop
		delete from resource_block where ingress_res_id = r.egress and ingress_client_id = r.client_id and digit::varchar = r.dnis;
		update block_ticket set block = false, unblock_time = CURRENT_TIMESTAMP(0) where id = r.id;
	end loop;
end;

$$;


ALTER FUNCTION public.enable_block() OWNER TO postgres;

--
-- Name: exchange_alert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION exchange_alert() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
	r record;
	r1 record;
	id_client integer;
	now_time text;
	enable_alert boolean := false;
	enable_email boolean := false;
	traffic_email boolean := false;

begin
	for r in select * from order_user_alert order by id
	loop
		if r.email is null or r.email = '' or r.email like ' %' then
			continue;
		end if;
		select into id_client client_id from order_user where id=r.user_id;
		raise notice 'alert id %',r.id;
		enable_alert := false;
		enable_email := false;
		traffic_email := false;
		if r.freq_type=0 then
			--raise notice 'Real time';
			enable_alert := true;
		elsif r.freq_type=1 then
			--raise notice 'Hourly,%',r.freq_value;
			select into now_time to_char(now(),'MI');
			--raise notice 'now time is %',now_time;
			continue when now_time != all(regexp_split_to_array(r.freq_value,','));
			enable_alert := true;
		elsif r.freq_type=2 then
			--raise notice 'Daily,%',r.freq_value;
			select into now_time to_char(now(),'HH24:MI');
			--raise notice 'now time is %',now_time;
			continue when now_time != all(regexp_split_to_array(r.freq_value,','));
			enable_alert := true;
		elsif r.freq_type=3 then
			--raise notice 'Weekly,%',r.freq_value;
			select into now_time to_char(now(),'D');
			--raise notice 'now time is %',now_time;
			continue when now_time != all(regexp_split_to_array(r.freq_value,','));
			enable_alert := true;
		elsif r.freq_type=4 then
			--raise notice 'Monthly,%',r.freq_value;
			select into now_time trim(leading '0' from to_char(now(),'DD'));
			--raise notice 'now time is %',now_time;
			continue when now_time != all(regexp_split_to_array(r.freq_value,','));
			enable_alert := true;
		end if;

if enable_alert = true then
		--raise notice '<CHECK START>';
		if r.order_type=1 then
			if r.alert_type=0 then
				raise notice 'Buy order confirmation';
				for r1 in
				SELECT id,create_time
				from buy_order
				where client_id=id_client
				loop
					--send_body is buy_order.id
					if not exists (select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text) then
					enable_email := true;
					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;
					end if;
				end loop;
			elsif r.alert_type=1 then
				raise notice 'Buy Order With No Matching Sell Order';
				for r1 in
				SELECT id,auto_match_time
				from buy_order
				where client_id=id_client and auto_match=true and auto_match_result=0
				loop
					--send_body is buy_order.id and auto_match_time
					if r1.auto_match_time is not null and
					not exists(select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text||','||r1.auto_match_time::text)
					then
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id::text||','||r1.auto_match_time::text;
					end if;

				end loop;
			elsif r.alert_type=2 then
				raise notice 'Buy Order Purged for inactivity';
				for r1 in
				SELECT buy_order.id,buy_order.create_time
				from buy_order
				right join contract on contract.order_id=buy_order.id
				left join stats_buy_order_summary
				on buy_order.id=stats_buy_order_summary.id
				where stats_buy_order_summary.week_ca=0
				and contract.contract_type=1 and purged = false
				and now()-buy_order.create_time>interval '7 days'
				and buy_order.client_id=id_client
				loop
					--send_body is buy_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update buy_order set purged=true where id=r1.id;
				end loop;
			elsif r.alert_type=3 then
				raise notice 'Buy Order Matched with Sell Order';
				for r1 in
				SELECT contract.id,contract.create_time
				from contract
				left join buy_order
				on contract.order_id=buy_order.id
				where contract.contract_type=1 and buy_order.client_id=id_client and contract.status=1
				union
				SELECT contract.id,contract.create_time
				from contract
				where contract_type=2 and client_id=id_client and contract.status=1
				loop
					--send_body is contract.id
					if not exists (select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text) then
					--if r.last_email_time is null or r1.create_time > r.last_email_time then
					enable_email := true;
					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;
					end if;
				end loop;

			elsif r.alert_type=4 then
				raise notice 'Buy Traffic Terminating';
				for r1 in
				SELECT buy_order.id
--,buy_order.id::text||coalesce(ca,0)::text||','||coalesce(ok_calls,0)::text||','||coalesce(minutes,0)::text||','||coalesce(week_ca,0)::text||','||coalesce(week_ok_calls,0)::text||','||coalesce(week_minutes,0)::text as c
				from buy_order
				--left join stats_buy_order_summary
				--on buy_order.id=stats_buy_order_summary.id
				where buy_order.client_id=id_client
				loop
					--send_body is buy_order.id and asr/acd
					if not exists (select id from alert_mail where user_alert_id=r.id) then

					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					else

					SELECT into traffic_email now()-max(create_time)>interval '1 minutes' from alert_mail where user_alert_id=r.id;
					if traffic_email then
                                        enable_email := true;

                                        insert into alert_mail(user_alert_id,send_body)
                                        select
                                        r.id,r1.c;
					end if;

					end if;

				end loop;

			elsif r.alert_type=5 then
				raise notice 'Buy order matched to sell orders below min ASR';
				for r1 in
				SELECT buy_order.id
				from buy_order
				right join contract on contract.order_id=buy_order.id
				left join stats_buy_order_summary
				on buy_order.id=stats_buy_order_summary.id
				where contract.contract_type=1
				and asr>case when stats_buy_order_summary.ca = 0 then 0 else stats_buy_order_summary.ok_calls/stats_buy_order_summary.ca end
				and buy_order.client_id=id_client
				loop
					--send_body is buy_order.id
					if not exists (select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text) then
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					end if;
				end loop;
			end if;
		elsif r.order_type=2 then
			if r.alert_type=0 then
				raise notice 'Ask order confirmation';
				for r1 in
				select id,create_time
				from sell_order
				where client_id = id_client
				loop
					--send_body is sell_order.id
					--if r.last_email_time is null or r1.create_time > r.last_email_time then
					if not exists (select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text) then
					enable_email := true;
					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;
					end if;
				end loop;
			elsif r.alert_type=1 then
				raise notice 'Sell order no long has matching orders';
				for r1 in
				SELECT id,auto_match_time
				from sell_order
				where client_id=id_client and auto_match=true and auto_match_result=0
				loop
					--send_body is sell_order.id
					if r1.auto_match_time is not null and
					not exists(select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text) then
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					end if;
				end loop;
			elsif r.alert_type=2 then
				raise notice 'Sell Order Congestion Notification';
				for r1 in
				SELECT order_id,count(*) as c
				from client_cdr
				where time between now()-interval '1 hours' and now()
				and egress_client_id=id_client::text
				and (release_cause='6' or release_cause='7')
				and order_type='2'
				group by order_id
				loop
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id::text||','||r1.c::text;

				end loop;
			elsif r.alert_type=3 then
				raise notice 'Sell Order Certified as â€œselectâ€ Route';
				for r1 in
				SELECT id from sell_order where is_select=2 and client_id=id_client
				loop
					--send_body is sell_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update sell_order set is_select=3 where id=r1.id;
				end loop;
			elsif r.alert_type=4 then
				raise notice 'Sell Order Placed First in LCR';
				for r1 in
				SELECT id from sell_order where is_first=1 and client_id=id_client
				loop
					--send_body is sell_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update sell_order set is_first=3 where id=r1.id;
				end loop;
			elsif r.alert_type=5 then
				raise notice 'Sell Order Lost First Position';
				for r1 in
				SELECT id from sell_order where is_first=2 and client_id=id_client
				loop
					--send_body is sell_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update sell_order set is_first=4 where id=r1.id;
				end loop;
			elsif r.alert_type=6 then
				raise notice 'Sell Order Deactivated due to quality drop';
			elsif r.alert_type=7 then
				raise notice 'Sell Order purged due to inactivity';
				for r1 in
				SELECT sell_order.id
				from sell_order
				left join stats_sell_order_summary
				on sell_order.id=stats_sell_order_summary.id
				where stats_sell_order_summary.week_ca=0 and purged = false
				loop
					--send_body is sell_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update sell_order set purged=true where id=r1.id;
				end loop;
			elsif r.alert_type=8 then
				raise notice 'Sell Order decertified as â€œselectâ€ route';
				for r1 in
				SELECT id from sell_order where is_select=1 and client_id=id_client
				loop
					--send_body is buy_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update sell_order set is_select=0 where id=r1.id;
				end loop;
			end if;
		end if;
		--raise notice '<CHECK END>';
		raise notice 'enable email %',enable_email;
		if enable_email then
			update order_user_alert set last_email_time = current_timestamp(0) where id=r.id;
		end if;
end if;

	end loop;

end;

$$;


ALTER FUNCTION public.exchange_alert() OWNER TO postgres;

--
-- Name: exchange_trans(timestamp with time zone, timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION exchange_trans(timestamp with time zone, timestamp with time zone, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	start_time alias for $1;
	end_time alias for $2;
	id_client alias for $3;
	r record;

begin

	for r in

	select
	report_time::date,
	'1' as type,
	sum(case when ingress_client_id=id_client then ingress_call_cost else 0 end) as buy
	from cdr_report
	where report_time between start_time and end_time
	group by report_time::date
	union
	select
	report_time::date,
	'2' as type,
	sum(case when egress_client_id=id_client then egress_call_cost else 0 end) as sell
	from cdr_report
	where report_time between start_time and end_time
	group by report_time::date
	union
	select
	complete_time::date,
	'3' as type,
	sum(case when client_id=id_client and action_type=2 and status=2 then actual_amount else 0 end) as deposit
	from exchange_finance
	where complete_time between start_time and end_time
	group by complete_time::date
	union
	select
	action_time::date,
	'4' as type,
	sum(case when client_id=id_client and action_type=1 then actual_amount else 0 end) as withdraw
	from exchange_finance
	where action_time between start_time and end_time
	group by action_time::date

	loop
		return next r;
	end loop;


	return;

end;
$_$;


ALTER FUNCTION public.exchange_trans(timestamp with time zone, timestamp with time zone, integer) OWNER TO postgres;

--
-- Name: fifth_select(text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION fifth_select(text, text, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
   declare
       fifth_rec record;
   begin
       for fifth_rec in select resource_direction.action,resource_direction.digits
from resource_direction where direction=2 and callee_digit_match@>$1 and caller_digit_match@>$2 and dire_group_id=$3
order by length(callee_digit_match::text) DESC limit 1
 loop
           return next fifth_rec;
       end loop;
	return;
   end;
   $_$;


ALTER FUNCTION public.fifth_select(text, text, integer) OWNER TO postgres;

--
-- Name: filter_rate(integer[], timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION filter_rate(integer[], timestamp with time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	a alias for $1;
	r record;
	r1 record;
	r2 record;
	rate_other text[];
	rate_time alias for $2;

begin
	PERFORM destroy_sorted_syntex();

	for r in select * from rate where rate_table_id=any(a) and effective_date >= rate_time
	loop
		--raise notice 'rate_id %,rate_table_id %,code %,effective_date %,other %',r.rate_id,r.rate_table_id,r.code,r.effective_date,
		--case when r.code_name is null then '' else r.code_name::text end||'@split@'||
		--case when r.country is null then '' else r.country::text end||'@split@'||
		--case when r.rate is null then '' else r.rate::text end||'@split@'||
		--case when r.intra_rate is null then '' else r.intra_rate::text end||'@split@'||
		--case when r.inter_rate is null then '' else r.inter_rate::text end||'@split@'||
		--case when r.local_rate is null then '' else r.local_rate::text end||'@split@'||
		--case when r.end_date is null then '' else r.end_date::text end||'@split@'||
		--case when r.time_profile_id is null then '' else r.time_profile_id::text end||'@split@'||
		--case when r.zone is null then '' else r.zone::text end||'@split@'||
		--r.min_time::text||'@split@'||
		--r.grace_time::text||'@split@'||
		--r.interval::text||'@split@'||
		--r.seconds::text;

		PERFORM create_sort_syntex(r.code::text,r.rate_table_id::text,EXTRACT(EPOCH from r.effective_date)::text,
		case when r.code_name is null then '' else r.code_name::text end||'@split@'||
		case when r.country is null then '' else r.country::text end||'@split@'||
		case when r.rate is null then '' else r.rate::text end||'@split@'||
		case when r.intra_rate is null then '' else r.intra_rate::text end||'@split@'||
		case when r.inter_rate is null then '' else r.inter_rate::text end||'@split@'||
		case when r.local_rate is null then '' else r.local_rate::text end||'@split@'||
		case when r.end_date is null then '' else r.end_date::text end||'@split@'||
		case when r.time_profile_id is null then '' else r.time_profile_id::text end||'@split@'||
		case when r.zone is null then '' else r.zone::text end||'@split@'||
		r.min_time::text||'@split@'||
		r.grace_time::text||'@split@'||
		r.interval::text||'@split@'||
		r.seconds::text);

	end loop;

	PERFORM execute_sorted_syntex();

	for r1 in select c1 as code,c2 as rate_table_id,(TIMESTAMP WITH TIME ZONE 'epoch' + c3::bigint * INTERVAL '1 second')::text as effective_date,c4 as other from record_sorted_result(0) as t(c1,c2,c3,c4)
	loop
		--raise notice 'code %,rate_table_id %,effective_date %',r1.code,r1.rate_table_id,r1.effective_date;
		--raise notice '---> %',r1.other;
		rate_other := regexp_split_to_array(r1.other,'@split@');
		--raise notice '---> %',rate_other[1];
		--raise notice '---> %',rate_other[2];
		--raise notice '---> %',rate_other[3];
		--raise notice '---> %',rate_other[4];
		--raise notice '---> %',rate_other[5];
		--raise notice '---> %',rate_other[6];
		--raise notice '---> %',rate_other[7];
		--raise notice '---> %',rate_other[8];
		--raise notice '---> %',rate_other[9];
		--raise notice '---> %',rate_other[10];
		--raise notice '---> %',rate_other[11];
		--raise notice '---> %',rate_other[12];
		--raise notice '---> %',rate_other[13];
		select into r2 r1.code,r1.rate_table_id,r1.effective_date,rate_other[1],rate_other[2],rate_other[3],rate_other[4],rate_other[5],rate_other[6],rate_other[7],rate_other[8],rate_other[9],rate_other[10],rate_other[11],rate_other[12],rate_other[13];
		return next r2;
	end loop;

	PERFORM destroy_sorted_syntex();

	return;

end;
$_$;


ALTER FUNCTION public.filter_rate(integer[], timestamp with time zone) OWNER TO postgres;

--
-- Name: first_select(ip4, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION first_select(ip4, text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
   declare
       first_rec record;
   begin
       for first_rec in select resource_ip.resource_id,resource_ip.capacity,resource_ip.cps_limit,
resource.rtp_tos_difserv,resource.payload,resource.ingress,resource.egress,
resource.active,resource.rfc_2833,resource.direct_media,resource.t38,resource.nat,resource.translation_id,resource.alias,
resource_product_ref.digit,resource_product_ref.product_id from resource_ip,resource,resource_product_ref
 where resource_ip.ip>>= $1 and resource_ip.resource_id=resource.resource_id
 and resource_ip.resource_id=resource_product_ref.resource_id and resource_product_ref.digit@> $2 order by ip4r_size(resource_ip.ip),length(resource_product_ref.digit::text) desc
 loop
           return next first_rec;
       end loop;
       return;
   end;
$_$;


ALTER FUNCTION public.first_select(ip4, text) OWNER TO postgres;

--
-- Name: fourth_select(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION fourth_select(text, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
   declare
       fourth_rec record;
   begin
       for fourth_rec in select resource_direction.action,resource_direction.digits
from resource_direction where direction=2 and callee_digit_match@>$1 and resource_id=$2
order by length(callee_digit_match::text) DESC limit 1
 loop
           return next fourth_rec;
       end loop;
	return;
   end;
   $_$;


ALTER FUNCTION public.fourth_select(text, integer) OWNER TO postgres;

--
-- Name: gbt_bit_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bit_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bit_compress';


ALTER FUNCTION public.gbt_bit_compress(internal) OWNER TO postgres;

--
-- Name: gbt_bit_consistent(internal, bit, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bit_consistent(internal, bit, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bit_consistent';


ALTER FUNCTION public.gbt_bit_consistent(internal, bit, smallint) OWNER TO postgres;

--
-- Name: gbt_bit_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bit_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_bit_penalty';


ALTER FUNCTION public.gbt_bit_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_bit_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bit_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bit_picksplit';


ALTER FUNCTION public.gbt_bit_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_bit_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bit_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bit_same';


ALTER FUNCTION public.gbt_bit_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_bit_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bit_union(bytea, internal) RETURNS gbtreekey_var
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bit_union';


ALTER FUNCTION public.gbt_bit_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_bpchar_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bpchar_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bpchar_compress';


ALTER FUNCTION public.gbt_bpchar_compress(internal) OWNER TO postgres;

--
-- Name: gbt_bpchar_consistent(internal, character, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bpchar_consistent(internal, character, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bpchar_consistent';


ALTER FUNCTION public.gbt_bpchar_consistent(internal, character, smallint) OWNER TO postgres;

--
-- Name: gbt_bytea_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bytea_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bytea_compress';


ALTER FUNCTION public.gbt_bytea_compress(internal) OWNER TO postgres;

--
-- Name: gbt_bytea_consistent(internal, bytea, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bytea_consistent(internal, bytea, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bytea_consistent';


ALTER FUNCTION public.gbt_bytea_consistent(internal, bytea, smallint) OWNER TO postgres;

--
-- Name: gbt_bytea_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bytea_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_bytea_penalty';


ALTER FUNCTION public.gbt_bytea_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_bytea_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bytea_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bytea_picksplit';


ALTER FUNCTION public.gbt_bytea_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_bytea_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bytea_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bytea_same';


ALTER FUNCTION public.gbt_bytea_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_bytea_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_bytea_union(bytea, internal) RETURNS gbtreekey_var
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bytea_union';


ALTER FUNCTION public.gbt_bytea_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_cash_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_cash_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_cash_compress';


ALTER FUNCTION public.gbt_cash_compress(internal) OWNER TO postgres;

--
-- Name: gbt_cash_consistent(internal, money, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_cash_consistent(internal, money, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_cash_consistent';


ALTER FUNCTION public.gbt_cash_consistent(internal, money, smallint) OWNER TO postgres;

--
-- Name: gbt_cash_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_cash_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_cash_penalty';


ALTER FUNCTION public.gbt_cash_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_cash_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_cash_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_cash_picksplit';


ALTER FUNCTION public.gbt_cash_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_cash_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_cash_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_cash_same';


ALTER FUNCTION public.gbt_cash_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_cash_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_cash_union(bytea, internal) RETURNS gbtreekey8
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_cash_union';


ALTER FUNCTION public.gbt_cash_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_date_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_date_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_date_compress';


ALTER FUNCTION public.gbt_date_compress(internal) OWNER TO postgres;

--
-- Name: gbt_date_consistent(internal, date, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_date_consistent(internal, date, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_date_consistent';


ALTER FUNCTION public.gbt_date_consistent(internal, date, smallint) OWNER TO postgres;

--
-- Name: gbt_date_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_date_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_date_penalty';


ALTER FUNCTION public.gbt_date_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_date_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_date_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_date_picksplit';


ALTER FUNCTION public.gbt_date_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_date_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_date_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_date_same';


ALTER FUNCTION public.gbt_date_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_date_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_date_union(bytea, internal) RETURNS gbtreekey8
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_date_union';


ALTER FUNCTION public.gbt_date_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_decompress';


ALTER FUNCTION public.gbt_decompress(internal) OWNER TO postgres;

--
-- Name: gbt_float4_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float4_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float4_compress';


ALTER FUNCTION public.gbt_float4_compress(internal) OWNER TO postgres;

--
-- Name: gbt_float4_consistent(internal, real, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float4_consistent(internal, real, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float4_consistent';


ALTER FUNCTION public.gbt_float4_consistent(internal, real, smallint) OWNER TO postgres;

--
-- Name: gbt_float4_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float4_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_float4_penalty';


ALTER FUNCTION public.gbt_float4_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_float4_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float4_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float4_picksplit';


ALTER FUNCTION public.gbt_float4_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_float4_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float4_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float4_same';


ALTER FUNCTION public.gbt_float4_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_float4_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float4_union(bytea, internal) RETURNS gbtreekey8
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float4_union';


ALTER FUNCTION public.gbt_float4_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_float8_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float8_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float8_compress';


ALTER FUNCTION public.gbt_float8_compress(internal) OWNER TO postgres;

--
-- Name: gbt_float8_consistent(internal, double precision, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float8_consistent(internal, double precision, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float8_consistent';


ALTER FUNCTION public.gbt_float8_consistent(internal, double precision, smallint) OWNER TO postgres;

--
-- Name: gbt_float8_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float8_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_float8_penalty';


ALTER FUNCTION public.gbt_float8_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_float8_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float8_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float8_picksplit';


ALTER FUNCTION public.gbt_float8_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_float8_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float8_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float8_same';


ALTER FUNCTION public.gbt_float8_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_float8_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_float8_union(bytea, internal) RETURNS gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float8_union';


ALTER FUNCTION public.gbt_float8_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_inet_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_inet_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_inet_compress';


ALTER FUNCTION public.gbt_inet_compress(internal) OWNER TO postgres;

--
-- Name: gbt_inet_consistent(internal, inet, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_inet_consistent(internal, inet, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_inet_consistent';


ALTER FUNCTION public.gbt_inet_consistent(internal, inet, smallint) OWNER TO postgres;

--
-- Name: gbt_inet_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_inet_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_inet_penalty';


ALTER FUNCTION public.gbt_inet_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_inet_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_inet_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_inet_picksplit';


ALTER FUNCTION public.gbt_inet_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_inet_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_inet_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_inet_same';


ALTER FUNCTION public.gbt_inet_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_inet_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_inet_union(bytea, internal) RETURNS gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_inet_union';


ALTER FUNCTION public.gbt_inet_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_int2_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int2_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int2_compress';


ALTER FUNCTION public.gbt_int2_compress(internal) OWNER TO postgres;

--
-- Name: gbt_int2_consistent(internal, smallint, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int2_consistent(internal, smallint, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int2_consistent';


ALTER FUNCTION public.gbt_int2_consistent(internal, smallint, smallint) OWNER TO postgres;

--
-- Name: gbt_int2_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int2_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_int2_penalty';


ALTER FUNCTION public.gbt_int2_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int2_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int2_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int2_picksplit';


ALTER FUNCTION public.gbt_int2_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_int2_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int2_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int2_same';


ALTER FUNCTION public.gbt_int2_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int2_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int2_union(bytea, internal) RETURNS gbtreekey4
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int2_union';


ALTER FUNCTION public.gbt_int2_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_int4_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int4_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int4_compress';


ALTER FUNCTION public.gbt_int4_compress(internal) OWNER TO postgres;

--
-- Name: gbt_int4_consistent(internal, integer, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int4_consistent(internal, integer, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int4_consistent';


ALTER FUNCTION public.gbt_int4_consistent(internal, integer, smallint) OWNER TO postgres;

--
-- Name: gbt_int4_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int4_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_int4_penalty';


ALTER FUNCTION public.gbt_int4_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int4_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int4_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int4_picksplit';


ALTER FUNCTION public.gbt_int4_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_int4_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int4_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int4_same';


ALTER FUNCTION public.gbt_int4_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int4_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int4_union(bytea, internal) RETURNS gbtreekey8
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int4_union';


ALTER FUNCTION public.gbt_int4_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_int8_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int8_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int8_compress';


ALTER FUNCTION public.gbt_int8_compress(internal) OWNER TO postgres;

--
-- Name: gbt_int8_consistent(internal, bigint, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int8_consistent(internal, bigint, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int8_consistent';


ALTER FUNCTION public.gbt_int8_consistent(internal, bigint, smallint) OWNER TO postgres;

--
-- Name: gbt_int8_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int8_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_int8_penalty';


ALTER FUNCTION public.gbt_int8_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int8_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int8_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int8_picksplit';


ALTER FUNCTION public.gbt_int8_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_int8_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int8_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int8_same';


ALTER FUNCTION public.gbt_int8_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int8_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_int8_union(bytea, internal) RETURNS gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int8_union';


ALTER FUNCTION public.gbt_int8_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_intv_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_intv_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_compress';


ALTER FUNCTION public.gbt_intv_compress(internal) OWNER TO postgres;

--
-- Name: gbt_intv_consistent(internal, interval, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_intv_consistent(internal, interval, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_consistent';


ALTER FUNCTION public.gbt_intv_consistent(internal, interval, smallint) OWNER TO postgres;

--
-- Name: gbt_intv_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_intv_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_decompress';


ALTER FUNCTION public.gbt_intv_decompress(internal) OWNER TO postgres;

--
-- Name: gbt_intv_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_intv_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_intv_penalty';


ALTER FUNCTION public.gbt_intv_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_intv_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_intv_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_picksplit';


ALTER FUNCTION public.gbt_intv_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_intv_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_intv_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_same';


ALTER FUNCTION public.gbt_intv_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_intv_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_intv_union(bytea, internal) RETURNS gbtreekey32
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_union';


ALTER FUNCTION public.gbt_intv_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_macad_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_macad_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_macad_compress';


ALTER FUNCTION public.gbt_macad_compress(internal) OWNER TO postgres;

--
-- Name: gbt_macad_consistent(internal, macaddr, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_macad_consistent(internal, macaddr, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_macad_consistent';


ALTER FUNCTION public.gbt_macad_consistent(internal, macaddr, smallint) OWNER TO postgres;

--
-- Name: gbt_macad_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_macad_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_macad_penalty';


ALTER FUNCTION public.gbt_macad_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_macad_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_macad_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_macad_picksplit';


ALTER FUNCTION public.gbt_macad_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_macad_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_macad_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_macad_same';


ALTER FUNCTION public.gbt_macad_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_macad_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_macad_union(bytea, internal) RETURNS gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_macad_union';


ALTER FUNCTION public.gbt_macad_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_numeric_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_numeric_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_numeric_compress';


ALTER FUNCTION public.gbt_numeric_compress(internal) OWNER TO postgres;

--
-- Name: gbt_numeric_consistent(internal, numeric, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_numeric_consistent(internal, numeric, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_numeric_consistent';


ALTER FUNCTION public.gbt_numeric_consistent(internal, numeric, smallint) OWNER TO postgres;

--
-- Name: gbt_numeric_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_numeric_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_numeric_penalty';


ALTER FUNCTION public.gbt_numeric_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_numeric_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_numeric_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_numeric_picksplit';


ALTER FUNCTION public.gbt_numeric_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_numeric_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_numeric_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_numeric_same';


ALTER FUNCTION public.gbt_numeric_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_numeric_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_numeric_union(bytea, internal) RETURNS gbtreekey_var
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_numeric_union';


ALTER FUNCTION public.gbt_numeric_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_oid_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_oid_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_oid_compress';


ALTER FUNCTION public.gbt_oid_compress(internal) OWNER TO postgres;

--
-- Name: gbt_oid_consistent(internal, oid, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_oid_consistent(internal, oid, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_oid_consistent';


ALTER FUNCTION public.gbt_oid_consistent(internal, oid, smallint) OWNER TO postgres;

--
-- Name: gbt_oid_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_oid_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_oid_penalty';


ALTER FUNCTION public.gbt_oid_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_oid_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_oid_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_oid_picksplit';


ALTER FUNCTION public.gbt_oid_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_oid_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_oid_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_oid_same';


ALTER FUNCTION public.gbt_oid_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_oid_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_oid_union(bytea, internal) RETURNS gbtreekey8
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_oid_union';


ALTER FUNCTION public.gbt_oid_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_text_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_text_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_text_compress';


ALTER FUNCTION public.gbt_text_compress(internal) OWNER TO postgres;

--
-- Name: gbt_text_consistent(internal, text, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_text_consistent(internal, text, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_text_consistent';


ALTER FUNCTION public.gbt_text_consistent(internal, text, smallint) OWNER TO postgres;

--
-- Name: gbt_text_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_text_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_text_penalty';


ALTER FUNCTION public.gbt_text_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_text_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_text_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_text_picksplit';


ALTER FUNCTION public.gbt_text_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_text_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_text_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_text_same';


ALTER FUNCTION public.gbt_text_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_text_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_text_union(bytea, internal) RETURNS gbtreekey_var
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_text_union';


ALTER FUNCTION public.gbt_text_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_time_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_time_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_time_compress';


ALTER FUNCTION public.gbt_time_compress(internal) OWNER TO postgres;

--
-- Name: gbt_time_consistent(internal, time without time zone, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_time_consistent(internal, time without time zone, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_time_consistent';


ALTER FUNCTION public.gbt_time_consistent(internal, time without time zone, smallint) OWNER TO postgres;

--
-- Name: gbt_time_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_time_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_time_penalty';


ALTER FUNCTION public.gbt_time_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_time_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_time_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_time_picksplit';


ALTER FUNCTION public.gbt_time_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_time_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_time_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_time_same';


ALTER FUNCTION public.gbt_time_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_time_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_time_union(bytea, internal) RETURNS gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_time_union';


ALTER FUNCTION public.gbt_time_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_timetz_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_timetz_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_timetz_compress';


ALTER FUNCTION public.gbt_timetz_compress(internal) OWNER TO postgres;

--
-- Name: gbt_timetz_consistent(internal, time with time zone, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_timetz_consistent(internal, time with time zone, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_timetz_consistent';


ALTER FUNCTION public.gbt_timetz_consistent(internal, time with time zone, smallint) OWNER TO postgres;

--
-- Name: gbt_ts_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_ts_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_ts_compress';


ALTER FUNCTION public.gbt_ts_compress(internal) OWNER TO postgres;

--
-- Name: gbt_ts_consistent(internal, timestamp without time zone, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_ts_consistent(internal, timestamp without time zone, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_ts_consistent';


ALTER FUNCTION public.gbt_ts_consistent(internal, timestamp without time zone, smallint) OWNER TO postgres;

--
-- Name: gbt_ts_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_ts_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_ts_penalty';


ALTER FUNCTION public.gbt_ts_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_ts_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_ts_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_ts_picksplit';


ALTER FUNCTION public.gbt_ts_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_ts_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_ts_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_ts_same';


ALTER FUNCTION public.gbt_ts_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_ts_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_ts_union(bytea, internal) RETURNS gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_ts_union';


ALTER FUNCTION public.gbt_ts_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_tstz_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_tstz_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_tstz_compress';


ALTER FUNCTION public.gbt_tstz_compress(internal) OWNER TO postgres;

--
-- Name: gbt_tstz_consistent(internal, timestamp with time zone, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_tstz_consistent(internal, timestamp with time zone, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_tstz_consistent';


ALTER FUNCTION public.gbt_tstz_consistent(internal, timestamp with time zone, smallint) OWNER TO postgres;

--
-- Name: gbt_var_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gbt_var_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_var_decompress';


ALTER FUNCTION public.gbt_var_decompress(internal) OWNER TO postgres;

--
-- Name: gip4r_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gip4r_compress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_compress';


ALTER FUNCTION public.gip4r_compress(internal) OWNER TO postgres;

--
-- Name: gip4r_consistent(internal, ip4r, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gip4r_consistent(internal, ip4r, integer) RETURNS boolean
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_consistent';


ALTER FUNCTION public.gip4r_consistent(internal, ip4r, integer) OWNER TO postgres;

--
-- Name: gip4r_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gip4r_decompress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_decompress';


ALTER FUNCTION public.gip4r_decompress(internal) OWNER TO postgres;

--
-- Name: gip4r_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gip4r_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c STRICT
    AS '$libdir/ip4r', 'gip4r_penalty';


ALTER FUNCTION public.gip4r_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gip4r_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gip4r_picksplit(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_picksplit';


ALTER FUNCTION public.gip4r_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gip4r_same(ip4r, ip4r, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gip4r_same(ip4r, ip4r, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_same';


ALTER FUNCTION public.gip4r_same(ip4r, ip4r, internal) OWNER TO postgres;

--
-- Name: gip4r_union(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gip4r_union(internal, internal) RETURNS ip4r
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_union';


ALTER FUNCTION public.gip4r_union(internal, internal) OWNER TO postgres;

--
-- Name: gpr_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gpr_compress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_compress';


ALTER FUNCTION public.gpr_compress(internal) OWNER TO postgres;

--
-- Name: gpr_consistent(internal, prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gpr_consistent(internal, prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_consistent';


ALTER FUNCTION public.gpr_consistent(internal, prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: gpr_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gpr_decompress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_decompress';


ALTER FUNCTION public.gpr_decompress(internal) OWNER TO postgres;

--
-- Name: gpr_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gpr_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c STRICT
    AS '$libdir/prefix', 'gpr_penalty';


ALTER FUNCTION public.gpr_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gpr_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gpr_picksplit(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_picksplit';


ALTER FUNCTION public.gpr_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gpr_picksplit_jordan(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gpr_picksplit_jordan(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_picksplit_jordan';


ALTER FUNCTION public.gpr_picksplit_jordan(internal, internal) OWNER TO postgres;

--
-- Name: gpr_same(prefix_range, prefix_range, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gpr_same(prefix_range, prefix_range, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_same';


ALTER FUNCTION public.gpr_same(prefix_range, prefix_range, internal) OWNER TO postgres;

--
-- Name: gpr_union(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gpr_union(internal, internal) RETURNS text
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_union';


ALTER FUNCTION public.gpr_union(internal, internal) OWNER TO postgres;

--
-- Name: ingress_cost(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ingress_cost(client integer, start_datetime timestamp with time zone, end_datetime timestamp with time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
total_datetime timestamp with time zone = CURRENT_TIMESTAMP(0);
r record;
BEGIN
	SELECT max(report_time) + interval '1 hour' as max_time into r FROM cdr_report WHERE report_time between start_datetime
	and end_datetime;

	total_datetime = r.max_time;



	if total_datetime is null then
		SELECT
sum(ingress_client_cost) as call_cost  into r
from client_cdr where time between start_datetime and end_datetime and ingress_client_id = client and is_final_call=1;




	elsif total_datetime > end_datetime then
		SELECT sum(ingress_call_cost) as call_cost into r
		from cdr_report where report_time between start_datetime and end_datetime
		and ingress_client_id = client;


	else

		SELECT
sum(call_cost) as call_cost into r FROM ( ( SELECT sum(ingress_call_cost) as call_cost
from cdr_report
where report_time between start_datetime and total_datetime and ingress_client_id = client ) union
(SELECT
sum(ingress_client_cost) as call_cost
from client_cdr where time between total_datetime and end_datetime and ingress_client_id = client and is_final_call=1 ) ) as t;



	end if;

	return next r;
	return;

END;
$$;


ALTER FUNCTION public.ingress_cost(client integer, start_datetime timestamp with time zone, end_datetime timestamp with time zone) OWNER TO postgres;

--
-- Name: ip4(double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4(double precision) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_from_double';


ALTER FUNCTION public.ip4(double precision) OWNER TO postgres;

--
-- Name: ip4(inet); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4(inet) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_from_inet';


ALTER FUNCTION public.ip4(inet) OWNER TO postgres;

--
-- Name: ip4(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4(bigint) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_from_bigint';


ALTER FUNCTION public.ip4(bigint) OWNER TO postgres;

--
-- Name: ip4(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4(text) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_from_text';


ALTER FUNCTION public.ip4(text) OWNER TO postgres;

--
-- Name: ip4_and(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_and(ip4, ip4) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_and';


ALTER FUNCTION public.ip4_and(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4_cmp(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_cmp(ip4, ip4) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cmp';


ALTER FUNCTION public.ip4_cmp(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4_contained_by(ip4, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_contained_by(ip4, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_contained_by';


ALTER FUNCTION public.ip4_contained_by(ip4, ip4r) OWNER TO postgres;

--
-- Name: ip4_contains(ip4r, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_contains(ip4r, ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_contains';


ALTER FUNCTION public.ip4_contains(ip4r, ip4) OWNER TO postgres;

--
-- Name: ip4_eq(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_eq(ip4, ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_eq';


ALTER FUNCTION public.ip4_eq(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4_ge(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_ge(ip4, ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_ge';


ALTER FUNCTION public.ip4_ge(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4_gt(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_gt(ip4, ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_gt';


ALTER FUNCTION public.ip4_gt(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4_le(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_le(ip4, ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_le';


ALTER FUNCTION public.ip4_le(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4_lt(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_lt(ip4, ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_lt';


ALTER FUNCTION public.ip4_lt(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4_minus_bigint(ip4, bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_minus_bigint(ip4, bigint) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_minus_bigint';


ALTER FUNCTION public.ip4_minus_bigint(ip4, bigint) OWNER TO postgres;

--
-- Name: ip4_minus_int(ip4, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_minus_int(ip4, integer) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_minus_int';


ALTER FUNCTION public.ip4_minus_int(ip4, integer) OWNER TO postgres;

--
-- Name: ip4_minus_ip4(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_minus_ip4(ip4, ip4) RETURNS bigint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_minus_ip4';


ALTER FUNCTION public.ip4_minus_ip4(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4_neq(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_neq(ip4, ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_neq';


ALTER FUNCTION public.ip4_neq(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4_net_lower(ip4, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_net_lower(ip4, integer) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_net_lower';


ALTER FUNCTION public.ip4_net_lower(ip4, integer) OWNER TO postgres;

--
-- Name: ip4_net_upper(ip4, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_net_upper(ip4, integer) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_net_upper';


ALTER FUNCTION public.ip4_net_upper(ip4, integer) OWNER TO postgres;

--
-- Name: ip4_netmask(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_netmask(integer) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_netmask';


ALTER FUNCTION public.ip4_netmask(integer) OWNER TO postgres;

--
-- Name: ip4_not(ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_not(ip4) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_not';


ALTER FUNCTION public.ip4_not(ip4) OWNER TO postgres;

--
-- Name: ip4_or(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_or(ip4, ip4) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_or';


ALTER FUNCTION public.ip4_or(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4_plus_bigint(ip4, bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_plus_bigint(ip4, bigint) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_plus_bigint';


ALTER FUNCTION public.ip4_plus_bigint(ip4, bigint) OWNER TO postgres;

--
-- Name: ip4_plus_int(ip4, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_plus_int(ip4, integer) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_plus_int';


ALTER FUNCTION public.ip4_plus_int(ip4, integer) OWNER TO postgres;

--
-- Name: ip4_xor(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4_xor(ip4, ip4) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_xor';


ALTER FUNCTION public.ip4_xor(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4hash(ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4hash(ip4) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4hash';


ALTER FUNCTION public.ip4hash(ip4) OWNER TO postgres;

--
-- Name: ip4r(cidr); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r(cidr) RETURNS ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cast_from_cidr';


ALTER FUNCTION public.ip4r(cidr) OWNER TO postgres;

--
-- Name: ip4r(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r(text) RETURNS ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cast_from_text';


ALTER FUNCTION public.ip4r(text) OWNER TO postgres;

--
-- Name: ip4r(ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r(ip4) RETURNS ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cast_from_ip4';


ALTER FUNCTION public.ip4r(ip4) OWNER TO postgres;

--
-- Name: ip4r(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r(ip4, ip4) RETURNS ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_from_ip4s';


ALTER FUNCTION public.ip4r(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4r_cmp(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_cmp(ip4r, ip4r) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cmp';


ALTER FUNCTION public.ip4r_cmp(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_contained_by(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_contained_by(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_contained_by';


ALTER FUNCTION public.ip4r_contained_by(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_contained_by_strict(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_contained_by_strict(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_contained_by_strict';


ALTER FUNCTION public.ip4r_contained_by_strict(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_contains(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_contains(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_contains';


ALTER FUNCTION public.ip4r_contains(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_contains_strict(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_contains_strict(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_contains_strict';


ALTER FUNCTION public.ip4r_contains_strict(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_eq(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_eq(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_eq';


ALTER FUNCTION public.ip4r_eq(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_ge(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_ge(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_ge';


ALTER FUNCTION public.ip4r_ge(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_gt(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_gt(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_gt';


ALTER FUNCTION public.ip4r_gt(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_inter(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_inter(ip4r, ip4r) RETURNS ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_inter';


ALTER FUNCTION public.ip4r_inter(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_le(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_le(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_le';


ALTER FUNCTION public.ip4r_le(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_left_of(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_left_of(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_left_of';


ALTER FUNCTION public.ip4r_left_of(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_lt(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_lt(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_lt';


ALTER FUNCTION public.ip4r_lt(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_neq(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_neq(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_neq';


ALTER FUNCTION public.ip4r_neq(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_net_mask(ip4, ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_net_mask(ip4, ip4) RETURNS ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_net_mask';


ALTER FUNCTION public.ip4r_net_mask(ip4, ip4) OWNER TO postgres;

--
-- Name: ip4r_net_prefix(ip4, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_net_prefix(ip4, integer) RETURNS ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_net_prefix';


ALTER FUNCTION public.ip4r_net_prefix(ip4, integer) OWNER TO postgres;

--
-- Name: ip4r_overlaps(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_overlaps(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_overlaps';


ALTER FUNCTION public.ip4r_overlaps(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_right_of(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_right_of(ip4r, ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_right_of';


ALTER FUNCTION public.ip4r_right_of(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4r_size(ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_size(ip4r) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_size';


ALTER FUNCTION public.ip4r_size(ip4r) OWNER TO postgres;

--
-- Name: ip4r_union(ip4r, ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4r_union(ip4r, ip4r) RETURNS ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_union';


ALTER FUNCTION public.ip4r_union(ip4r, ip4r) OWNER TO postgres;

--
-- Name: ip4rhash(ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ip4rhash(ip4r) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4rhash';


ALTER FUNCTION public.ip4rhash(ip4r) OWNER TO postgres;

--
-- Name: is_cidr(ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION is_cidr(ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_is_cidr';


ALTER FUNCTION public.is_cidr(ip4r) OWNER TO postgres;

--
-- Name: lower(ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION lower(ip4r) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_lower';


ALTER FUNCTION public.lower(ip4r) OWNER TO postgres;

--
-- Name: margin_max(bigint, real, real, real, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION margin_max(bigint, real, real, real, integer, text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	r1 record;
	in_ca alias for $1;
	in_rate alias for $2;
	in_asr alias for $3;
	in_acd alias for $4;
	t alias for $5;
	--1,find buy order;2--find sell order
	total_minutes real;
	name_code alias for $6;
begin
if t=1 then
	raise notice 'find buy order for code_name < % >',name_code;
	for r in
	SELECT
	s.id,
	case sum(s.minutes) when 0 then 0 else sum(s.cost)/sum(s.minutes) end as avg_rate,
	case sum(s.ca) when 0 then 0 else sum(s.ok_calls::real)/sum(s.ca) end as asr,
	case sum(s.minutes) when 0 then 0 else sum(s.minutes)/sum(s.ok_calls) end as acd
	from stats_buy_order_summary as s where code_name=name_code group by s.id having(sum(s.ca)>0 and sum(s.minutes)>0)
	loop
		raise notice 'order id %, avg_rate %, asr %, acd %',r.id,r.avg_rate,r.asr,r.acd;
		select into total_minutes in_ca*least(in_asr,r.asr)*least(in_acd,r.acd);
		select into r1 r.id::text,r.avg_rate::text,r.asr::text,r.acd::text,total_minutes::text,(total_minutes*r.avg_rate)::text,(total_minutes*in_rate)::text;
		return next r1;
	end loop;
elsif t=2 then
	raise notice 'find sell order for code_name < % >',name_code;
	for r in
	SELECT
	s.id,
	case sum(s.minutes) when 0 then 0 else sum(s.cost)/sum(s.minutes) end as avg_rate,
	case sum(s.ca) when 0 then 0 else sum(s.ok_calls::real)/sum(s.ca) end as asr,
	case sum(s.minutes) when 0 then 0 else sum(s.minutes)/sum(s.ok_calls) end as acd
	from stats_sell_order_summary as s where code_name=name_code group by s.id having(sum(s.ca)>0 and sum(s.minutes)>0)
	loop
		raise notice 'order id %, avg_rate %, asr %, acd %',r.id,r.avg_rate,r.asr,r.acd;
		select into total_minutes in_ca*least(in_asr,r.asr)*least(in_acd,r.acd);
		select into r1 r.id::text,r.avg_rate::text,r.asr::text,r.acd::text,total_minutes::text,(total_minutes*r.avg_rate)::text,(total_minutes*in_rate)::text;
		return next r1;
	end loop;
end if;

	return;
end;

$_$;


ALTER FUNCTION public.margin_max(bigint, real, real, real, integer, text) OWNER TO postgres;

--
-- Name: mutual_trans(timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION mutual_trans(timestamp with time zone, timestamp with time zone, integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	start_time alias for $1;
	end_time alias for $2;
	id_client alias for $3;
	trans_type alias for $4;
	r record;

begin

	if trans_type = 0 then --all

	if id_client = 0 then
		for r in
		select
		payment_time::text,
		(case payment_type
		when 4 then 1
		when 5 then 1
		when 3 then 2
		when 6 then 2
		when 7 then 5
		when 8 then 6
		when 9 then 9
		when 11 then 7
		when 12 then 8
		end)::text as t_type,
		client_id::text,
		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
		from client_payment
		where payment_type in (3,4,5,6,7,8,9,11,12) and
		payment_time between start_time and end_time
		union
		select
		invoice_time::text,
		(case type
		when 0 then 4
		when 2 then 4
		end)::text as t_type,
		client_id::text,
		total_amount::text
		from invoice
		where state=9 and type in (0,2) and
		invoice_time between start_time and end_time
		union
		select
		invoice_time::text,
		'3' as t_type,
		client_id::text,
		total_amount::text
		from invoice
		where type = 3 and
		invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select
		payment_time::text,
		(case payment_type
		when 4 then 1
		when 5 then 1
		when 3 then 2
		when 6 then 2
		when 7 then 5
		when 8 then 6
		when 9 then 9
		when 11 then 7
		when 12 then 8
		end)::text as t_type,
		client_id::text,
		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
		from client_payment
		where payment_type in (3,4,5,6,7,8,9,11,12) and client_id=id_client and
		payment_time between start_time and end_time
		union
		select
		invoice_time::text,
		(case type
		when 0 then 4
		when 2 then 4
		end)::text as t_type,
		client_id::text,
		total_amount::text
		from invoice
		where state=9 and type in (0,2) and client_id=id_client and
		invoice_time between start_time and end_time
		union
		select
		invoice_time::text,
		'3' as t_type,
		client_id::text,
		total_amount::text
		from invoice
		where type = 3 and client_id=id_client and
		invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 1 then --payment received

	if id_client=0 then
		for r in
		select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 2 then --payment sent

	if id_client=0 then
		for r in
		select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 3 then --invoice received

	if id_client=0 then
		for r in
		select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
		and invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
		and invoice_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 4 then --invoice sent

	if id_client=0 then
		for r in
		select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
		and invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
		and invoice_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 5 then --credit note received

	if id_client=0 then
		for r in
		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 6 then --credit note sent

	if id_client=0 then
		for r in
		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 7 then --debit note received

	if id_client=0 then
		for r in
		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 8 then --debit note sent

	if id_client=0 then
		for r in
		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 9 then --reset

	if id_client=0 then
		for r in
		select payment_time::text,9::text,client_id::text,amount::text from client_payment where payment_type=9
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,9::text,client_id::text,amount::text from client_payment where payment_type=9
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	end if;

	return;

end;
$_$;


ALTER FUNCTION public.mutual_trans(timestamp with time zone, timestamp with time zone, integer, integer) OWNER TO postgres;

--
-- Name: normal_rand(integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION normal_rand(integer, double precision, double precision) RETURNS SETOF double precision
    LANGUAGE c STRICT
    AS '$libdir/tablefunc', 'normal_rand';


ALTER FUNCTION public.normal_rand(integer, double precision, double precision) OWNER TO postgres;

--
-- Name: opentact_balance_func(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION opentact_balance_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        current_ingress_id integer;
            current_egress_rate double precision;
    BEGIN
        current_ingress_id := NEW.ingress_id;
        current_egress_rate := NEW.egress_rate;

        UPDATE  opentact_balance SET balance = balance - current_egress_rate WHERE ingress_id = current_ingress_id;

            return null;
    END;
    $$;


ALTER FUNCTION public.opentact_balance_func() OWNER TO postgres;

--
-- Name: opentact_egress_registration(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION opentact_egress_registration() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ingress_id integer;
            egress_alias varchar;
            egress_id integer;
            resource_ip varchar;
            resource_port integer;
            current_state integer;
    BEGIN
            if  (TG_OP = 'INSERT') THEN
                    current_state := NEW.state;

                    SELECT into ingress_id resource_id FROM resource_ip WHERE  username = NEW.username  limit 1;

                    if ingress_id is not null then

                    SELECT into egress_alias replace(alias, '_ingress', '_egress') FROM resource WHERE  resource_id = ingress_id  limit 1;

                if egress_alias is not null then

                    SELECT into egress_id resource_id FROM resource WHERE alias = egress_alias and egress = true limit 1;
                    if egress_id is not null then
                        if current_state = 1 then
                            update resource_ip set ip = NEW.ip, port = NEW.port WHERE resource_id = egress_id;
                        else
                            update resource_ip set ip = NULL WHERE resource_id = egress_id;
                        end if;
                    end if;

                END IF;

            END IF;

            END IF;
            return null;
    END;
    $$;


ALTER FUNCTION public.opentact_egress_registration() OWNER TO postgres;

--
-- Name: order_stats(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION order_stats(timestamp with time zone, timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	time_start alias for $1;
	time_end alias for $2;
begin

	raise notice 'stats_trunk_origination';
	delete from stats_trunk_origination;
	for r in
	select ingress_client_id::integer as client_id,ingress_id::integer as resource_id,trunk_id_origination as alias,
	term_country as country,term_code_name as code_name,term_code as code,

	count(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as ca,
	count(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then ingress_client_cost::real else 0 end) as cost,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as total_pdd,

	count(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then time else null end) as yesday_ca,
	count(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone and answer_time_of_date > '0' then answer_time_of_date else null end) as yesday_ok_calls,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then call_duration::real else 0 end)/60 as yesday_minutes,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then ingress_client_cost::real else 0 end) as yesday_cost,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone and answer_time_of_date > '0' then pdd::integer else 0 end) as yesday_pdd,

	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as week_ca,
	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as week_ok_calls,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as week_minutes,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then ingress_client_cost::real else 0 end) as week_cost,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as week_pdd,

	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then time else null end) as mtd_ca,
	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as mtd_ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as mtd_minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then ingress_client_cost::real else 0 end) as mtd_cost,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as mtd_pdd

	from client_cdr
	where time between time_start and time_end
	and ingress_client_id != '' and ingress_id != ''
	group by ingress_client_id,ingress_id,trunk_id_origination,term_country,term_code_name,term_code
	loop
		raise notice 'ingress trunk % stats,country %,code_name %,code %',r.resource_id,r.country,r.code_name,r.code;
		insert into stats_trunk_origination
		(client_id,resource_id,trunk_id_origination,country,code_name,code,cost,pdd,ca,ok_calls,minutes,yesday_ca,yesday_ok_calls,yesday_minutes,week_ok_calls,week_minutes,mtd_ok_calls,mtd_minutes,week_ca,mtd_ca,yesday_pdd,yesday_cost,week_pdd,week_cost,mtd_pdd,mtd_cost)
		select r.client_id,r.resource_id,r.alias,r.country,r.code_name,r.code,r.cost,r.total_pdd,r.ca,r.ok_calls,r.minutes,r.yesday_ca,r.yesday_ok_calls,r.yesday_minutes,r.week_ok_calls,r.week_minutes,r.mtd_ok_calls,r.mtd_minutes,r.week_ca,r.mtd_ca,r.yesday_pdd,r.yesday_cost,r.week_pdd,r.week_cost,r.mtd_pdd,r.mtd_cost;
		--select r.client_id,r.resource_id,r.alias,r.country,r.code_name,r.code,r.cost,r.total_pdd,r.ca,r.ok_calls,r.minutes,0,0,0,0,0,0,0,0,0;
	end loop;

	raise notice 'stats_trunk_termination';
	delete from stats_trunk_termination;
	for r in
	select egress_client_id::integer as client_id,egress_id::integer as resource_id,trunk_id_termination as alias,
	term_country as country,term_code_name as code_name,term_code as code,

	count(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as ca,
	count(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then egress_cost::real else 0 end) as cost,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as total_pdd,

	count(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then time else null end) as yesday_ca,
	count(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone and answer_time_of_date > '0' then answer_time_of_date else null end) as yesday_ok_calls,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then call_duration::real else 0 end)/60 as yesday_minutes,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then egress_cost::real else 0 end) as yesday_cost,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone and answer_time_of_date > '0' then pdd::integer else 0 end) as yesday_pdd,

	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as week_ca,
	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as week_ok_calls,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as week_minutes,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then egress_cost::real else 0 end) as week_cost,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as week_pdd,

	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then time else null end) as mtd_ca,
	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as mtd_ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as mtd_minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then egress_cost::real else 0 end) as mtd_cost,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as mtd_pdd

	from client_cdr
	where time between time_start and time_end
	and egress_client_id != '' and egress_id != ''
	group by egress_client_id,egress_id,trunk_id_termination,term_country,term_code_name,term_code
	loop
		raise notice 'egress trunk % stats,country %,code_name %,code %',r.resource_id,r.country,r.code_name,r.code;
		insert into stats_trunk_termination
		(client_id,resource_id,trunk_id_termination,country,code_name,code,cost,pdd,ca,ok_calls,minutes,yesday_ca,yesday_ok_calls,yesday_minutes,week_ok_calls,week_minutes,mtd_ok_calls,mtd_minutes,week_ca,mtd_ca,yesday_pdd,yesday_cost,week_pdd,week_cost,mtd_pdd,mtd_cost)
		select r.client_id,r.resource_id,r.alias,r.country,r.code_name,r.code,r.cost,r.total_pdd,r.ca,r.ok_calls,r.minutes,r.yesday_ca,r.yesday_ok_calls,r.yesday_minutes,r.week_ok_calls,r.week_minutes,r.mtd_ok_calls,r.mtd_minutes,r.week_ca,r.mtd_ca,r.yesday_pdd,r.yesday_cost,r.week_pdd,r.week_cost,r.mtd_pdd,r.mtd_cost;
		--select r.client_id,r.resource_id,r.alias,r.country,r.code_name,r.code,r.cost,r.total_pdd,r.ca,r.ok_calls,r.minutes,0,0,0,0,0,0,0,0,0;
	end loop;

	raise notice 'stats_buy_order_summary';
	delete from stats_buy_order_summary;
	for r in
	select order_id,term_country as country,term_code_name as code_name,term_code as code,

	count(case when time between time_end-interval '24 hours' and time_end then time else null end) as ca,
	count(case when time between time_end-interval '24 hours' and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as ok_calls,
	sum(case when time between time_end-interval '24 hours' and time_end then call_duration::real else 0 end)/60 as minutes,
	sum(case when time between time_end-interval '24 hours' and time_end then ingress_client_cost::real else 0 end) as cost,
	sum(case when time between time_end-interval '24 hours' and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as total_pdd,

	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as week_ca,
	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as week_ok_calls,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as week_minutes,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then ingress_client_cost::real else 0 end) as week_cost,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as week_pdd,

	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then time else null end) as mtd_ca,
	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as mtd_ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as mtd_minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then ingress_client_cost::real else 0 end) as mtd_cost,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as mtd_pdd

	from client_cdr
	where time between time_start and time_end and order_type='1'
	group by order_id,term_country,term_code_name,term_code
	loop
		raise notice 'buy order id %,country %,code_name %,code %',r.order_id,r.country,r.code_name,r.code;
		insert into stats_buy_order_summary
		(id,country,code_name,code,ca,ok_calls,minutes,week_ca,week_ok_calls,week_minutes,mtd_ca,mtd_ok_calls,mtd_minutes,cost,mtd_cost,week_pdd,week_cost,mtd_pdd,pdd)
		select r.order_id::integer,r.country,r.code_name,r.code,r.ca,r.ok_calls,r.minutes,r.week_ca,r.week_ok_calls,r.week_minutes,r.mtd_ca,r.mtd_ok_calls,r.mtd_minutes,r.cost,r.mtd_cost,r.week_pdd,r.week_cost,r.mtd_pdd,r.total_pdd;
		--select r.id,r.country,r.code_name,r.code,r.ca,r.ok_calls,r.minutes,0,0,0,0,0,0,r.cost,0;
	end loop;

	raise notice 'stats_sell_order_summary';
	delete from stats_sell_order_summary;
	for r in
	select order_id,term_country as country,term_code_name as code_name,term_code as code,

	count(case when time between time_end-interval '24 hours' and time_end then time else null end) as ca,
	count(case when time between time_end-interval '24 hours' and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as ok_calls,
	sum(case when time between time_end-interval '24 hours' and time_end then call_duration::real else 0 end)/60 as minutes,
	sum(case when time between time_end-interval '24 hours' and time_end then egress_cost::real else 0 end) as cost,
	sum(case when time between time_end-interval '24 hours' and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as total_pdd,

	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as week_ca,
	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as week_ok_calls,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as week_minutes,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then egress_cost::real else 0 end) as week_cost,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as week_pdd,

	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then time else null end) as mtd_ca,
	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as mtd_ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as mtd_minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then egress_cost::real else 0 end) as mtd_cost,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as mtd_pdd

	from client_cdr
	where time between time_start and time_end and order_type='2'
	group by order_id,term_country,term_code_name,term_code
	loop
		raise notice 'sell order id %,country %,code_name %,code %',r.order_id,r.country,r.code_name,r.code;
		insert into stats_sell_order_summary
		(id,country,code_name,code,ca,ok_calls,minutes,week_ca,week_ok_calls,week_minutes,mtd_ca,mtd_ok_calls,mtd_minutes,cost,mtd_cost,week_pdd,week_cost,mtd_pdd,pdd)
		select r.order_id::integer,r.country,r.code_name,r.code,r.ca,r.ok_calls,r.minutes,r.week_ca,r.week_ok_calls,r.week_minutes,r.mtd_ca,r.mtd_ok_calls,r.mtd_minutes,r.cost,r.mtd_cost,r.week_pdd,r.week_cost,r.mtd_pdd,r.total_pdd;
		--select r.id,r.country,r.code_name,r.code,r.ca,r.ok_calls,r.minutes,0,0,0,0,0,0,r.cost,0;
	end loop;

end;

$_$;


ALTER FUNCTION public.order_stats(timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: order_stats_report(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION order_stats_report(timestamp with time zone, timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	time_start alias for $1;
	time_end alias for $2;
begin

	delete from stats_buy_order;
	for r in
		select order_id,term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00') as s_time,
		count(*) as ca,
		count(case answer_time_of_date when '0' then null when '' then null else answer_time_of_date end) as success_calls,
		sum(call_duration::real)/60 as minutes
		from client_cdr
		where time between time_start and time_end and order_type='1'
		group by order_id,term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00')
	loop
		raise notice 'buy order id %,country %,code_name %,code %',r.order_id,r.term_country,r.term_code_name,r.term_code;
		insert into stats_buy_order(id,country,code_name,code,call_duration,ca,success_calls,stat_time)
		select r.order_id::integer,r.term_country,r.term_code_name,r.term_code,r.minutes,r.ca,r.success_calls,r.s_time::timestamp with time zone;
	end loop;

	delete from stats_sell_order;
	for r in
		select order_id,term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00') as s_time,
		count(*) as ca,
		count(case answer_time_of_date when '0' then null when '' then null else answer_time_of_date end) as success_calls,
		sum(call_duration::real)/60 as minutes
		from client_cdr
		where time between time_start and time_end and order_type='2'
		group by order_id,term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00')
	loop
		raise notice 'sell order id %,country %,code_name %,code %',r.order_id,r.term_country,r.term_code_name,r.term_code;
		insert into stats_sell_order(id,country,code_name,code,call_duration,ca,success_calls,stat_time)
		select r.order_id::integer,r.term_country,r.term_code_name,r.term_code,r.minutes,r.ca,r.success_calls,r.s_time::timestamp with time zone;
	end loop;
end;

$_$;


ALTER FUNCTION public.order_stats_report(timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: pay_update_invoice(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pay_update_invoice() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
   r RECORD;
   is_approved client_payment.approved%type ;--æ˜¯å¦å®¡æ ¸

	id_client integer;
	id_invoice  integer;

	amount_pay client_payment.amount%type; --å……å€¼é‡‘é¢
   amount_total    client_payment.amount%type;--æ€»å…±è¦ä»˜çš„é’±
   paid_flag   invoice.paid%type;--æ˜¯å¦ä»˜æ¸…


begin

	id_client := NEW.client_id;


    --æ‰¾ ä¸åˆ°client
	if id_client is null then
		return null;
	end if;

	--æœªå®¡æ ¸
	is_approved := NEW.approved;
	if is_approved !=true then
		return null;
	end if;

--ä»˜æ¬¾ä¸º0
	amount_pay := NEW.amount;
	if amount_pay is null then
		return null;
	end if;


	select   invoice_id,total_amount into r from invoice where client_id = id_client  order by   invoice_id   desc   limit 1;

--æ‰¾ä¸åˆ°invoice
	if r.invoice_id is null then
		return null;
   else
     id_invoice:=r.invoice_id;
     amount_total :=r.total_amount;
   end if;



if amount_total>amount_pay then
  paid_flag:=false;
else
  paid_flag:=true;
end if;

update  invoice  set pay_amount=amount_pay ,paid = paid_flag, client_id=id_client  where  invoice_id=id_invoice;

	return null;

end;
$$;


ALTER FUNCTION public.pay_update_invoice() OWNER TO postgres;

--
-- Name: pr_penalty(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pr_penalty(prefix_range, prefix_range) RETURNS real
    LANGUAGE c STRICT
    AS '$libdir/prefix', 'pr_penalty';


ALTER FUNCTION public.pr_penalty(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range(text) RETURNS prefix_range
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_cast_from_text';


ALTER FUNCTION public.prefix_range(text) OWNER TO postgres;

--
-- Name: prefix_range_cmp(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_cmp(prefix_range, prefix_range) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_cmp';


ALTER FUNCTION public.prefix_range_cmp(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_contained_by(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_contained_by(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_contained_by';


ALTER FUNCTION public.prefix_range_contained_by(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_contained_by_strict(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_contained_by_strict(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_contained_by_strict';


ALTER FUNCTION public.prefix_range_contained_by_strict(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_contains(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_contains(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_contains';


ALTER FUNCTION public.prefix_range_contains(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_contains_strict(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_contains_strict(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_contains_strict';


ALTER FUNCTION public.prefix_range_contains_strict(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_eq(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_eq(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_eq';


ALTER FUNCTION public.prefix_range_eq(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_ge(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_ge(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_ge';


ALTER FUNCTION public.prefix_range_ge(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_gt(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_gt(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_gt';


ALTER FUNCTION public.prefix_range_gt(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_inter(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_inter(prefix_range, prefix_range) RETURNS prefix_range
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_inter';


ALTER FUNCTION public.prefix_range_inter(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_le(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_le(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_le';


ALTER FUNCTION public.prefix_range_le(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_lt(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_lt(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_lt';


ALTER FUNCTION public.prefix_range_lt(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_neq(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_neq(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_neq';


ALTER FUNCTION public.prefix_range_neq(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_overlaps(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_overlaps(prefix_range, prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_overlaps';


ALTER FUNCTION public.prefix_range_overlaps(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_union(prefix_range, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prefix_range_union(prefix_range, prefix_range) RETURNS prefix_range
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_union';


ALTER FUNCTION public.prefix_range_union(prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: product_rout_rate_table_trigfun_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION product_rout_rate_table_trigfun_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into product_rout_rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into product_rout_rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into product_rout_rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into product_rout_rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.product_rout_rate_table_trigfun_record() OWNER TO postgres;

--
-- Name: qos_chart(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION qos_chart(integer, integer, integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	qos_type alias for $1;
	search_id alias for $2;
	qos_name alias for $3;
	qos_duration alias for $4;
	r record;
	r1 record;
	success_asr_calls3 real := 0;
	total_asr_calls3 integer := 0;
	total_acd3 real := 0;
	total_pdd3 integer := 0;
	total_acd_calls3 integer := 0;
	total_ca3 integer := 0;
	asr3 real := 0;
	acd3 real := 0;
	pdd3 integer := 0;


begin

if qos_duration!=1 and qos_duration!=2 and qos_duration!=3 then
	raise notice 'qos duration error';
	return;
end if;

--Gobal Stats
if qos_type =1 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;


--Route Stats
elsif qos_type=2 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(value::integer) as ca
	from product_info
	where time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	and product_id=search_id::text
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from prefix_info
	where direction='1'
	and pro_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from prefix_info
	where direction='1'
	and pro_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from prefix_info
	where direction='1'
	and pro_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from prefix_info
	where direction='1'
	and pro_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

--Ingress Stats
elsif qos_type=3 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where res_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where res_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where res_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where res_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where res_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

--Egress Stats
elsif qos_type=4 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where res_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where res_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where res_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where res_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where res_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

--Ingress ip Stats
elsif qos_type=5 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where ip_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where ip_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

--Egress ip Stats
elsif qos_type=6 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where ip_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where ip_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

--Route prefix Stats
elsif qos_type=7 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(call_count::integer) as ca
	from prefix_info
	where prefix_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from prefix_info
	where prefix_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from prefix_info
	where prefix_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from prefix_info
	where prefix_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from prefix_info
	where prefix_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

elsif qos_type =8 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

end if;

	return;

end;
$_$;


ALTER FUNCTION public.qos_chart(integer, integer, integer, integer) OWNER TO postgres;

--
-- Name: qos_report(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION qos_report(integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	qos_type alias for $1;
	search_id alias for $2;
	r record;
	r1 record;
	success_asr_calls1 real := 0;
	total_asr_calls1 bigint := 0;
	total_acd1 real := 0;
	total_pdd1 bigint := 0;
	total_acd_calls1 bigint := 0;
	total_pdd_calls1 bigint := 0;
	total_ca1 bigint := 0;
	success_asr_calls2 real := 0;
	total_asr_calls2 bigint := 0;
	total_acd2 real := 0;
	total_pdd2 bigint := 0;
	total_acd_calls2 bigint := 0;
	total_pdd_calls2 bigint := 0;
	total_ca2 bigint := 0;
	success_asr_calls3 real := 0;
	total_asr_calls3 bigint := 0;
	total_acd3 real := 0;
	total_pdd3 bigint := 0;
	total_acd_calls3 bigint := 0;
	total_pdd_calls3 bigint := 0;
	total_ca3 bigint := 0;
	asr1 real := 0;
	acd1 real := 0;
	pdd1 bigint := 0;

	asr2 real := 0;
	acd2 real := 0;
	pdd2 bigint := 0;

	asr3 real := 0;
	acd3 real := 0;
	pdd3 bigint := 0;


begin

--Gobal Stats
if qos_type =1 then
	for r in
	SELECT
	*
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	loop
		if r.time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then
		success_asr_calls1 = success_asr_calls1 + r.asr::real*r.call_count_asr::integer;
		total_asr_calls1 = total_asr_calls1 + r.call_count_asr::integer;
		total_acd1 = total_acd1 + case when r.acd::real<0 then 0 else r.acd::real end;
		total_pdd1 = total_pdd1 + r.pdd::integer;
		total_acd_calls1 = total_acd_calls1 + r.call_count::integer;
		total_ca1 = total_ca1 + r.ca::integer;
		total_pdd_calls1 = total_pdd_calls1 + 1;
		end if;
		if r.time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then
		success_asr_calls2 = success_asr_calls2 + r.asr::real*r.call_count_asr::integer;
		total_asr_calls2 = total_asr_calls2 + r.call_count_asr::integer;
		total_acd2 = total_acd2 + case when r.acd::real<0 then 0 else r.acd::real end;
		total_pdd2 = total_pdd2 + r.pdd::integer;
		total_acd_calls2 = total_acd_calls2 + r.call_count::integer;
		total_ca2 = total_ca2 + r.ca::integer;
		total_pdd_calls2 = total_pdd_calls2 + 1;
		end if;
		success_asr_calls3 = success_asr_calls3 + r.asr::real*r.call_count_asr::integer;
		total_asr_calls3 = total_asr_calls3 + r.call_count_asr::integer;
		total_acd3 = total_acd3 + case when r.acd::real<0 then 0 else r.acd::real end;
		total_pdd3 = total_pdd3 + r.pdd::integer;
		total_acd_calls3 = total_acd_calls3 + r.call_count::integer;
		total_ca3 = total_ca3 + r.ca::integer;
		total_pdd_calls3 = total_pdd_calls3 + 1;
	end loop;

	raise notice '%,%,%,%,%,%',success_asr_calls1,total_asr_calls1,total_acd1,total_pdd1,total_acd_calls1,total_ca1;
	if total_asr_calls1>0 then asr1 := success_asr_calls1/total_asr_calls1; end if;
	if total_acd_calls1>0 then acd1 := total_acd1/total_acd_calls1; end if;
	if total_pdd_calls1>0 then pdd1 := total_pdd1/total_pdd_calls1; end if;
	if total_asr_calls2>0 then asr2 := success_asr_calls2/total_asr_calls2; end if;
	if total_acd_calls2>0 then acd2 := total_acd2/total_acd_calls2; end if;
	if total_pdd_calls2>0 then pdd2 := total_pdd2/total_pdd_calls2; end if;
	if total_asr_calls3>0 then asr3 := success_asr_calls3/total_asr_calls3; end if;
	if total_acd_calls3>0 then acd3 := total_acd3/total_acd_calls3; end if;
	if total_pdd_calls3>0 then pdd3 := total_pdd3/total_pdd_calls3; end if;

	select into r1 '1'::text,asr1::text,acd1::text,total_ca1::text,pdd1::text,asr2::text,acd2::text,total_ca2::text,pdd2::text,asr3::text,acd3::text,total_ca3::text,pdd3::text;
	return next r1;

--Route Stats
elsif qos_type=2 then

	for r in
	SELECT
	pro_id,
	case when prefix_id ='' then 1 else 2 end as pro_type,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(acd::real) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from prefix_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by pro_id,case when prefix_id ='' then 1 else 2 end
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.pro_id::text,r.pro_type::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

--Ingress Stats
elsif qos_type=3 then

	for r in
	SELECT
	res_id,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 and acd::real>=0 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 and acd::real>=0 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(case when acd::real<0 then 0 else acd::real end) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by res_id
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.res_id::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

--Egress Stats
elsif qos_type=4 then

	for r in
	SELECT
	res_id,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 and acd::real>=0 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 and acd::real>=0 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(case when acd::real<0 then 0 else acd::real end) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by res_id
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.res_id::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

--Ingress ip Stats
elsif qos_type=5 then

	for r in
	SELECT
	ip_id,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 and acd::real>=0 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 and acd::real>=0 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(case when acd::real<0 then 0 else acd::real end) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='0' and res_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by ip_id
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.ip_id::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

--Egress ip Stats
elsif qos_type=6 then

	for r in
	SELECT
	ip_id,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 and acd::real>=0 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 and acd::real>=0 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(case when acd::real<0 then 0 else acd::real end) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='1' and res_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by ip_id
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.ip_id::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

--Route prefix Stats
elsif qos_type=7 then

	for r in
	SELECT
	prefix_id,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(acd::real) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from prefix_info
	where direction='1' and pro_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by prefix_id
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.prefix_id::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

end if;

	return;

end;
$_$;


ALTER FUNCTION public.qos_report(integer, integer) OWNER TO postgres;

--
-- Name: rate_code_check(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION rate_code_check(integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	id_code_deck alias for $1;
begin

	for r in select * from rate_table where code_deck_id=id_code_deck order by 1
	loop
		update rate
		set end_date=current_timestamp(0)
		where rate_table_id=r.rate_table_id and
		code not in (select code from code where code_deck_id=id_code_deck);
	end loop;

end;

$_$;


ALTER FUNCTION public.rate_code_check(integer) OWNER TO postgres;

--
-- Name: rate_overflow(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION rate_overflow(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  egress_trunk_trace ALIAS FOR $1;
  single_value TEXT;
  tmp integer;
  error_code TEXT;
begin
  if (egress_trunk_trace is null) THEN
    return 0;
  ELSE
    tmp = 0;
    for single_value in select regexp_split_to_table(egress_trunk_trace,';')
    LOOP
      if (tmp = 0) THEN
        tmp = 1;
      ELSE
      select INTO error_code substring(single_value from '..$');
        if (error_code != '21') THEN
          return 0;
        END IF ;
      END IF ;
    END LOOP ;
    return 1;
  END IF ;
end;
$_$;


ALTER FUNCTION public.rate_overflow(text) OWNER TO postgres;

--
-- Name: re_total(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION re_total(begin_time text, end_time text) RETURNS integer
    LANGUAGE plpgsql
    AS $$

declare

	mviews RECORD;

begin

	for mviews in SELECT tablename FROM  pg_tables where tablename like 'statistic_cdr%'

and substring(tablename from 14) > begin_time and substring(tablename from 14) < end_time loop

		execute 'DROP TABLE ' || mviews.tablename;

	end loop;

	return 1;
end

$$;


ALTER FUNCTION public.re_total(begin_time text, end_time text) OWNER TO postgres;

--
-- Name: rerate_cdr(text, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION rerate_cdr(text, integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	orig_term alias for $2;--1:ingress,2:egress
	id_rate_table alias for $3;
	cdr_info alias for $1;
	cdr_text text[];
	r record;
	r1 record;
	new_rate numeric;
	new_cost numeric;
	new_time integer;
	r2 record;
	id_jurisdiction_country numeric;
	ani_jurisdiction integer;
	dnis_jurisdiction integer;
	res text;
	rate_dnis text;
	dp text := ';';
	start_time text;
	end_time text;
	r_zone text;
	l_time timestamp with time zone;
	rate_found boolean := false;
	exe_sql text;
	rec record;
	is_lrn integer;
begin
	SELECT into cdr_text regexp_split_to_array(cdr_info, ';');
	start_time := TIMESTAMP WITH TIME ZONE 'epoch' + cdr_text[9]::bigint/1000000 * INTERVAL '1 second';
	end_time := TIMESTAMP WITH TIME ZONE 'epoch' + cdr_text[10]::bigint/1000000 * INTERVAL '1 second';

	select into is_lrn rate_type from rate_table where rate_table_id=id_rate_table;

	if orig_term=1 then
		if is_lrn=1 then
			raise notice 'rate for lrn';
			rate_dnis := cdr_text[12];
		else
			raise notice 'rate for dnis';
			rate_dnis := cdr_text[13];
		end if;
	elsif orig_term=2 then
		if is_lrn=1 then
			raise notice 'rate for lrn';
			rate_dnis := cdr_text[12];
		else
			raise notice 'rate for dnis';
			rate_dnis := cdr_text[13];
		end if;
	end if;
        --exe_sql := 'select t1.* from (SELECT * from rate where rate_table_id='||id_rate_table||' and code @> \''||rate_dnis||'\'::prefix_range and effective_date<=\''||cdr_text[14]||'\'::timestamp with time zone order by length(code::text) desc,effective_date desc) as t1,(SELECT * from rate where rate_table_id='||id_rate_table||' and code @> \''||rate_dnis||'\'::prefix_range and effective_date<=\''||cdr_text[14]||'\'::timestamp with time zone order by length(code::text) desc,effective_date desc limit 1) as t2 where t1.code=t2.code and t1.effective_date=t2.effective_date';
        --raise notice '%',exe_sql;
        --for rec IN EXECUTE 'EXPLAIN ANALYZE ' || exe_sql LOOP
        --        RAISE NOTICE ' - %', rec;
        --end loop;

	for r1 in select t1.* from (SELECT * from rate where rate_table_id=id_rate_table and code @> rate_dnis and effective_date<=cdr_text[14]::timestamp with time zone and (end_date is null or end_date>=cdr_text[14]::timestamp with time zone) order by length(code::text) desc,effective_date desc) as t1,(SELECT * from rate where rate_table_id=id_rate_table and code @> rate_dnis and effective_date<=cdr_text[14]::timestamp with time zone and (end_date is null or end_date>=cdr_text[14]::timestamp with time zone) order by length(code::text) desc,effective_date desc limit 1) as t2 where t1.code=t2.code and t1.effective_date=t2.effective_date
	loop
		raise notice '---check rate id %',r1.rate_id;
		if r1.zone is null or r1.zone='' or r1.zone='0' then
			r_zone='0:00';
		else
			r_zone := r1.zone;
		end if;
		--l_time := r.time+r_zone::time;
		l_time := cdr_text[14]::timestamp with time zone+r_zone::time;
		--if r1.effective_date > r.time then
		if r1.effective_date > cdr_text[14]::timestamp with time zone then
			raise notice 'effective date % invalid',r1.effective_date;
			continue;
		end if;
		if r1.end_date is not null then
			--if r1.end_date < r.time then
			if r1.end_date < cdr_text[14]::timestamp with time zone then
				raise notice 'end date % invalid',r1.end_date;
				continue;
			end if;
		end if;
		if r1.time_profile_id is not null then
			select into r2 * from time_profile where time_profile_id=r1.time_profile_id;
			if r2.type != 0 then
				if r2.type = 1 then
					if l_time::time not between r2.start_time and r2.end_time then
						raise notice 'time_profile % type week invalid',r1.time_profile_id;
						continue;
					end if;
					if EXTRACT(DOW from l_time) not between r2.start_week and r2.end_week then
						raise notice 'time_profile % type week invalid',r1.time_profile_id;
						continue;
					end if;
				elsif r2.type = 2 then
					if l_time::time not between r2.start_time and r2.end_time then
						raise notice 'time_profile % type time invalid',r1.time_profile_id;
						continue;
					end if;
				end if;
			end if;
		end if;
		if r1.rate_id is not null then
			raise notice 'found it id %',r1.rate_id;
			rate_found := true;
			exit;
		end if;
	end loop;

	if rate_found is false then
		raise notice 'rate not found';
		if orig_term=1 then
			res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'orig rate not found'||dp||'N/A'||dp||'N/A'||dp||'N/A';
		elsif orig_term=2 then
			res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'N/A'||dp||'N/A'||dp||'term rate not found'||dp||'N/A';
		end if;
		return res;
	end if;
	select into id_jurisdiction_country jurisdiction_country_id from rate_table where rate_table_id=id_rate_table;
	if id_jurisdiction_country is null then
		raise notice 'rate table no select jurisdiction_country';
		new_rate := r1.rate;
	else
		select into ani_jurisdiction jurisdiction_id from jurisdiction_prefix where jurisdiction_country_id=id_jurisdiction_country and prefix @> cdr_text[15]::prefix_range order by length(prefix::text) desc limit 1;
		select into dnis_jurisdiction jurisdiction_id from jurisdiction_prefix where jurisdiction_country_id=id_jurisdiction_country and prefix @> rate_dnis::prefix_range order by length(prefix::text) desc limit 1;
		if ani_jurisdiction is not null and dnis_jurisdiction is not null then
			if ani_jurisdiction=dnis_jurisdiction then
				raise notice 'intra rate';
				new_rate := r1.intra_rate;
			else
				raise notice 'inter rate';
				new_rate := r1.inter_rate;
			end if;
		else
			raise notice 'other rate';
			new_rate := r1.rate;
		end if;
	end if;
	--if r.call_duration::integer <= r1.grace_time then
	if cdr_text[4]::integer <= r1.grace_time then
		new_time := 0;
	--elsif r.call_duration::integer <= r1.min_time then
	elsif cdr_text[4]::integer <= r1.min_time then
		new_time := r1.min_time;
	else
		--new_time := ceil(r.call_duration::real/r1.interval)*r1.interval;
		new_time := ceil(cdr_text[4]::real/r1.interval)*r1.interval;
	end if;
	new_cost := new_rate*new_time/r1.seconds;
	raise notice 'new rate %,new bill time %,new cost %',new_rate,new_time,new_cost;


	if orig_term=1 then
		res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||new_rate::numeric(30,6)||dp||new_cost::numeric(30,6)||dp||'N/A'||dp||'N/A';
	elsif orig_term=2 then
		res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'N/A'||dp||'N/A'||dp||new_rate::numeric(30,6)||dp||new_cost::numeric(30,6);
	end if;

	return res;
end;
$_$;


ALTER FUNCTION public.rerate_cdr(text, integer, integer) OWNER TO postgres;

--
-- Name: route_egress(integer, prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION route_egress(route_strategy integer, digit prefix_range) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
result  record;
r1      record;
r2      record;
BEGIN
	for r1 in
		SELECT dynamic_route_id, static_route_id FROM route where route_strategy_id = route_strategy and digits  <@ digit

	loop
		if r1.static_route_id is not null then

			for r2 in
				SELECT item_id FROM product_items where product_id = r1.static_route_id
			loop
				for result in
					select resource_id from product_items_resource where item_id = r2.item_id
				loop
					return next result;
				end loop;
			end loop;

		end if;

		if r1.dynamic_route_id is not null then

			for result in
				select resource_id from dynamic_route_items where dynamic_route_id = r1.dynamic_route_id
			loop
				return next result;
			end loop;
		end if;

	end loop;
	return;

END;
$$;


ALTER FUNCTION public.route_egress(route_strategy integer, digit prefix_range) OWNER TO postgres;

--
-- Name: second_select(text, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION second_select(text, integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
   declare
       second_rec record;
   begin
       for second_rec in select resource_direction.action,resource_direction.digits
from resource_direction where direction=$3 and dnis@>$1 and resource_id=$2
order by length(dnis::text) DESC limit 1
 loop
           return next second_rec;
       end loop;
	return;
   end;
   $_$;


ALTER FUNCTION public.second_select(text, integer, integer) OWNER TO postgres;

--
-- Name: test(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION test() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
begin
   return 1;
end;
$$;


ALTER FUNCTION public.test() OWNER TO postgres;

--
-- Name: test2(date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION test2(startdate date, enddate date) RETURNS date
    LANGUAGE plpgsql
    AS $$
declare
today date := CURRENT_DATE;
sqltext text :='';
datetext text :='';
maxaa text :='';
begin
create  temporary table temp_tb(report_time timestamp);
 WHILE Startdate < Enddate LOOP

 	datetext:=to_char(Startdate, 'YYYYMMDD');
 	sqltext:='insert into temp_tb(report_time) SELECT max(report_time)
        FROM cdr_report_detail' || datetext;
        execute sqltext;
    Startdate:=Startdate + cast('1 day' as interval);

 END LOOP;
	today := (SELECT max(report_time)  FROM temp_tb);
    RETURN today;
END;
$$;


ALTER FUNCTION public.test2(startdate date, enddate date) OWNER TO postgres;

--
-- Name: test_bin(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION test_bin(OUT c integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

begin
	c = 10* c;

end;
$$;


ALTER FUNCTION public.test_bin(OUT c integer) OWNER TO postgres;

--
-- Name: test_bin(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION test_bin(c integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
	a integer := 10;
	b integer;
begin
	b = a * c;
	return b;
end;
$$;


ALTER FUNCTION public.test_bin(c integer) OWNER TO postgres;

--
-- Name: text(ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION text(ip4) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_to_text';


ALTER FUNCTION public.text(ip4) OWNER TO postgres;

--
-- Name: text(ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION text(ip4r) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cast_to_text';


ALTER FUNCTION public.text(ip4r) OWNER TO postgres;

--
-- Name: text(prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION text(prefix_range) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_cast_to_text';


ALTER FUNCTION public.text(prefix_range) OWNER TO postgres;

--
-- Name: third_select(integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION third_select(integer, text, text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
   declare
       third_rec record;
   begin
       for third_rec in select ani,dnis,action_ani,action_dnis,ani_method,dnis_method from translation_item where translation_id= $1 and ani@>$2 and dnis@>$3 order by length(dnis::text) DESC,length(ani::text) DESC limit 1
 loop
           return next third_rec;
       end loop;
	return;
   end;
   $_$;


ALTER FUNCTION public.third_select(integer, text, text) OWNER TO postgres;

--
-- Name: to_bigint(ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION to_bigint(ip4) RETURNS bigint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_to_bigint';


ALTER FUNCTION public.to_bigint(ip4) OWNER TO postgres;

--
-- Name: to_double(ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION to_double(ip4) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_to_double';


ALTER FUNCTION public.to_double(ip4) OWNER TO postgres;

--
-- Name: transf(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION transf() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare
begin
 PERFORM cs_log('Refreshing materialized view ');
end;
$$;


ALTER FUNCTION public.transf() OWNER TO postgres;

--
-- Name: trunk_pstn_header_trigfun_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION trunk_pstn_header_trigfun_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into trunk_pstn_header_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into trunk_pstn_header_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into trunk_pstn_header_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into trunk_pstn_header_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.trunk_pstn_header_trigfun_record() OWNER TO postgres;

--
-- Name: update_cdr(text, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION update_cdr(text, integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	orig_term alias for $2;--1:ingress,2:egress
	id_rate_table alias for $3;
	cdr_info alias for $1;
	cdr_text text[];
	r record;
	r1 record;
	new_rate numeric;
	new_cost numeric;
	new_time integer;
	new_mins numeric;
	r2 record;
	id_jurisdiction_country numeric;
	ani_jurisdiction integer;
	dnis_jurisdiction integer;
	res text;
	rate_dnis text;
	dp text := ';';
	start_time text;
	end_time text;
	r_zone text;
	l_time timestamp with time zone;
	rate_found boolean := false;
	exe_sql text;
	is_lrn integer;
begin

	SELECT into cdr_text regexp_split_to_array(cdr_info, ';');
	start_time := TIMESTAMP WITH TIME ZONE 'epoch' + cdr_text[9]::bigint/1000000 * INTERVAL '1 second';
	end_time := TIMESTAMP WITH TIME ZONE 'epoch' + cdr_text[10]::bigint/1000000 * INTERVAL '1 second';

	select into is_lrn rate_type from rate_table where rate_table_id=id_rate_table;

	if orig_term=1 then
		if is_lrn=1 then
			rate_dnis := cdr_text[12];
		else
			rate_dnis := cdr_text[13];
		end if;
	elsif orig_term=2 then
		if is_lrn=1 then
			rate_dnis := cdr_text[12];
		else
			rate_dnis := cdr_text[13];
		end if;
	end if;

	for r1 in select t1.* from (SELECT * from rate where rate_table_id=id_rate_table and code @> rate_dnis and effective_date<=cdr_text[14]::timestamp with time zone and (end_date is null or end_date>=cdr_text[14]::timestamp with time zone) order by length(code::text) desc,effective_date desc) as t1,(SELECT * from rate where rate_table_id=id_rate_table and code @> rate_dnis and effective_date<=cdr_text[14]::timestamp with time zone and (end_date is null or end_date>=cdr_text[14]::timestamp with time zone) order by length(code::text) desc,effective_date desc limit 1) as t2 where t1.code=t2.code and t1.effective_date=t2.effective_date
	loop
		raise notice '---check rate id %',r1.rate_id;
		if r1.zone is null or r1.zone='' or r1.zone='0' then
			r_zone='0:00';
		else
			r_zone := r1.zone;
		end if;
		--l_time := r.time+r_zone::time;
		l_time := cdr_text[14]::timestamp with time zone+r_zone::time;
		--if r1.effective_date > r.time then
		if r1.effective_date > cdr_text[14]::timestamp with time zone then
			raise notice 'effective date % invalid',r1.effective_date;
			continue;
		end if;
		if r1.end_date is not null then
			--if r1.end_date < r.time then
			if r1.end_date < cdr_text[14]::timestamp with time zone then
				raise notice 'end date % invalid',r1.end_date;
				continue;
			end if;
		end if;
		if r1.time_profile_id is not null then
			select into r2 * from time_profile where time_profile_id=r1.time_profile_id;
			if r2.type != 0 then
				if r2.type = 1 then
					if l_time::time not between r2.start_time and r2.end_time then
						raise notice 'time_profile % type week invalid',r1.time_profile_id;
						continue;
					end if;
					if EXTRACT(DOW from l_time) not between r2.start_week and r2.end_week then
						raise notice 'time_profile % type week invalid',r1.time_profile_id;
						continue;
					end if;
				elsif r2.type = 2 then
					if l_time::time not between r2.start_time and r2.end_time then
						raise notice 'time_profile % type time invalid',r1.time_profile_id;
						continue;
					end if;
				end if;
			end if;
		end if;
		if r1.rate_id is not null then
			raise notice 'found it id %',r1.rate_id;
			rate_found := true;
			exit;
		end if;
	end loop;

	if rate_found is false then
		raise notice 'rate not found';
		if orig_term=1 then
			res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'orig rate not found'||dp||'N/A'||dp||'N/A'||dp||'N/A';
		elsif orig_term=2 then
			res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'N/A'||dp||'N/A'||dp||'term rate not found'||dp||'N/A';
		end if;
		return '';
	end if;
	select into id_jurisdiction_country jurisdiction_country_id from rate_table where rate_table_id=id_rate_table;
	if id_jurisdiction_country is null then
		new_rate := r1.rate;
	else
		select into ani_jurisdiction jurisdiction_id from jurisdiction_prefix where jurisdiction_country_id=id_jurisdiction_country and prefix @> cdr_text[15]::prefix_range order by length(prefix::text) desc limit 1;
		select into dnis_jurisdiction jurisdiction_id from jurisdiction_prefix where jurisdiction_country_id=id_jurisdiction_country and prefix @> rate_dnis::prefix_range order by length(prefix::text) desc limit 1;
		if ani_jurisdiction is not null and dnis_jurisdiction is not null then
			if ani_jurisdiction=dnis_jurisdiction then
				new_rate := r1.intra_rate;
			else
				new_rate := r1.inter_rate;
			end if;
		else
			new_rate := r1.rate;
		end if;
	end if;
	--if r.call_duration::integer <= r1.grace_time then
	if cdr_text[4]::integer <= r1.grace_time then
		new_time := 0;
	--elsif r.call_duration::integer <= r1.min_time then
	elsif cdr_text[4]::integer <= r1.min_time then
		new_time := r1.min_time;
	else
		--new_time := ceil(r.call_duration::real/r1.interval)*r1.interval;
		new_time := ceil(cdr_text[4]::real/r1.interval)*r1.interval;
	end if;
	new_cost := new_rate*new_time/r1.seconds;
	new_mins := (new_time::real/r1.seconds)::numeric(30,6);
	raise notice 'new rate %,new bill time %,new cost %',new_rate,new_time,new_cost;


	if orig_term=1 then
		res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||new_rate::numeric(30,6)||dp||new_cost::numeric(30,6)||dp||'N/A'||dp||'N/A';
--update client_cdr set ingress_client_rate=new_rate::numeric(30,6),ingress_client_cost=new_cost::numeric(30,6),ingress_client_bill_result='1',ingress_rate_id=r1.rate_id,rerate_time=current_timestamp(0)
--where id=cdr_text[1]::integer and time=cdr_text[14]::timestamp with time zone;
        exe_sql := 'update client_cdr set ingress_client_rate='||new_rate||'::numeric(30,6),ingress_client_cost='||new_cost||'::numeric(30,6),ingress_client_bill_time='||new_time||',ingress_bill_minutes='||new_mins||',ingress_client_bill_result=\'1\',ingress_rate_id='||r1.rate_id||',orig_code='''||r1.code||''',orig_code_name='''||COALESCE(r1.code_name,'')||''',orig_country='''||COALESCE(r1.country,'')||''',ingress_rate_effective_date=EXTRACT(EPOCH from TIMESTAMP '''||r1.effective_date||'''),rerate_time='''||current_timestamp(0)||''' where id='||cdr_text[1]||'::integer and time='''||cdr_text[14]||'''::timestamp with time zone';
	elsif orig_term=2 then
		res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'N/A'||dp||'N/A'||dp||new_rate::numeric(30,6)||dp||new_cost::numeric(30,6);
--update client_cdr set egress_rate=new_rate::numeric(30,6),egress_cost=new_cost::numeric(30,6),egress_bill_result='1',egress_rate_id=r1.rate_id,rerate_time=current_timestamp(0)
--where id=cdr_text[1]::integer and time=cdr_text[14] ::timestamp with time zone;
        exe_sql := 'update client_cdr set egress_rate='||new_rate||'::numeric(30,6),egress_cost='||new_cost||'::numeric(30,6),egress_bill_time='||new_time||',egress_bill_minutes='||new_mins||',egress_bill_result=\'1\',egress_rate_id='||r1.rate_id||',term_code='''||r1.code||''',term_code_name='''||COALESCE(r1.code_name,'')||''',term_country='''||COALESCE(r1.country,'')||''',egress_rate_effective_date=EXTRACT(EPOCH from TIMESTAMP '''||r1.effective_date||'''),rerate_time='''||current_timestamp(0)||''' where id='||cdr_text[1]||'::integer and time='''||cdr_text[14]||'''::timestamp with time zone';
	end if;

	return exe_sql;
end;
$_$;


ALTER FUNCTION public.update_cdr(text, integer, integer) OWNER TO postgres;

--
-- Name: update_db(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION update_db() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
	r record;

begin
        for r in select * from resource_replace_action_record_tmp order by record_id asc limit 100000
        loop
                --raise notice 'record currency,record id %',r.record_id;
                insert into resource_replace_action_record
                select r.id,r.resource_id,r.ani_prefix,r.ani,r.ani_min_length,r.ani_max_length,r.time,r.flag;
                delete from resource_replace_action_record_tmp where record_id=r.record_id;
        end loop;

        for r in select * from code_record_tmp order by record_id asc limit 100000
        loop
                --raise notice 'record currency,record id %',r.record_id;
                insert into code_record
                select r.code_id,r.code,r.code_deck_id,r.city,r.state,r.country,r.name,r.time,r.flag;
                delete from code_record_tmp where record_id=r.record_id;
        end loop;

        for r in select * from egress_profile_record_tmp order by record_id asc limit 100000
        loop
                --raise notice 'record currency,record id %',r.record_id;
                insert into egress_profile_record
                select r.id,r.egress_id,r.profile_id,r.server_name,r.ingress_id,r.time,r.flag;
                delete from egress_profile_record_tmp where record_id=r.record_id;
        end loop;

	for r in select * from transaction_fee_items_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into transaction_fee_items_record
		select r.id,r.trans_type,r.transaction_fee_id,r.trans_id,r.use_fee,r.time,r.flag;
		delete from transaction_fee_items_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from switch_profile_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into switch_profile_record
		select r.id,r.switch_name,r.profile_name,r.sip_ip,r.sip_port,r.sip_debug,r.sip_trace,r.proxy_ip,r.proxy_port,r.voip_gateway_id,r.support_rpid,r.support_oli,r.support_priv,r.support_div,r.support_paid,r.support_pci,r.support_x_lrn,r.support_x_header,r.sip_capture_ip,r.sip_capture_port,r.sip_capture_path,r.lan_ip,r.lan_port,r.profile_status,r.time,r.flag;
		delete from switch_profile_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from currency_updates_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into currency_updates_record
		select r.currency_id,r.modify_time,r.rate,r.last_rate,r.currency_updates_id,r.time,r.flag;
		delete from currency_updates_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from service_charge_items_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into service_charge_items_record
		select r.id,r.min_rate,r.max_rate,r.charge_value,r.service_charge_id,r.time,r.flag;
		delete from service_charge_items_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from payment_term_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into payment_term_record
		select r.payment_term_id,r.name,r.type,r.days,r.grace_days,r.notify_days,r.more_days,r.finance_rate,r.time,r.flag;
		delete from payment_term_record_tmp where record_id=r.record_id;
	end loop;

--         for r in select * from resource_rate_record_tmp order by record_id asc limit 100000
--         loop
--                 ----raise notice 'record time profile,record id %',r.record_id;
--                 insert into resource_rate_record
--                 select r.id,r.code,r.rate,r.service_rate,r.finance_rate,r.resource_id,r.order_type,r.min_time,r.interval,r.code_name,r.country,r.ingress_id,r.egress_id,r.time,r.flag;
--                 delete from resource_rate_record_tmp where record_id=r.record_id;
--         end loop;

-- 	for r in select * from buy_order_record_tmp order by record_id asc limit 100000
-- 	loop
-- 		----raise notice 'record time profile,record id %',r.record_id;
-- 		insert into buy_order_record
-- 		select r.id,r.name,r.client_id,r.resource_id,r.code_deck_id,r.rate,r.is_private,r.is_commit,r.commit_minutes,r.create_time,r.update_time,r.cli,r.g729,r.fax,r.active,r.status,r.expire_time,r.country,r.acd,r.asr,r.user_id,r.dtmf,r.state_date,r.end_date,r.limit_price,r.g723,r.g711,r.time_of_date,r.peak,r.offpeak,r.weekend,r.currency_id,r.asr_var,r.acd_var,r.rate_only,r.match_type,r.route_priority,r.invite_id,r.partner_id,r.resource_prefix,r.route_type,r.auto_match,r.auto_match_result,r.dialer,r.interval,r.limit,r.minimal_duration,r.purged,r.cli_type,r.pdd_timeout,r.pdd_var,r.auto_match_time,r.min_threedays,r.time,r.flag;
-- 		delete from buy_order_record_tmp where record_id=r.record_id;
-- 	end loop;

-- 	for r in select * from sell_order_record_tmp order by record_id asc limit 100000
-- 	loop
-- 		----raise notice 'record time profile,record id %',r.record_id;
-- 		insert into sell_order_record
-- 		select r.id,r.name,r.client_id,r.resource_id,r.code_deck_id,r.rate,r.is_private,r.is_commit,r.commit_minutes,r.create_time,r.update_time,r.cli,r.g729,r.fax,r.active,r.status,r.expire_time,r.country,r.acd,r.asr,r.user_id,r.dtmf,r.state_date,r.end_date,r.limit_price,r.g723,r.g711,r.time_of_date,r.peak,r.offpeak,r.weekend,r.invite_id,r.partner_id,r.resource_prefix,r.route_type,r.asr_var,r.acd_var,r.rate_only,r.match_type,r.route_priority,r.auto_match,r.auto_match_result,r.dialer,r.interval,r.limit,r.is_select,r.purged,r.cli_type,r.minimal_duration,r.pdd_timeout,r.auto_match_time,r.is_first,r.time,r.flag;
-- 		delete from sell_order_record_tmp where record_id=r.record_id;
-- 	end loop;

-- 	for r in select * from contract_record_tmp order by record_id asc limit 100000
-- 	loop
-- 		----raise notice 'record time profile,record id %',r.record_id;
-- 		insert into contract_record
-- 		select r.id,r.contract_type,r.order_id,r.order_response_id,r.create_time,r.update_time,r.status,r.expire_time,r.is_commit,r.commit_minutes,r.client_id,r.is_private,r.resource_id,r.confirm_order_number,r.user_id,r.resource_prefix,r.order_response_rate,r.auto_match,r.finance_rate,r.actioned,r.time,r.flag;
-- 		delete from contract_record_tmp where record_id=r.record_id;
-- 	end loop;

	for r in select * from time_profile_record_tmp order by record_id asc limit 100000
	loop
		----raise notice 'record time profile,record id %',r.record_id;
		insert into time_profile_record
		select r.time_profile_id,r.name,r.start_time,r.end_time,r.start_week,r.end_week,r.type,r.time_zone,r.time,r.flag;
		delete from time_profile_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from client_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record client,record id %',r.record_id;
		insert into client_record
		select r.client_id,r.name,r.mode,r.orig_rate_table_id,r.term_rate_table_id,r.currency_id,r.allowed_credit,r.status,r.auto_invoicing,r.payment_term_id,r.invoice_format,r.attach_cdrs_list,r.cdr_list_format,r.last_invoiced,r.notify_client_balance,r.notify_admin_balance,r.low_balance_notice,r.company,r.address,r.email,r.logo,r.login,r.password,r.is_panelaccess,r.is_client_info,r.is_invoices,r.is_rateslist,r.is_summaryreport,r.is_cdrslist,r.is_mutualsettlements,r.is_changepassword,r.role_id,r.create_time,r.profit_margin,r.enough_balance,r.service_charge_id,r.noc_email,r.billing_email,r.rate_email,r.tax_id,r.details,r.invoice_show_details,r.invoice_past_amount,r.is_link_cdr,r.is_trunk,r.is_route,r.is_spam,r.is_location,r.is_orig_term,r.is_usage,r.is_qos,r.is_discon,r.is_bill_mismatch,r.is_active_call,r.is_termin,r.database_name,r.is_rate_anal,r.is_capture,r.is_call_simulation,r.is_ingress_sim,r.is_egress_sim,r.is_report,r.is_tools,r.is_manage,r.mail_sended,r.scc_bellow,r.scc_percent,r.scc_charge,r.user_id,r.profit_type,r.auto_invoice_type,r.cps_limit,r.call_limit,r.invoice_zone,r.invoice_zero,r.update_at,r.update_by,r.corporate_contact_email,r.paypal,r.is_auto_summary,r.auto_send_zone,r.is_daily_balance_notification,r.daily_balance_notification,r.daily_balance_recipient,r.low_balance_number,r.is_auto_balance,r.numer_of_days_balance,r.auto_daily_balance_recipient,r.daily_cdr_generation,r.daily_cdr_generation_zone,r.daily_cdr_generation_type,r.transaction_fee_id,r.unlimited_credit,r.include_payment_history,r.include_available_credit,r.include_payment_history_days,r.auto_summary_not_zero,r.auto_summary_group_by,r.daily_balance_already_sent,r.last_autoreport_time,r.last_lowbalance_time,r.last_cdrdown_time,r.include_tax,r.tax,r.invoice_jurisdictional_detail,r.decimal_place,r.par_id,r.rate_value,r.email_invoice,r.scc_type,r.is_invoice_account_summary,r.is_show_daily_usage,r.invoice_include_payment,r.is_short_duration_call_surcharge_detail,r.usage_detail_fields,r.auto_summary_hour,r.auto_summary_period,r.last_autobalance_time,r.auto_summary_include_cdr,r.time,r.flag;
		delete from client_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from dynamic_route_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record dynamic route,record id %',r.record_id;
		insert into dynamic_route_record
		select r.dynamic_route_id,r.name,r.routing_rule,r.time_profile_id,r.update_at,r.update_by,r.lcr_flag,r.time,r.flag;
		delete from dynamic_route_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from dynamic_route_items_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record dynamic route items,record id %',r.record_id;
		insert into dynamic_route_items_record
		select r.id,r.dynamic_route_id,r.resource_id,r.time,r.flag;
		delete from dynamic_route_items_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from rate_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record rate,record id %',r.record_id;
		insert into rate_record
		select r.rate_id,r.rate_table_id,r.code,r.rate,r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.basic_percentages,r.gift_percentages,r.rate_type,r.intra_rate,r.inter_rate,r.local_rate,r.country,r.zone,r.ocn,r.lata,r.time,r.flag;
		delete from rate_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from route_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record route,record id %',r.record_id;
		insert into route_record
		select r.route_id,r.digits,r.dynamic_route_id,r.static_route_id,r.route_type,r.route_strategy_id,r.lnp,r.lrn_block,r.dnis_only,r.code_deck_type,r.update_at,r.update_by,r.intra_static_route_id,r.inter_static_route_id,r.jurisdiction_country_id,r.ani_prefix,r.ani_min_length,r.ani_max_length,r.time,r.flag;
		delete from route_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource,record id %',r.record_id;
		insert into resource_record
		select r.resource_id,r.name,r.ingress,r.egress,r.active,r.rfc_2833,r.t38,r.alias,r.res_strategy,r.cps_limit,r.capacity,r.lnp,r.lrn_block,r.client_id,r.tdm,r.rate_table_id,r.transnexus,r.route_strategy_id,r.media_type,r.pass_through,r.profit_margin,r.enough_balance,r.egress_bill_after_action,r.proto,r.dnis_only,r.ring_timeout,r.ignore_ring,r.ignore_early_media,r.disable_by_alert,r.last_priority,r.priority,r.create_time,r.update_time,r.status,r.wait_ringtime180,r.profit_type,r.lnp_dipping,r.lnp_dipping_rate,r.update_at,r.update_by,r.cli_type,r.auth_type,r.delay_bye_second,r.delay_bye_limit,r.max_duration,r.marketplace,r.rating_type,r.billing_type,r.trunk_type,r.switch_profile_id,r.transaction_fee_id,r.service_type,r.product_id,r.rpid,r.paid,r.oli,r.pci,r.priv,r.div,r.trunk_type2,r.account_id,r.billing_method,r.amount_per_port,r.billing_rule,r.ignore_early_nosdp,r.media_timeout,r.private,r.agent_type,r.bill_by,r.time,r.flag;
		delete from resource_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_ip_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource ip,record id %',r.record_id;
		insert into resource_ip_record
		select r.resource_id,r.resource_ip_id,r.ip,r.port,r.fqdn,r.username,r.password,r.sip_rpid,r.registered,r.need_register,r.disable_by_alert,r.last_priority,r.priority,r.addr_type,r.time,r.flag;
		delete from resource_ip_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_direction_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource direction,record id %',r.record_id;
		insert into resource_direction_record
		select r.direction,r.action,r.digits,r.direction_id,r.dnis,r.resource_id,r.time_profile_id,r.type,r.number_length,r.number_type,r.time,r.flag;
		delete from resource_direction_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_codecs_ref_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource codec,record id %',r.record_id;
		insert into resource_codecs_ref_record
		select r.id,r.resource_id,r.codec_id,r.time,r.flag;
		delete from resource_codecs_ref_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_block_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource block,record id %',r.record_id;
		insert into resource_block_record
		select r.ingress_res_id,r.engress_res_id,r.digit,r.res_block_id,r.time_profile_id,r.ingress_client_id,r.egress_client_id,r.disable_by_alert,r.ani_prefix,r.ani_length,r.dnis_length,r.ani_method,r.dnis_method,r.ani_empty,r.action_type,r.time,r.flag;
		delete from resource_block_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from product_items_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record product item,record id %',r.record_id;
		insert into product_items_record
		select r.item_id,r.product_id,r.alias,r.digits,r.strategy,r.time_profile_id,r.min_len,r.max_len,r.min_asr,r.max_asr,r.min_abr,r.max_abr,r.min_acd,r.max_acd,r.min_pdd,r.max_pdd,r.min_aloc,r.max_aloc,r.limit_price,r.update_at,r.update_by,r.code_name,r.time,r.flag;
		delete from product_items_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from product_items_resource_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record product item resource,record id %',r.record_id;
		insert into product_items_resource_record
		select r.id,r.item_id,r.resource_id,r.by_percentage,r.order_id,r.order_type,r.time,r.flag;
		delete from product_items_resource_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from translation_item_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record translation item,record id %',r.record_id;
		insert into translation_item_record
		select r.ref_id,r.translation_id,r.ani,r.dnis,r.action_ani,r.action_dnis,r.ani_method,r.dnis_method,r.time,r.flag;
		delete from translation_item_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from product_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record product,record id %',r.record_id;
		insert into product_record
		select r.product_id,r.name,r.modify_time,r.introduction,r.dynamic_route_id,r.update_by,r.code_type,r.code_deck_id,r.route_lrn,r.time,r.flag;
		delete from product_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from currency_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into currency_record
		select r.currency_id,r.code,r.active,r.update_by,r.time,r.flag;
		delete from currency_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from rate_table_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record rate table,record id %',r.record_id;
		insert into rate_table_record
		select r.rate_table_id,r.name,r.modify_time,r.create_time,r.code_deck_id,r.currency_id,r.rate_type,r.jurisdiction_country_id,r.update_at,r.update_by,r.lnp_dipping_rate,r.jurisdiction_prefix,r.noprefix_min_length,r.noprefix_max_length,r.prefix_min_length,r.prefix_max_length,r.jur_type,r.is_uploading,r.time,r.flag;
		delete from rate_table_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_ip_limit_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource ip limit,record id %',r.record_id;
		insert into resource_ip_limit_record
		select r.limit_id,r.ip_id,r.cps,r.capacity,r.time_profile_id,r.time,r.flag;
		delete from resource_ip_limit_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_translation_ref_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource translation,record id %',r.record_id;
		insert into resource_translation_ref_record
		select r.ref_id,r.resource_id,r.translation_id,r.time_profile_id,r.time,r.flag;
		delete from resource_translation_ref_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from jurisdiction_prefix_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record jurisdiction prefix,record id %',r.record_id;
		insert into jurisdiction_prefix_record
		select r.id,r.alias,r.prefix,r.jurisdiction_id,r.jurisdiction_country_id,r.jurisdiction_name,r.jurisdiction_country_name,r.ocn,r.lata,r.time,r.flag;
		delete from jurisdiction_prefix_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from sip_error_code_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record sip error code,record id %',r.record_id;
		insert into sip_error_code_record
		select r.sip_error_code_id,r.return_code,r.return_code_str,r.switch_error_code,r.switch_error_code_str,r.resource_id,r.time,r.flag;
		delete from sip_error_code_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_next_route_rule_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource next route,record id %',r.record_id;
		insert into resource_next_route_rule_record
		select r.id,r.route_type,r.reponse_code,r.resource_id,r.return_code,r.return_string,r.time,r.flag;
		delete from resource_next_route_rule_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_prefix_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource prefix,record id %',r.record_id;
		insert into resource_prefix_record
		select r.id,r.resource_id,r.tech_prefix,r.route_strategy_id,r.rate_table_id,r.time,r.flag;
		delete from resource_prefix_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_lrn_action_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record lrn action,record id %',r.record_id;
		insert into resource_lrn_action_record
		select r.id,r.direction,r.action,r.digits,r.dnis,r.resource_id,r.time,r.flag;
		delete from resource_lrn_action_record_tmp where record_id=r.record_id;
	end loop;


	for r in select * from dynamic_route_override_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource,record id %',r.record_id;
		insert into dynamic_route_override_record
		select r.id,r.dynamic_route_id,r.digits,r.resource_id,r.percentage,r.time,r.flag;
		delete from dynamic_route_override_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from dynamic_route_pri_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource,record id %',r.record_id;
		insert into dynamic_route_pri_record
		select r.id,r.dynamic_route_id,r.digits,r.resource_id,r.resource_pri,r.time,r.flag;
		delete from dynamic_route_pri_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from dynamic_route_qos_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource,record id %',r.record_id;
		insert into dynamic_route_qos_record
		select r.id,r.dynamic_route_id,r.digits,r.min_asr,r.max_asr,r.min_abr,r.max_abr,r.min_acd,r.max_acd,r.min_pdd,r.max_pdd,r.min_aloc,r.max_aloc,r.limit_price,r.time,r.flag;
		delete from dynamic_route_qos_record_tmp where record_id=r.record_id;
	end loop;


	return null;

end;
$$;


ALTER FUNCTION public.update_db() OWNER TO postgres;

--
-- Name: upper(ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION upper(ip4r) RETURNS ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_upper';


ALTER FUNCTION public.upper(ip4r) OWNER TO postgres;

--
-- Name: array_accum(anyelement); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE array_accum(anyelement) (
    SFUNC = array_append,
    STYPE = anyarray,
    INITCOND = '{}'
);


ALTER AGGREGATE public.array_accum(anyelement) OWNER TO postgres;

--
-- Name: textcat_all(text); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE textcat_all(text) (
    SFUNC = textcat,
    STYPE = text,
    INITCOND = ''
);


ALTER AGGREGATE public.textcat_all(text) OWNER TO postgres;

--
-- Name: #; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR # (
    PROCEDURE = ip4_xor,
    LEFTARG = ip4,
    RIGHTARG = ip4
);


ALTER OPERATOR public.# (ip4, ip4) OWNER TO postgres;

--
-- Name: &; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR & (
    PROCEDURE = ip4_and,
    LEFTARG = ip4,
    RIGHTARG = ip4
);


ALTER OPERATOR public.& (ip4, ip4) OWNER TO postgres;

--
-- Name: &; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR & (
    PROCEDURE = prefix_range_inter,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range
);


ALTER OPERATOR public.& (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR & (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR & (prefix_range, prefix_range) IS 'intersection';


--
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR && (
    PROCEDURE = ip4r_overlaps,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = &&,
    RESTRICT = areasel,
    JOIN = areajoinsel
);


ALTER OPERATOR public.&& (ip4r, ip4r) OWNER TO postgres;

--
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR && (
    PROCEDURE = prefix_range_overlaps,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range,
    COMMUTATOR = &&,
    RESTRICT = areasel,
    JOIN = areajoinsel
);


ALTER OPERATOR public.&& (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR && (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR && (prefix_range, prefix_range) IS 'overlaps?';


--
-- Name: +; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR + (
    PROCEDURE = ip4_plus_int,
    LEFTARG = ip4,
    RIGHTARG = integer
);


ALTER OPERATOR public.+ (ip4, integer) OWNER TO postgres;

--
-- Name: +; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR + (
    PROCEDURE = ip4_plus_bigint,
    LEFTARG = ip4,
    RIGHTARG = bigint
);


ALTER OPERATOR public.+ (ip4, bigint) OWNER TO postgres;

--
-- Name: -; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR - (
    PROCEDURE = ip4_minus_int,
    LEFTARG = ip4,
    RIGHTARG = integer
);


ALTER OPERATOR public.- (ip4, integer) OWNER TO postgres;

--
-- Name: -; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR - (
    PROCEDURE = ip4_minus_bigint,
    LEFTARG = ip4,
    RIGHTARG = bigint
);


ALTER OPERATOR public.- (ip4, bigint) OWNER TO postgres;

--
-- Name: -; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR - (
    PROCEDURE = ip4_minus_ip4,
    LEFTARG = ip4,
    RIGHTARG = ip4
);


ALTER OPERATOR public.- (ip4, ip4) OWNER TO postgres;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR < (
    PROCEDURE = ip4_lt,
    LEFTARG = ip4,
    RIGHTARG = ip4,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ip4, ip4) OWNER TO postgres;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR < (
    PROCEDURE = ip4r_lt,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = >,
    NEGATOR = >=,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (ip4r, ip4r) OWNER TO postgres;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR < (
    PROCEDURE = prefix_range_lt,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range
);


ALTER OPERATOR public.< (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR < (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR < (prefix_range, prefix_range) IS 'less-than';


--
-- Name: <<; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR << (
    PROCEDURE = ip4r_contained_by_strict,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = >>,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.<< (ip4r, ip4r) OWNER TO postgres;

--
-- Name: <<<; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <<< (
    PROCEDURE = ip4r_left_of,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = >>>,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.<<< (ip4r, ip4r) OWNER TO postgres;

--
-- Name: <<=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <<= (
    PROCEDURE = ip4r_contained_by,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = >>=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.<<= (ip4r, ip4r) OWNER TO postgres;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <= (
    PROCEDURE = ip4_le,
    LEFTARG = ip4,
    RIGHTARG = ip4,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ip4, ip4) OWNER TO postgres;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <= (
    PROCEDURE = ip4r_le,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = >=,
    NEGATOR = >,
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (ip4r, ip4r) OWNER TO postgres;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <= (
    PROCEDURE = prefix_range_le,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range
);


ALTER OPERATOR public.<= (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR <= (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR <= (prefix_range, prefix_range) IS 'less-than-or-equal';


--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <> (
    PROCEDURE = ip4_neq,
    LEFTARG = ip4,
    RIGHTARG = ip4,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ip4, ip4) OWNER TO postgres;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <> (
    PROCEDURE = ip4r_neq,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (ip4r, ip4r) OWNER TO postgres;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <> (
    PROCEDURE = prefix_range_neq,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range,
    COMMUTATOR = <>,
    NEGATOR = =,
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR <> (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR <> (prefix_range, prefix_range) IS 'not equals?';


--
-- Name: <@; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR <@ (
    PROCEDURE = prefix_range_contained_by,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range,
    COMMUTATOR = @>
);


ALTER OPERATOR public.<@ (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR <@ (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR <@ (prefix_range, prefix_range) IS 'contained by?';


--
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR = (
    PROCEDURE = ip4_eq,
    LEFTARG = ip4,
    RIGHTARG = ip4,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ip4, ip4) OWNER TO postgres;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR = (
    PROCEDURE = ip4r_eq,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = =,
    NEGATOR = <>,
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (ip4r, ip4r) OWNER TO postgres;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR = (
    PROCEDURE = prefix_range_eq,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range,
    COMMUTATOR = =,
    NEGATOR = <>,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR = (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR = (prefix_range, prefix_range) IS 'equals?';


--
-- Name: >; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR > (
    PROCEDURE = ip4_gt,
    LEFTARG = ip4,
    RIGHTARG = ip4,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ip4, ip4) OWNER TO postgres;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR > (
    PROCEDURE = ip4r_gt,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = <,
    NEGATOR = <=,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (ip4r, ip4r) OWNER TO postgres;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR > (
    PROCEDURE = prefix_range_gt,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range
);


ALTER OPERATOR public.> (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR > (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR > (prefix_range, prefix_range) IS 'greater-than';


--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >= (
    PROCEDURE = ip4_ge,
    LEFTARG = ip4,
    RIGHTARG = ip4,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ip4, ip4) OWNER TO postgres;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >= (
    PROCEDURE = ip4r_ge,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = <=,
    NEGATOR = <,
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (ip4r, ip4r) OWNER TO postgres;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >= (
    PROCEDURE = prefix_range_ge,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range
);


ALTER OPERATOR public.>= (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR >= (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR >= (prefix_range, prefix_range) IS 'greater-than-or-equal';


--
-- Name: >>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >> (
    PROCEDURE = ip4r_contains_strict,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = <<,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.>> (ip4r, ip4r) OWNER TO postgres;

--
-- Name: >>=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >>= (
    PROCEDURE = ip4r_contains,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = <<=,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.>>= (ip4r, ip4r) OWNER TO postgres;

--
-- Name: >>>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR >>> (
    PROCEDURE = ip4r_right_of,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = <<<,
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.>>> (ip4r, ip4r) OWNER TO postgres;

--
-- Name: @; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR @ (
    PROCEDURE = ip4r_contains,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = ~,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@ (ip4r, ip4r) OWNER TO postgres;

--
-- Name: @>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR @> (
    PROCEDURE = prefix_range_contains,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range,
    COMMUTATOR = <@,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@> (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR @> (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR @> (prefix_range, prefix_range) IS 'contains?';


--
-- Name: |; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR | (
    PROCEDURE = ip4_or,
    LEFTARG = ip4,
    RIGHTARG = ip4
);


ALTER OPERATOR public.| (ip4, ip4) OWNER TO postgres;

--
-- Name: |; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR | (
    PROCEDURE = prefix_range_union,
    LEFTARG = prefix_range,
    RIGHTARG = prefix_range
);


ALTER OPERATOR public.| (prefix_range, prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR | (prefix_range, prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR | (prefix_range, prefix_range) IS 'union';


--
-- Name: ~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~ (
    PROCEDURE = ip4_not,
    RIGHTARG = ip4
);


ALTER OPERATOR public.~ (NONE, ip4) OWNER TO postgres;

--
-- Name: ~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR ~ (
    PROCEDURE = ip4r_contained_by,
    LEFTARG = ip4r,
    RIGHTARG = ip4r,
    COMMUTATOR = @,
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~ (ip4r, ip4r) OWNER TO postgres;

--
-- Name: btree_ip4_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY btree_ip4_ops USING btree;


ALTER OPERATOR FAMILY public.btree_ip4_ops USING btree OWNER TO postgres;

--
-- Name: btree_ip4_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS btree_ip4_ops
    DEFAULT FOR TYPE ip4 USING btree FAMILY btree_ip4_ops AS
    OPERATOR 1 <(ip4,ip4) ,
    OPERATOR 2 <=(ip4,ip4) ,
    OPERATOR 3 =(ip4,ip4) ,
    OPERATOR 4 >=(ip4,ip4) ,
    OPERATOR 5 >(ip4,ip4) ,
    FUNCTION 1 (ip4, ip4) ip4_cmp(ip4,ip4);


ALTER OPERATOR CLASS public.btree_ip4_ops USING btree OWNER TO postgres;

--
-- Name: btree_ip4r_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY btree_ip4r_ops USING btree;


ALTER OPERATOR FAMILY public.btree_ip4r_ops USING btree OWNER TO postgres;

--
-- Name: btree_ip4r_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS btree_ip4r_ops
    DEFAULT FOR TYPE ip4r USING btree FAMILY btree_ip4r_ops AS
    OPERATOR 1 <(ip4r,ip4r) ,
    OPERATOR 2 <=(ip4r,ip4r) ,
    OPERATOR 3 =(ip4r,ip4r) ,
    OPERATOR 4 >=(ip4r,ip4r) ,
    OPERATOR 5 >(ip4r,ip4r) ,
    FUNCTION 1 (ip4r, ip4r) ip4r_cmp(ip4r,ip4r);


ALTER OPERATOR CLASS public.btree_ip4r_ops USING btree OWNER TO postgres;

--
-- Name: btree_prefix_range_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY btree_prefix_range_ops USING btree;


ALTER OPERATOR FAMILY public.btree_prefix_range_ops USING btree OWNER TO postgres;

--
-- Name: btree_prefix_range_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS btree_prefix_range_ops
    DEFAULT FOR TYPE prefix_range USING btree FAMILY btree_prefix_range_ops AS
    OPERATOR 1 <(prefix_range,prefix_range) ,
    OPERATOR 2 <=(prefix_range,prefix_range) ,
    OPERATOR 3 =(prefix_range,prefix_range) ,
    OPERATOR 4 >=(prefix_range,prefix_range) ,
    OPERATOR 5 >(prefix_range,prefix_range) ,
    FUNCTION 1 (prefix_range, prefix_range) prefix_range_cmp(prefix_range,prefix_range);


ALTER OPERATOR CLASS public.btree_prefix_range_ops USING btree OWNER TO postgres;

--
-- Name: gist_bit_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_bit_ops USING gist;


ALTER OPERATOR FAMILY public.gist_bit_ops USING gist OWNER TO postgres;

--
-- Name: gist_bit_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_bit_ops
    DEFAULT FOR TYPE bit USING gist FAMILY gist_bit_ops AS
    STORAGE gbtreekey_var ,
    OPERATOR 1 <(bit,bit) ,
    OPERATOR 2 <=(bit,bit) ,
    OPERATOR 3 =(bit,bit) ,
    OPERATOR 4 >=(bit,bit) ,
    OPERATOR 5 >(bit,bit) ,
    FUNCTION 1 (bit, bit) gbt_bit_consistent(internal,bit,smallint) ,
    FUNCTION 2 (bit, bit) gbt_bit_union(bytea,internal) ,
    FUNCTION 3 (bit, bit) gbt_bit_compress(internal) ,
    FUNCTION 4 (bit, bit) gbt_var_decompress(internal) ,
    FUNCTION 5 (bit, bit) gbt_bit_penalty(internal,internal,internal) ,
    FUNCTION 6 (bit, bit) gbt_bit_picksplit(internal,internal) ,
    FUNCTION 7 (bit, bit) gbt_bit_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_bit_ops USING gist OWNER TO postgres;

--
-- Name: gist_bpchar_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_bpchar_ops USING gist;


ALTER OPERATOR FAMILY public.gist_bpchar_ops USING gist OWNER TO postgres;

--
-- Name: gist_bpchar_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_bpchar_ops
    DEFAULT FOR TYPE character USING gist FAMILY gist_bpchar_ops AS
    STORAGE gbtreekey_var ,
    OPERATOR 1 <(character,character) ,
    OPERATOR 2 <=(character,character) ,
    OPERATOR 3 =(character,character) ,
    OPERATOR 4 >=(character,character) ,
    OPERATOR 5 >(character,character) ,
    FUNCTION 1 (character, character) gbt_bpchar_consistent(internal,character,smallint) ,
    FUNCTION 2 (character, character) gbt_text_union(bytea,internal) ,
    FUNCTION 3 (character, character) gbt_bpchar_compress(internal) ,
    FUNCTION 4 (character, character) gbt_var_decompress(internal) ,
    FUNCTION 5 (character, character) gbt_text_penalty(internal,internal,internal) ,
    FUNCTION 6 (character, character) gbt_text_picksplit(internal,internal) ,
    FUNCTION 7 (character, character) gbt_text_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_bpchar_ops USING gist OWNER TO postgres;

--
-- Name: gist_bytea_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_bytea_ops USING gist;


ALTER OPERATOR FAMILY public.gist_bytea_ops USING gist OWNER TO postgres;

--
-- Name: gist_bytea_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_bytea_ops
    DEFAULT FOR TYPE bytea USING gist FAMILY gist_bytea_ops AS
    STORAGE gbtreekey_var ,
    OPERATOR 1 <(bytea,bytea) ,
    OPERATOR 2 <=(bytea,bytea) ,
    OPERATOR 3 =(bytea,bytea) ,
    OPERATOR 4 >=(bytea,bytea) ,
    OPERATOR 5 >(bytea,bytea) ,
    FUNCTION 1 (bytea, bytea) gbt_bytea_consistent(internal,bytea,smallint) ,
    FUNCTION 2 (bytea, bytea) gbt_bytea_union(bytea,internal) ,
    FUNCTION 3 (bytea, bytea) gbt_bytea_compress(internal) ,
    FUNCTION 4 (bytea, bytea) gbt_var_decompress(internal) ,
    FUNCTION 5 (bytea, bytea) gbt_bytea_penalty(internal,internal,internal) ,
    FUNCTION 6 (bytea, bytea) gbt_bytea_picksplit(internal,internal) ,
    FUNCTION 7 (bytea, bytea) gbt_bytea_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_bytea_ops USING gist OWNER TO postgres;

--
-- Name: gist_cash_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_cash_ops USING gist;


ALTER OPERATOR FAMILY public.gist_cash_ops USING gist OWNER TO postgres;

--
-- Name: gist_cash_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_cash_ops
    DEFAULT FOR TYPE money USING gist FAMILY gist_cash_ops AS
    STORAGE gbtreekey16 ,
    OPERATOR 1 <(money,money) ,
    OPERATOR 2 <=(money,money) ,
    OPERATOR 3 =(money,money) ,
    OPERATOR 4 >=(money,money) ,
    OPERATOR 5 >(money,money) ,
    FUNCTION 1 (money, money) gbt_cash_consistent(internal,money,smallint) ,
    FUNCTION 2 (money, money) gbt_cash_union(bytea,internal) ,
    FUNCTION 3 (money, money) gbt_cash_compress(internal) ,
    FUNCTION 4 (money, money) gbt_decompress(internal) ,
    FUNCTION 5 (money, money) gbt_cash_penalty(internal,internal,internal) ,
    FUNCTION 6 (money, money) gbt_cash_picksplit(internal,internal) ,
    FUNCTION 7 (money, money) gbt_cash_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_cash_ops USING gist OWNER TO postgres;

--
-- Name: gist_cidr_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_cidr_ops USING gist;


ALTER OPERATOR FAMILY public.gist_cidr_ops USING gist OWNER TO postgres;

--
-- Name: gist_cidr_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_cidr_ops
    DEFAULT FOR TYPE cidr USING gist FAMILY gist_cidr_ops AS
    STORAGE gbtreekey16 ,
    OPERATOR 1 <(inet,inet) ,
    OPERATOR 2 <=(inet,inet) ,
    OPERATOR 3 =(inet,inet) ,
    OPERATOR 4 >=(inet,inet) ,
    OPERATOR 5 >(inet,inet) ,
    FUNCTION 1 (cidr, cidr) gbt_inet_consistent(internal,inet,smallint) ,
    FUNCTION 2 (cidr, cidr) gbt_inet_union(bytea,internal) ,
    FUNCTION 3 (cidr, cidr) gbt_inet_compress(internal) ,
    FUNCTION 4 (cidr, cidr) gbt_decompress(internal) ,
    FUNCTION 5 (cidr, cidr) gbt_inet_penalty(internal,internal,internal) ,
    FUNCTION 6 (cidr, cidr) gbt_inet_picksplit(internal,internal) ,
    FUNCTION 7 (cidr, cidr) gbt_inet_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_cidr_ops USING gist OWNER TO postgres;

--
-- Name: gist_date_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_date_ops USING gist;


ALTER OPERATOR FAMILY public.gist_date_ops USING gist OWNER TO postgres;

--
-- Name: gist_date_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_date_ops
    DEFAULT FOR TYPE date USING gist FAMILY gist_date_ops AS
    STORAGE gbtreekey8 ,
    OPERATOR 1 <(date,date) ,
    OPERATOR 2 <=(date,date) ,
    OPERATOR 3 =(date,date) ,
    OPERATOR 4 >=(date,date) ,
    OPERATOR 5 >(date,date) ,
    FUNCTION 1 (date, date) gbt_date_consistent(internal,date,smallint) ,
    FUNCTION 2 (date, date) gbt_date_union(bytea,internal) ,
    FUNCTION 3 (date, date) gbt_date_compress(internal) ,
    FUNCTION 4 (date, date) gbt_decompress(internal) ,
    FUNCTION 5 (date, date) gbt_date_penalty(internal,internal,internal) ,
    FUNCTION 6 (date, date) gbt_date_picksplit(internal,internal) ,
    FUNCTION 7 (date, date) gbt_date_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_date_ops USING gist OWNER TO postgres;

--
-- Name: gist_float4_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_float4_ops USING gist;


ALTER OPERATOR FAMILY public.gist_float4_ops USING gist OWNER TO postgres;

--
-- Name: gist_float4_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_float4_ops
    DEFAULT FOR TYPE real USING gist FAMILY gist_float4_ops AS
    STORAGE gbtreekey8 ,
    OPERATOR 1 <(real,real) ,
    OPERATOR 2 <=(real,real) ,
    OPERATOR 3 =(real,real) ,
    OPERATOR 4 >=(real,real) ,
    OPERATOR 5 >(real,real) ,
    FUNCTION 1 (real, real) gbt_float4_consistent(internal,real,smallint) ,
    FUNCTION 2 (real, real) gbt_float4_union(bytea,internal) ,
    FUNCTION 3 (real, real) gbt_float4_compress(internal) ,
    FUNCTION 4 (real, real) gbt_decompress(internal) ,
    FUNCTION 5 (real, real) gbt_float4_penalty(internal,internal,internal) ,
    FUNCTION 6 (real, real) gbt_float4_picksplit(internal,internal) ,
    FUNCTION 7 (real, real) gbt_float4_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_float4_ops USING gist OWNER TO postgres;

--
-- Name: gist_float8_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_float8_ops USING gist;


ALTER OPERATOR FAMILY public.gist_float8_ops USING gist OWNER TO postgres;

--
-- Name: gist_float8_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_float8_ops
    DEFAULT FOR TYPE double precision USING gist FAMILY gist_float8_ops AS
    STORAGE gbtreekey16 ,
    OPERATOR 1 <(double precision,double precision) ,
    OPERATOR 2 <=(double precision,double precision) ,
    OPERATOR 3 =(double precision,double precision) ,
    OPERATOR 4 >=(double precision,double precision) ,
    OPERATOR 5 >(double precision,double precision) ,
    FUNCTION 1 (double precision, double precision) gbt_float8_consistent(internal,double precision,smallint) ,
    FUNCTION 2 (double precision, double precision) gbt_float8_union(bytea,internal) ,
    FUNCTION 3 (double precision, double precision) gbt_float8_compress(internal) ,
    FUNCTION 4 (double precision, double precision) gbt_decompress(internal) ,
    FUNCTION 5 (double precision, double precision) gbt_float8_penalty(internal,internal,internal) ,
    FUNCTION 6 (double precision, double precision) gbt_float8_picksplit(internal,internal) ,
    FUNCTION 7 (double precision, double precision) gbt_float8_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_float8_ops USING gist OWNER TO postgres;

--
-- Name: gist_inet_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_inet_ops USING gist;


ALTER OPERATOR FAMILY public.gist_inet_ops USING gist OWNER TO postgres;

--
-- Name: gist_inet_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_inet_ops
    DEFAULT FOR TYPE inet USING gist FAMILY gist_inet_ops AS
    STORAGE gbtreekey16 ,
    OPERATOR 1 <(inet,inet) ,
    OPERATOR 2 <=(inet,inet) ,
    OPERATOR 3 =(inet,inet) ,
    OPERATOR 4 >=(inet,inet) ,
    OPERATOR 5 >(inet,inet) ,
    FUNCTION 1 (inet, inet) gbt_inet_consistent(internal,inet,smallint) ,
    FUNCTION 2 (inet, inet) gbt_inet_union(bytea,internal) ,
    FUNCTION 3 (inet, inet) gbt_inet_compress(internal) ,
    FUNCTION 4 (inet, inet) gbt_decompress(internal) ,
    FUNCTION 5 (inet, inet) gbt_inet_penalty(internal,internal,internal) ,
    FUNCTION 6 (inet, inet) gbt_inet_picksplit(internal,internal) ,
    FUNCTION 7 (inet, inet) gbt_inet_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_inet_ops USING gist OWNER TO postgres;

--
-- Name: gist_int2_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_int2_ops USING gist;


ALTER OPERATOR FAMILY public.gist_int2_ops USING gist OWNER TO postgres;

--
-- Name: gist_int2_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_int2_ops
    DEFAULT FOR TYPE smallint USING gist FAMILY gist_int2_ops AS
    STORAGE gbtreekey4 ,
    OPERATOR 1 <(smallint,smallint) ,
    OPERATOR 2 <=(smallint,smallint) ,
    OPERATOR 3 =(smallint,smallint) ,
    OPERATOR 4 >=(smallint,smallint) ,
    OPERATOR 5 >(smallint,smallint) ,
    FUNCTION 1 (smallint, smallint) gbt_int2_consistent(internal,smallint,smallint) ,
    FUNCTION 2 (smallint, smallint) gbt_int2_union(bytea,internal) ,
    FUNCTION 3 (smallint, smallint) gbt_int2_compress(internal) ,
    FUNCTION 4 (smallint, smallint) gbt_decompress(internal) ,
    FUNCTION 5 (smallint, smallint) gbt_int2_penalty(internal,internal,internal) ,
    FUNCTION 6 (smallint, smallint) gbt_int2_picksplit(internal,internal) ,
    FUNCTION 7 (smallint, smallint) gbt_int2_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_int2_ops USING gist OWNER TO postgres;

--
-- Name: gist_int4_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_int4_ops USING gist;


ALTER OPERATOR FAMILY public.gist_int4_ops USING gist OWNER TO postgres;

--
-- Name: gist_int4_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_int4_ops
    DEFAULT FOR TYPE integer USING gist FAMILY gist_int4_ops AS
    STORAGE gbtreekey8 ,
    OPERATOR 1 <(integer,integer) ,
    OPERATOR 2 <=(integer,integer) ,
    OPERATOR 3 =(integer,integer) ,
    OPERATOR 4 >=(integer,integer) ,
    OPERATOR 5 >(integer,integer) ,
    FUNCTION 1 (integer, integer) gbt_int4_consistent(internal,integer,smallint) ,
    FUNCTION 2 (integer, integer) gbt_int4_union(bytea,internal) ,
    FUNCTION 3 (integer, integer) gbt_int4_compress(internal) ,
    FUNCTION 4 (integer, integer) gbt_decompress(internal) ,
    FUNCTION 5 (integer, integer) gbt_int4_penalty(internal,internal,internal) ,
    FUNCTION 6 (integer, integer) gbt_int4_picksplit(internal,internal) ,
    FUNCTION 7 (integer, integer) gbt_int4_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_int4_ops USING gist OWNER TO postgres;

--
-- Name: gist_int8_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_int8_ops USING gist;


ALTER OPERATOR FAMILY public.gist_int8_ops USING gist OWNER TO postgres;

--
-- Name: gist_int8_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_int8_ops
    DEFAULT FOR TYPE bigint USING gist FAMILY gist_int8_ops AS
    STORAGE gbtreekey16 ,
    OPERATOR 1 <(bigint,bigint) ,
    OPERATOR 2 <=(bigint,bigint) ,
    OPERATOR 3 =(bigint,bigint) ,
    OPERATOR 4 >=(bigint,bigint) ,
    OPERATOR 5 >(bigint,bigint) ,
    FUNCTION 1 (bigint, bigint) gbt_int8_consistent(internal,bigint,smallint) ,
    FUNCTION 2 (bigint, bigint) gbt_int8_union(bytea,internal) ,
    FUNCTION 3 (bigint, bigint) gbt_int8_compress(internal) ,
    FUNCTION 4 (bigint, bigint) gbt_decompress(internal) ,
    FUNCTION 5 (bigint, bigint) gbt_int8_penalty(internal,internal,internal) ,
    FUNCTION 6 (bigint, bigint) gbt_int8_picksplit(internal,internal) ,
    FUNCTION 7 (bigint, bigint) gbt_int8_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_int8_ops USING gist OWNER TO postgres;

--
-- Name: gist_interval_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_interval_ops USING gist;


ALTER OPERATOR FAMILY public.gist_interval_ops USING gist OWNER TO postgres;

--
-- Name: gist_interval_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_interval_ops
    DEFAULT FOR TYPE interval USING gist FAMILY gist_interval_ops AS
    STORAGE gbtreekey32 ,
    OPERATOR 1 <(interval,interval) ,
    OPERATOR 2 <=(interval,interval) ,
    OPERATOR 3 =(interval,interval) ,
    OPERATOR 4 >=(interval,interval) ,
    OPERATOR 5 >(interval,interval) ,
    FUNCTION 1 (interval, interval) gbt_intv_consistent(internal,interval,smallint) ,
    FUNCTION 2 (interval, interval) gbt_intv_union(bytea,internal) ,
    FUNCTION 3 (interval, interval) gbt_intv_compress(internal) ,
    FUNCTION 4 (interval, interval) gbt_intv_decompress(internal) ,
    FUNCTION 5 (interval, interval) gbt_intv_penalty(internal,internal,internal) ,
    FUNCTION 6 (interval, interval) gbt_intv_picksplit(internal,internal) ,
    FUNCTION 7 (interval, interval) gbt_intv_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_interval_ops USING gist OWNER TO postgres;

--
-- Name: gist_ip4r_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_ip4r_ops USING gist;


ALTER OPERATOR FAMILY public.gist_ip4r_ops USING gist OWNER TO postgres;

--
-- Name: gist_ip4r_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_ip4r_ops
    DEFAULT FOR TYPE ip4r USING gist FAMILY gist_ip4r_ops AS
    OPERATOR 1 >>=(ip4r,ip4r) ,
    OPERATOR 2 <<=(ip4r,ip4r) ,
    OPERATOR 3 >>(ip4r,ip4r) ,
    OPERATOR 4 <<(ip4r,ip4r) ,
    OPERATOR 5 &&(ip4r,ip4r) ,
    OPERATOR 6 =(ip4r,ip4r) ,
    FUNCTION 1 (ip4r, ip4r) gip4r_consistent(internal,ip4r,integer) ,
    FUNCTION 2 (ip4r, ip4r) gip4r_union(internal,internal) ,
    FUNCTION 3 (ip4r, ip4r) gip4r_compress(internal) ,
    FUNCTION 4 (ip4r, ip4r) gip4r_decompress(internal) ,
    FUNCTION 5 (ip4r, ip4r) gip4r_penalty(internal,internal,internal) ,
    FUNCTION 6 (ip4r, ip4r) gip4r_picksplit(internal,internal) ,
    FUNCTION 7 (ip4r, ip4r) gip4r_same(ip4r,ip4r,internal);


ALTER OPERATOR CLASS public.gist_ip4r_ops USING gist OWNER TO postgres;

--
-- Name: gist_macaddr_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_macaddr_ops USING gist;


ALTER OPERATOR FAMILY public.gist_macaddr_ops USING gist OWNER TO postgres;

--
-- Name: gist_macaddr_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_macaddr_ops
    DEFAULT FOR TYPE macaddr USING gist FAMILY gist_macaddr_ops AS
    STORAGE gbtreekey16 ,
    OPERATOR 1 <(macaddr,macaddr) ,
    OPERATOR 2 <=(macaddr,macaddr) ,
    OPERATOR 3 =(macaddr,macaddr) ,
    OPERATOR 4 >=(macaddr,macaddr) ,
    OPERATOR 5 >(macaddr,macaddr) ,
    FUNCTION 1 (macaddr, macaddr) gbt_macad_consistent(internal,macaddr,smallint) ,
    FUNCTION 2 (macaddr, macaddr) gbt_macad_union(bytea,internal) ,
    FUNCTION 3 (macaddr, macaddr) gbt_macad_compress(internal) ,
    FUNCTION 4 (macaddr, macaddr) gbt_decompress(internal) ,
    FUNCTION 5 (macaddr, macaddr) gbt_macad_penalty(internal,internal,internal) ,
    FUNCTION 6 (macaddr, macaddr) gbt_macad_picksplit(internal,internal) ,
    FUNCTION 7 (macaddr, macaddr) gbt_macad_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_macaddr_ops USING gist OWNER TO postgres;

--
-- Name: gist_numeric_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_numeric_ops USING gist;


ALTER OPERATOR FAMILY public.gist_numeric_ops USING gist OWNER TO postgres;

--
-- Name: gist_numeric_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_numeric_ops
    DEFAULT FOR TYPE numeric USING gist FAMILY gist_numeric_ops AS
    STORAGE gbtreekey_var ,
    OPERATOR 1 <(numeric,numeric) ,
    OPERATOR 2 <=(numeric,numeric) ,
    OPERATOR 3 =(numeric,numeric) ,
    OPERATOR 4 >=(numeric,numeric) ,
    OPERATOR 5 >(numeric,numeric) ,
    FUNCTION 1 (numeric, numeric) gbt_numeric_consistent(internal,numeric,smallint) ,
    FUNCTION 2 (numeric, numeric) gbt_numeric_union(bytea,internal) ,
    FUNCTION 3 (numeric, numeric) gbt_numeric_compress(internal) ,
    FUNCTION 4 (numeric, numeric) gbt_var_decompress(internal) ,
    FUNCTION 5 (numeric, numeric) gbt_numeric_penalty(internal,internal,internal) ,
    FUNCTION 6 (numeric, numeric) gbt_numeric_picksplit(internal,internal) ,
    FUNCTION 7 (numeric, numeric) gbt_numeric_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_numeric_ops USING gist OWNER TO postgres;

--
-- Name: gist_oid_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_oid_ops USING gist;


ALTER OPERATOR FAMILY public.gist_oid_ops USING gist OWNER TO postgres;

--
-- Name: gist_oid_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_oid_ops
    DEFAULT FOR TYPE oid USING gist FAMILY gist_oid_ops AS
    STORAGE gbtreekey8 ,
    OPERATOR 1 <(oid,oid) ,
    OPERATOR 2 <=(oid,oid) ,
    OPERATOR 3 =(oid,oid) ,
    OPERATOR 4 >=(oid,oid) ,
    OPERATOR 5 >(oid,oid) ,
    FUNCTION 1 (oid, oid) gbt_oid_consistent(internal,oid,smallint) ,
    FUNCTION 2 (oid, oid) gbt_oid_union(bytea,internal) ,
    FUNCTION 3 (oid, oid) gbt_oid_compress(internal) ,
    FUNCTION 4 (oid, oid) gbt_decompress(internal) ,
    FUNCTION 5 (oid, oid) gbt_oid_penalty(internal,internal,internal) ,
    FUNCTION 6 (oid, oid) gbt_oid_picksplit(internal,internal) ,
    FUNCTION 7 (oid, oid) gbt_oid_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_oid_ops USING gist OWNER TO postgres;

--
-- Name: gist_prefix_range_jordan_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_prefix_range_jordan_ops USING gist;


ALTER OPERATOR FAMILY public.gist_prefix_range_jordan_ops USING gist OWNER TO postgres;

--
-- Name: gist_prefix_range_jordan_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_prefix_range_jordan_ops
    FOR TYPE prefix_range USING gist FAMILY gist_prefix_range_jordan_ops AS
    OPERATOR 1 @>(prefix_range,prefix_range) ,
    FUNCTION 1 (prefix_range, prefix_range) gpr_consistent(internal,prefix_range,prefix_range) ,
    FUNCTION 2 (prefix_range, prefix_range) gpr_union(internal,internal) ,
    FUNCTION 3 (prefix_range, prefix_range) gpr_compress(internal) ,
    FUNCTION 4 (prefix_range, prefix_range) gpr_decompress(internal) ,
    FUNCTION 5 (prefix_range, prefix_range) gpr_penalty(internal,internal,internal) ,
    FUNCTION 6 (prefix_range, prefix_range) gpr_picksplit_jordan(internal,internal) ,
    FUNCTION 7 (prefix_range, prefix_range) gpr_same(prefix_range,prefix_range,internal);


ALTER OPERATOR CLASS public.gist_prefix_range_jordan_ops USING gist OWNER TO postgres;

--
-- Name: gist_prefix_range_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_prefix_range_ops USING gist;


ALTER OPERATOR FAMILY public.gist_prefix_range_ops USING gist OWNER TO postgres;

--
-- Name: gist_prefix_range_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_prefix_range_ops
    FOR TYPE prefix_range USING gist FAMILY gist_prefix_range_ops AS
    OPERATOR 1 @>(prefix_range,prefix_range) ,
    FUNCTION 1 (prefix_range, prefix_range) gpr_consistent(internal,prefix_range,prefix_range) ,
    FUNCTION 2 (prefix_range, prefix_range) gpr_union(internal,internal) ,
    FUNCTION 3 (prefix_range, prefix_range) gpr_compress(internal) ,
    FUNCTION 4 (prefix_range, prefix_range) gpr_decompress(internal) ,
    FUNCTION 5 (prefix_range, prefix_range) gpr_penalty(internal,internal,internal) ,
    FUNCTION 6 (prefix_range, prefix_range) gpr_picksplit(internal,internal) ,
    FUNCTION 7 (prefix_range, prefix_range) gpr_same(prefix_range,prefix_range,internal);


ALTER OPERATOR CLASS public.gist_prefix_range_ops USING gist OWNER TO postgres;

--
-- Name: gist_text_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_text_ops USING gist;


ALTER OPERATOR FAMILY public.gist_text_ops USING gist OWNER TO postgres;

--
-- Name: gist_text_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_text_ops
    DEFAULT FOR TYPE text USING gist FAMILY gist_text_ops AS
    STORAGE gbtreekey_var ,
    OPERATOR 1 <(text,text) ,
    OPERATOR 2 <=(text,text) ,
    OPERATOR 3 =(text,text) ,
    OPERATOR 4 >=(text,text) ,
    OPERATOR 5 >(text,text) ,
    FUNCTION 1 (text, text) gbt_text_consistent(internal,text,smallint) ,
    FUNCTION 2 (text, text) gbt_text_union(bytea,internal) ,
    FUNCTION 3 (text, text) gbt_text_compress(internal) ,
    FUNCTION 4 (text, text) gbt_var_decompress(internal) ,
    FUNCTION 5 (text, text) gbt_text_penalty(internal,internal,internal) ,
    FUNCTION 6 (text, text) gbt_text_picksplit(internal,internal) ,
    FUNCTION 7 (text, text) gbt_text_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_text_ops USING gist OWNER TO postgres;

--
-- Name: gist_time_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_time_ops USING gist;


ALTER OPERATOR FAMILY public.gist_time_ops USING gist OWNER TO postgres;

--
-- Name: gist_time_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_time_ops
    DEFAULT FOR TYPE time without time zone USING gist FAMILY gist_time_ops AS
    STORAGE gbtreekey16 ,
    OPERATOR 1 <(time without time zone,time without time zone) ,
    OPERATOR 2 <=(time without time zone,time without time zone) ,
    OPERATOR 3 =(time without time zone,time without time zone) ,
    OPERATOR 4 >=(time without time zone,time without time zone) ,
    OPERATOR 5 >(time without time zone,time without time zone) ,
    FUNCTION 1 (time without time zone, time without time zone) gbt_time_consistent(internal,time without time zone,smallint) ,
    FUNCTION 2 (time without time zone, time without time zone) gbt_time_union(bytea,internal) ,
    FUNCTION 3 (time without time zone, time without time zone) gbt_time_compress(internal) ,
    FUNCTION 4 (time without time zone, time without time zone) gbt_decompress(internal) ,
    FUNCTION 5 (time without time zone, time without time zone) gbt_time_penalty(internal,internal,internal) ,
    FUNCTION 6 (time without time zone, time without time zone) gbt_time_picksplit(internal,internal) ,
    FUNCTION 7 (time without time zone, time without time zone) gbt_time_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_time_ops USING gist OWNER TO postgres;

--
-- Name: gist_timestamp_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_timestamp_ops USING gist;


ALTER OPERATOR FAMILY public.gist_timestamp_ops USING gist OWNER TO postgres;

--
-- Name: gist_timestamp_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_timestamp_ops
    DEFAULT FOR TYPE timestamp without time zone USING gist FAMILY gist_timestamp_ops AS
    STORAGE gbtreekey16 ,
    OPERATOR 1 <(timestamp without time zone,timestamp without time zone) ,
    OPERATOR 2 <=(timestamp without time zone,timestamp without time zone) ,
    OPERATOR 3 =(timestamp without time zone,timestamp without time zone) ,
    OPERATOR 4 >=(timestamp without time zone,timestamp without time zone) ,
    OPERATOR 5 >(timestamp without time zone,timestamp without time zone) ,
    FUNCTION 1 (timestamp without time zone, timestamp without time zone) gbt_ts_consistent(internal,timestamp without time zone,smallint) ,
    FUNCTION 2 (timestamp without time zone, timestamp without time zone) gbt_ts_union(bytea,internal) ,
    FUNCTION 3 (timestamp without time zone, timestamp without time zone) gbt_ts_compress(internal) ,
    FUNCTION 4 (timestamp without time zone, timestamp without time zone) gbt_decompress(internal) ,
    FUNCTION 5 (timestamp without time zone, timestamp without time zone) gbt_ts_penalty(internal,internal,internal) ,
    FUNCTION 6 (timestamp without time zone, timestamp without time zone) gbt_ts_picksplit(internal,internal) ,
    FUNCTION 7 (timestamp without time zone, timestamp without time zone) gbt_ts_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_timestamp_ops USING gist OWNER TO postgres;

--
-- Name: gist_timestamptz_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_timestamptz_ops USING gist;


ALTER OPERATOR FAMILY public.gist_timestamptz_ops USING gist OWNER TO postgres;

--
-- Name: gist_timestamptz_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_timestamptz_ops
    DEFAULT FOR TYPE timestamp with time zone USING gist FAMILY gist_timestamptz_ops AS
    STORAGE gbtreekey16 ,
    OPERATOR 1 <(timestamp with time zone,timestamp with time zone) ,
    OPERATOR 2 <=(timestamp with time zone,timestamp with time zone) ,
    OPERATOR 3 =(timestamp with time zone,timestamp with time zone) ,
    OPERATOR 4 >=(timestamp with time zone,timestamp with time zone) ,
    OPERATOR 5 >(timestamp with time zone,timestamp with time zone) ,
    FUNCTION 1 (timestamp with time zone, timestamp with time zone) gbt_tstz_consistent(internal,timestamp with time zone,smallint) ,
    FUNCTION 2 (timestamp with time zone, timestamp with time zone) gbt_ts_union(bytea,internal) ,
    FUNCTION 3 (timestamp with time zone, timestamp with time zone) gbt_tstz_compress(internal) ,
    FUNCTION 4 (timestamp with time zone, timestamp with time zone) gbt_decompress(internal) ,
    FUNCTION 5 (timestamp with time zone, timestamp with time zone) gbt_ts_penalty(internal,internal,internal) ,
    FUNCTION 6 (timestamp with time zone, timestamp with time zone) gbt_ts_picksplit(internal,internal) ,
    FUNCTION 7 (timestamp with time zone, timestamp with time zone) gbt_ts_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_timestamptz_ops USING gist OWNER TO postgres;

--
-- Name: gist_timetz_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_timetz_ops USING gist;


ALTER OPERATOR FAMILY public.gist_timetz_ops USING gist OWNER TO postgres;

--
-- Name: gist_timetz_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_timetz_ops
    DEFAULT FOR TYPE time with time zone USING gist FAMILY gist_timetz_ops AS
    STORAGE gbtreekey16 ,
    OPERATOR 1 <(time with time zone,time with time zone) ,
    OPERATOR 2 <=(time with time zone,time with time zone) ,
    OPERATOR 3 =(time with time zone,time with time zone) ,
    OPERATOR 4 >=(time with time zone,time with time zone) ,
    OPERATOR 5 >(time with time zone,time with time zone) ,
    FUNCTION 1 (time with time zone, time with time zone) gbt_timetz_consistent(internal,time with time zone,smallint) ,
    FUNCTION 2 (time with time zone, time with time zone) gbt_time_union(bytea,internal) ,
    FUNCTION 3 (time with time zone, time with time zone) gbt_timetz_compress(internal) ,
    FUNCTION 4 (time with time zone, time with time zone) gbt_decompress(internal) ,
    FUNCTION 5 (time with time zone, time with time zone) gbt_time_penalty(internal,internal,internal) ,
    FUNCTION 6 (time with time zone, time with time zone) gbt_time_picksplit(internal,internal) ,
    FUNCTION 7 (time with time zone, time with time zone) gbt_time_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_timetz_ops USING gist OWNER TO postgres;

--
-- Name: gist_vbit_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY gist_vbit_ops USING gist;


ALTER OPERATOR FAMILY public.gist_vbit_ops USING gist OWNER TO postgres;

--
-- Name: gist_vbit_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS gist_vbit_ops
    DEFAULT FOR TYPE bit varying USING gist FAMILY gist_vbit_ops AS
    STORAGE gbtreekey_var ,
    OPERATOR 1 <(bit varying,bit varying) ,
    OPERATOR 2 <=(bit varying,bit varying) ,
    OPERATOR 3 =(bit varying,bit varying) ,
    OPERATOR 4 >=(bit varying,bit varying) ,
    OPERATOR 5 >(bit varying,bit varying) ,
    FUNCTION 1 (bit varying, bit varying) gbt_bit_consistent(internal,bit,smallint) ,
    FUNCTION 2 (bit varying, bit varying) gbt_bit_union(bytea,internal) ,
    FUNCTION 3 (bit varying, bit varying) gbt_bit_compress(internal) ,
    FUNCTION 4 (bit varying, bit varying) gbt_var_decompress(internal) ,
    FUNCTION 5 (bit varying, bit varying) gbt_bit_penalty(internal,internal,internal) ,
    FUNCTION 6 (bit varying, bit varying) gbt_bit_picksplit(internal,internal) ,
    FUNCTION 7 (bit varying, bit varying) gbt_bit_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_vbit_ops USING gist OWNER TO postgres;

--
-- Name: hash_ip4_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY hash_ip4_ops USING hash;


ALTER OPERATOR FAMILY public.hash_ip4_ops USING hash OWNER TO postgres;

--
-- Name: hash_ip4_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS hash_ip4_ops
    DEFAULT FOR TYPE ip4 USING hash FAMILY hash_ip4_ops AS
    OPERATOR 1 =(ip4,ip4) ,
    FUNCTION 1 (ip4, ip4) ip4hash(ip4);


ALTER OPERATOR CLASS public.hash_ip4_ops USING hash OWNER TO postgres;

--
-- Name: hash_ip4r_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY hash_ip4r_ops USING hash;


ALTER OPERATOR FAMILY public.hash_ip4r_ops USING hash OWNER TO postgres;

--
-- Name: hash_ip4r_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS hash_ip4r_ops
    DEFAULT FOR TYPE ip4r USING hash FAMILY hash_ip4r_ops AS
    OPERATOR 1 =(ip4r,ip4r) ,
    FUNCTION 1 (ip4r, ip4r) ip4rhash(ip4r);


ALTER OPERATOR CLASS public.hash_ip4r_ops USING hash OWNER TO postgres;

SET search_path = pg_catalog;

--
-- Name: CAST (cidr AS public.ip4r); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (cidr AS public.ip4r) WITH FUNCTION public.ip4r(cidr) AS ASSIGNMENT;


--
-- Name: CAST (double precision AS public.ip4); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (double precision AS public.ip4) WITH FUNCTION public.ip4(double precision);


--
-- Name: CAST (inet AS public.ip4); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (inet AS public.ip4) WITH FUNCTION public.ip4(inet) AS ASSIGNMENT;


--
-- Name: CAST (bigint AS public.ip4); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (bigint AS public.ip4) WITH FUNCTION public.ip4(bigint);


--
-- Name: CAST (public.ip4 AS cidr); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ip4 AS cidr) WITH FUNCTION public.cidr(public.ip4) AS ASSIGNMENT;


--
-- Name: CAST (public.ip4 AS double precision); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ip4 AS double precision) WITH FUNCTION public.to_double(public.ip4);


--
-- Name: CAST (public.ip4 AS bigint); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ip4 AS bigint) WITH FUNCTION public.to_bigint(public.ip4);


--
-- Name: CAST (public.ip4 AS public.ip4r); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ip4 AS public.ip4r) WITH FUNCTION public.ip4r(public.ip4) AS IMPLICIT;


--
-- Name: CAST (public.ip4 AS text); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ip4 AS text) WITH FUNCTION public.text(public.ip4);


--
-- Name: CAST (public.ip4r AS cidr); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ip4r AS cidr) WITH FUNCTION public.cidr(public.ip4r);


--
-- Name: CAST (public.ip4r AS text); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.ip4r AS text) WITH FUNCTION public.text(public.ip4r);


--
-- Name: CAST (public.prefix_range AS text); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (public.prefix_range AS text) WITH FUNCTION public.text(public.prefix_range);


--
-- Name: CAST (text AS public.ip4); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text AS public.ip4) WITH FUNCTION public.ip4(text);


--
-- Name: CAST (text AS public.ip4r); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text AS public.ip4r) WITH FUNCTION public.ip4r(text);


--
-- Name: CAST (text AS public.prefix_range); Type: CAST; Schema: pg_catalog; Owner: 
--

CREATE CAST (text AS public.prefix_range) WITH FUNCTION public.prefix_range(text) AS IMPLICIT;


SET search_path = pgagent, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: pga_exception; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pga_exception (
    jexid integer NOT NULL,
    jexscid integer NOT NULL,
    jexdate date,
    jextime time without time zone
);


ALTER TABLE pga_exception OWNER TO postgres;

--
-- Name: pga_exception_jexid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pga_exception_jexid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pga_exception_jexid_seq OWNER TO postgres;

--
-- Name: pga_exception_jexid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pga_exception_jexid_seq OWNED BY pga_exception.jexid;


--
-- Name: pga_job; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pga_job (
    jobid integer NOT NULL,
    jobjclid integer NOT NULL,
    jobname text NOT NULL,
    jobdesc text DEFAULT ''::text NOT NULL,
    jobhostagent text DEFAULT ''::text NOT NULL,
    jobenabled boolean DEFAULT true NOT NULL,
    jobcreated timestamp with time zone DEFAULT now() NOT NULL,
    jobchanged timestamp with time zone DEFAULT now() NOT NULL,
    jobagentid integer,
    jobnextrun timestamp with time zone,
    joblastrun timestamp with time zone
);


ALTER TABLE pga_job OWNER TO postgres;

--
-- Name: TABLE pga_job; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pga_job IS 'Job main entry';


--
-- Name: COLUMN pga_job.jobagentid; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pga_job.jobagentid IS 'Agent that currently executes this job.';


--
-- Name: pga_job_jobid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pga_job_jobid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pga_job_jobid_seq OWNER TO postgres;

--
-- Name: pga_job_jobid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pga_job_jobid_seq OWNED BY pga_job.jobid;


--
-- Name: pga_jobagent; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pga_jobagent (
    jagpid integer NOT NULL,
    jaglogintime timestamp with time zone DEFAULT now() NOT NULL,
    jagstation text NOT NULL
);


ALTER TABLE pga_jobagent OWNER TO postgres;

--
-- Name: TABLE pga_jobagent; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pga_jobagent IS 'Active job agents';


--
-- Name: pga_jobclass; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pga_jobclass (
    jclid integer NOT NULL,
    jclname text NOT NULL
);


ALTER TABLE pga_jobclass OWNER TO postgres;

--
-- Name: TABLE pga_jobclass; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pga_jobclass IS 'Job classification';


--
-- Name: pga_jobclass_jclid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pga_jobclass_jclid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pga_jobclass_jclid_seq OWNER TO postgres;

--
-- Name: pga_jobclass_jclid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pga_jobclass_jclid_seq OWNED BY pga_jobclass.jclid;


--
-- Name: pga_joblog; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pga_joblog (
    jlgid integer NOT NULL,
    jlgjobid integer NOT NULL,
    jlgstatus character(1) DEFAULT 'r'::bpchar NOT NULL,
    jlgstart timestamp with time zone DEFAULT now() NOT NULL,
    jlgduration interval,
    CONSTRAINT pga_joblog_jlgstatus_check CHECK ((jlgstatus = ANY (ARRAY['r'::bpchar, 's'::bpchar, 'f'::bpchar, 'i'::bpchar, 'd'::bpchar])))
);


ALTER TABLE pga_joblog OWNER TO postgres;

--
-- Name: TABLE pga_joblog; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pga_joblog IS 'Job run logs.';


--
-- Name: COLUMN pga_joblog.jlgstatus; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pga_joblog.jlgstatus IS 'Status of job: r=running, s=successfully finished, f=failed, i=no steps to execute, d=aborted';


--
-- Name: pga_joblog_jlgid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pga_joblog_jlgid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pga_joblog_jlgid_seq OWNER TO postgres;

--
-- Name: pga_joblog_jlgid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pga_joblog_jlgid_seq OWNED BY pga_joblog.jlgid;


--
-- Name: pga_jobstep; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pga_jobstep (
    jstid integer NOT NULL,
    jstjobid integer NOT NULL,
    jstname text NOT NULL,
    jstdesc text DEFAULT ''::text NOT NULL,
    jstenabled boolean DEFAULT true NOT NULL,
    jstkind character(1) NOT NULL,
    jstcode text NOT NULL,
    jstdbname name DEFAULT ''::name NOT NULL,
    jstonerror character(1) DEFAULT 'f'::bpchar NOT NULL,
    jscnextrun timestamp with time zone,
    CONSTRAINT pga_jobstep_check CHECK ((((jstdbname <> ''::name) AND (jstkind = 's'::bpchar)) OR ((jstdbname = ''::name) AND (jstkind = 'b'::bpchar)))),
    CONSTRAINT pga_jobstep_jstkind_check CHECK ((jstkind = ANY (ARRAY['b'::bpchar, 's'::bpchar]))),
    CONSTRAINT pga_jobstep_jstonerror_check CHECK ((jstonerror = ANY (ARRAY['f'::bpchar, 's'::bpchar, 'i'::bpchar])))
);


ALTER TABLE pga_jobstep OWNER TO postgres;

--
-- Name: TABLE pga_jobstep; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pga_jobstep IS 'Job step to be executed';


--
-- Name: COLUMN pga_jobstep.jstkind; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pga_jobstep.jstkind IS 'Kind of jobstep: s=sql, b=batch';


--
-- Name: COLUMN pga_jobstep.jstonerror; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pga_jobstep.jstonerror IS 'What to do if step returns an error: f=fail the job, s=mark step as succeeded and continue, i=mark as fail but ignore it and proceed';


--
-- Name: pga_jobstep_jstid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pga_jobstep_jstid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pga_jobstep_jstid_seq OWNER TO postgres;

--
-- Name: pga_jobstep_jstid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pga_jobstep_jstid_seq OWNED BY pga_jobstep.jstid;


--
-- Name: pga_jobsteplog; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pga_jobsteplog (
    jslid integer NOT NULL,
    jsljlgid integer NOT NULL,
    jsljstid integer NOT NULL,
    jslstatus character(1) DEFAULT 'r'::bpchar NOT NULL,
    jslresult integer,
    jslstart timestamp with time zone DEFAULT now() NOT NULL,
    jslduration interval,
    jsloutput text,
    CONSTRAINT pga_jobsteplog_jslstatus_check CHECK ((jslstatus = ANY (ARRAY['r'::bpchar, 's'::bpchar, 'i'::bpchar, 'f'::bpchar, 'd'::bpchar])))
);


ALTER TABLE pga_jobsteplog OWNER TO postgres;

--
-- Name: TABLE pga_jobsteplog; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pga_jobsteplog IS 'Job step run logs.';


--
-- Name: COLUMN pga_jobsteplog.jslstatus; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pga_jobsteplog.jslstatus IS 'Status of job step: r=running, s=successfully finished,  f=failed stopping job, i=ignored failure, d=aborted';


--
-- Name: COLUMN pga_jobsteplog.jslresult; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pga_jobsteplog.jslresult IS 'Return code of job step';


--
-- Name: pga_jobsteplog_jslid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pga_jobsteplog_jslid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pga_jobsteplog_jslid_seq OWNER TO postgres;

--
-- Name: pga_jobsteplog_jslid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pga_jobsteplog_jslid_seq OWNED BY pga_jobsteplog.jslid;


--
-- Name: pga_schedule; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pga_schedule (
    jscid integer NOT NULL,
    jscjobid integer NOT NULL,
    jscname text NOT NULL,
    jscdesc text DEFAULT ''::text NOT NULL,
    jscenabled boolean DEFAULT true NOT NULL,
    jscstart timestamp with time zone DEFAULT now() NOT NULL,
    jscend timestamp with time zone,
    jscminutes boolean[] DEFAULT '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}'::boolean[] NOT NULL,
    jschours boolean[] DEFAULT '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}'::boolean[] NOT NULL,
    jscweekdays boolean[] DEFAULT '{f,f,f,f,f,f,f}'::boolean[] NOT NULL,
    jscmonthdays boolean[] DEFAULT '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}'::boolean[] NOT NULL,
    jscmonths boolean[] DEFAULT '{f,f,f,f,f,f,f,f,f,f,f,f}'::boolean[] NOT NULL,
    CONSTRAINT pga_schedule_jschours_size CHECK ((array_upper(jschours, 1) = 24)),
    CONSTRAINT pga_schedule_jscminutes_size CHECK ((array_upper(jscminutes, 1) = 60)),
    CONSTRAINT pga_schedule_jscmonthdays_size CHECK ((array_upper(jscmonthdays, 1) = 32)),
    CONSTRAINT pga_schedule_jscmonths_size CHECK ((array_upper(jscmonths, 1) = 12)),
    CONSTRAINT pga_schedule_jscweekdays_size CHECK ((array_upper(jscweekdays, 1) = 7))
);


ALTER TABLE pga_schedule OWNER TO postgres;

--
-- Name: TABLE pga_schedule; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pga_schedule IS 'Job schedule exceptions';


--
-- Name: pga_schedule_jscid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pga_schedule_jscid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pga_schedule_jscid_seq OWNER TO postgres;

--
-- Name: pga_schedule_jscid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pga_schedule_jscid_seq OWNED BY pga_schedule.jscid;


SET search_path = public, pg_catalog;

--
-- Name: actual_transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE actual_transaction (
    "time" date,
    amount real,
    client_id character varying,
    type integer,
    id integer NOT NULL,
    balance real
);


ALTER TABLE actual_transaction OWNER TO postgres;

--
-- Name: actual_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE actual_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE actual_transaction_id_seq OWNER TO postgres;

--
-- Name: actual_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE actual_transaction_id_seq OWNED BY actual_transaction.id;


--
-- Name: admin_alert; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE admin_alert (
    id integer NOT NULL,
    type integer NOT NULL,
    subject character varying(100),
    content text,
    is_view integer DEFAULT 0 NOT NULL,
    create_time timestamp with time zone,
    view_time timestamp with time zone,
    view_by character varying(100)
);


ALTER TABLE admin_alert OWNER TO postgres;

--
-- Name: COLUMN admin_alert.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN admin_alert.type IS '1 => ''Carrier Daily Usage Limit Exceeded'',
2 => ''Carrier hourly Usage Limit Exceeded'',
3 => ''Invalid Login Alert'',
';


--
-- Name: COLUMN admin_alert.is_view; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN admin_alert.is_view IS 'å¦‚æžœ 1è¡¨ç¤ºå·²ç»æŸ¥çœ‹è¿‡';


--
-- Name: COLUMN admin_alert.view_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN admin_alert.view_time IS 'æŸ¥çœ‹æ—¶é—´';


--
-- Name: admin_alert_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE admin_alert_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE admin_alert_id_seq OWNER TO postgres;

--
-- Name: admin_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE admin_alert_id_seq OWNED BY admin_alert.id;


--
-- Name: agent; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE agent (
    agent_id integer NOT NULL,
    agent_name character varying(100),
    create_on timestamp with time zone,
    email character varying(200),
    commission numeric(5,2),
    method_type integer,
    frequency_type integer,
    status boolean,
    user_id integer,
    agent_role_id integer,
    update_on timestamp with time zone,
    update_by character varying(100),
    edit_permission boolean DEFAULT true
);


ALTER TABLE agent OWNER TO postgres;

--
-- Name: COLUMN agent.method_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN agent.method_type IS '0:By Profit; 1:By  Revenue';


--
-- Name: COLUMN agent.frequency_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN agent.frequency_type IS '0:daily;1:weekly;2:monthly';


--
-- Name: agent_agent_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE agent_agent_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agent_agent_id_seq OWNER TO postgres;

--
-- Name: agent_agent_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE agent_agent_id_seq OWNED BY agent.agent_id;


--
-- Name: agent_client; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE agent_client (
    id integer NOT NULL,
    agent_id integer,
    client_id integer,
    commission numeric(5,2),
    update_on timestamp with time zone,
    update_by character varying(100)
);


ALTER TABLE agent_client OWNER TO postgres;

--
-- Name: agent_client_client; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE agent_client_client (
    id integer NOT NULL,
    agent_client_id integer NOT NULL,
    client_id integer NOT NULL,
    commission integer
);


ALTER TABLE agent_client_client OWNER TO postgres;

--
-- Name: agent_client_client_id_seq1; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE agent_client_client_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agent_client_client_id_seq1 OWNER TO postgres;

--
-- Name: agent_client_client_id_seq1; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE agent_client_client_id_seq1 OWNED BY agent_client_client.id;


--
-- Name: agent_client_client_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE agent_client_client_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agent_client_client_record_record_id_seq OWNER TO postgres;

--
-- Name: agent_client_client_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE agent_client_client_record (
    id integer,
    agent_client_id integer,
    client_id integer,
    commission integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('agent_client_client_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE agent_client_client_record OWNER TO postgres;

--
-- Name: agent_client_client_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE agent_client_client_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agent_client_client_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: agent_client_client_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE agent_client_client_record_tmp (
    id integer,
    agent_client_id integer,
    client_id integer,
    commission integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('agent_client_client_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE agent_client_client_record_tmp OWNER TO postgres;

--
-- Name: agent_client_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE agent_client_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agent_client_id_seq OWNER TO postgres;

--
-- Name: agent_client_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE agent_client_id_seq OWNED BY agent_client.id;


--
-- Name: agent_clients; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE agent_clients (
    id integer NOT NULL,
    agent_id integer,
    client_id integer,
    commission numeric(5,2),
    update_on timestamp with time zone,
    update_by character varying(100),
    method_type integer DEFAULT 0
);


ALTER TABLE agent_clients OWNER TO postgres;

--
-- Name: agent_clients_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE agent_clients_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agent_clients_id_seq OWNER TO postgres;

--
-- Name: agent_clients_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE agent_clients_id_seq OWNED BY agent_clients.id;


--
-- Name: agent_commission_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE agent_commission_history (
    history_id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    total_date integer,
    amount numeric(7,2),
    agent_id integer,
    create_date date,
    finished boolean DEFAULT false
);


ALTER TABLE agent_commission_history OWNER TO postgres;

--
-- Name: agent_commission_history_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE agent_commission_history_detail (
    id integer NOT NULL,
    history_id integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    total_date integer,
    commission numeric(5,2),
    client_id integer,
    client_cost numeric(7,2)
);


ALTER TABLE agent_commission_history_detail OWNER TO postgres;

--
-- Name: agent_commission_history_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE agent_commission_history_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agent_commission_history_detail_id_seq OWNER TO postgres;

--
-- Name: agent_commission_history_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE agent_commission_history_detail_id_seq OWNED BY agent_commission_history_detail.id;


--
-- Name: agent_commission_history_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE agent_commission_history_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agent_commission_history_history_id_seq OWNER TO postgres;

--
-- Name: agent_commission_history_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE agent_commission_history_history_id_seq OWNED BY agent_commission_history.history_id;


--
-- Name: agent_commission_payment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE agent_commission_payment (
    id integer NOT NULL,
    history_id integer,
    create_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    create_by character varying(100),
    amount numeric(7,2),
    note text
);


ALTER TABLE agent_commission_payment OWNER TO postgres;

--
-- Name: agent_commission_payment_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE agent_commission_payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE agent_commission_payment_id_seq OWNER TO postgres;

--
-- Name: agent_commission_payment_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE agent_commission_payment_id_seq OWNED BY agent_commission_payment.id;


--
-- Name: alert_action; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE alert_action (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    email_to_noc boolean DEFAULT true NOT NULL,
    email_to_carrier boolean DEFAULT false NOT NULL,
    disable_host boolean DEFAULT false NOT NULL,
    disable_resource boolean DEFAULT false NOT NULL,
    disable_duration integer DEFAULT 0 NOT NULL,
    host_priority integer DEFAULT 0 NOT NULL,
    res_priority integer DEFAULT 0 NOT NULL,
    pri_chg_duration integer DEFAULT 0 NOT NULL,
    disable_code_trunk boolean DEFAULT false NOT NULL,
    code_trunk_disable_duration integer DEFAULT 0 NOT NULL,
    noc_email_subject character varying(1000),
    noc_email_content character varying(1000),
    carrier_email_subject character varying(1000),
    carrier_email_content character varying(1000),
    noc_attach_type integer DEFAULT 0 NOT NULL,
    carrier_attach_type integer DEFAULT 0 NOT NULL,
    backup_type integer DEFAULT 0 NOT NULL,
    email_notification integer,
    update_by character varying,
    update_at timestamp with time zone,
    disable_route_target smallint DEFAULT 0,
    change_prioprity smallint DEFAULT 0,
    change_to_priority integer DEFAULT 0,
    block_ani boolean DEFAULT false,
    trouble_tickets_template integer,
    exclude_ani character varying(255),
    loop_detection boolean DEFAULT false
);


ALTER TABLE alert_action OWNER TO postgres;

--
-- Name: COLUMN alert_action.disable_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.disable_duration IS 'å¤šå°‘åˆ†é’ŸåŽé‡æ–°å¯åŠ¨host/resource
ç­‰äºŽ0è¡¨ç¤ºä¸å†å¯åŠ¨';


--
-- Name: COLUMN alert_action.pri_chg_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.pri_chg_duration IS 'å¤šå°‘åˆ†é’ŸåŽæŠŠpriorityæ”¹å›žåŽ»
ç­‰äºŽ0è¡¨ç¤ºä¸å†æ”¹å›žåŽ»';


--
-- Name: COLUMN alert_action.code_trunk_disable_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.code_trunk_disable_duration IS 'åœæ­¢å¤šå°‘åˆ†é’Ÿ';


--
-- Name: COLUMN alert_action.noc_email_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.noc_email_subject IS 'delete';


--
-- Name: COLUMN alert_action.noc_email_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.noc_email_content IS 'delete';


--
-- Name: COLUMN alert_action.carrier_email_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.carrier_email_subject IS 'delete';


--
-- Name: COLUMN alert_action.carrier_email_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.carrier_email_content IS 'delete';


--
-- Name: COLUMN alert_action.noc_attach_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.noc_attach_type IS '0--none
1--pdf
2--xls
3--html
delete';


--
-- Name: COLUMN alert_action.carrier_attach_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.carrier_attach_type IS '0--none
1--pdf
2--xls
3--html
delete';


--
-- Name: COLUMN alert_action.backup_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.backup_type IS '0--none
1--pdf
2--xls
3--html
delete';


--
-- Name: COLUMN alert_action.email_notification; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.email_notification IS '0-None,
1-System''s NOC,
2- Partner''s NOC,
3-Both NOC';


--
-- Name: COLUMN alert_action.disable_route_target; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.disable_route_target IS '0 -- none
1 -- Entire Trunk
2 -- Entire Host';


--
-- Name: COLUMN alert_action.change_prioprity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_action.change_prioprity IS '0  None
1 Trunk
2 Host';


--
-- Name: alert_action_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE alert_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE alert_action_id_seq OWNER TO postgres;

--
-- Name: alert_action_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE alert_action_id_seq OWNED BY alert_action.id;


--
-- Name: alert_action_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE alert_action_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE alert_action_log_id_seq OWNER TO postgres;

--
-- Name: alert_condition; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE alert_condition (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    for_all integer DEFAULT 0 NOT NULL,
    acd_comparator integer DEFAULT 0 NOT NULL,
    acd_value_min real DEFAULT 0,
    acd_value_max real DEFAULT 0,
    asr_comparator integer DEFAULT 0 NOT NULL,
    asr_value_min real DEFAULT 0,
    asr_value_max real DEFAULT 0,
    margin_comparator integer DEFAULT 0 NOT NULL,
    margin_value_min real DEFAULT 0,
    margin_value_max real DEFAULT 0,
    acd_ignore integer DEFAULT 0,
    asr_ignore integer DEFAULT 0,
    margin_ignore integer DEFAULT 0,
    update_by character varying,
    update_at timestamp with time zone,
    abr_comparator integer DEFAULT 0,
    abr_value_min real DEFAULT 0,
    abr_value_max real DEFAULT 0,
    special_ani_comparator integer DEFAULT 0 NOT NULL,
    special_ani_value real DEFAULT 0,
    special_cost_comparator integer DEFAULT 0 NOT NULL,
    special_cost_value real DEFAULT 0
);


ALTER TABLE alert_condition OWNER TO postgres;

--
-- Name: COLUMN alert_condition.for_all; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_condition.for_all IS '0--or
1--and';


--
-- Name: COLUMN alert_condition.acd_comparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_condition.acd_comparator IS '0--target<XX,target<=XX
1--target>XX,target>=XX,YY>target>XX,
YY>target>=XX,YY>=target>XX,YY>=target>=XX
';


--
-- Name: COLUMN alert_condition.asr_comparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_condition.asr_comparator IS '0--target<XX,target<=XX
1--target>XX,target>=XX,YY>target>XX,
YY>target>=XX,YY>=target>XX,YY>=target>=XX';


--
-- Name: COLUMN alert_condition.margin_comparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_condition.margin_comparator IS '0--target<XX,target<=XX
1--target>XX,target>=XX,YY>target>XX,
YY>target>=XX,YY>=target>XX,YY>=target>=XX';


--
-- Name: COLUMN alert_condition.abr_comparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_condition.abr_comparator IS '0--target<XX,target<=XX
1--target>XX,target>=XX,YY>target>XX,
YY>target>=XX,YY>=target>XX,YY>=target>=XX';


--
-- Name: COLUMN alert_condition.special_ani_comparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_condition.special_ani_comparator IS '0--great than xx
1--less than xx,
2-ignore';


--
-- Name: alert_condition_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE alert_condition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE alert_condition_id_seq OWNER TO postgres;

--
-- Name: alert_condition_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE alert_condition_id_seq OWNED BY alert_condition.id;


--
-- Name: alert_event; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE alert_event (
    id integer NOT NULL,
    event_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    event_type integer DEFAULT 8 NOT NULL,
    res_id integer,
    host_id integer,
    product_prefix_id integer,
    old_priority integer,
    new_priority integer,
    email_addr character varying(1000),
    alert_exec_id integer,
    mail_sended boolean DEFAULT false,
    alert_rule_id integer,
    alert_action_id integer,
    mail_subject text,
    mail_content text,
    disable_duration integer,
    is_enable boolean DEFAULT false,
    disable_code prefix_range DEFAULT ''::prefix_range
);


ALTER TABLE alert_event OWNER TO postgres;

--
-- Name: COLUMN alert_event.event_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_event.event_type IS '1--disable trunk
2--disable host
3--enable trunk
4--enable host
5--disable code trunk
6--enable code trunk
7--change priority
8--email
9--change to old priority';


--
-- Name: alert_event_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE alert_event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE alert_event_id_seq OWNER TO postgres;

--
-- Name: alert_event_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE alert_event_id_seq OWNED BY alert_event.id;


--
-- Name: alert_exec_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE alert_exec_log (
    id integer DEFAULT nextval('alert_action_log_id_seq'::regclass) NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone
);


ALTER TABLE alert_exec_log OWNER TO postgres;

--
-- Name: TABLE alert_exec_log; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE alert_exec_log IS 'alertå‘é€é‚®ç®±çš„log';


--
-- Name: alert_mail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE alert_mail (
    id integer NOT NULL,
    user_alert_id integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    send_time timestamp with time zone,
    mailed integer DEFAULT 0,
    send_body character varying(1000)
);


ALTER TABLE alert_mail OWNER TO postgres;

--
-- Name: alert_mail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE alert_mail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE alert_mail_id_seq OWNER TO postgres;

--
-- Name: alert_mail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE alert_mail_id_seq OWNED BY alert_mail.id;


--
-- Name: alert_rule; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE alert_rule (
    id integer NOT NULL,
    name character varying(100),
    res_id integer NOT NULL,
    host_id integer DEFAULT 0 NOT NULL,
    ani character varying(100) DEFAULT ''::character varying NOT NULL,
    dnis character varying(100) DEFAULT ''::character varying NOT NULL,
    alert_condition_id integer NOT NULL,
    alert_action_id integer NOT NULL,
    freq_type integer NOT NULL,
    last_runtime timestamp with time zone,
    next_runtime timestamp with time zone,
    sample_size integer,
    switch_ip ip4r,
    weekday_time character varying(100),
    status smallint DEFAULT 1,
    freq_value integer,
    update_by character varying,
    update_at timestamp with time zone,
    ingress_trunk_prefix integer,
    source_code_name character varying,
    destination_code_name character varying,
    monitor_type integer,
    min_call_time integer DEFAULT 0,
    apply_type integer,
    mail_duration integer,
    is_origin integer DEFAULT 0
);


ALTER TABLE alert_rule OWNER TO postgres;

--
-- Name: TABLE alert_rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE alert_rule IS 'alert rule è§„åˆ™';


--
-- Name: COLUMN alert_rule.host_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rule.host_id IS '0--è¡¨ç¤ºæ‰€æœ‰';


--
-- Name: COLUMN alert_rule.freq_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rule.freq_type IS '1--every xx minutes
2--every æ˜ŸæœŸå‡
0 - Never
';


--
-- Name: COLUMN alert_rule.sample_size; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rule.sample_size IS 'ç»Ÿè®¡å¤šå°‘åˆ†é’Ÿçš„æ•°æ®';


--
-- Name: COLUMN alert_rule.apply_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rule.apply_type IS '0 - Apply To All ä»£è¡¨æ‰€æœ‰

1 - Apply Specific Ani æŒ‡å®šå¤šä¸ªä¸»å« æ˜¯æ£€æµ‹æŒ‡å®šçš„ä¸»å«

2 - Exclude Specific Ani é™¤äº†æŒ‡å®šçš„å‡ ä¸ªä¸»å« æ‰€æœ‰éƒ½æ‹’ç»
';


--
-- Name: alert_rule_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE alert_rule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE alert_rule_id_seq OWNER TO postgres;

--
-- Name: alert_rule_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE alert_rule_id_seq OWNED BY alert_rule.id;


--
-- Name: alert_rules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE alert_rules (
    id integer NOT NULL,
    rule_name character varying(100),
    trunk_type smallint DEFAULT 1 NOT NULL,
    all_trunk boolean DEFAULT false NOT NULL,
    include smallint DEFAULT 0 NOT NULL,
    in_codes character varying(500),
    in_code_deck integer,
    in_code_name_id character varying(100),
    exclude smallint,
    ex_code_deck integer,
    ex_code_name_id character varying(100),
    acd character(1),
    acd_value real,
    asr character(1),
    asr_value real,
    abr character(1),
    abr_value real,
    pdd character(1),
    pdd_value double precision,
    profitability character(1),
    profitability_value real,
    revenue character(1),
    revenue_value real,
    min_call_attempt integer,
    step3_type smallint DEFAULT 2 NOT NULL,
    disable_scope smallint,
    trouble_ticket_sent_to smallint,
    trouble_ticket_sent_from integer,
    trouble_ticket_subject character varying(100),
    trouble_ticket_content text,
    auto_enable_type smallint,
    auto_enable integer,
    execution_schedule smallint,
    specific_minutes integer,
    daily_time smallint,
    weekly_time smallint,
    weekly_value smallint,
    sample_size integer,
    ex_codes character varying(500),
    update_by character varying(100),
    update_at timestamp with time zone,
    last_run_time timestamp with time zone,
    active boolean DEFAULT true,
    is_block boolean DEFAULT true,
    is_email boolean DEFAULT true,
    status boolean DEFAULT false,
    monitor_by integer DEFAULT 0,
    res_id text,
    next_run_time timestamp with time zone,
    unblock_after_min integer,
    auto_define boolean DEFAULT false,
    sdp_type integer DEFAULT 0,
    sdp_sign integer DEFAULT 0,
    sdp_value integer DEFAULT 0
);


ALTER TABLE alert_rules OWNER TO postgres;

--
-- Name: COLUMN alert_rules.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.id IS 'id ä¸»é”®';


--
-- Name: COLUMN alert_rules.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.trunk_type IS '1:ingress
2:egress';


--
-- Name: COLUMN alert_rules.all_trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.all_trunk IS '1ä¸ºå…¨éƒ¨';


--
-- Name: COLUMN alert_rules.include; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.include IS '0:all code
1:Specific Codes
2:Specific Code Names';


--
-- Name: COLUMN alert_rules.in_codes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.in_codes IS 'ä»¥é€—å·éš”å¼€çš„code';


--
-- Name: COLUMN alert_rules.in_code_deck; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.in_code_deck IS 'code deck id';


--
-- Name: COLUMN alert_rules.in_code_name_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.in_code_name_id IS 'ä»¥é€—å·éš”å¼€çš„code name id';


--
-- Name: COLUMN alert_rules.exclude; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.exclude IS '0:ä¸é€‰æ‹©
1ï¼šSpecific Codes
2ï¼šSpecific Code Names';


--
-- Name: COLUMN alert_rules.ex_code_deck; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.ex_code_deck IS 'ä¸åŒ…æ‹¬ çš„ code deck id';


--
-- Name: COLUMN alert_rules.ex_code_name_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.ex_code_name_id IS 'ä¸åŒ…æ‹¬çš„ code name id';


--
-- Name: COLUMN alert_rules.acd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.acd IS '''1'':ignore
''>'':å¤§äºŽ
''<'':å°äºŽ
''='':ç­‰äºŽ';


--
-- Name: COLUMN alert_rules.acd_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.acd_value IS 'acd çš„å€¼';


--
-- Name: COLUMN alert_rules.asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.asr IS '''1'':ignore
''>'':å¤§äºŽ
''<'':å°äºŽ
''='':ç­‰äºŽ';


--
-- Name: COLUMN alert_rules.asr_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.asr_value IS 'asr çš„å€¼';


--
-- Name: COLUMN alert_rules.abr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.abr IS '''1'':ignore
''>'':å¤§äºŽ
''<'':å°äºŽ
''='':ç­‰äºŽ';


--
-- Name: COLUMN alert_rules.abr_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.abr_value IS 'abr çš„å€¼';


--
-- Name: COLUMN alert_rules.pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.pdd IS '''1'':ignore
''>'':å¤§äºŽ
''<'':å°äºŽ
''='':ç­‰äºŽ';


--
-- Name: COLUMN alert_rules.pdd_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.pdd_value IS 'pdd çš„å€¼';


--
-- Name: COLUMN alert_rules.profitability; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.profitability IS '''1'':ignore
''>'':å¤§äºŽ
''<'':å°äºŽ
''='':ç­‰äºŽ';


--
-- Name: COLUMN alert_rules.profitability_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.profitability_value IS 'profitability çš„å€¼';


--
-- Name: COLUMN alert_rules.step3_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.step3_type IS '1:Send Trouble Ticket Email
2:Disable Trunks';


--
-- Name: COLUMN alert_rules.disable_scope; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.disable_scope IS '1:Disable Entire Trunk
2:Disable Specific Code
3:Disable Specific Code Name

step3 é‡Œçš„Disable Scope';


--
-- Name: COLUMN alert_rules.trouble_ticket_sent_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.trouble_ticket_sent_to IS '1:Your Own NOC Email
2:Partnerâ€™s NOC Email
3:Both';


--
-- Name: COLUMN alert_rules.trouble_ticket_sent_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.trouble_ticket_sent_from IS 'mail sender id';


--
-- Name: COLUMN alert_rules.trouble_ticket_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.trouble_ticket_content IS 'å†…å®¹';


--
-- Name: COLUMN alert_rules.auto_enable_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.auto_enable_type IS '1:Never
2:After';


--
-- Name: COLUMN alert_rules.auto_enable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.auto_enable IS 'auto_enable çš„å€¼';


--
-- Name: COLUMN alert_rules.execution_schedule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.execution_schedule IS '0:never
1:Every Specific Minutes
2:Daily
3:Weekly';


--
-- Name: COLUMN alert_rules.specific_minutes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.specific_minutes IS 'å½“Execution Schedule é€‰æ‹©Every Specific Minutesæ—¶çš„å€¼';


--
-- Name: COLUMN alert_rules.daily_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.daily_time IS '0-23 å°æ—¶å€¼';


--
-- Name: COLUMN alert_rules.weekly_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.weekly_time IS '0-23å°æ—¶å€¼';


--
-- Name: COLUMN alert_rules.weekly_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.weekly_value IS '0-6
0ä¸ºæ˜ŸæœŸå¤©';


--
-- Name: COLUMN alert_rules.is_block; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.is_block IS 'æ˜¯å¦block';


--
-- Name: COLUMN alert_rules.is_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN alert_rules.is_email IS 'æ˜¯å¦å‘é‚®ä»¶';


--
-- Name: alert_rules_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE alert_rules_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE alert_rules_id_seq OWNER TO postgres;

--
-- Name: alert_rules_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE alert_rules_id_seq OWNED BY alert_rules.id;


--
-- Name: alert_rules_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE alert_rules_log (
    id integer NOT NULL,
    alert_rules_id integer,
    create_on timestamp with time zone,
    status integer,
    finish_time timestamp with time zone,
    limit_acd_value real,
    limit_asr_value real,
    limit_abr_value real,
    limit_pdd_value double precision,
    limit_profitability_value real,
    limit_revenue_value real,
    limit_asr character(1),
    limit_abr character(1),
    limit_acd character(1),
    limit_pdd character(1),
    limit_profitability character(1),
    limit_revenue character(1),
    "time" numeric DEFAULT date_part('epoch'::text, ('now'::text)::timestamp(0) with time zone),
    call_attempt numeric NOT NULL,
    sdp_sign integer DEFAULT 0,
    sdp_type integer DEFAULT 0,
    sdp_value integer DEFAULT 0
);


ALTER TABLE alert_rules_log OWNER TO postgres;

--
-- Name: alert_rules_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE alert_rules_log_detail (
    id integer NOT NULL,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    alert_rules_log_id integer,
    resource_id integer,
    code character varying(50),
    asr real,
    abr real,
    acd real,
    pdd real,
    profitability real,
    revenue real,
    system_email_address character varying(100),
    system_email_status boolean,
    partner_email_address character varying(100),
    partner_email_status boolean,
    is_email boolean,
    is_block boolean,
    resource_block_id integer,
    email_type integer,
    valid_to numeric,
    exclude integer,
    include integer,
    trunk_type integer,
    monitor_by integer,
    prefix text,
    "time" numeric DEFAULT date_part('epoch'::text, ('now'::text)::timestamp(0) with time zone),
    country character varying(100),
    code_name character varying(100),
    origination_source_number character varying(100),
    routing_digits character varying(100),
    sdp_value integer DEFAULT 0
);


ALTER TABLE alert_rules_log_detail OWNER TO postgres;

--
-- Name: alert_rules_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE alert_rules_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE alert_rules_log_detail_id_seq OWNER TO postgres;

--
-- Name: alert_rules_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE alert_rules_log_detail_id_seq OWNED BY alert_rules_log_detail.id;


--
-- Name: alert_rules_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE alert_rules_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE alert_rules_log_id_seq OWNER TO postgres;

--
-- Name: alert_rules_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE alert_rules_log_id_seq OWNED BY alert_rules_log.id;


--
-- Name: allowed_sendto_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE allowed_sendto_ip (
    id integer NOT NULL,
    resource_id integer,
    direction integer,
    sip_profile_ip ip4r,
    sip_profile_port integer
);


ALTER TABLE allowed_sendto_ip OWNER TO postgres;

--
-- Name: allowed_sendto_ip_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE allowed_sendto_ip_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE allowed_sendto_ip_id_seq OWNER TO postgres;

--
-- Name: allowed_sendto_ip_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE allowed_sendto_ip_id_seq OWNED BY allowed_sendto_ip.id;


--
-- Name: allowed_sendto_ip_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE allowed_sendto_ip_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE allowed_sendto_ip_record_record_id_seq OWNER TO postgres;

--
-- Name: allowed_sendto_ip_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE allowed_sendto_ip_record (
    id integer,
    resource_id integer,
    direction integer,
    sip_profile_ip ip4r,
    sip_profile_port integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('allowed_sendto_ip_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE allowed_sendto_ip_record OWNER TO postgres;

--
-- Name: dynamic_route_dynamic_route_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_dynamic_route_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_dynamic_route_id_seq OWNER TO postgres;

--
-- Name: dynamic_route; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route (
    dynamic_route_id integer DEFAULT nextval('dynamic_route_dynamic_route_id_seq'::regclass) NOT NULL,
    name character varying(100) NOT NULL,
    routing_rule integer DEFAULT 6 NOT NULL,
    time_profile_id integer,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    lcr_flag integer DEFAULT 1,
    is_virtual boolean
);


ALTER TABLE dynamic_route OWNER TO postgres;

--
-- Name: TABLE dynamic_route; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE dynamic_route IS 'åŠ¨æ€è·¯ç”±';


--
-- Name: COLUMN dynamic_route.routing_rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dynamic_route.routing_rule IS 'è·¯ç”±è§„åˆ™ï¼š4 â€“ æŒ‰æœ€å¤§ASRï¼›5 â€“ æŒ‰æœ€å¤§ACDï¼›6 â€“ æŒ‰æœ€ä½Žè´¹ç”¨';


--
-- Name: COLUMN dynamic_route.lcr_flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dynamic_route.lcr_flag IS '1-15åˆ†é’Ÿ
2-30åˆ†é’Ÿ
3-1å°æ—¶
4-1å¤©';


--
-- Name: dynamic_route_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_items (
    id integer NOT NULL,
    dynamic_route_id integer NOT NULL,
    resource_id integer NOT NULL
);


ALTER TABLE dynamic_route_items OWNER TO postgres;

--
-- Name: product_product_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_product_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE product_product_id_seq OWNER TO postgres;

--
-- Name: product; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product (
    product_id integer DEFAULT nextval('product_product_id_seq'::regclass) NOT NULL,
    name character varying(100),
    modify_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    introduction character varying(80),
    dynamic_route_id integer,
    update_by character varying,
    code_type integer DEFAULT 0,
    code_deck_id integer,
    route_lrn integer
);


ALTER TABLE product OWNER TO postgres;

--
-- Name: TABLE product; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE product IS 'é™æ€è·¯ç”±è¡¨';


--
-- Name: COLUMN product.product_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product.product_id IS 'ä¸»é”®';


--
-- Name: COLUMN product.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product.name IS 'åç§°';


--
-- Name: COLUMN product.modify_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product.modify_time IS 'ä¿®æ”¹æ—¶é—´';


--
-- Name: COLUMN product.introduction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product.introduction IS 'è¯´æ˜Ž';


--
-- Name: COLUMN product.dynamic_route_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product.dynamic_route_id IS 'åŠ¨æ€è·¯ç”±è½¬æ¢ç”Ÿæˆ';


--
-- Name: COLUMN product.route_lrn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product.route_lrn IS '0-dnis
1-lrn';


--
-- Name: product_items_item_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_items_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_items_item_id_seq OWNER TO postgres;

--
-- Name: product_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_items (
    item_id integer DEFAULT nextval('product_items_item_id_seq'::regclass) NOT NULL,
    product_id integer,
    alias character varying(100),
    digits prefix_range DEFAULT ''::prefix_range NOT NULL,
    strategy integer DEFAULT 1 NOT NULL,
    time_profile_id integer,
    min_len integer DEFAULT 0,
    max_len integer DEFAULT 32,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    code_name character(100)
);


ALTER TABLE product_items OWNER TO postgres;

--
-- Name: TABLE product_items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE product_items IS 'é™æ€è·¯ç”±';


--
-- Name: COLUMN product_items.strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product_items.strategy IS '0-;By Percentage
1-Top-Down
2-Round-Robin';


--
-- Name: product_items_resource; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_items_resource (
    id integer NOT NULL,
    item_id integer NOT NULL,
    resource_id integer NOT NULL,
    by_percentage integer,
    order_id integer,
    order_type integer
);


ALTER TABLE product_items_resource OWNER TO postgres;

--
-- Name: COLUMN product_items_resource.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product_items_resource.order_type IS '1-buy order
2-sell order';


--
-- Name: resource_resource_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_resource_id_seq OWNER TO postgres;

--
-- Name: resource; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource (
    resource_id integer DEFAULT nextval('resource_resource_id_seq'::regclass) NOT NULL,
    name character varying(100),
    ingress boolean,
    egress boolean,
    active boolean DEFAULT true NOT NULL,
    rfc_2833 boolean DEFAULT false NOT NULL,
    t38 boolean DEFAULT false NOT NULL,
    alias character varying(100) DEFAULT NULL::character varying NOT NULL,
    res_strategy smallint,
    cps_limit integer,
    capacity integer,
    lnp boolean DEFAULT false NOT NULL,
    lrn_block boolean DEFAULT false NOT NULL,
    client_id integer,
    tdm boolean DEFAULT true NOT NULL,
    rate_table_id integer,
    transnexus integer,
    route_strategy_id integer,
    media_type integer DEFAULT 2 NOT NULL,
    pass_through integer,
    profit_margin double precision DEFAULT 0 NOT NULL,
    enough_balance boolean DEFAULT true,
    egress_bill_after_action boolean DEFAULT true,
    proto integer DEFAULT 1,
    dnis_only boolean DEFAULT true NOT NULL,
    ring_timeout integer DEFAULT 60 NOT NULL,
    ignore_ring boolean DEFAULT false,
    ignore_early_media boolean DEFAULT false,
    disable_by_alert boolean DEFAULT false,
    priority integer DEFAULT 0,
    last_priority integer DEFAULT 0,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status integer DEFAULT 1,
    wait_ringtime180 integer DEFAULT 6000,
    profit_type integer DEFAULT 1 NOT NULL,
    lnp_dipping boolean DEFAULT false,
    lnp_dipping_rate real,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    cli_type integer,
    auth_type integer DEFAULT 0,
    delay_bye_second integer,
    delay_bye_limit integer,
    max_duration integer,
    marketplace integer DEFAULT 0,
    rating_type integer DEFAULT 0,
    billing_type integer DEFAULT 0,
    trunk_type integer,
    switch_profile_id integer,
    transaction_fee_id integer,
    service_type integer DEFAULT 0 NOT NULL,
    product_id integer,
    rpid smallint,
    paid smallint,
    oli smallint,
    pci smallint,
    priv smallint,
    div smallint,
    trunk_type2 smallint DEFAULT 0 NOT NULL,
    account_id character(32),
    billing_method smallint,
    amount_per_port numeric,
    billing_rule integer,
    ignore_early_nosdp integer,
    media_timeout integer,
    private integer DEFAULT 0 NOT NULL,
    agent_type integer,
    bill_by integer DEFAULT 4,
    rate_profile integer DEFAULT 0,
    us_route integer DEFAULT 0,
    intl_route integer DEFAULT 0,
    canada_route integer DEFAULT 0,
    rate_decimal integer DEFAULT 6,
    rate_rounding integer DEFAULT 0,
    us_other integer DEFAULT 0,
    canada_other integer DEFAULT 0,
    redirect integer DEFAULT 0,
    lrn_prefix integer DEFAULT 1 NOT NULL,
    pass_response_code integer DEFAULT 0,
    is_del integer DEFAULT 0,
    dtmf_type integer DEFAULT 3,
    dtmf_detect integer DEFAULT 0,
    rpid_screen integer DEFAULT 0,
    rpid_party integer DEFAULT 0,
    display_name integer,
    rpid_id_type integer DEFAULT 0,
    rpid_privacy integer DEFAULT 0,
    counter_time integer,
    number integer,
    block_time integer,
    re_invite integer,
    re_invite_interval integer,
    info integer,
    rfc2833 integer,
    inband integer,
    dummy_trunk boolean,
    random_table_id integer,
    is_virtual boolean,
    rfc_r833_payload integer,
    resource_template_id integer,
    rate_use_rpid boolean DEFAULT false,
    group_id integer,
    resource_block_group_id integer,
    block_404_number_time integer,
    billing_port_type integer DEFAULT 0,
    cost_per_port numeric DEFAULT 0,
    price_per_actual_channel double precision,
    price_per_max_channel double precision,
    enfource_cid boolean DEFAULT false,
    ani_cps_limit integer,
    ani_cap_limit integer,
    dnis_cps_limit integer,
    dnis_cap_limit integer,
    jurisdiction_use_dnis boolean DEFAULT false,
    cid_min_asr integer,
    cid_min_acd integer,
    cid_max_sdp integer,
    tech_prefix varchar(255)
);


ALTER TABLE resource OWNER TO postgres;

--
-- Name: TABLE resource; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource IS 'ç½‘å…³ç»„';


--
-- Name: COLUMN resource.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.resource_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.name IS 'åå­—';


--
-- Name: COLUMN resource.ingress; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.ingress IS 'å¯¹æŽ¥ç½‘å…³';


--
-- Name: COLUMN resource.egress; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.egress IS 'è½åœ°ç½‘å…³';


--
-- Name: COLUMN resource.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.active IS 'å¯ç”¨ï¼ç¦ç”¨';


--
-- Name: COLUMN resource.rfc_2833; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rfc_2833 IS 'rfc_2833';


--
-- Name: COLUMN resource.t38; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.t38 IS 't38';


--
-- Name: COLUMN resource.alias; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.alias IS 'åˆ«åresourceID';


--
-- Name: COLUMN resource.res_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.res_strategy IS 'è½åœ°ç½‘å…³é€‰æ‹©ç­–ç•¥
1ï¼ï¼top-down
2ï¼ï¼round-robin';


--
-- Name: COLUMN resource.cps_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.cps_limit IS 'å®¹è®¸æ¯ç§’å‘¼å«æ•°';


--
-- Name: COLUMN resource.capacity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.capacity IS 'å®¹è®¸åœ¨çº¿å‘¼å«æ•°';


--
-- Name: COLUMN resource.lnp; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.lnp IS 'lrn';


--
-- Name: COLUMN resource.lrn_block; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.lrn_block IS 'lrn block';


--
-- Name: COLUMN resource.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.client_id IS 'æ‰¹å‘å•†';


--
-- Name: COLUMN resource.tdm; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.tdm IS 'TDM';


--
-- Name: COLUMN resource.rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rate_table_id IS 'è´¹çŽ‡æ¨¡æ¿';


--
-- Name: COLUMN resource.transnexus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.transnexus IS 'transnexus';


--
-- Name: COLUMN resource.route_strategy_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.route_strategy_id IS 'è·¯ç”±ç­–ç•¥';


--
-- Name: COLUMN resource.media_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.media_type IS '0ï¼ï¼Proxy Media + Transcoding
1ï¼ï¼Proxy Media
2ï¼ï¼Bypass Media';


--
-- Name: COLUMN resource.pass_through; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.pass_through IS 'å·ç é€ä¼ è§„åˆ™
1--é€ä¼
2--ä¸é€ä¼
3--ä¸é€ä¼ ç¦æ˜¾ ';


--
-- Name: COLUMN resource.profit_margin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.profit_margin IS 'æœ€ä½Žåˆ©æ¶¦çŽ‡';


--
-- Name: COLUMN resource.enough_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.enough_balance IS 'æ˜¯å¦ä½™é¢ä¸è¶³';


--
-- Name: COLUMN resource.proto; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.proto IS '1--sip
2--h323
0--all';


--
-- Name: COLUMN resource.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.status IS '1--untested
2--tested
3--failed';


--
-- Name: COLUMN resource.profit_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.profit_type IS '1--ç™¾åˆ†æ¯”
2--æ•°å€¼';


--
-- Name: COLUMN resource.cli_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.cli_type IS '0-white
1-white non cli
2-grey';


--
-- Name: COLUMN resource.auth_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.auth_type IS 'æƒé™å­—æ®µ

0 - ALL

1 - resource_auth

';


--
-- Name: COLUMN resource.marketplace; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.marketplace IS '0:International A-Z
1:US Domestic';


--
-- Name: COLUMN resource.rating_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rating_type IS '0:US JD
1:US Non-JD
2:OCN-LATA JD
3:OCN-LATA Non-JD';


--
-- Name: COLUMN resource.billing_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.billing_type IS '0:DNIS
1:LRN
2:LRN Block All
3:LRN Block Higher Rate Codes Only
';


--
-- Name: COLUMN resource.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.trunk_type IS '1-class4
2-exchange
3-product_default
4-product_agent';


--
-- Name: COLUMN resource.service_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.service_type IS '0:Self  Service
1:Standand Deck';


--
-- Name: COLUMN resource.rpid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rpid IS 'Remote-Party-ID:

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.paid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.paid IS 'P-Asserted-Identity:

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.oli; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.oli IS 'From: <...;isup-oli=>

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.pci; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.pci IS 'P-Charge-Info:

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.priv; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.priv IS 'Privacy:

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.div; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.div IS 'Diversion:

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.billing_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.billing_method IS '0 - by minutes

1- by port';


--
-- Name: COLUMN resource.amount_per_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.amount_per_port IS 'money per port';


--
-- Name: COLUMN resource.agent_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.agent_type IS '1-exchange
2-default agent
3-client agent';


--
-- Name: COLUMN resource.bill_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.bill_by IS '0 -- DNISï¼ŒDNISè®¡è´¹ï¼Œä¸éœ€è¦æŸ¥è¯¢LRN
1 -- LRNï¼ŒLRNè®¡è´¹ï¼Œå¿½ç•¥è¿è¥å•†å˜åŒ–
2 -- LRN Blockï¼ŒLRNè®¡è´¹å·ç è¿è¥å•†æœ‰æ”¹å˜ï¼Œåˆ™æ‹’ç»
3 -- LRN Block Higher Rateï¼ŒLRNè´¹çŽ‡é«˜äºŽDNISè´¹çŽ‡
4 -- Follow Rate Deckï¼Œä½¿ç”¨è´¹çŽ‡è¡¨çš„ä»¥ä¸Šé…ç½®';


--
-- Name: COLUMN resource.rate_profile; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rate_profile IS '0 --- false
1 --- true';


--
-- Name: COLUMN resource.us_route; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.us_route IS '0 --- other
1 --- intra
2 --- inter
3 --- highest';


--
-- Name: COLUMN resource.intl_route; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.intl_route IS '0 --- other
1 --- intra
2 --- inter
3 --- highest';


--
-- Name: COLUMN resource.canada_route; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.canada_route IS '0 --- other
1 --- intra
2 --- inter
3 --- highest';


--
-- Name: COLUMN resource.rate_decimal; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rate_decimal IS 'å†³å®šè´¹çŽ‡çš„å°æ•°ä½å–å¤šå°‘ä½ã€‚';


--
-- Name: COLUMN resource.rate_rounding; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rate_rounding IS 'è´¹çŽ‡å°æ•°ä½æ–¹æ³•ï¼š
0 --- èˆå…¥
1 --- èˆå¼ƒ';


--
-- Name: COLUMN resource.us_other; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.us_other IS '0 --- other

1 --- intra

2 --- inter

3 --- highest';


--
-- Name: COLUMN resource.canada_other; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.canada_other IS '0 --- other

1 --- intra

2 --- inter

3 --- highest';


--
-- Name: COLUMN resource.redirect; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.redirect IS '0 --- false
1 --- true';


--
-- Name: COLUMN resource.lrn_prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.lrn_prefix IS '0 --- false
1 --- true (default)';


--
-- Name: COLUMN resource.pass_response_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.pass_response_code IS '0 -- false, 1 -- true, å¦‚æžœæ­¤é€‰é¡¹è®¾ç½®true, åˆ™ä»Žegressè¿”å›žè¿‡æ¥çš„æœ€åŽä¸€ä¸ªsipé”™è¯¯ç è¿”å›žç»™ingress';


--
-- Name: COLUMN resource.is_del; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.is_del IS '0: not del
1: is del';


--
-- Name: COLUMN resource.dtmf_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.dtmf_type IS '0 -- æ‰€æœ‰
1 -- info
2 -- rfc2833
3 -- inband

baohq 20140408 create
baohq 20140520 update';


--
-- Name: COLUMN resource.dtmf_detect; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.dtmf_detect IS '0 -- è‡ªåŠ¨æ£€æµ‹ï¼Œmedia_type = transcode
1 -- é¢„å®šæ£€æµ‹ï¼Œmedia_type = transcodeå¹¶ä¸”ä¸»è¢«å«dtmfä¸åŒå¹¶ä¸”æœ‰ç›¸åŒè¯­éŸ³ç¼–ç 

baohq add 20140408';


--
-- Name: COLUMN resource.rpid_screen; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rpid_screen IS '0 -- none ä¸å¸¦screen
1 -- no
2 -- yes
3 -- proxy ä½¿ç”¨ä¸»å«RPID screen

baohq20140514';


--
-- Name: COLUMN resource.rpid_party; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rpid_party IS '0 --- none å‘¼å‡ºä¸å¸¦party
1 --- calling
2 --- called
3 --- proxy ä½¿ç”¨ä¸»å«RPID party

baohq20140514';


--
-- Name: COLUMN resource.display_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.display_name IS '0 --- false
1 --- true

å‘¼å‡ºæ—¶æ˜¯å¦é€ä¼ ä¸»å«çš„æ˜¾ç¤ºåå­—

baohq20140514';


--
-- Name: COLUMN resource.rpid_id_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rpid_id_type IS '0 --- none å‘¼å‡ºä¸å¸¦id_type
1 --- subscriber
2 --- user
3 --- term
4 --- proxy ä½¿ç”¨ä¸»å«RPID id_type

baohq20140514';


--
-- Name: COLUMN resource.rpid_privacy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rpid_privacy IS '0 --- none å‘¼å‡ºä¸å¸¦privacy
1 --- full
2 --- name
3 --- url
4 --- off
5 --- ipaddr
6 --- proxy ä½¿ç”¨ä¸»å«RPID privacy

baohq20140514';


--
-- Name: COLUMN resource.counter_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.counter_time IS 'loop detectionä½¿ç”¨ï¼Œå•ä½ç§’
è¿™ä¸ªæ—¶é—´æ®µå†…æ”¶åˆ°å¤šå°‘ä¸ªä¸»è¢«å«ä¸€æ ·çš„å‘¼å«ï¼Œåˆ™blockã€‚

baohq-20140620';


--
-- Name: COLUMN resource.number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.number IS 'loop detectionä½¿ç”¨ï¼Œè¡¨ç¤ºæ•°é‡
æŸä¸ªæ—¶é—´æ®µå†…æ”¶åˆ°è¿™ä¸ªæ•°å­—çš„ä¸»è¢«å«ä¸€æ ·çš„å‘¼å«ï¼Œåˆ™blockã€‚

baohq-20140620';


--
-- Name: COLUMN resource.block_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.block_time IS 'loop detectionä½¿ç”¨ï¼Œå•ä½ç§’
æ»¡è¶³blockçš„æ¡ä»¶åŽblockå¤šé•¿æ—¶é—´ã€‚

baohq-20140620';


--
-- Name: COLUMN resource.re_invite; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.re_invite IS '0 -- false
1 -- true

å‘é€re-INVITEæ£€æµ‹å¯¹æ–¹æ˜¯å¦æ´»è·ƒ';


--
-- Name: COLUMN resource.re_invite_interval; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.re_invite_interval IS 'ç§’å•ä½ï¼Œå»ºè®®ä¸å°äºŽ60ç§’';


--
-- Name: COLUMN resource.info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.info IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource.rfc2833; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.rfc2833 IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource.inband; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.inband IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource.dummy_trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource.dummy_trunk IS 'æ˜¯å¦ä¸ºorigination clientä¸­çš„failoverçš„trunk';


--
-- Name: route; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE route (
    route_id integer NOT NULL,
    digits prefix_range DEFAULT ''::prefix_range,
    dynamic_route_id integer,
    static_route_id integer,
    route_type integer NOT NULL,
    route_strategy_id integer NOT NULL,
    lnp boolean DEFAULT false,
    lrn_block boolean DEFAULT false,
    dnis_only boolean DEFAULT true,
    code_deck_type integer DEFAULT 0,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    intra_static_route_id integer,
    inter_static_route_id integer,
    jurisdiction_country_id integer,
    ani_prefix prefix_range,
    ani_min_length integer DEFAULT 0,
    ani_max_length integer DEFAULT 32,
    digits_min_length integer DEFAULT 0,
    digits_max_length integer DEFAULT 32,
    code_name character varying,
    country character varying(50),
    route_type_flg integer
);


ALTER TABLE route OWNER TO postgres;

--
-- Name: TABLE route; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE route IS 'è·¯ç”±';


--
-- Name: COLUMN route.route_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN route.route_id IS 'ä¸»é”®';


--
-- Name: COLUMN route.digits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN route.digits IS 'å‰ç¼€';


--
-- Name: COLUMN route.dynamic_route_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN route.dynamic_route_id IS 'åŠ¨æ€è·¯ç”±';


--
-- Name: COLUMN route.static_route_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN route.static_route_id IS 'é™æ€è·¯ç”±';


--
-- Name: COLUMN route.route_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN route.route_type IS 'è·¯ç”±æ–¹å¼
1--åŠ¨æ€è·¯ç”±
2--é™æ€è·¯ç”±
3--åŠ¨æ€è·¯ç”±åŽå†é™æ€è·¯ç”±
4--é™æ€è·¯ç”±åŽå†åŠ¨æ€è·¯ç”±';


--
-- Name: COLUMN route.route_strategy_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN route.route_strategy_id IS 'è·¯ç”±ç­–ç•¥';


--
-- Name: COLUMN route.code_deck_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN route.code_deck_type IS '0-icx code deck
1-custom code deck';


--
-- Name: route_strategy; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE route_strategy (
    route_strategy_id integer NOT NULL,
    name character varying(256) NOT NULL,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    is_virtual boolean
);


ALTER TABLE route_strategy OWNER TO postgres;

--
-- Name: TABLE route_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE route_strategy IS 'è·¯ç”±ç­–ç•¥';


--
-- Name: COLUMN route_strategy.route_strategy_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN route_strategy.route_strategy_id IS 'ä¸»é”®';


--
-- Name: COLUMN route_strategy.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN route_strategy.name IS 'åç§°';


--
-- Name: alternative_route_report; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW alternative_route_report AS
 SELECT product.name,
    product_items.digits,
    'Static Route'::text AS type
   FROM (((product_items
     JOIN product ON ((product_items.product_id = product.product_id)))
     JOIN product_items_resource ON ((product_items.item_id = product_items_resource.item_id)))
     JOIN resource ON ((product_items_resource.resource_id = resource.resource_id)))
  WHERE (product_items.item_id IN ( SELECT product_items_resource_1.item_id
           FROM product_items_resource product_items_resource_1
          GROUP BY product_items_resource_1.item_id
         HAVING (count(*) = 1)))
UNION
 SELECT dynamic_route.name,
    ''::prefix_range AS digits,
    'Dynamic Route'::text AS type
   FROM ((dynamic_route
     JOIN dynamic_route_items ON ((dynamic_route.dynamic_route_id = dynamic_route_items.dynamic_route_id)))
     JOIN resource ON ((dynamic_route_items.resource_id = resource.resource_id)))
  WHERE (dynamic_route.dynamic_route_id IN ( SELECT dynamic_route_items_1.dynamic_route_id
           FROM dynamic_route_items dynamic_route_items_1
          GROUP BY dynamic_route_items_1.dynamic_route_id
         HAVING (count(*) = 1)))
UNION
 SELECT route_strategy.name,
    route.digits,
    'Route Plan'::text AS type
   FROM (route_strategy
     LEFT JOIN route ON ((route_strategy.route_strategy_id = route.route_strategy_id)))
  WHERE ((EXISTS ( SELECT dynamic_route_items.dynamic_route_id
           FROM dynamic_route_items
          GROUP BY dynamic_route_items.dynamic_route_id
         HAVING ((count(*) = 1) AND (dynamic_route_items.dynamic_route_id = route.dynamic_route_id)))) OR (EXISTS ( SELECT product_items_resource.item_id
           FROM (product_items_resource
             JOIN product_items ON ((product_items_resource.item_id = product_items.item_id)))
          WHERE (product_items.product_id = route.static_route_id)
          GROUP BY product_items_resource.item_id
         HAVING (count(*) = 1))));


ALTER TABLE alternative_route_report OWNER TO postgres;

--
-- Name: ani_blocking_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ani_blocking_log (
    id integer NOT NULL,
    rule_name character varying(100),
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    type integer DEFAULT 0 NOT NULL,
    res_block_id integer,
    dialer_detection_id integer,
    ani character varying(50)
);


ALTER TABLE ani_blocking_log OWNER TO postgres;

--
-- Name: ani_blocking_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ani_blocking_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ani_blocking_log_id_seq OWNER TO postgres;

--
-- Name: ani_blocking_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ani_blocking_log_id_seq OWNED BY ani_blocking_log.id;


--
-- Name: api_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE api_log (
    id integer NOT NULL,
    "time" integer,
    request text,
    status integer
);


ALTER TABLE api_log OWNER TO postgres;

--
-- Name: api_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE api_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE api_log_id_seq OWNER TO postgres;

--
-- Name: api_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE api_log_id_seq OWNED BY api_log.id;


--
-- Name: rate_bot_import_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_bot_import_logs (
    id integer NOT NULL,
    status  int default 0,
	email_subject varchar(100),
	email_from varchar(100),
	email_time varchar(100),
	start_time   timestamp with time zone DEFAULT now(),
	finish_time  timestamp with time zone ,
	rule_name varchar(100),
	error_msg varchar(200),
	mail_vendor varchar(128)
);


ALTER TABLE rate_bot_import_logs OWNER TO postgres;

--
-- Name: rate_bot_import_logs_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_bot_import_logs_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_bot_import_logs_seq OWNER TO postgres;

--
-- Name: rate_bot_import_logs_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_bot_import_logs_seq OWNED BY rate_bot_import_logs.id;

--
-- Name: rate_bot_import_logs id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_bot_import_logs ALTER COLUMN id SET DEFAULT nextval('rate_bot_import_logs_seq'::regclass);

--
-- Name: rate_bot_import_logs rate_bot_import_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_bot_import_logs
    ADD CONSTRAINT rate_bot_import_logs_pkey PRIMARY KEY (id);
    

--
-- Name: authorization_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE authorization_logs (
    id integer,
    direction integer,
    auth_type integer,
    error_type integer,
    request_ip ip4r,
    request_port integer,
    username character varying(64),
    authname character varying(64),
    sip_callid character varying(128),
    "time" bigint
);


ALTER TABLE authorization_logs OWNER TO postgres;

--
-- Name: TABLE authorization_logs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE authorization_logs IS 'èº«ä»½éªŒè¯ç›¸å…³çš„æ—¥å¿—

baohq20140430';


--
-- Name: COLUMN authorization_logs.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN authorization_logs.id IS 'é€’å¢žçš„åºåˆ—å·

baohq20140504';


--
-- Name: COLUMN authorization_logs.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN authorization_logs.direction IS 'in -- 0
out -- 1

baohq20140504
';


--
-- Name: COLUMN authorization_logs.auth_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN authorization_logs.auth_type IS 'REGISTER -- 0
INVITE -- 1

baohq20140504';


--
-- Name: COLUMN authorization_logs.error_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN authorization_logs.error_type IS '0 -- normal
1 -- auth params incomplete
2 -- user nothingness
3 -- wrong password
4 -- wrong username

baohq20140504';


--
-- Name: COLUMN authorization_logs.request_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN authorization_logs.request_ip IS 'å‘é€æºIP

baohq20140504';


--
-- Name: COLUMN authorization_logs.request_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN authorization_logs.request_port IS 'å‘åŒ…æºç«¯å£

baohq20140504';


--
-- Name: COLUMN authorization_logs.username; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN authorization_logs.username IS 'sip ç”¨æˆ·åæˆ–ç”¨æˆ·IDï¼Œ ä¹Ÿæ˜¯fromçš„ç”µè¯å·ç 

baohq20140504';


--
-- Name: COLUMN authorization_logs.authname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN authorization_logs.authname IS 'è®¤è¯ä½¿ç”¨çš„ç”¨æˆ·åï¼Œä¸æ˜¯to, fromç­‰ç”¨æˆ·åï¼Œæ˜¯authorizationåŠ å¯†çš„ç”¨æˆ·åã€‚

baohq20140504';


--
-- Name: COLUMN authorization_logs.sip_callid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN authorization_logs.sip_callid IS 'REGISTERæˆ–INVITEæ¶ˆæ¯çš„sip call id

baohq20140504';


--
-- Name: COLUMN authorization_logs."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN authorization_logs."time" IS 'å‘ç”Ÿè®°å½•æ—¶é—´ï¼Œä¹Ÿå°±æ˜¯é”™è¯¯äº§ç”Ÿæ—¶é—´ã€‚

baohq20140504';


--
-- Name: automatic_rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE automatic_rate (
    id integer NOT NULL,
    egress_id integer,
    day integer,
    start_line integer,
    format character varying(255),
    end_date_type integer,
    end_date_when integer,
    from_email character varying(255)
);


ALTER TABLE automatic_rate OWNER TO postgres;

--
-- Name: COLUMN automatic_rate.end_date_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN automatic_rate.end_date_type IS '0 --  End Date All Codes
1 -- End Date Uploaded Codes
';


--
-- Name: COLUMN automatic_rate.end_date_when; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN automatic_rate.end_date_when IS '0 -- Set End Date to 7 days after rate is received.
1 -- Set End Date to right before the earliest effective date.';


--
-- Name: automatic_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE automatic_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE automatic_rate_id_seq OWNER TO postgres;

--
-- Name: automatic_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE automatic_rate_id_seq OWNED BY automatic_rate.id;


--
-- Name: backup_clean; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE backup_clean (
    id integer NOT NULL,
    clean_type integer
);


ALTER TABLE backup_clean OWNER TO postgres;

--
-- Name: COLUMN backup_clean.clean_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN backup_clean.clean_type IS 'cdr
record
qos';


--
-- Name: backup_clean_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE backup_clean_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE backup_clean_id_seq OWNER TO postgres;

--
-- Name: backup_clean_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE backup_clean_id_seq OWNED BY backup_clean.id;


--
-- Name: backup_limit_state; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE backup_limit_state (
    cps character varying(100),
    cap character varying(100),
    cps_i character varying(100),
    cap_i character varying(100),
    cps_e character varying(100),
    cap_e character varying(100),
    cap_w character varying(100),
    cap_o character varying(100),
    id_type character varying(100),
    long_time character varying(100),
    pid character varying(100),
    key character varying(100),
    listen_ip character varying(100),
    listen_port character varying(100),
    up_time character varying(100)
);


ALTER TABLE backup_limit_state OWNER TO postgres;

--
-- Name: backup_peak_state; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE backup_peak_state (
    curr character varying(100),
    _24hr character varying(100),
    _7day character varying(100),
    rece character varying(100),
    curr_t character varying(100),
    _24hr_t character varying(100),
    _7day_t character varying(100),
    id_type character varying(100),
    pid character varying(100),
    listen_ip character varying(100),
    listen_port character varying(100),
    up_time character varying(100)
);


ALTER TABLE backup_peak_state OWNER TO postgres;

--
-- Name: bad_number_detection_rules_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE bad_number_detection_rules_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE bad_number_detection_rules_seq OWNER TO postgres;

--
-- Name: bad_number_detection_rules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE bad_number_detection_rules (
    id integer DEFAULT nextval('bad_number_detection_rules_seq'::regclass),
    name character varying(30) NOT NULL,
    target integer,
    valid_attempts integer,
    p200 integer,
    p404 integer,
    p503 integer,
    p480 integer,
    p486 integer,
    p487 integer,
    p45 integer,
    asr integer,
    acd integer,
    block_type integer,
    trunk_list text,
    exec_every integer,
    from_last integer,
    last_executed timestamp with time zone,
    ip character varying(15)
);


ALTER TABLE bad_number_detection_rules OWNER TO postgres;

--
-- Name: balance_daily_reset_task; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE balance_daily_reset_task (
    id integer NOT NULL,
    start_time timestamp with time zone,
    reset_balance smallint,
    mutual smallint,
    actual smallint,
    client_id integer,
    status smallint DEFAULT 0 NOT NULL,
    finished_time timestamp with time zone,
    create_by character varying(100),
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE balance_daily_reset_task OWNER TO postgres;

--
-- Name: COLUMN balance_daily_reset_task.start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN balance_daily_reset_task.start_time IS 'The start time of balance daily resetting';


--
-- Name: COLUMN balance_daily_reset_task.reset_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN balance_daily_reset_task.reset_balance IS '1 for reset client balance, other for ignore';


--
-- Name: COLUMN balance_daily_reset_task.mutual; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN balance_daily_reset_task.mutual IS '1 for reset mutual balance, other for ignore';


--
-- Name: COLUMN balance_daily_reset_task.actual; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN balance_daily_reset_task.actual IS '1 for reset actual balance, other for ignore';


--
-- Name: COLUMN balance_daily_reset_task.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN balance_daily_reset_task.client_id IS '0 for all client, other is the specified client ID';


--
-- Name: COLUMN balance_daily_reset_task.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN balance_daily_reset_task.status IS '0 for initial; 1 for in process, 2 for finished; 3 for error';


--
-- Name: balance_daily_reset_task_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE balance_daily_reset_task_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE balance_daily_reset_task_id_seq OWNER TO postgres;

--
-- Name: balance_daily_reset_task_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE balance_daily_reset_task_id_seq OWNED BY balance_daily_reset_task.id;


--
-- Name: balance_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE balance_history (
    id integer NOT NULL,
    date date,
    payment_received numeric(20,5) DEFAULT 0 NOT NULL,
    credit_note_sent numeric(20,5) DEFAULT 0 NOT NULL,
    debit_note_sent numeric(20,5) DEFAULT 0 NOT NULL,
    payment_sent numeric(20,5) DEFAULT 0 NOT NULL,
    credit_note_received numeric(20,5) DEFAULT 0 NOT NULL,
    debit_note_received numeric(20,5) DEFAULT 0 NOT NULL,
    invoice_set numeric(20,5) DEFAULT 0 NOT NULL,
    invoice_received numeric(20,5) DEFAULT 0 NOT NULL,
    mutual_balance numeric(20,5) NOT NULL,
    client_id integer,
    mutual_ingress_balance numeric(20,5) DEFAULT 0 NOT NULL,
    mutual_egress_balance numeric(20,5) DEFAULT 0 NOT NULL
);


ALTER TABLE balance_history OWNER TO postgres;

--
-- Name: balance_history_actual; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE balance_history_actual (
    id integer NOT NULL,
    date date,
    payment_received numeric(20,5) DEFAULT 0 NOT NULL,
    credit_note_sent numeric(20,5) DEFAULT 0 NOT NULL,
    debit_note_sent numeric(20,5) DEFAULT 0 NOT NULL,
    unbilled_incoming_traffic numeric(20,5) DEFAULT 0 NOT NULL,
    short_charges numeric(20,5) DEFAULT 0 NOT NULL,
    payment_sent numeric(20,5) DEFAULT 0 NOT NULL,
    credit_note_received numeric(20,5) DEFAULT 0 NOT NULL,
    debit_note_received numeric(20,5) DEFAULT 0 NOT NULL,
    unbilled_outgoing_traffic numeric(20,5) DEFAULT 0 NOT NULL,
    actual_balance numeric(20,5) NOT NULL,
    client_id integer,
    actual_ingress_balance numeric(20,5) DEFAULT 0 NOT NULL,
    actual_egress_balance numeric(20,5) DEFAULT 0 NOT NULL
);


ALTER TABLE balance_history_actual OWNER TO postgres;

--
-- Name: balance_history_actual_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE balance_history_actual_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE balance_history_actual_id_seq OWNER TO postgres;

--
-- Name: balance_history_actual_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE balance_history_actual_id_seq OWNED BY balance_history_actual.id;


--
-- Name: balance_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE balance_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE balance_history_id_seq OWNER TO postgres;

--
-- Name: balance_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE balance_history_id_seq OWNED BY balance_history.id;


--
-- Name: balance_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE balance_log (
    id integer NOT NULL,
    client_id integer,
    balance numeric(30,6),
    date date DEFAULT ('now'::text)::date,
    ingress_balance numeric(30,6),
    egress_balance numeric(30,6)
);


ALTER TABLE balance_log OWNER TO postgres;

--
-- Name: balance_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE balance_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE balance_log_id_seq OWNER TO postgres;

--
-- Name: balance_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE balance_log_id_seq OWNED BY balance_log.id;


--
-- Name: block_ani; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE block_ani (
    id integer NOT NULL,
    ingress integer,
    asr real,
    acd real,
    blocked_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    email boolean DEFAULT false,
    block boolean DEFAULT false,
    ani character varying(255),
    egress integer,
    calls integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    action_id integer,
    unblock_time timestamp without time zone,
    rule_id integer,
    condition_id integer,
    code_name character varying(100)
);


ALTER TABLE block_ani OWNER TO postgres;

--
-- Name: block_ani_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE block_ani_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE block_ani_id_seq OWNER TO postgres;

--
-- Name: block_ani_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE block_ani_id_seq OWNED BY block_ani.id;


--
-- Name: block_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE block_log (
    log_id integer NOT NULL,
    block_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    block_by character varying(100),
    code_detail character varying(500),
    re_enable_time timestamp with time zone,
    asr character varying(100),
    abr character varying(100),
    acd character varying(100),
    pdd character varying(100),
    margin character varying(100),
    re_enable boolean DEFAULT false,
    type smallint DEFAULT 0 NOT NULL
);


ALTER TABLE block_log OWNER TO postgres;

--
-- Name: COLUMN block_log.block_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN block_log.block_by IS 'rule name';


--
-- Name: COLUMN block_log.code_detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN block_log.code_detail IS 'Code Name/Code';


--
-- Name: COLUMN block_log.re_enable_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN block_log.re_enable_time IS 'è‡ªåŠ¨é‡å¯çš„æ—¶é—´';


--
-- Name: COLUMN block_log.margin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN block_log.margin IS 'profitability';


--
-- Name: COLUMN block_log.re_enable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN block_log.re_enable IS 'æ˜¯å¦å·²ç»è¿˜åŽŸ';


--
-- Name: block_log_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE block_log_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE block_log_log_id_seq OWNER TO postgres;

--
-- Name: block_log_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE block_log_log_id_seq OWNED BY block_log.log_id;


--
-- Name: block_loop; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE block_loop (
    id integer NOT NULL,
    name character varying(100),
    loop_interval integer,
    loop_count integer,
    block_interval integer
);


ALTER TABLE block_loop OWNER TO postgres;

--
-- Name: COLUMN block_loop.block_interval; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN block_loop.block_interval IS '0-forever';


--
-- Name: block_loop_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE block_loop_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE block_loop_id_seq OWNER TO postgres;

--
-- Name: block_loop_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE block_loop_id_seq OWNED BY block_loop.id;


--
-- Name: block_loop_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE block_loop_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    loop_count integer
);


ALTER TABLE block_loop_log OWNER TO postgres;

--
-- Name: block_loop_log_calls; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE block_loop_log_calls (
    id integer NOT NULL,
    block_loop_log_id integer NOT NULL,
    ani character varying(50),
    dnis character varying(50),
    loop_count integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone
);


ALTER TABLE block_loop_log_calls OWNER TO postgres;

--
-- Name: block_loop_log_calls_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE block_loop_log_calls_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE block_loop_log_calls_id_seq OWNER TO postgres;

--
-- Name: block_loop_log_calls_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE block_loop_log_calls_id_seq OWNED BY block_loop_log_calls.id;


--
-- Name: block_loop_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE block_loop_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE block_loop_log_id_seq OWNER TO postgres;

--
-- Name: block_loop_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE block_loop_log_id_seq OWNED BY block_loop_log.id;


--
-- Name: block_ticket; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE block_ticket (
    id integer NOT NULL,
    ingress integer,
    asr real,
    acd real,
    blocked_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    email boolean DEFAULT false,
    block boolean DEFAULT false,
    dnis character varying(255),
    egress integer,
    calls integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    code_name character varying(100),
    rule_name character varying(100),
    not_zero_calls integer,
    unblock_time timestamp without time zone
);


ALTER TABLE block_ticket OWNER TO postgres;

--
-- Name: block_ticket_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE block_ticket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE block_ticket_id_seq OWNER TO postgres;

--
-- Name: block_ticket_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE block_ticket_id_seq OWNED BY block_ticket.id;


--
-- Name: block_trouble_ticket; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE block_trouble_ticket (
    id integer NOT NULL,
    block_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    block_by character varying(100),
    code_detail character varying(500),
    asr character varying(100),
    abr character varying(100),
    acd character varying(100),
    pdd character varying(100),
    margin character varying(100),
    email character varying(100)
);


ALTER TABLE block_trouble_ticket OWNER TO postgres;

--
-- Name: COLUMN block_trouble_ticket.block_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN block_trouble_ticket.block_by IS 'rule name';


--
-- Name: COLUMN block_trouble_ticket.code_detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN block_trouble_ticket.code_detail IS 'Code Name/Code';


--
-- Name: COLUMN block_trouble_ticket.margin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN block_trouble_ticket.margin IS 'profitability';


--
-- Name: COLUMN block_trouble_ticket.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN block_trouble_ticket.email IS 'noc_email';


--
-- Name: block_trouble_ticket_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE block_trouble_ticket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE block_trouble_ticket_id_seq OWNER TO postgres;

--
-- Name: block_trouble_ticket_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE block_trouble_ticket_id_seq OWNED BY block_trouble_ticket.id;


--
-- Name: buy_order; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE buy_order (
    id integer NOT NULL,
    name character varying(40),
    client_id integer NOT NULL,
    resource_id integer NOT NULL,
    code_deck_id integer DEFAULT 1,
    rate numeric(30,10) NOT NULL,
    is_private boolean DEFAULT false NOT NULL,
    is_commit boolean DEFAULT false NOT NULL,
    commit_minutes integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    cli boolean DEFAULT false NOT NULL,
    g729 boolean DEFAULT false NOT NULL,
    fax boolean DEFAULT false NOT NULL,
    active boolean DEFAULT true NOT NULL,
    status integer DEFAULT 0 NOT NULL,
    expire_time timestamp with time zone,
    country character varying(100),
    acd real,
    asr real,
    user_id integer NOT NULL,
    dtmf boolean DEFAULT false NOT NULL,
    state_date timestamp with time zone NOT NULL,
    end_date timestamp with time zone,
    limit_price numeric(30,10),
    g723 boolean DEFAULT false NOT NULL,
    g711 boolean DEFAULT false NOT NULL,
    time_of_date boolean DEFAULT false NOT NULL,
    peak boolean DEFAULT false NOT NULL,
    offpeak boolean DEFAULT false NOT NULL,
    weekend boolean DEFAULT false NOT NULL,
    currency_id integer,
    asr_var real,
    acd_var real,
    rate_only boolean DEFAULT false NOT NULL,
    match_type integer DEFAULT 2 NOT NULL,
    route_priority integer DEFAULT 1 NOT NULL,
    invite_id integer,
    partner_id integer,
    resource_prefix prefix_range DEFAULT ''::prefix_range NOT NULL,
    route_type integer DEFAULT 1 NOT NULL,
    auto_match boolean DEFAULT false NOT NULL,
    auto_match_result integer,
    dialer boolean DEFAULT false NOT NULL,
    "interval" integer DEFAULT 1 NOT NULL,
    "limit" integer,
    minimal_duration integer,
    purged boolean DEFAULT false NOT NULL,
    cli_type integer DEFAULT 0 NOT NULL,
    pdd_timeout integer,
    pdd_var integer,
    auto_match_time timestamp with time zone,
    min_threedays integer
);


ALTER TABLE buy_order OWNER TO postgres;

--
-- Name: COLUMN buy_order.match_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN buy_order.match_type IS '1--var
2--soft
3--hard';


--
-- Name: COLUMN buy_order.route_priority; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN buy_order.route_priority IS '1--quality
2--price';


--
-- Name: COLUMN buy_order.route_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN buy_order.route_type IS '1:Prime,
2:Select,
3:Direct
';


--
-- Name: COLUMN buy_order.auto_match_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN buy_order.auto_match_result IS '0-fail
1-success';


--
-- Name: COLUMN buy_order.minimal_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN buy_order.minimal_duration IS 'rateçš„min_time';


--
-- Name: COLUMN buy_order.cli_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN buy_order.cli_type IS '0-white
1-white non cli
2-grey';


--
-- Name: buy_order_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE buy_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE buy_order_id_seq OWNER TO postgres;

--
-- Name: buy_order_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE buy_order_id_seq OWNED BY buy_order.id;


--
-- Name: buy_order_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE buy_order_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE buy_order_record_record_id_seq OWNER TO postgres;

--
-- Name: buy_order_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE buy_order_record (
    id integer,
    name character varying(40),
    client_id integer,
    resource_id integer,
    code_deck_id integer,
    rate numeric(30,10),
    is_private boolean,
    is_commit boolean,
    commit_minutes integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    cli boolean,
    g729 boolean,
    fax boolean,
    active boolean,
    status integer,
    expire_time timestamp with time zone,
    country character varying(100),
    acd real,
    asr real,
    user_id integer,
    dtmf boolean,
    state_date timestamp with time zone,
    end_date timestamp with time zone,
    limit_price numeric(30,10),
    g723 boolean,
    g711 boolean,
    time_of_date boolean,
    peak boolean,
    offpeak boolean,
    weekend boolean,
    currency_id integer,
    asr_var real,
    acd_var real,
    rate_only boolean,
    match_type integer,
    route_priority integer,
    invite_id integer,
    partner_id integer,
    resource_prefix prefix_range,
    route_type integer,
    auto_match boolean,
    auto_match_result integer,
    dialer boolean,
    "interval" integer,
    "limit" integer,
    minimal_duration integer,
    purged boolean,
    cli_type integer,
    pdd_timeout integer,
    pdd_var integer,
    auto_match_time timestamp with time zone,
    min_threedays integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('buy_order_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE buy_order_record OWNER TO postgres;

--
-- Name: buy_order_response; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE buy_order_response (
    id integer NOT NULL,
    buy_order_id integer,
    client_id integer,
    is_commit boolean DEFAULT true NOT NULL,
    commit_minutes integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    status integer DEFAULT 0 NOT NULL,
    expire_time timestamp with time zone,
    resource_id integer,
    pdd_timeout integer,
    pdd_var integer
);


ALTER TABLE buy_order_response OWNER TO postgres;

--
-- Name: COLUMN buy_order_response.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN buy_order_response.client_id IS 'ä¹°è€…çš„client_id';


--
-- Name: buy_order_response_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE buy_order_response_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE buy_order_response_id_seq OWNER TO postgres;

--
-- Name: buy_order_response_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE buy_order_response_id_seq OWNED BY buy_order_response.id;


--
-- Name: buy_order_response_resource_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE buy_order_response_resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE buy_order_response_resource_id_seq OWNER TO postgres;

--
-- Name: c4_client_balance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE c4_client_balance (
    id integer NOT NULL,
    client_id character varying(100) NOT NULL,
    balance numeric(30,6) DEFAULT 0.00 NOT NULL,
    ingress_balance numeric(30,6) DEFAULT 0.00 NOT NULL,
    egress_balance numeric(30,6) DEFAULT 0.00 NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL
);


ALTER TABLE c4_client_balance OWNER TO postgres;

--
-- Name: COLUMN c4_client_balance.balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN c4_client_balance.balance IS 'current balance';


--
-- Name: COLUMN c4_client_balance.create_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN c4_client_balance.create_time IS 'balance update time';


--
-- Name: c4_client_balance_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE c4_client_balance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE c4_client_balance_id_seq OWNER TO postgres;

--
-- Name: c4_client_balance_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE c4_client_balance_id_seq OWNED BY c4_client_balance.id;


--
-- Name: c4_client_balance_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE c4_client_balance_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE c4_client_balance_record_record_id_seq OWNER TO postgres;

--
-- Name: c4_client_balance_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE c4_client_balance_record (
    id integer,
    client_id character varying(100),
    balance numeric(30,6),
    ingress_balance numeric(30,6),
    egress_balance numeric(30,6),
    create_time timestamp with time zone,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('c4_client_balance_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE c4_client_balance_record OWNER TO postgres;

--
-- Name: c4_livecall_user; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE c4_livecall_user (
    id integer NOT NULL,
    name character varying(50) NOT NULL,
    password character varying(50) NOT NULL,
    user_type smallint DEFAULT 0 NOT NULL
);


ALTER TABLE c4_livecall_user OWNER TO postgres;

--
-- Name: COLUMN c4_livecall_user.user_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN c4_livecall_user.user_type IS '0 for softswitch; 1 for web user';


--
-- Name: c4_livecall_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE c4_livecall_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE c4_livecall_user_id_seq OWNER TO postgres;

--
-- Name: c4_livecall_user_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE c4_livecall_user_id_seq OWNED BY c4_livecall_user.id;


--
-- Name: c4_livecall_user_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE c4_livecall_user_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE c4_livecall_user_record_record_id_seq OWNER TO postgres;

--
-- Name: c4_livecall_user_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE c4_livecall_user_record (
    id integer,
    name character varying(50),
    password character varying(50),
    user_type smallint,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('c4_livecall_user_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE c4_livecall_user_record OWNER TO postgres;

--
-- Name: c4_lrn; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE c4_lrn (
    id integer NOT NULL,
    srv1_ip character varying(16),
    srv1_port integer DEFAULT 5060 NOT NULL,
    srv2_ip character varying(16),
    srv2_port integer DEFAULT 5060 NOT NULL
);


ALTER TABLE c4_lrn OWNER TO postgres;

--
-- Name: COLUMN c4_lrn.srv1_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN c4_lrn.srv1_ip IS 'Master lrn server ip';


--
-- Name: COLUMN c4_lrn.srv2_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN c4_lrn.srv2_ip IS 'Slave lrn server ip';


--
-- Name: c4_lrn_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE c4_lrn_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE c4_lrn_id_seq OWNER TO postgres;

--
-- Name: c4_lrn_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE c4_lrn_id_seq OWNED BY c4_lrn.id;


--
-- Name: c4_lrn_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE c4_lrn_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE c4_lrn_record_record_id_seq OWNER TO postgres;

--
-- Name: c4_lrn_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE c4_lrn_record (
    id integer,
    srv1_ip character varying(16),
    srv1_port integer,
    srv2_ip character varying(16),
    srv2_port integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('c4_lrn_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE c4_lrn_record OWNER TO postgres;

--
-- Name: c4_spam_traffic_ip_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE c4_spam_traffic_ip_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE c4_spam_traffic_ip_record_record_id_seq OWNER TO postgres;

--
-- Name: call_monitor; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE call_monitor (
    id integer NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    ani character varying(50),
    dnis character varying(50),
    remote_ip character varying(50),
    remote_port character varying(50),
    status smallint DEFAULT 0
);


ALTER TABLE call_monitor OWNER TO postgres;

--
-- Name: call_monitor_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE call_monitor_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE call_monitor_id_seq OWNER TO postgres;

--
-- Name: call_monitor_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE call_monitor_id_seq OWNED BY call_monitor.id;


--
-- Name: captcha; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE captcha (
    captcha_id integer NOT NULL,
    captcha_time integer NOT NULL,
    ip_address character varying(16) DEFAULT 0 NOT NULL,
    word character varying(20) NOT NULL
);


ALTER TABLE captcha OWNER TO postgres;

--
-- Name: TABLE captcha; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE captcha IS 'ç™»å½•é¡µé¢çš„éªŒè¯ç ';


--
-- Name: captcha_captcha_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE captcha_captcha_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE captcha_captcha_id_seq OWNER TO postgres;

--
-- Name: captcha_captcha_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE captcha_captcha_id_seq OWNED BY captcha.captcha_id;


--
-- Name: capture_capture_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE capture_capture_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999
    CACHE 1;


ALTER TABLE capture_capture_id_seq OWNER TO postgres;

--
-- Name: capture; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE capture (
    capture_id integer DEFAULT nextval('capture_capture_id_seq'::regclass) NOT NULL,
    capture_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    file_name character varying(256),
    src_ip ip4r,
    src_port character varying(10),
    dest_ip ip4r,
    dest_port character varying(10),
    time_val integer,
    key_word character varying(100),
    view boolean NOT NULL,
    user_id integer,
    flag integer DEFAULT 2,
    ani character varying(40),
    dnis character varying(40),
    server_ip character varying,
    file_size integer,
    server_port integer
);


ALTER TABLE capture OWNER TO postgres;

--
-- Name: TABLE capture; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE capture IS 'æŠ“åŒ…è®°å½•';


--
-- Name: COLUMN capture.capture_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.capture_id IS 'ä¸»é”®';


--
-- Name: COLUMN capture.capture_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.capture_time IS 'æŠ“åŒ…æ—¶é—´';


--
-- Name: COLUMN capture.file_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.file_name IS 'æ–‡ä»¶åç§°';


--
-- Name: COLUMN capture.src_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.src_ip IS 'æºåœ°å€';


--
-- Name: COLUMN capture.src_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.src_port IS 'æºç«¯å£';


--
-- Name: COLUMN capture.dest_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.dest_ip IS 'ç›®çš„åœ°å€';


--
-- Name: COLUMN capture.dest_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.dest_port IS 'ç›®æ ‡ç«¯å£';


--
-- Name: COLUMN capture.time_val; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.time_val IS 'æŠ“åŒ…æ—¶é•¿';


--
-- Name: COLUMN capture.key_word; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.key_word IS 'å…³é”®å­—';


--
-- Name: COLUMN capture.view; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.view IS 'èƒ½å¦æŸ¥çœ‹';


--
-- Name: COLUMN capture.flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capture.flag IS '1---capture ç»“æŸ
2---capture æœªç»“æŸ';


--
-- Name: carrier_group; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE carrier_group (
    group_id integer NOT NULL,
    group_name character varying
);


ALTER TABLE carrier_group OWNER TO postgres;

--
-- Name: carrier_group_group_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE carrier_group_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE carrier_group_group_id_seq OWNER TO postgres;

--
-- Name: carrier_group_group_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE carrier_group_group_id_seq OWNED BY carrier_group.group_id;


--
-- Name: carrier_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE carrier_template (
    template_name character varying(100),
    create_by character varying(100),
    update_on timestamp with time zone,
    create_on timestamp with time zone,
    mode integer DEFAULT 1 NOT NULL,
    currency_id integer NOT NULL,
    unlimited_credit integer DEFAULT 0,
    allowed_credit numeric(30,10) DEFAULT 0 NOT NULL,
    profit_margin double precision DEFAULT 0 NOT NULL,
    profit_type integer DEFAULT 1 NOT NULL,
    cps_limit integer,
    call_limit integer,
    daily_limit integer,
    hourly_limit integer,
    auto_summary_hour integer,
    auto_summary_period integer DEFAULT 24,
    auto_send_zone character varying DEFAULT '+00:00'::character varying,
    auto_summary_include_cdr integer DEFAULT 0,
    auto_daily_balance_recipient integer DEFAULT 0,
    is_auto_summary integer DEFAULT 0,
    auto_summary_not_zero smallint DEFAULT 0,
    auto_summary_group_by smallint DEFAULT 0,
    is_auto_balance integer DEFAULT 0,
    numer_of_days_balance integer DEFAULT 1,
    daily_cdr_generation_zone character varying DEFAULT '+00:00'::character varying,
    daily_cdr_generation_type smallint DEFAULT 0,
    scc_bellow integer DEFAULT 0,
    scc_percent integer DEFAULT 0,
    scc_charge numeric(30,10),
    scc_type integer DEFAULT 0,
    auto_invoicing integer DEFAULT 1 NOT NULL,
    include_tax integer DEFAULT 0,
    tax integer,
    invoice_start_from date,
    attach_cdrs_list integer,
    invoice_show_details integer DEFAULT 0,
    invoice_jurisdictional_detail integer DEFAULT 0,
    decimal_place integer DEFAULT 5,
    rate_value integer DEFAULT 0,
    is_email_invoice integer DEFAULT 0,
    email_invoice integer DEFAULT 0,
    include_available_credit smallint DEFAULT 0,
    is_invoice_account_summary integer DEFAULT 0,
    invoice_use_balance_type integer DEFAULT 0,
    is_show_daily_usage integer DEFAULT 0,
    is_short_duration_call_surcharge_detail integer DEFAULT 0,
    invoice_include_payment integer,
    is_show_daily_trunk integer DEFAULT 0,
    is_show_total_trunk integer DEFAULT 0,
    is_show_code_100 integer DEFAULT 0,
    is_show_code_name integer DEFAULT 0,
    is_show_country integer DEFAULT 0,
    is_show_by_date integer DEFAULT 0,
    usage_detail_fields text,
    is_breakdown_by_rate_table integer,
    breakdown_by_rate_table smallint,
    daily_balance_send_time time without time zone,
    daily_balance_send_time_zone character varying(20),
    is_daily_balance_notification integer DEFAULT 0,
    notify_client_balance_type integer DEFAULT 0,
    daily_balance_notification integer,
    daily_balance_recipient integer,
    id integer NOT NULL,
    daily_cdr_generation integer DEFAULT 0,
    auto_invoice_type integer DEFAULT 0,
    invoice_format integer DEFAULT 1,
    invoice_zone character varying(10),
    invoice_zero integer DEFAULT 1,
    cdr_list_format integer,
    last_invoiced timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    notify_client_balance numeric(30,10) DEFAULT 0,
    is_send_as_link boolean DEFAULT false,
    is_send_trunk_update boolean DEFAULT true,
    is_show_detail_trunk boolean DEFAULT false
);


ALTER TABLE carrier_template OWNER TO postgres;

--
-- Name: carrier_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE carrier_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE carrier_template_id_seq OWNER TO postgres;

--
-- Name: carrier_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE carrier_template_id_seq OWNED BY carrier_template.id;


--
-- Name: cdr_api_export_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_api_export_log (
    id integer NOT NULL,
    request_id character varying(255),
    status integer DEFAULT 0,
    type integer,
    user_id integer,
    filename character varying,
    start_time integer NOT NULL,
    end_time integer NOT NULL,
    ftp_url character varying(255),
    ftp_port integer,
    ftp_user character varying(255),
    ftp_password character varying(255),
    ftp_directory character varying,
    create_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    total_records integer,
    completed_records integer
);


ALTER TABLE cdr_api_export_log OWNER TO postgres;

--
-- Name: cdr_api_export_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cdr_api_export_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cdr_api_export_log_id_seq OWNER TO postgres;

--
-- Name: cdr_api_export_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cdr_api_export_log_id_seq OWNED BY cdr_api_export_log.id;

--
-- Name: client_taxes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_taxes (
    id integer NOT NULL,
    client_id integer NOT NULL,
    tax_name varchar(255) NOT NULL,
    tax_percent numeric NOT NULL
);


ALTER TABLE client_taxes OWNER TO postgres;

--
-- Name: client_taxes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_taxes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_taxes_id_seq OWNER TO postgres;

--
-- Name: client_taxes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE client_taxes_id_seq OWNED BY client_taxes.id;

--
-- Name: client_taxes id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_taxes ALTER COLUMN id SET DEFAULT nextval('client_taxes_id_seq'::regclass);

--
-- Name: cdr_backup; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_backup (
    method integer,
    user_name character varying(100),
    user_password character varying(100),
    host_ip ip4r,
    host_dir character varying(100),
    period text,
    usr_port integer
);


ALTER TABLE cdr_backup OWNER TO postgres;

--
-- Name: COLUMN cdr_backup.method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_backup.method IS '1-scp
2-ftp
3-local';


--
-- Name: cdr_compare; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_compare (
    id integer NOT NULL,
    source_filename text,
    diff_filename text,
    is_rate boolean DEFAULT false,
    duration_diff integer,
    calltime_diff integer,
    status integer DEFAULT 0,
    diff_report_file text,
    diff_cdr_file text,
    create_time timestamp with time zone,
    finish_time timestamp with time zone,
    format integer DEFAULT 0
);


ALTER TABLE cdr_compare OWNER TO postgres;

--
-- Name: TABLE cdr_compare; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE cdr_compare IS 'å¯¹æ¯”';


--
-- Name: COLUMN cdr_compare.is_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare.is_rate IS 'æš‚ä¸ä½¿ç”¨';


--
-- Name: COLUMN cdr_compare.duration_diff; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare.duration_diff IS 'æš‚ä¸ä½¿ç”¨';


--
-- Name: COLUMN cdr_compare.calltime_diff; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare.calltime_diff IS 'æš‚ä¸ä½¿ç”¨';


--
-- Name: COLUMN cdr_compare.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare.status IS '0 æœªæ‰§è¡Œ
1 æ­£åœ¨æ‰§è¡Œ
2 å®Œæˆ
-1 æ‰“å¼€cdræ–‡ä»¶å¤±è´¥
-2 cdræ–‡ä»¶æ ¼å¼ä¸å¯¹
-3 unkown error';


--
-- Name: COLUMN cdr_compare.format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare.format IS '0.Line-by-Line ç›´æŽ¥æ¯”è¾ƒ
1.Aggregated Comparison  æ ¹æ®code name æ±‡æ€»ç»“æžœ';


--
-- Name: cdr_compare_cloud; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_compare_cloud (
    id integer NOT NULL,
    source_filename text NOT NULL,
    diff_filename text NOT NULL,
    status integer DEFAULT 0 NOT NULL,
    diff_report_file text,
    diff_cdr_file text,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    finish_time timestamp with time zone,
    format integer DEFAULT 0,
    compare_type integer NOT NULL,
    client_id integer,
    sf_count integer DEFAULT 0,
    sf_nozero_count integer DEFAULT 0,
    sf_total_duration real DEFAULT 0,
    sf_total_cost real DEFAULT 0,
    sf_mismatch_count integer DEFAULT 0,
    sf_match_count integer DEFAULT 0,
    df_count integer DEFAULT 0,
    df_nozero_count integer DEFAULT 0,
    df_total_duration real DEFAULT 0,
    df_total_cost real DEFAULT 0,
    df_mismatch_count integer DEFAULT 0,
    df_match_count integer DEFAULT 0,
    match_cdr_file character varying,
    mismatch_cdr_file character varying,
    left_right_cdr_file character varying,
    aggregated_analysis_file character varying,
    source_csv_heads character varying,
    diff_csv_heads character varying,
    source_csv_line integer,
    diff_csv_line integer,
    source_duration_type smallint DEFAULT 1,
    diff_duration_type smallint DEFAULT 1,
    active integer DEFAULT 1 NOT NULL,
    source_compare_based integer,
    diff_compare_based integer,
    source_filename_real text,
    diff_filename_real text
);


ALTER TABLE cdr_compare_cloud OWNER TO postgres;

--
-- Name: TABLE cdr_compare_cloud; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE cdr_compare_cloud IS 'å¯¹æ¯”';


--
-- Name: COLUMN cdr_compare_cloud.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare_cloud.status IS '0 æœªæ‰§è¡Œ
1 æ­£åœ¨æ‰§è¡Œ
2 å®Œæˆ
-1 æ‰“å¼€cdræ–‡ä»¶å¤±è´¥
-2 cdræ–‡ä»¶æ ¼å¼ä¸å¯¹
-3 unkown error';


--
-- Name: COLUMN cdr_compare_cloud.diff_report_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare_cloud.diff_report_file IS 'ä¸å†ä½¿ç”¨';


--
-- Name: COLUMN cdr_compare_cloud.diff_cdr_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare_cloud.diff_cdr_file IS 'ä¸å†ä½¿ç”¨';


--
-- Name: COLUMN cdr_compare_cloud.format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare_cloud.format IS 'ä¸å†ä½¿ç”¨
0.Line-by-Line
1.Aggregated Comparison';


--
-- Name: COLUMN cdr_compare_cloud.compare_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare_cloud.compare_type IS '0-
1-
2-';


--
-- Name: COLUMN cdr_compare_cloud.source_duration_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare_cloud.source_duration_type IS '1-min
2-sec';


--
-- Name: COLUMN cdr_compare_cloud.source_compare_based; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare_cloud.source_compare_based IS '1:Compare Based on DNIS only
2:Compare Based on ANI and DNIS';


--
-- Name: COLUMN cdr_compare_cloud.diff_compare_based; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_compare_cloud.diff_compare_based IS '1:Compare Based on DNIS only
2:Compare Based on ANI and DNIS';


--
-- Name: cdr_compare_cloud_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cdr_compare_cloud_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cdr_compare_cloud_id_seq OWNER TO postgres;

--
-- Name: cdr_compare_cloud_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cdr_compare_cloud_id_seq OWNED BY cdr_compare_cloud.id;


--
-- Name: cdr_compare_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cdr_compare_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cdr_compare_id_seq OWNER TO postgres;

--
-- Name: cdr_compare_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cdr_compare_id_seq OWNED BY cdr_compare.id;


--
-- Name: cdr_export_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_export_log (
    id integer NOT NULL,
    export_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status integer DEFAULT 0,
    file_name character varying(500),
    user_id integer,
    is_dipp boolean,
    backend_pid integer DEFAULT 0,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    sql character varying,
    file_rows integer,
    error_msg text,
    send_mail character varying(200),
    where_sql character varying,
    show_fields_sql character varying,
    total_hours integer DEFAULT 0,
    finished_hours integer DEFAULT 0,
    stop_time timestamp with time zone,
    download_cdr_from character varying(200),
    download_cdr_subject text,
    download_cdr_content text,
    download_cdr_cc character varying(200),
    send_type integer,
    total_date integer DEFAULT 0,
    finished_date integer DEFAULT 0,
    finished_time timestamp with time zone,
    job_id integer,
    pid integer,
    file_dir text,
    file_path text,
    total_days integer,
    completed_days integer
);


ALTER TABLE cdr_export_log OWNER TO postgres;

--
-- Name: COLUMN cdr_export_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_export_log.status IS '0 -waiting
1 - in progress
2 - query
3 - compress
4 - done
';


--
-- Name: COLUMN cdr_export_log.file_rows; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_export_log.file_rows IS 'è®°å½•æ¡æ•°';


--
-- Name: cdr_export_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cdr_export_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cdr_export_log_id_seq OWNER TO postgres;

--
-- Name: cdr_export_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cdr_export_log_id_seq OWNED BY cdr_export_log.id;


--
-- Name: cdr_list_export_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_list_export_log (
    id integer NOT NULL,
    file_path character varying(200),
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    job_start_time timestamp with time zone,
    job_end_time timestamp with time zone,
    line_count integer DEFAULT 0,
    status integer DEFAULT 0,
    query character varying,
    report_ip character varying(100),
    report_port integer DEFAULT 3300,
    file_type smallint DEFAULT 0,
    client_id integer
);


ALTER TABLE cdr_list_export_log OWNER TO postgres;

--
-- Name: cdr_list_export_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cdr_list_export_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cdr_list_export_log_id_seq OWNER TO postgres;

--
-- Name: cdr_list_export_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cdr_list_export_log_id_seq OWNED BY cdr_list_export_log.id;


--
-- Name: cdr_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_log (
    id integer NOT NULL,
    cdr_filename character varying(100),
    status integer,
    copy_time timestamp with time zone,
    finish_time timestamp with time zone,
    error_info text
);


ALTER TABLE cdr_log OWNER TO postgres;

--
-- Name: COLUMN cdr_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_log.status IS '-2--copy cdr data error
-1--open fail
1--import success
2--file empty';


--
-- Name: cdr_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cdr_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cdr_log_id_seq OWNER TO postgres;

--
-- Name: cdr_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cdr_log_id_seq OWNED BY cdr_log.id;


--
-- Name: cdr_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_report (
    report_time timestamp with time zone,
    duration integer,
    ingress_bill_time integer,
    ingress_call_cost numeric(15,6),
    lnp_cost numeric(15,8),
    ingress_total_calls integer,
    not_zero_calls integer,
    ingress_success_calls integer,
    ingress_busy_calls integer,
    lrn_calls integer,
    pdd bigint,
    ingress_cancel_calls integer,
    ingress_client_id integer,
    ingress_id integer,
    ingress_country character varying(100),
    ingress_code_name character varying(100),
    ingress_code character varying(100),
    egress_client_id integer,
    egress_id integer,
    egress_country character varying(100),
    egress_code_name character varying(100),
    egress_code character varying(100),
    ingress_prefix character varying(100),
    egress_bill_time integer,
    egress_call_cost numeric(15,6),
    egress_total_calls integer,
    egress_success_calls integer,
    egress_busy_calls integer,
    egress_cancel_calls integer,
    incoming_bandwidth integer,
    outgoing_bandwidth integer,
    ingress_call_cost_intra numeric(15,6),
    ingress_call_cost_inter numeric(15,6),
    egress_call_cost_intra numeric(15,6),
    egress_call_cost_inter numeric(15,6),
    ingress_bill_time_intra integer,
    ingress_bill_time_inter integer,
    egress_bill_time_intra integer,
    egress_bill_time_inter integer,
    agent_id integer,
    agent_rate double precision,
    agent_cost numeric(12,6),
    ingress_rate_table_id integer,
    route_plan_id integer,
    orig_jur_type integer,
    term_jur_type integer,
    par_id integer,
    origination_destination_host_name character varying(255),
    termination_source_host_name character varying(255),
    binary_value_of_release_cause_from_protocol_stack character varying(100),
    release_cause smallint,
    release_cause_from_protocol_stack character varying(100),
    q850_cause_count integer,
    npr_count integer,
    ingress_call_cost_local numeric(15,6),
    ingress_call_cost_ij numeric(15,6),
    egress_call_cost_local numeric(15,6),
    egress_call_cost_ij numeric(15,6),
    egress_no_ring integer,
    ring_pdd integer
);


ALTER TABLE cdr_report OWNER TO postgres;

--
-- Name: cdr_report_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_report_detail (
    report_time timestamp with time zone,
    duration integer,
    ingress_bill_time integer,
    ingress_call_cost numeric(15,6),
    lnp_cost numeric(15,8),
    ingress_total_calls integer,
    not_zero_calls integer,
    ingress_success_calls integer,
    ingress_busy_calls integer,
    lrn_calls integer,
    pdd bigint,
    ingress_cancel_calls integer,
    ingress_client_id integer,
    ingress_id integer,
    ingress_country character varying(100),
    ingress_code_name character varying(100),
    egress_client_id integer,
    egress_id integer,
    egress_country character varying(100),
    egress_code_name character varying(100),
    egress_code character varying(100),
    ingress_prefix character varying(100),
    egress_bill_time integer,
    egress_call_cost numeric(15,6),
    egress_total_calls integer,
    egress_success_calls integer,
    egress_busy_calls integer,
    egress_cancel_calls integer,
    not_zero_calls_30 integer,
    duration_30 integer,
    not_zero_calls_6 integer,
    duration_6 integer,
    call_18s integer,
    call_24s integer,
    call_2h integer,
    call_3h integer,
    call_4h integer,
    call_12s integer,
    ingress_rate double precision,
    egress_rate double precision,
    product_rout_id integer,
    ingress_rate_date bigint,
    egress_rate_date bigint,
    incoming_bandwidth integer,
    outgoing_bandwidth integer,
    ingress_call_cost_intra numeric(15,6),
    ingress_call_cost_inter numeric(15,6),
    egress_call_cost_intra numeric(15,6),
    egress_call_cost_inter numeric(15,6),
    ingress_bill_time_intra integer,
    ingress_bill_time_inter integer,
    egress_bill_time_intra integer,
    egress_bill_time_inter integer,
    agent_id integer,
    agent_rate double precision,
    agent_cost numeric(12,6),
    ingress_rate_table_id integer,
    route_plan_id integer,
    orig_jur_type integer,
    term_jur_type integer,
    par_id integer,
    origination_destination_host_name character varying(255),
    termination_source_host_name character varying(255),
    binary_value_of_release_cause_from_protocol_stack character varying(100),
    release_cause smallint,
    release_cause_from_protocol_stack character varying(100),
    inter_ingress_total_calls integer,
    intra_ingress_total_calls integer,
    inter_duration integer,
    intra_duration integer,
    inter_not_zero_calls integer,
    intra_not_zero_calls integer,
    q850_cause_count integer,
    npr_count integer,
    ingress_call_cost_local numeric(15,6),
    ingress_call_cost_ij numeric(15,6),
    egress_call_cost_local numeric(15,6),
    egress_call_cost_ij numeric(15,6),
    cdr_date character varying(24),
    ingress_code character varying(100),
    ring_pdd integer,
    egress_no_ring integer
);


ALTER TABLE cdr_report_detail OWNER TO postgres;

--
-- Name: TABLE cdr_report_detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE cdr_report_detail IS 'é¢„ç»Ÿè®¡';


--
-- Name: COLUMN cdr_report_detail.not_zero_calls_30; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_detail.not_zero_calls_30 IS 'calls between 24s and 30s';


--
-- Name: COLUMN cdr_report_detail.duration_30; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_detail.duration_30 IS 'durations between 24s and 30s';


--
-- Name: COLUMN cdr_report_detail.not_zero_calls_6; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_detail.not_zero_calls_6 IS 'calls between 1s and 6s';


--
-- Name: COLUMN cdr_report_detail.duration_6; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_detail.duration_6 IS 'durations between 1s and 6s';


--
-- Name: COLUMN cdr_report_detail.call_18s; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_detail.call_18s IS 'calls between 12s and 18s';


--
-- Name: COLUMN cdr_report_detail.call_24s; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_detail.call_24s IS 'calls between 18s and 24s';


--
-- Name: COLUMN cdr_report_detail.call_2h; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_detail.call_2h IS 'calls between 30s and 2h';


--
-- Name: COLUMN cdr_report_detail.call_3h; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_detail.call_3h IS 'calls between 2h and 3h';


--
-- Name: COLUMN cdr_report_detail.call_4h; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_detail.call_4h IS 'calls between 3h and 4h';


--
-- Name: COLUMN cdr_report_detail.call_12s; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_detail.call_12s IS 'calls between 6s and 12s';


--
-- Name: cdr_report_regenerate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_report_regenerate_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    executed_on timestamp with time zone,
    executed_by character varying(50),
    process_start_on timestamp with time zone,
    process_end_on timestamp with time zone,
    status integer DEFAULT 0,
    complete numeric(5,2) DEFAULT 0,
    is_stop boolean DEFAULT false,
    stop_time timestamp with time zone
);


ALTER TABLE cdr_report_regenerate_log OWNER TO postgres;

--
-- Name: COLUMN cdr_report_regenerate_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_report_regenerate_log.status IS '-2 --Stop
-1 -- Fail,
0 -- Waitingï¼Œ
1 -- In Progressï¼Œ
2 -- Finished';


--
-- Name: cdr_report_regenerate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cdr_report_regenerate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cdr_report_regenerate_log_id_seq OWNER TO postgres;

--
-- Name: cdr_report_regenerate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cdr_report_regenerate_log_id_seq OWNED BY cdr_report_regenerate_log.id;


--
-- Name: cdr_rerate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_rerate (
    id integer NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    finish_time timestamp with time zone,
    status integer DEFAULT 0 NOT NULL,
    rerate_type integer DEFAULT 1 NOT NULL,
    rerate_rate_time timestamp with time zone,
    rate_table_id integer,
    rate_table_name character varying(255),
    cdr_backup_file character varying(255),
    where_condition text,
    start_time timestamp with time zone NOT NULL,
    end_time timestamp with time zone NOT NULL,
    pid integer
);


ALTER TABLE cdr_rerate OWNER TO postgres;

--
-- Name: TABLE cdr_rerate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE cdr_rerate IS 'é‡æ–°è®¡è´¹
';


--
-- Name: COLUMN cdr_rerate.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN cdr_rerate.status IS '0-æ²¡æœ‰å¤„ç†
1-è®¡è´¹å®Œæˆ
2-å¼€å§‹å¤„ç†
3-å¤‡ä»½cdr
4-åˆ é™¤cdr
5-æ‰§è¡Œé‡è®¡è´¹
6-redo report
-1-rerate exec file error
-2-rerate exec conf error
-3-rerate cdr backup conf error
-4-open cdr backup file error
-5-cdr backup error
-6-delete cdr error
-7-rerate exec error';


--
-- Name: cdr_rerate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cdr_rerate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cdr_rerate_id_seq OWNER TO postgres;

--
-- Name: cdr_rerate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cdr_rerate_id_seq OWNED BY cdr_rerate.id;


--
-- Name: cdr_transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cdr_transaction (
    id integer NOT NULL,
    client_id text,
    amount real,
    balance real,
    "time" timestamp with time zone
);


ALTER TABLE cdr_transaction OWNER TO postgres;

--
-- Name: cdr_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cdr_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cdr_transaction_id_seq OWNER TO postgres;

--
-- Name: cdr_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cdr_transaction_id_seq OWNED BY cdr_transaction.id;


--
-- Name: class4_call_id_cloud_shark_id_map; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE class4_call_id_cloud_shark_id_map (
    id integer NOT NULL,
    call_id character varying,
    type smallint,
    cloud_shark_id character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE class4_call_id_cloud_shark_id_map OWNER TO postgres;

--
-- Name: class4_call_id_cloud_shark_id_map_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE class4_call_id_cloud_shark_id_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE class4_call_id_cloud_shark_id_map_id_seq OWNER TO postgres;

--
-- Name: class4_call_id_cloud_shark_id_map_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE class4_call_id_cloud_shark_id_map_id_seq OWNED BY class4_call_id_cloud_shark_id_map.id;


--
-- Name: class4_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE class4_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    msg_info text,
    run_pid integer,
    run_type integer
);


ALTER TABLE class4_log OWNER TO postgres;

--
-- Name: COLUMN class4_log.run_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN class4_log.run_type IS 'create_cdr_report_table=1,0 0 * * *
update_db_record=2,*/1 * * * *
upload_check=3,no crontab
alert_route=4,*/1 * * * *
cdr_report=5,58 * * * *
create_invoice=6,57 * * * *
qos_report=7,*/1 * * * *
ftp_cdr=8,59 * * * *
rerate_cdr=9,*/10 * * * *
cdr_import=10,*/1 * * * *
dns_dig=11,*/1 * * * *
finance_transaction=12,1 1 * * *
summary_report=13,0 * * * *
low_balance_alert=14,1 * * * *
real_cdr=15,no use
cdr_down=16,59 * * * *
rate_mail=17,no use
lnp_report=18,56 * * * *
loop_alert=19,*/1 * * * *
did_report=20,58 * * * *
summary_report_minute=21,*/1 * * * *
did_invoice=22,57 * * * *
summary_balance=23,0 * * * *';


--
-- Name: class4_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE class4_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE class4_log_id_seq OWNER TO postgres;

--
-- Name: class4_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE class4_log_id_seq OWNED BY class4_log.id;


--
-- Name: class4_seq_invoice_no; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE class4_seq_invoice_no
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE class4_seq_invoice_no OWNER TO postgres;

--
-- Name: cleanup; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE cleanup (
    id integer NOT NULL,
    name character varying(255),
    backup_frequency integer,
    data_size integer,
    data_cleansing_frequency integer,
    data_removal integer,
    ftp_server character varying(255),
    ftp_user character varying(255),
    ftp_password character varying(255),
    actived boolean DEFAULT true,
    last_time timestamp with time zone
);


ALTER TABLE cleanup OWNER TO postgres;

--
-- Name: cleanup_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cleanup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE cleanup_id_seq OWNER TO postgres;

--
-- Name: cleanup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cleanup_id_seq OWNED BY cleanup.id;


--
-- Name: client_client_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_client_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_client_id_seq OWNER TO postgres;

--
-- Name: client; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client (
    client_id integer DEFAULT nextval('client_client_id_seq'::regclass) NOT NULL,
    name character varying(500),
    mode integer DEFAULT 1 NOT NULL,
    orig_rate_table_id integer,
    term_rate_table_id integer,
    currency_id integer NOT NULL,
    allowed_credit numeric(30,10) DEFAULT 0 NOT NULL,
    status boolean DEFAULT true NOT NULL,
    auto_invoicing boolean DEFAULT true NOT NULL,
    payment_term_id integer,
    invoice_format integer,
    attach_cdrs_list boolean,
    cdr_list_format integer,
    last_invoiced timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    notify_client_balance numeric(30,10) DEFAULT 0,
    notify_admin_balance numeric(30,10) DEFAULT 0,
    low_balance_notice boolean DEFAULT true NOT NULL,
    company character varying,
    address character varying(500),
    email character varying(100),
    logo character varying(100),
    login character varying(40),
    password character varying(50),
    is_panelaccess boolean,
    is_panel_accountsummary boolean DEFAULT true,
    is_panel_ratetable boolean DEFAULT true,
    is_panel_trunks boolean DEFAULT true,
    is_panel_products boolean DEFAULT true,
    is_panel_balance boolean DEFAULT true,
    is_panel_paymenthistory boolean DEFAULT true,
    is_panel_onlinepayment boolean DEFAULT true,
    role_id integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    profit_margin double precision DEFAULT 0 NOT NULL,
    enough_balance boolean DEFAULT true,
    service_charge_id integer,
    noc_email character varying(100),
    billing_email character varying,
    rate_email character varying(100),
    tax_id character varying(100),
    details character varying(1000),
    invoice_show_details boolean DEFAULT false,
    invoice_past_amount numeric(30,10) DEFAULT 0,
    is_link_cdr boolean DEFAULT true,
    is_trunk boolean DEFAULT false,
    is_route boolean DEFAULT false,
    is_spam boolean DEFAULT false,
    is_location boolean DEFAULT false,
    is_orig_term boolean DEFAULT false,
    is_usage boolean DEFAULT false,
    is_qos boolean DEFAULT false,
    is_discon boolean DEFAULT false,
    is_bill_mismatch boolean DEFAULT false,
    is_active_call boolean DEFAULT false,
    is_termin boolean DEFAULT false,
    database_name character varying(50),
    is_rate_anal boolean DEFAULT false,
    is_capture boolean DEFAULT false,
    is_call_simulation boolean DEFAULT false,
    is_ingress_sim boolean DEFAULT false,
    is_egress_sim boolean DEFAULT false,
    is_report boolean DEFAULT false,
    is_tools boolean DEFAULT false,
    is_manage boolean DEFAULT false,
    mail_sended integer DEFAULT 0,
    scc_bellow integer DEFAULT 0,
    scc_percent integer DEFAULT 0,
    scc_charge numeric(30,10),
    user_id integer,
    profit_type integer DEFAULT 1 NOT NULL,
    auto_invoice_type integer DEFAULT 2 NOT NULL,
    cps_limit integer,
    call_limit integer,
    invoice_zone character varying(10),
    invoice_zero boolean DEFAULT true,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    corporate_contact_email character varying(100),
    paypal character varying(100),
    is_auto_summary boolean DEFAULT false,
    auto_send_zone character varying DEFAULT '+00:00'::character varying,
    is_daily_balance_notification boolean DEFAULT false,
    daily_balance_notification integer,
    daily_balance_recipient integer,
    low_balance_number integer,
    is_auto_balance boolean DEFAULT false,
    numer_of_days_balance integer DEFAULT 1,
    auto_daily_balance_recipient integer DEFAULT 0,
    daily_cdr_generation boolean DEFAULT false,
    daily_cdr_generation_zone character varying DEFAULT '+00:00'::character varying,
    daily_cdr_generation_type smallint DEFAULT 0,
    transaction_fee_id integer,
    unlimited_credit boolean DEFAULT false,
    include_payment_history smallint DEFAULT 0,
    include_available_credit smallint DEFAULT 0,
    include_payment_history_days integer DEFAULT 1,
    auto_summary_not_zero smallint DEFAULT 0,
    auto_summary_group_by smallint DEFAULT 0,
    daily_balance_already_sent boolean DEFAULT false,
    last_autoreport_time timestamp with time zone,
    last_lowbalance_time timestamp with time zone,
    last_cdrdown_time timestamp with time zone,
    include_tax boolean DEFAULT false,
    tax numeric(5,2),
    invoice_jurisdictional_detail boolean DEFAULT false,
    decimal_place integer DEFAULT 5,
    par_id integer,
    rate_value integer DEFAULT 0,
    email_invoice boolean DEFAULT false,
    scc_type integer DEFAULT 0,
    is_invoice_account_summary boolean DEFAULT false,
    is_show_daily_usage boolean DEFAULT false,
    invoice_include_payment boolean,
    is_short_duration_call_surcharge_detail boolean DEFAULT false,
    usage_detail_fields text,
    auto_summary_hour integer,
    auto_summary_period integer DEFAULT 24,
    last_autobalance_time timestamp with time zone,
    auto_summary_include_cdr boolean DEFAULT false NOT NULL,
    client_type integer,
    rate_delivery_email character varying(250),
    invoice_use_balance_type integer DEFAULT 0,
    notify_client_balance_type integer DEFAULT 0,
    finance_email_cc character varying,
    decimals_num integer,
    invoice_start_from date,
    low_balance_notification_time_type integer DEFAULT 0,
    low_balance_notification_time_cycle integer DEFAULT 1,
    daily_balance_send_time time without time zone,
    daily_balance_send_time_zone character varying(20),
    is_breakdown_by_rate_table boolean,
    breakdown_by_rate_table smallint,
    offset_balance boolean DEFAULT true,
    is_show_detail_trunk boolean DEFAULT false,
    is_show_total_trunk boolean DEFAULT false,
    is_show_code_100 boolean DEFAULT false,
    is_show_code_name boolean DEFAULT false,
    is_show_country boolean DEFAULT false,
    is_show_by_date boolean DEFAULT false,
    daily_limit integer,
    hourly_limit integer,
    carrier_template_id integer DEFAULT 0 NOT NULL,
    is_send_trunk_update boolean DEFAULT true,
    phone character varying(20),
    is_panel_invoices boolean DEFAULT true,
    is_panel_cdrslist boolean DEFAULT true,
    is_panel_summaryreport boolean DEFAULT true,
    is_panel_sippacket boolean DEFAULT true,
    is_panel_mydid boolean DEFAULT true,
    is_panel_didrequest boolean DEFAULT true,
    is_send_as_link boolean DEFAULT false,
    is_vendor_invoice boolean DEFAULT false,
    vendor_payment_term_id integer,
    group_id integer,
    zero_balance_notice_time integer DEFAULT 0,
    zero_balance_notice_last_sent timestamp with time zone,
    zero_balance_notice_first_sended boolean DEFAULT false,
    zero_balance_notice boolean,
    auto_report_type integer,
    daily_cdr_generation_last_qcreated timestamp with time zone,
    enable_payment_alert boolean DEFAULT false,
    is_panel_cid_blocking boolean DEFAULT true,
    did_invoice_include varchar(255),
    auto_invoice_hour integer
);


ALTER TABLE client OWNER TO postgres;

--
-- Name: TABLE client; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE client IS 'å®¢æˆ·';


--
-- Name: COLUMN client.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.client_id IS 'ä¸»é”®';


--
-- Name: COLUMN client.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.name IS 'åç§°';


--
-- Name: COLUMN client.mode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.mode IS 'ä»˜è´¹æ¨¡å¼ï¼š1ï¼é¢„ä»˜ï¼Œ2ï¼åŽä»˜';


--
-- Name: COLUMN client.orig_rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.orig_rate_table_id IS 'æ‰“è¿›è´¹çŽ‡';


--
-- Name: COLUMN client.term_rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.term_rate_table_id IS 'æ‰“å‡ºè´¹ï¼ï¼æ²¡ç”¨ï¼Œå‡†å¤‡åˆ é™¤';


--
-- Name: COLUMN client.currency_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.currency_id IS 'è´§å¸';


--
-- Name: COLUMN client.allowed_credit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.allowed_credit IS 'å®¹è®¸æ¬ è´¹';


--
-- Name: COLUMN client.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.status IS 'çŠ¶æ€ï¼štrue-activeï¼Œfalse-inactive';


--
-- Name: COLUMN client.auto_invoicing; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.auto_invoicing IS 'æ˜¯å¦è‡ªåŠ¨ç”Ÿæˆå‘ç¥¨';


--
-- Name: COLUMN client.payment_term_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.payment_term_id IS 'ç¼´è´¹è§„åˆ™';


--
-- Name: COLUMN client.invoice_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.invoice_format IS 'ç”Ÿæˆå‘ç¥¨æ ¼å¼ï¼š1ï¼PDFï¼Œ2ï¼Excelï¼Œ3ï¼HTML';


--
-- Name: COLUMN client.attach_cdrs_list; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.attach_cdrs_list IS 'æ˜¯å¦é™„ä»¶è¯å•è¯¦ç»†';


--
-- Name: COLUMN client.cdr_list_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.cdr_list_format IS 'è¯å•æ ¼å¼ï¼š1ï¼Excelï¼Œ2ï¼CSV,
3-zip, 4-tar.gz';


--
-- Name: COLUMN client.last_invoiced; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.last_invoiced IS 'ä¸Šæ¬¡å‘ç¥¨ç”Ÿæˆæ—¥æœŸ';


--
-- Name: COLUMN client.notify_client_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.notify_client_balance IS 'æç¤ºå®¢æˆ·ä½™é¢';


--
-- Name: COLUMN client.notify_admin_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.notify_admin_balance IS 'æç¤ºç³»ç»Ÿä½™é¢';


--
-- Name: COLUMN client.low_balance_notice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.low_balance_notice IS 'æ˜¯å¦æä¾›ä½™é¢ä¸è¶³æç¤º';


--
-- Name: COLUMN client.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.company IS 'å…¬å¸åç§°';


--
-- Name: COLUMN client.address; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.address IS 'åœ°å€';


--
-- Name: COLUMN client.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.email IS 'ç”µå­é‚®ä»¶';


--
-- Name: COLUMN client.logo; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.logo IS 'logo';


--
-- Name: COLUMN client.login; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.login IS 'å®¢æˆ·æ¨¡æ¿è®¿é—®å¸å·

å®¢æˆ·ç™»å½•å¸å·';


--
-- Name: COLUMN client.password; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.password IS 'å®¢æˆ·æ¨¡æ¿è®¿é—®å¯†ç ';


--
-- Name: COLUMN client.is_panelaccess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panelaccess IS 'æ˜¯å¦èƒ½è®¿é—®å®¢æˆ·æ¨¡æ¿ï¼ï¼ä¸å†ä½¿ç”¨ï¼Œå‡†å¤‡åˆ é™¤';


--
-- Name: COLUMN client.is_panel_accountsummary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_accountsummary IS 'æ˜¯å¦èƒ½è®¿é—® Account Summary';


--
-- Name: COLUMN client.is_panel_ratetable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_ratetable IS 'æ˜¯å¦èƒ½è®¿é—® RateTable';


--
-- Name: COLUMN client.is_panel_trunks; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_trunks IS 'æ˜¯å¦èƒ½è®¿é—® Trunks';


--
-- Name: COLUMN client.is_panel_products; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_products IS 'æ˜¯å¦èƒ½è®¿é—®products';


--
-- Name: COLUMN client.is_panel_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_balance IS 'æ˜¯å¦èƒ½è®¿é—® Balance';


--
-- Name: COLUMN client.is_panel_paymenthistory; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_paymenthistory IS 'æ˜¯å¦å¯ä»¥è®¿é—®Payment History';


--
-- Name: COLUMN client.is_panel_onlinepayment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_onlinepayment IS 'æ˜¯å¦èƒ½è®¿é—® Online Payment';


--
-- Name: COLUMN client.role_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.role_id IS 'è§’è‰²';


--
-- Name: COLUMN client.create_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.create_time IS 'æ²¡ç”¨ï¼ï¼å‡†å¤‡åˆ é™¤';


--
-- Name: COLUMN client.profit_margin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.profit_margin IS 'æœ€ä½Žåˆ©æ¶¦çŽ‡';


--
-- Name: COLUMN client.enough_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.enough_balance IS 'æ˜¯å¦ä½™é¢ä¸è¶³';


--
-- Name: COLUMN client.is_link_cdr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_link_cdr IS 'æ˜¯å¦å¯ä»¥ é“¾æŽ¥ä¸‹è½½cdr';


--
-- Name: COLUMN client.mail_sended; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.mail_sended IS '0-æ²¡æœ‰å‘é€
1-ä½™é¢ä¸è¶³å‘é€';


--
-- Name: COLUMN client.scc_bellow; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.scc_bellow IS 'call_durationå‘¼å«æ—¶é•¿å°‘äºŽè¿™ä¸ªå€¼çš„è®¡ä¸€ä¸ªshort call';


--
-- Name: COLUMN client.scc_percent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.scc_percent IS 'short callçš„answered*100/allå¤§äºŽè¿™ä¸ªå€¼å°±åœ¨invoiceä¸­å¢žåŠ çŸ­æš‚å‘¼å«ç½šæ¬¾';


--
-- Name: COLUMN client.scc_charge; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.scc_charge IS 'çŸ­æš‚å‘¼å«ç½šæ¬¾é‡‘é¢';


--
-- Name: COLUMN client.profit_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.profit_type IS '1--ç™¾åˆ†æ¯”
2--æ•°å€¼';


--
-- Name: COLUMN client.auto_invoice_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.auto_invoice_type IS '0:buy(client)
1:sell(vendor)
2:both';


--
-- Name: COLUMN client.invoice_zero; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.invoice_zero IS 'é»˜è®¤ä¸ç”Ÿæˆ';


--
-- Name: COLUMN client.daily_balance_recipient; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.daily_balance_recipient IS '0:Partner''s Billing Contact
1:Owner''s Billing Contact
2:Both';


--
-- Name: COLUMN client.auto_summary_group_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.auto_summary_group_by IS '<option value="0">By Country</option>
<option value="1">By Code Name</option>
 <option value="2">By Code</option>';


--
-- Name: COLUMN client.decimal_place; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.decimal_place IS 'å°æ•°ä½æ•°ï¼Œé»˜è®¤5ä½';


--
-- Name: COLUMN client.scc_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.scc_type IS '0 meeting the short duration defined above
1 that exceed the defined percentage';


--
-- Name: COLUMN client.auto_summary_period; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.auto_summary_period IS '1
2
4
6
8
12
24
-15
-30';


--
-- Name: COLUMN client.client_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.client_type IS 'did
0 vendor
1 client
';


--
-- Name: COLUMN client.invoice_use_balance_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.invoice_use_balance_type IS '0-actual
1-mutual';


--
-- Name: COLUMN client.is_breakdown_by_rate_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_breakdown_by_rate_table IS 'invoice æ˜¯å¦æ˜¾ç¤º Break Down by Rate Table';


--
-- Name: COLUMN client.breakdown_by_rate_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.breakdown_by_rate_table IS 'breakdown_by_rate_table çš„ç±»åž‹
1ï¼šBreakdown A-Z Rate Table by Destination
2ï¼š Breakdown US Rate Table by Jurisdiction';


--
-- Name: COLUMN client.carrier_template_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.carrier_template_id IS 'ä½¿ç”¨Carrier Templateæ¨¡æ¿ï¼Œé»˜è®¤ä¸º0ï¼Œä¸ä½¿ç”¨æ¨¡æ¿';


--
-- Name: COLUMN client.is_send_trunk_update; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_send_trunk_update IS 'åœ¨æ”¹å˜å…¶trunk ipæ—¶æ˜¯å¦å‘é€é‚®ä»¶';


--
-- Name: COLUMN client.is_panel_invoices; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_invoices IS 'æ˜¯å¦èƒ½è®¿é—® Invoices';


--
-- Name: COLUMN client.is_panel_cdrslist; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_cdrslist IS 'æ˜¯å¦èƒ½è®¿é—® CDRs List';


--
-- Name: COLUMN client.is_panel_summaryreport; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_summaryreport IS 'æ˜¯å¦èƒ½è®¿é—® Summary Report';


--
-- Name: COLUMN client.is_panel_sippacket; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_sippacket IS 'æ˜¯å¦èƒ½è®¿é—® SIP PACKET Search';


--
-- Name: COLUMN client.is_panel_mydid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_mydid IS 'æ˜¯å¦èƒ½è®¿é—® My DID';


--
-- Name: COLUMN client.is_panel_didrequest; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client.is_panel_didrequest IS 'æ˜¯å¦èƒ½è®¿é—® DID Request';


--
-- Name: client_balance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_balance (
    client_id character varying(100) NOT NULL,
    balance character varying(100) DEFAULT 0.00 NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    ingress_balance character varying(100) DEFAULT 0,
    egress_balance character varying(100) DEFAULT 0,
    bod_balance character varying(100) DEFAULT 0.00 NOT NULL
);


ALTER TABLE client_balance OWNER TO postgres;

--
-- Name: TABLE client_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE client_balance IS 'å®¢æˆ·æ¯æ¬¡é€šè¯ï¼Œæˆ–è€…æ¯æ¬¡å……å€¼çš„ä½™é¢è®¡ç®—è¡¨';


--
-- Name: COLUMN client_balance.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_balance.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN client_balance.balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_balance.balance IS 'å½“å‰ä½™é¢';


--
-- Name: COLUMN client_balance.create_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_balance.create_time IS 'æ”¹åŠ¨æ—¶é—´';


--
-- Name: COLUMN client_balance.bod_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_balance.bod_balance IS 'begin of day balance:å½“å¤©0ç‚¹æ—¶çš„balance';


--
-- Name: client_balance_operation_action; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_balance_operation_action (
    id integer NOT NULL,
    client_id integer,
    balance numeric(12,6) DEFAULT 0.00 NOT NULL,
    ingress_balance numeric(12,6) DEFAULT 0.00 NOT NULL,
    egress_balance numeric(12,6) DEFAULT 0.00 NOT NULL,
    action integer,
    update_result integer DEFAULT 0 NOT NULL,
    update_by character varying(100),
    update_time timestamp with time zone,
    create_by character varying(100),
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL
);


ALTER TABLE client_balance_operation_action OWNER TO postgres;

--
-- Name: COLUMN client_balance_operation_action.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_balance_operation_action.action IS '0-Added a new client balance, 1-Reset client balance, ingress balance, egress balance, 2-Increase ingress balance, 3-Decrease ingress balance, 4-Increase egress balance, 5-Decrease egress balance';


--
-- Name: COLUMN client_balance_operation_action.update_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_balance_operation_action.update_result IS '0-Initial, 1-Update completed, 2-Update failed';


--
-- Name: client_balance_operation_action_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_balance_operation_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_balance_operation_action_id_seq OWNER TO postgres;

--
-- Name: client_balance_operation_action_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE client_balance_operation_action_id_seq OWNED BY client_balance_operation_action.id;


--
-- Name: client_balance_test; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_balance_test (
    client_id character varying(100),
    balance numeric(20,10),
    create_time timestamp with time zone,
    ingress_balance numeric(20,10),
    egress_balance numeric(20,10),
    bod_balance character varying(100)
);


ALTER TABLE client_balance_test OWNER TO postgres;

--
-- Name: client_cdr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_cdr (
    id bigint,
    record_sequence_number character varying(100),
    version_number character varying(100),
    record_type character varying(100),
    connection_type character varying(100),
    session_id character varying(100),
    release_cause smallint,
    start_time_of_date bigint,
    answer_time_of_date bigint,
    release_tod bigint,
    minutes_west_of_greenwich_mean_time smallint,
    release_cause_from_protocol_stack character varying(100),
    binary_value_of_release_cause_from_protocol_stack character varying(100),
    first_release_dialogue character varying(100),
    trunk_id_origination character varying(100),
    voip_protocol_origination character varying(100),
    origination_source_number character varying(100),
    origination_source_host_name character varying(100),
    origination_destination_number character varying(100),
    origination_destination_host_name character varying(100),
    origination_call_id character varying(150),
    origination_remote_payload_ip_address character varying(100),
    origination_remote_payload_udp_address integer,
    origination_local_payload_ip_address character varying(100),
    origination_local_payload_udp_address integer,
    origination_codec_list character varying(100),
    origination_ingress_packets integer,
    origination_egress_packets integer,
    origination_ingress_octets integer,
    origination_egress_octets integer,
    origination_ingress_packet_loss integer,
    origination_ingress_delay integer,
    origination_ingress_packet_jitter integer,
    trunk_id_termination character varying(100),
    voip_protocol_termination character varying(100),
    termination_source_number character varying(100),
    termination_source_host_name character varying(100),
    termination_destination_number character varying(100),
    termination_destination_host_name character varying(100),
    termination_call_id character varying(150),
    termination_remote_payload_ip_address character varying(100),
    termination_remote_payload_udp_address integer,
    termination_local_payload_ip_address character varying(100),
    termination_local_payload_udp_address integer,
    termination_codec_list character varying(100),
    termination_ingress_packets integer,
    termination_egress_packets integer,
    termination_ingress_octets integer,
    termination_egress_octets integer,
    termination_ingress_packet_loss integer,
    termination_ingress_delay integer,
    termination_ingress_packet_jitter integer,
    final_route_indication character varying(100),
    routing_digits character varying(100),
    call_duration integer,
    pdd integer,
    ring_time bigint,
    callduration_in_ms integer,
    conf_id character varying(100),
    call_type smallint,
    ingress_id integer,
    ingress_client_id integer,
    ingress_client_rate_table_id integer,
    ingress_client_currency_id integer,
    ingress_client_rate double precision,
    ingress_client_currency character varying(100),
    ingress_client_bill_time integer,
    ingress_client_bill_result smallint,
    ingress_client_cost numeric(12,6),
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    egress_id integer,
    egress_rate_table_id integer,
    egress_rate double precision,
    egress_cost numeric(12,6),
    egress_bill_time integer,
    egress_client_id integer,
    egress_client_currency_id integer,
    egress_client_currency character varying(100),
    egress_six_seconds integer,
    egress_bill_minutes real,
    egress_bill_result smallint,
    ingress_bill_minutes real,
    ingress_dnis_type smallint,
    ingress_rate_type smallint,
    lrn_dnis character varying(100),
    egress_dnis_type smallint,
    egress_rate_type smallint,
    translation_ani character varying(100),
    ani_code_id integer,
    dnis_code_id integer,
    item_id integer,
    ingress_rate_id integer,
    egress_rate_id integer,
    rerate_time timestamp with time zone,
    orig_code character varying(100),
    orig_code_name character varying(100),
    orig_country character varying(100),
    term_code character varying(100),
    term_code_name character varying(100),
    term_country character varying(100),
    ingress_rate_effective_date bigint,
    egress_rate_effective_date bigint,
    egress_erro_string text,
    route_plan integer,
    dynamic_route integer,
    static_route integer,
    contract_id character varying(100),
    order_id character varying(100),
    order_type character varying(100),
    lrn_number_vendor smallint,
    lnp_dipping_cost numeric(10,8),
    is_final_call smallint,
    egress_code_asr real,
    egress_code_acd real,
    route_prefix character varying(100),
    is_manual_kill boolean DEFAULT false,
    orig_call_duration integer,
    orig_delay_second integer,
    term_delay_second integer,
    trunk_type smallint,
    origination_profile_port integer,
    termination_profile_port integer,
    o_trunk_type2 smallint,
    o_billing_method smallint,
    t_trunk_type2 smallint,
    t_billing_method smallint,
    campaign_id integer,
    tax integer,
    agent_id integer,
    agent_rate double precision,
    agent_cost numeric(12,6),
    orig_jur_type integer,
    term_jur_type integer,
    ring_epoch bigint,
    end_epoch bigint,
    par_id integer,
    paid_user character varying(100),
    rpid_user character varying(100),
    timeout_type smallint,
    q850_cause integer,
    q850_cause_string character varying(100),
    route_id integer
);


ALTER TABLE client_cdr OWNER TO postgres;

--
-- Name: COLUMN client_cdr.release_cause; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.release_cause IS 'è¿”å›žç»™ä¸»å«çš„é”™è¯¯ç ï¼Œä¸€å…±20ç§ã€‚

        REC_CALL_ARGS = 0,
        REC_SYSTEM_CAP = 1,
        REC_SYSTEM_CPS = 2,
        REC_INGRESS_IP_CHECK = 3,
        REC_INGRESS_RESOURCE = 4,
        REC_PRODUCT_CHECK = 5,
        REC_IN_RESORUCE_CAP = 6,
        REC_IN_RESORUCE_CPS = 7,
        REC_IN_RESORUCE_IP_CAP = 8,
        REC_IN_RESORUCE_IP_CPS = 9,
        REC_RESOURCE_CODEC = 10,
        REC_INGRESS_LRN_BLOCK = 11,
        REC_INGRESS_RATE = 12,
        REC_EGRESS_NOT_FOUND = 13,
        REC_EGRESS_RESPONSE404 = 14,
        REC_EGRESS_RESPONSE486 = 15,
        REC_EGRESS_RESPONSE487 = 16,
        REC_EGRESS_RESPONSE200 = 17,
        REC_ALL_EGRESS_FAILED = 81,
        REC_NORMAL = 19

        { "0", "404", "Not Found" },
        { "1", "503", "Service Unavailable" },
        { "2", "503", "Service Unavailable" },
        { "3", "403", "Forbidden" },
        { "4", "403", "Forbidden" },
        { "5", "403", "Forbidden" },
        { "6", "503", "Service Unavailable" },
        { "7", "503", "Service Unavailable" },
        { "8", "503", "Service Unavailable" },
        { "9", "503", "Service Unavailable" },
        { "10", "415", "Unsupported Media Type" },
        { "11", "403", "Forbidden" },
        { "12", "403", "Forbidden" },
        { "13", "403", "Forbidden" },
        { "14", "404", "Not Found" },
        { "15", "486", "Busy Here" },
        { "16", "503", "Service Unavailable" },
        { "17", "200", "OK" },
        { "18", "503", "Service Unavailable" },
        { "19", "200", "OK" }



ç³»ç»Ÿå®šä¹‰é”™è¯¯ç ç¿»è¯‘ï¼Œå¦‚æžœæœ‰ä¸å¦¥å½“çš„è¯·æ¢å¤ä¸€ä¸‹ã€‚

REC_CALL_ARGS Invalid Argument
REC_SYSTEM_CAP System Limit Exceeded
REC_SYSTEM_CPS System Limit Exceeded
REC_INGRESS_IP_CHECK Unauthorized IP Address
REC_INGRESS_RESOURCE No Ingress Resource Found
REC_PRODUCT_CHECK No Product Found
REC_IN_RESORUCE_CAP Trunk Limit Exceeded
REC_IN_RESORUCE_CPS Trunk Limit Exceeded
REC_IN_RESORUCE_IP_CAP IP Limit Exceeded
REC_IN_RESORUCE_IP_CPS IP Limit Exceeded
REC_RESOURCE_CODEC Invalid Codec Negotiation
REC_INGRESS_LRN_BLOCK Block due to LRN
REC_INGRESS_RATE Ingress Rate Not Found
REC_EGRESS_NOT_FOUND Egress Trunk Not Found
REC_EGRESS_RESPONSE404 From egress response 404
REC_EGRESS_RESPONSE486 From egress response 486
REC_EGRESS_RESPONSE487 From egress response 487
REC_EGRESS_RESPONSE200 From egress response 200
REC_ALL_EGRESS_FAILED All egress not available
REC_NORMAL Normal



';


--
-- Name: COLUMN client_cdr.release_cause_from_protocol_stack; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.release_cause_from_protocol_stack IS '
ingress
æ‰“è¿›ç¹å¿™çš„call 486
æ‰“è¿›æ²¡æœ‰é€šé“çš„call  503
è¢«å«è¿”å›žçš„

ingress_to_egress

è¿”å›žç»™egress çš„ åŽŸå› Response From Egress';


--
-- Name: COLUMN client_cdr.binary_value_of_release_cause_from_protocol_stack; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.binary_value_of_release_cause_from_protocol_stack IS 'è¿”å›žç»™ä¸»å«çš„åŽŸå›
ingress_to_ingress

è¿”å›žç»™ingress çš„åŽŸå›     Response TO Ingress';


--
-- Name: COLUMN client_cdr.trunk_id_origination; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.trunk_id_origination IS 'trunk_id_origination

å¯¹æŽ¥ç½‘å…³çš„alais';


--
-- Name: COLUMN client_cdr.trunk_id_termination; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.trunk_id_termination IS 'è¢«å«ä¿¡æ¯ï¼Œè½åœ°ç½‘å…³ï¼Œegress alias
ä¸ºç©º ï¼ï¼æ‰¾ä¸åˆ°è·¯ç”±çš„cdr';


--
-- Name: COLUMN client_cdr.routing_digits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.routing_digits IS 'è¢«å«å·';


--
-- Name: COLUMN client_cdr.call_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.call_duration IS 'é€šè¯æ—¶é•¿
æ‰“è¿›-ä¸ä¸º0çš„call call_duration>0çš„cdr';


--
-- Name: COLUMN client_cdr.ingress_client_bill_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.ingress_client_bill_result IS ' æ‰“è¿› è®¡è´¹ç»“æžœ
1ï¼ï¼æˆåŠŸ
2ï¼ï¼Calls with unknown clients

3ï¼ï¼è´¹çŽ‡æ¨¡æ¿æ‰¾ä¸åˆ°
4ï¼ï¼è´¹çŽ‡æ‰¾ä¸åˆ°
5--Calls with unknown destinations (known clients)
6--';


--
-- Name: COLUMN client_cdr.ingress_client_cost; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.ingress_client_cost IS 'é€šè¯è´¹ç”¨(å¯¹æŽ¥ç½‘å…³çš„é’±)

incoming';


--
-- Name: COLUMN client_cdr."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr."time" IS 'æ’å…¥æ•°æ®åº“çš„æ—¶é—´';


--
-- Name: COLUMN client_cdr.egress_cost; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.egress_cost IS 'æˆæœ¬ï¼ï¼è½åœ°ç½‘å…³çš„é’±
outgoing';


--
-- Name: COLUMN client_cdr.egress_bill_minutes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.egress_bill_minutes IS 'æ‰“å‡º  è®¡è´¹ç»“æžœ';


--
-- Name: COLUMN client_cdr.egress_bill_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.egress_bill_result IS '
Termination
è®¡è´¹ç»“æžœ
1ï¼ï¼æˆåŠŸ
2ï¼ï¼è´¦å·æ‰¾ä¸åˆ°
3ï¼ï¼è´¹çŽ‡æ¨¡æ¿æ‰¾ä¸åˆ°
4ï¼ï¼è´¹çŽ‡æ‰¾ä¸åˆ°';


--
-- Name: COLUMN client_cdr.ingress_dnis_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.ingress_dnis_type IS '0-dnis
1-lrn
2-lrn block';


--
-- Name: COLUMN client_cdr.ingress_rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.ingress_rate_type IS '1ï¼ï¼interstate
2ï¼ï¼intrastate
3ï¼ï¼others
4 -- error
5 -- local rate';


--
-- Name: COLUMN client_cdr.egress_dnis_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.egress_dnis_type IS '0-dnis
1-lrn
2-lrn block';


--
-- Name: COLUMN client_cdr.egress_rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.egress_rate_type IS '1. --interstate
2. --intrastate
3. --others
4. --error
5. --local rate

';


--
-- Name: COLUMN client_cdr.translation_ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.translation_ani IS 'è½¬æ¢åŽçš„ä¸»å«å·';


--
-- Name: COLUMN client_cdr.item_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.item_id IS 'é™æ€è·¯ç”±è¡¨prefix ID';


--
-- Name: COLUMN client_cdr.rerate_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.rerate_time IS 'é‡æ–°è®¡è´¹çš„æ—¶é—´';


--
-- Name: COLUMN client_cdr.orig_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.orig_code IS 'æ‰“è¿›å·ç ';


--
-- Name: COLUMN client_cdr.orig_code_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.orig_code_name IS 'æ‰“è¿›å·ç åç§°';


--
-- Name: COLUMN client_cdr.orig_country; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.orig_country IS 'æ‰“è¿›å›½å®¶';


--
-- Name: COLUMN client_cdr.egress_erro_string; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.egress_erro_string IS 'è¿”å›žé”™è¯¯åŽŸå› ';


--
-- Name: COLUMN client_cdr.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.order_type IS '1--buy order
2--sell order';


--
-- Name: COLUMN client_cdr.lrn_number_vendor; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.lrn_number_vendor IS '1-client
2-lrn server';


--
-- Name: COLUMN client_cdr.lnp_dipping_cost; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.lnp_dipping_cost IS 'ï¼ï¼lrn_number_vendorä¸º2ï¼Œæ­¤å˜é‡æœ‰æ•ˆ
ï¼ï¼client_balanceé‡Œå®žæ—¶æ‰£è´¹
ï¼ï¼å¤±è´¥çš„å‘¼å«ä¹Ÿä¼šæ‰£æ­¤è´¹ç”¨';


--
-- Name: COLUMN client_cdr.is_final_call; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.is_final_call IS '0-é»˜è®¤å¿½ç•¥
1-æœ€åŽä¸€ä¸ªè·¯ç”±';


--
-- Name: COLUMN client_cdr.orig_jur_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.orig_jur_type IS 'from rate_table jur_type';


--
-- Name: COLUMN client_cdr.term_jur_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.term_jur_type IS 'from rate_table';


--
-- Name: COLUMN client_cdr.ring_epoch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.ring_epoch IS 'å¾—åˆ°180æˆ–183çš„æ—¶é—´';


--
-- Name: COLUMN client_cdr.end_epoch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_cdr.end_epoch IS 'è¢«å«æ”¶åˆ°byeæˆ–å‘ç»™è¢«å«byeçš„æ—¶é—´';


--
-- Name: client_cdr_delete_bak; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_cdr_delete_bak (
    id bigint NOT NULL,
    record_sequence_number character varying(100),
    version_number character varying(100),
    record_type character varying(100),
    connection_type character varying(100),
    session_id character varying(100),
    release_cause smallint,
    start_time_of_date bigint,
    answer_time_of_date bigint,
    release_tod bigint,
    minutes_west_of_greenwich_mean_time smallint,
    release_cause_from_protocol_stack character varying(100),
    binary_value_of_release_cause_from_protocol_stack character varying(100),
    first_release_dialogue character varying(100),
    trunk_id_origination character varying(100),
    voip_protocol_origination character varying(100),
    origination_source_number character varying(100),
    origination_source_host_name character varying(100),
    origination_destination_number character varying(100),
    origination_destination_host_name character varying(100),
    origination_call_id character varying(150),
    origination_remote_payload_ip_address character varying(100),
    origination_remote_payload_udp_address integer,
    origination_local_payload_ip_address character varying(100),
    origination_local_payload_udp_address integer,
    origination_codec_list character varying(100),
    origination_ingress_packets integer,
    origination_egress_packets integer,
    origination_ingress_octets integer,
    origination_egress_octets integer,
    origination_ingress_packet_loss integer,
    origination_ingress_delay integer,
    origination_ingress_packet_jitter integer,
    trunk_id_termination character varying(100),
    voip_protocol_termination character varying(100),
    termination_source_number character varying(100),
    termination_source_host_name character varying(100),
    termination_destination_number character varying(100),
    termination_destination_host_name character varying(100),
    termination_call_id character varying(150),
    termination_remote_payload_ip_address character varying(100),
    termination_remote_payload_udp_address integer,
    termination_local_payload_ip_address character varying(100),
    termination_local_payload_udp_address integer,
    termination_codec_list character varying(100),
    termination_ingress_packets integer,
    termination_egress_packets integer,
    termination_ingress_octets integer,
    termination_egress_octets integer,
    termination_ingress_packet_loss integer,
    termination_ingress_delay integer,
    termination_ingress_packet_jitter integer,
    final_route_indication character varying(100),
    routing_digits character varying(100),
    call_duration integer,
    pdd integer,
    ring_time bigint,
    callduration_in_ms integer,
    conf_id character varying(100),
    call_type smallint,
    ingress_id integer,
    ingress_client_id integer,
    ingress_client_rate_table_id integer,
    ingress_client_currency_id integer,
    ingress_client_rate double precision,
    ingress_client_currency character varying(100),
    ingress_client_bill_time integer,
    ingress_client_bill_result smallint,
    ingress_client_cost numeric(12,6),
    "time" timestamp with time zone,
    egress_id integer,
    egress_rate_table_id integer,
    egress_rate double precision,
    egress_cost numeric(12,6),
    egress_bill_time integer,
    egress_client_id integer,
    egress_client_currency_id integer,
    egress_client_currency character varying(100),
    egress_six_seconds integer,
    egress_bill_minutes real,
    egress_bill_result smallint,
    ingress_bill_minutes real,
    ingress_dnis_type smallint,
    ingress_rate_type smallint,
    lrn_dnis character varying(100),
    egress_dnis_type smallint,
    egress_rate_type smallint,
    translation_ani character varying(100),
    ani_code_id integer,
    dnis_code_id integer,
    item_id integer,
    ingress_rate_id integer,
    egress_rate_id integer,
    rerate_time timestamp with time zone,
    orig_code character varying(100),
    orig_code_name character varying(100),
    orig_country character varying(100),
    term_code character varying(100),
    term_code_name character varying(100),
    term_country character varying(100),
    ingress_rate_effective_date bigint,
    egress_rate_effective_date bigint,
    egress_erro_string text,
    route_plan integer,
    dynamic_route integer,
    static_route integer,
    contract_id character varying(100),
    order_id character varying(100),
    order_type character varying(100),
    lrn_number_vendor smallint,
    lnp_dipping_cost numeric(10,8),
    is_final_call smallint,
    egress_code_asr real,
    egress_code_acd real,
    route_prefix character varying(100),
    is_manual_kill boolean,
    orig_call_duration integer,
    orig_delay_second integer,
    term_delay_second integer,
    trunk_type smallint,
    origination_profile_port integer,
    termination_profile_port integer,
    o_trunk_type2 smallint,
    o_billing_method smallint,
    t_trunk_type2 smallint,
    t_billing_method smallint,
    campaign_id integer,
    tax integer,
    agent_id integer,
    agent_rate double precision,
    agent_cost numeric(12,6),
    orig_jur_type integer,
    term_jur_type integer,
    ring_epoch bigint,
    end_epoch bigint,
    par_id integer,
    paid_user character varying(100),
    rpid_user character varying(100),
    timeout_type smallint,
    q850_cause integer,
    q850_cause_string character varying(100)
);


ALTER TABLE client_cdr_delete_bak OWNER TO postgres;

--
-- Name: client_cdr_new_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_cdr_new_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_cdr_new_id_seq OWNER TO postgres;

--
-- Name: client_commit_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_commit_code (
    id integer NOT NULL,
    ingress_id integer,
    egress_id integer,
    code prefix_range DEFAULT ''::prefix_range NOT NULL,
    contract_id integer
);


ALTER TABLE client_commit_code OWNER TO postgres;

--
-- Name: client_commit_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_commit_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_commit_code_id_seq OWNER TO postgres;

--
-- Name: client_commit_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE client_commit_code_id_seq OWNED BY client_commit_code.id;


--
-- Name: client_commit_code_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_commit_code_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_commit_code_record_record_id_seq OWNER TO postgres;

--
-- Name: client_commit_code_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_commit_code_record (
    id integer,
    ingress_id integer,
    egress_id integer,
    code prefix_range,
    contract_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('client_commit_code_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE client_commit_code_record OWNER TO postgres;

--
-- Name: client_commit_minutes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_commit_minutes (
    id integer NOT NULL,
    client_id integer,
    ingress_id integer,
    commit_minutes bigint DEFAULT 0 NOT NULL,
    contract_id integer
);


ALTER TABLE client_commit_minutes OWNER TO postgres;

--
-- Name: client_commit_minutes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_commit_minutes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_commit_minutes_id_seq OWNER TO postgres;

--
-- Name: client_commit_minutes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE client_commit_minutes_id_seq OWNED BY client_commit_minutes.id;


--
-- Name: client_commit_minutes_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_commit_minutes_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_commit_minutes_record_record_id_seq OWNER TO postgres;

--
-- Name: client_commit_minutes_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_commit_minutes_record (
    id integer,
    client_id integer,
    ingress_id integer,
    commit_minutes bigint,
    contract_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('client_commit_minutes_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE client_commit_minutes_record OWNER TO postgres;

--
-- Name: client_day_cost; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_day_cost (
    client_id integer,
    cost_date timestamp with time zone,
    buy_cost numeric(30,10),
    sell_cost numeric(30,10)
);


ALTER TABLE client_day_cost OWNER TO postgres;

--
-- Name: client_finance_transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_finance_transaction (
    id integer NOT NULL,
    client_id integer,
    amount real,
    transaction_type integer,
    transaction_time timestamp with time zone
);


ALTER TABLE client_finance_transaction OWNER TO postgres;

--
-- Name: COLUMN client_finance_transaction.transaction_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_finance_transaction.transaction_type IS '1-buy
2-sell
3-deposit
4-withdraw
0-balance';


--
-- Name: client_finance_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_finance_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_finance_transaction_id_seq OWNER TO postgres;

--
-- Name: client_finance_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE client_finance_transaction_id_seq OWNED BY client_finance_transaction.id;


--
-- Name: client_low_balance_config; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_low_balance_config (
    client_id integer NOT NULL,
    is_notify boolean,
    value_type integer,
    actual_notify_balance numeric(30,2),
    percentage_notify_balance numeric(30,2),
    send_time_type integer,
    daily_send_time integer,
    duplicate_days integer,
    send_to integer,
    duplicate_send_days integer DEFAULT 0 NOT NULL,
    last_alert_time timestamp with time zone,
    disable_trunks_days integer DEFAULT 5
);


ALTER TABLE client_low_balance_config OWNER TO postgres;

--
-- Name: COLUMN client_low_balance_config.is_notify; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_low_balance_config.is_notify IS 'æ˜¯å¦æ£€æµ‹';


--
-- Name: COLUMN client_low_balance_config.value_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_low_balance_config.value_type IS '0 =>Actual Balance,1 =>Percentage';


--
-- Name: COLUMN client_low_balance_config.send_time_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_low_balance_config.send_time_type IS '0 => daily, 1=> hourly';


--
-- Name: COLUMN client_low_balance_config.daily_send_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_low_balance_config.daily_send_time IS 'if selected daily to choose between 00:00 - 23:00 GMT';


--
-- Name: COLUMN client_low_balance_config.duplicate_days; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_low_balance_config.duplicate_days IS 'é‡å¤å‘é€å‡ å¤©';


--
-- Name: COLUMN client_low_balance_config.send_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_low_balance_config.send_to IS '0 => Owner''sBilling Contact,  1 =>  Partner''s Billing Contact,  2 => Both';


--
-- Name: COLUMN client_low_balance_config.duplicate_send_days; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_low_balance_config.duplicate_send_days IS 'å·²ç»å‘é€çš„å¤©æ•°';


--
-- Name: client_payment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_payment (
    client_payment_id integer NOT NULL,
    payment_time timestamp with time zone NOT NULL,
    amount numeric(20,10) NOT NULL,
    result boolean NOT NULL,
    client_id integer,
    cause character varying(20),
    description character varying(500),
    approved boolean,
    current_balance numeric(30,10) DEFAULT 0,
    invoice_number character varying(100),
    payment_type integer DEFAULT 1,
    payment_method integer,
    email_sended boolean DEFAULT false,
    update_by character varying,
    receiving_time timestamp with time zone,
    egress_amount numeric
);


ALTER TABLE client_payment OWNER TO postgres;

--
-- Name: TABLE client_payment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE client_payment IS 'å®¢æˆ·æ¯æ¬¡å……å€¼è®°å½•è¡¨';


--
-- Name: COLUMN client_payment.client_payment_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_payment.client_payment_id IS 'ä¸»é”®';


--
-- Name: COLUMN client_payment.payment_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_payment.payment_time IS 'å……å€¼æ—¶é—´';


--
-- Name: COLUMN client_payment.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_payment.amount IS 'å……å€¼é‡‘é¢';


--
-- Name: COLUMN client_payment.result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_payment.result IS 'å……å€¼ç»“æžœ(æˆåŠŸ/å¤±è´¥)';


--
-- Name: COLUMN client_payment.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_payment.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN client_payment.cause; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_payment.cause IS 'æ²¡ç”¨ï¼ï¼å‡†å¤‡åˆ é™¤';


--
-- Name: COLUMN client_payment.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_payment.description IS 'è®¾ç½®reset balance çš„note';


--
-- Name: COLUMN client_payment.approved; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_payment.approved IS 'æ˜¯å¦ç»è¿‡å®¡æ ¸';


--
-- Name: COLUMN client_payment.payment_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_payment.payment_type IS '3:invoice payment sent
4:invoice payment received
5:prepay payment received
6:payment sent
7:credit note received
8:credit note sent
9:reset
10:offset
11: debit received
12:debit sent
13:mutual reset
14:actual reset
15:scc cost';


--
-- Name: client_payment_client_payment_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_payment_client_payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_payment_client_payment_id_seq OWNER TO postgres;

--
-- Name: client_payment_client_payment_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE client_payment_client_payment_id_seq OWNED BY client_payment.client_payment_id;


--
-- Name: client_rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_rate (
    client_id integer,
    rate_table_id integer,
    code character varying(20),
    code_name character varying(50),
    country character varying(50),
    rate numeric(30,10),
    "interval" integer DEFAULT 1,
    effective_date timestamp with time zone,
    end_date timestamp with time zone,
    send_date timestamp with time zone
);


ALTER TABLE client_rate OWNER TO postgres;

--
-- Name: client_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_record_record_id_seq OWNER TO postgres;

--
-- Name: client_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_record (
    client_id integer,
    name character varying(500),
    mode integer,
    orig_rate_table_id integer,
    term_rate_table_id integer,
    currency_id integer,
    allowed_credit numeric(30,10),
    status boolean,
    auto_invoicing boolean,
    payment_term_id integer,
    invoice_format integer,
    attach_cdrs_list boolean,
    cdr_list_format integer,
    last_invoiced timestamp with time zone,
    notify_client_balance numeric(30,10),
    notify_admin_balance numeric(30,10),
    low_balance_notice boolean,
    company character varying,
    address character varying(500),
    email character varying(100),
    logo character varying(100),
    login character varying(40),
    password character varying(50),
    is_panelaccess boolean,
    is_panel_accountsummary boolean,
    is_panel_ratetable boolean,
    is_panel_trunks boolean,
    is_panel_products boolean,
    is_panel_balance boolean,
    is_panel_paymenthistory boolean,
    is_panel_onlinepayment boolean,
    role_id integer,
    create_time timestamp with time zone,
    profit_margin double precision,
    enough_balance boolean,
    service_charge_id integer,
    noc_email character varying(100),
    billing_email character varying,
    rate_email character varying(100),
    tax_id character varying(100),
    details character varying(1000),
    invoice_show_details boolean,
    invoice_past_amount numeric(30,10),
    is_link_cdr boolean,
    is_trunk boolean,
    is_route boolean,
    is_spam boolean,
    is_location boolean,
    is_orig_term boolean,
    is_usage boolean,
    is_qos boolean,
    is_discon boolean,
    is_bill_mismatch boolean,
    is_active_call boolean,
    is_termin boolean,
    database_name character varying(50),
    is_rate_anal boolean,
    is_capture boolean,
    is_call_simulation boolean,
    is_ingress_sim boolean,
    is_egress_sim boolean,
    is_report boolean,
    is_tools boolean,
    is_manage boolean,
    mail_sended integer,
    scc_bellow integer,
    scc_percent integer,
    scc_charge numeric(30,10),
    user_id integer,
    profit_type integer,
    auto_invoice_type integer,
    cps_limit integer,
    call_limit integer,
    invoice_zone character varying(10),
    invoice_zero boolean,
    update_at timestamp with time zone,
    update_by character varying,
    corporate_contact_email character varying(100),
    paypal character varying(100),
    is_auto_summary boolean,
    auto_send_zone character varying,
    is_daily_balance_notification boolean,
    daily_balance_notification integer,
    daily_balance_recipient integer,
    low_balance_number integer,
    is_auto_balance boolean,
    numer_of_days_balance integer,
    auto_daily_balance_recipient integer,
    daily_cdr_generation boolean,
    daily_cdr_generation_zone character varying,
    daily_cdr_generation_type smallint,
    transaction_fee_id integer,
    unlimited_credit boolean,
    include_payment_history smallint,
    include_available_credit smallint,
    include_payment_history_days integer,
    auto_summary_not_zero smallint,
    auto_summary_group_by smallint,
    daily_balance_already_sent boolean,
    last_autoreport_time timestamp with time zone,
    last_lowbalance_time timestamp with time zone,
    last_cdrdown_time timestamp with time zone,
    include_tax boolean,
    tax numeric(5,2),
    invoice_jurisdictional_detail boolean,
    decimal_place integer,
    par_id integer,
    rate_value integer,
    email_invoice boolean,
    scc_type integer,
    is_invoice_account_summary boolean,
    is_show_daily_usage boolean,
    invoice_include_payment boolean,
    is_short_duration_call_surcharge_detail boolean,
    usage_detail_fields text,
    auto_summary_hour integer,
    auto_summary_period integer,
    last_autobalance_time timestamp with time zone,
    auto_summary_include_cdr boolean,
    client_type integer,
    rate_delivery_email character varying(250),
    invoice_use_balance_type integer,
    notify_client_balance_type integer,
    finance_email_cc character varying,
    decimals_num integer,
    invoice_start_from date,
    low_balance_notification_time_type integer,
    low_balance_notification_time_cycle integer,
    daily_balance_send_time time without time zone,
    daily_balance_send_time_zone character varying(20),
    is_breakdown_by_rate_table boolean,
    breakdown_by_rate_table smallint,
    offset_balance boolean,
    is_show_detail_trunk boolean,
    is_show_total_trunk boolean,
    is_show_code_100 boolean,
    is_show_code_name boolean,
    is_show_country boolean,
    is_show_by_date boolean,
    daily_limit integer,
    hourly_limit integer,
    carrier_template_id integer,
    is_send_trunk_update boolean,
    phone character varying(20),
    is_panel_invoices boolean,
    is_panel_cdrslist boolean,
    is_panel_summaryreport boolean,
    is_panel_sippacket boolean,
    is_panel_mydid boolean,
    is_panel_didrequest boolean,
    is_send_as_link boolean,
    is_vendor_invoice boolean,
    vendor_payment_term_id integer,
    group_id integer,
    zero_balance_notice_time integer,
    zero_balance_notice_last_sent timestamp with time zone,
    zero_balance_notice_first_sended boolean,
    zero_balance_notice boolean,
    auto_report_type integer,
    daily_cdr_generation_last_qcreated timestamp with time zone,
    enable_payment_alert boolean,
    is_panel_cid_blocking boolean,
    did_invoice_include varchar(255),
    auto_invoice_hour integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('client_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE client_record OWNER TO postgres;

--
-- Name: client_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: client_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_record_tmp (
    client_id integer,
    name character varying(500),
    mode integer,
    orig_rate_table_id integer,
    term_rate_table_id integer,
    currency_id integer,
    allowed_credit numeric(30,10),
    status boolean,
    auto_invoicing boolean,
    payment_term_id integer,
    invoice_format integer,
    attach_cdrs_list boolean,
    cdr_list_format integer,
    last_invoiced timestamp with time zone,
    notify_client_balance numeric(30,10),
    notify_admin_balance numeric(30,10),
    low_balance_notice boolean,
    company character varying,
    address character varying(500),
    email character varying(100),
    logo character varying(100),
    login character varying(40),
    password character varying(50),
    is_panelaccess boolean,
    is_panel_accountsummary boolean,
    is_panel_ratetable boolean,
    is_panel_trunks boolean,
    is_panel_products boolean,
    is_panel_balance boolean,
    is_panel_paymenthistory boolean,
    is_panel_onlinepayment boolean,
    role_id integer,
    create_time timestamp with time zone,
    profit_margin double precision,
    enough_balance boolean,
    service_charge_id integer,
    noc_email character varying(100),
    billing_email character varying,
    rate_email character varying(100),
    tax_id character varying(100),
    details character varying(1000),
    invoice_show_details boolean,
    invoice_past_amount numeric(30,10),
    is_link_cdr boolean,
    is_trunk boolean,
    is_route boolean,
    is_spam boolean,
    is_location boolean,
    is_orig_term boolean,
    is_usage boolean,
    is_qos boolean,
    is_discon boolean,
    is_bill_mismatch boolean,
    is_active_call boolean,
    is_termin boolean,
    database_name character varying(50),
    is_rate_anal boolean,
    is_capture boolean,
    is_call_simulation boolean,
    is_ingress_sim boolean,
    is_egress_sim boolean,
    is_report boolean,
    is_tools boolean,
    is_manage boolean,
    mail_sended integer,
    scc_bellow integer,
    scc_percent integer,
    scc_charge numeric(30,10),
    user_id integer,
    profit_type integer,
    auto_invoice_type integer,
    cps_limit integer,
    call_limit integer,
    invoice_zone character varying(10),
    invoice_zero boolean,
    update_at timestamp with time zone,
    update_by character varying,
    corporate_contact_email character varying(100),
    paypal character varying(100),
    is_auto_summary boolean,
    auto_send_zone character varying,
    is_daily_balance_notification boolean,
    daily_balance_notification integer,
    daily_balance_recipient integer,
    low_balance_number integer,
    is_auto_balance boolean,
    numer_of_days_balance integer,
    auto_daily_balance_recipient integer,
    daily_cdr_generation boolean,
    daily_cdr_generation_zone character varying,
    daily_cdr_generation_type smallint,
    transaction_fee_id integer,
    unlimited_credit boolean,
    include_payment_history smallint,
    include_available_credit smallint,
    include_payment_history_days integer,
    auto_summary_not_zero smallint,
    auto_summary_group_by smallint,
    daily_balance_already_sent boolean,
    last_autoreport_time timestamp with time zone,
    last_lowbalance_time timestamp with time zone,
    last_cdrdown_time timestamp with time zone,
    include_tax boolean,
    tax numeric(5,2),
    invoice_jurisdictional_detail boolean,
    decimal_place integer,
    par_id integer,
    rate_value integer,
    email_invoice boolean,
    scc_type integer,
    is_invoice_account_summary boolean,
    is_show_daily_usage boolean,
    invoice_include_payment boolean,
    is_short_duration_call_surcharge_detail boolean,
    usage_detail_fields text,
    auto_summary_hour integer,
    auto_summary_period integer,
    last_autobalance_time timestamp with time zone,
    auto_summary_include_cdr boolean,
    client_type integer,
    rate_delivery_email character varying(250),
    invoice_use_balance_type integer,
    notify_client_balance_type integer,
    finance_email_cc character varying,
    decimals_num integer,
    invoice_start_from date,
    low_balance_notification_time_type integer,
    low_balance_notification_time_cycle integer,
    daily_balance_send_time time without time zone,
    daily_balance_send_time_zone character varying(20),
    is_breakdown_by_rate_table boolean,
    breakdown_by_rate_table smallint,
    offset_balance boolean,
    is_show_detail_trunk boolean,
    is_show_total_trunk boolean,
    is_show_code_100 boolean,
    is_show_code_name boolean,
    is_show_country boolean,
    is_show_by_date boolean,
    daily_limit integer,
    hourly_limit integer,
    carrier_template_id integer,
    is_send_trunk_update boolean,
    phone character varying(20),
    is_panel_invoices boolean,
    is_panel_cdrslist boolean,
    is_panel_summaryreport boolean,
    is_panel_sippacket boolean,
    is_panel_mydid boolean,
    is_panel_didrequest boolean,
    is_send_as_link boolean,
    is_vendor_invoice boolean,
    vendor_payment_term_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('client_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE client_record_tmp OWNER TO postgres;

--
-- Name: client_route_request; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_route_request (
    id integer NOT NULL,
    client_id integer,
    rate real,
    asr real,
    acd real,
    request_time timestamp with time zone,
    dtmf boolean,
    t38 boolean,
    g729 boolean,
    g723 boolean,
    g711 boolean,
    route_quality integer,
    traffic integer,
    resource_id numeric
);


ALTER TABLE client_route_request OWNER TO postgres;

--
-- Name: client_route_request_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_route_request_code (
    id integer NOT NULL,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    request_id integer
);


ALTER TABLE client_route_request_code OWNER TO postgres;

--
-- Name: client_route_request_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_route_request_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_route_request_code_id_seq OWNER TO postgres;

--
-- Name: client_route_request_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE client_route_request_code_id_seq OWNED BY client_route_request_code.id;


--
-- Name: client_route_request_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_route_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_route_request_id_seq OWNER TO postgres;

--
-- Name: client_route_request_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE client_route_request_id_seq OWNED BY client_route_request.id;


--
-- Name: client_route_strategy; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_route_strategy (
    id integer NOT NULL,
    prefix prefix_range DEFAULT ''::prefix_range,
    routing_rule integer DEFAULT 1,
    priority integer DEFAULT 1,
    priority_val integer DEFAULT 0,
    client_id integer NOT NULL
);


ALTER TABLE client_route_strategy OWNER TO postgres;

--
-- Name: COLUMN client_route_strategy.prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_route_strategy.prefix IS 'å·ç å‰ç¼€ï¼Œæ‰‹åŠ¨è¾“å…¥';


--
-- Name: COLUMN client_route_strategy.routing_rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_route_strategy.routing_rule IS '1ï¼šManually Buy, Manually Sell, Automatic Match
2ï¼šManually Buy, Automatic Match, Manually Sell
3ï¼šManually Sell, Manually Buy, Automatic Match,
4ï¼šManually Sell, Automatic Match, Manually Buy
5ï¼šAutomatic Match, Manually Buy, Manually Sell
6ï¼šAutomatic Match, Manually Sell, Manually Buy';


--
-- Name: COLUMN client_route_strategy.priority; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_route_strategy.priority IS '1ï¼šprice
2ï¼šQOS';


--
-- Name: COLUMN client_route_strategy.priority_val; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_route_strategy.priority_val IS '1: ASR
2: ACD
3: PDD';


--
-- Name: COLUMN client_route_strategy.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN client_route_strategy.client_id IS 'å®¢æˆ·id';


--
-- Name: client_route_strategy_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_route_strategy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_route_strategy_id_seq OWNER TO postgres;

--
-- Name: client_route_strategy_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE client_route_strategy_id_seq OWNED BY client_route_strategy.id;


--
-- Name: client_transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE client_transaction (
    client_id integer,
    amount real,
    balance real,
    type integer,
    date timestamp with time zone,
    id integer NOT NULL
);


ALTER TABLE client_transaction OWNER TO postgres;

--
-- Name: client_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE client_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE client_transaction_id_seq OWNER TO postgres;

--
-- Name: client_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE client_transaction_id_seq OWNED BY client_transaction.id;


--
-- Name: code_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE code_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE code_code_id_seq OWNER TO postgres;

--
-- Name: code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE code (
    code_id integer DEFAULT nextval('code_code_id_seq'::regclass) NOT NULL,
    code prefix_range NOT NULL,
    code_deck_id integer,
    city character varying(20),
    state character varying(20),
    country character varying(100),
    name character varying(100)
);


ALTER TABLE code OWNER TO postgres;

--
-- Name: TABLE code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE code IS 'è´¹çŽ‡å‰ç¼€';


--
-- Name: COLUMN code.code_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code.code_id IS 'ä¸»é”®';


--
-- Name: COLUMN code.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code.code IS 'å‰ç¼€';


--
-- Name: COLUMN code.code_deck_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code.code_deck_id IS 'å‰ç¼€ç»„(å·ç ç»„)';


--
-- Name: COLUMN code.city; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code.city IS 'åŸŽå¸‚';


--
-- Name: COLUMN code.state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code.state IS 'çœä»½';


--
-- Name: COLUMN code.country; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code.country IS 'å›½å®¶';


--
-- Name: COLUMN code.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code.name IS 'åç§°';


--
-- Name: code_based_report_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE code_based_report_log (
    id integer NOT NULL,
    user_id integer,
    status_id integer DEFAULT 0,
    export_start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    export_end_time timestamp with time zone,
    file_name character varying(500),
    search_start_date timestamp with time zone,
    search_end_date timestamp with time zone,
    email_when_done integer DEFAULT 0,
    ingress_trunk_id integer DEFAULT 0,
    egress_trunk_id integer DEFAULT 0
);


ALTER TABLE code_based_report_log OWNER TO postgres;

--
-- Name: code_based_report_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE code_based_report_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE code_based_report_log_id_seq OWNER TO postgres;

--
-- Name: code_based_report_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE code_based_report_log_id_seq OWNED BY code_based_report_log.id;


--
-- Name: code_based_report_log_status; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE code_based_report_log_status (
    id integer NOT NULL,
    status_value character varying(200)
);


ALTER TABLE code_based_report_log_status OWNER TO postgres;

--
-- Name: code_based_report_log_status_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE code_based_report_log_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE code_based_report_log_status_id_seq OWNER TO postgres;

--
-- Name: code_based_report_log_status_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE code_based_report_log_status_id_seq OWNED BY code_based_report_log_status.id;


--
-- Name: code_country; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE code_country (
    country character varying(80),
    country_code character varying(20)
);


ALTER TABLE code_country OWNER TO postgres;

--
-- Name: code_deck; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE code_deck (
    code_deck_id integer NOT NULL,
    name character varying(100) NOT NULL,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    client_id integer
);


ALTER TABLE code_deck OWNER TO postgres;

--
-- Name: TABLE code_deck; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE code_deck IS 'è´¹çŽ‡å‰ç¼€ç»„';


--
-- Name: COLUMN code_deck.code_deck_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_deck.code_deck_id IS 'ä¸»é”®';


--
-- Name: COLUMN code_deck.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_deck.name IS 'åç§°';


--
-- Name: COLUMN code_deck.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_deck.client_id IS 'ç­‰äºŽé›¶éƒ½æ˜¯é»˜è®¤çš„
0-a/z
-1-us
å…¶å®ƒå€¼ä¸ºè¯¥code deck ä¸“ç”¨';


--
-- Name: code_deck_code_deck_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE code_deck_code_deck_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE code_deck_code_deck_id_seq OWNER TO postgres;

--
-- Name: code_deck_code_deck_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE code_deck_code_deck_id_seq OWNED BY code_deck.code_deck_id;


--
-- Name: code_name_rate_table_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE code_name_rate_table_ref (
    "time" bigint,
    code_name character varying(100),
    rate_table_id integer,
    min_rate numeric,
    max_rate numeric,
    min_rate_fee numeric,
    max_rate_fee numeric
);


ALTER TABLE code_name_rate_table_ref OWNER TO postgres;

--
-- Name: TABLE code_name_rate_table_ref; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE code_name_rate_table_ref IS 'exchangeä½¿ç”¨ï¼Œcode decké‡Œçš„code nameå’Œrate tableå¯¹åº”è¡¨ã€‚';


--
-- Name: COLUMN code_name_rate_table_ref."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_name_rate_table_ref."time" IS 'äº§ç”Ÿè®°å½•æ—¶é—´ï¼Œé•¿æ•´å½¢ï¼Œç§’ç²¾åº¦ã€‚';


--
-- Name: COLUMN code_name_rate_table_ref.code_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_name_rate_table_ref.code_name IS 'å¯¹åº”code_decké‡Œçš„code_name';


--
-- Name: COLUMN code_name_rate_table_ref.min_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_name_rate_table_ref.min_rate IS 'åœ°åŒºæœ€ä½Žè´¹çŽ‡';


--
-- Name: COLUMN code_name_rate_table_ref.max_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_name_rate_table_ref.max_rate IS 'åœ°åŒºæœ€é«˜è´¹çŽ‡';


--
-- Name: COLUMN code_name_rate_table_ref.min_rate_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_name_rate_table_ref.min_rate_fee IS 'åœ°åŒºæœ€ä½Žè´¹çŽ‡ï¼Œå·²ç®—è¿›transaction fee';


--
-- Name: COLUMN code_name_rate_table_ref.max_rate_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_name_rate_table_ref.max_rate_fee IS 'åœ°åŒºæœ€é«˜è´¹çŽ‡ï¼Œå·²ç®—è¿›transaction fee';


--
-- Name: code_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE code_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE code_record_record_id_seq OWNER TO postgres;

--
-- Name: code_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE code_record (
    code_id integer,
    code prefix_range,
    code_deck_id integer,
    city character varying(20),
    state character varying(20),
    country character varying(100),
    name character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('code_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE code_record OWNER TO postgres;

--
-- Name: code_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE code_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE code_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: code_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE code_record_tmp (
    code_id integer,
    code prefix_range,
    code_deck_id integer,
    city character varying(20),
    state character varying(20),
    country character varying(100),
    name character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('code_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE code_record_tmp OWNER TO postgres;

--
-- Name: code_stats; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE code_stats (
    id integer NOT NULL,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    call_duration real,
    asr real,
    acd real,
    ca integer,
    success_calls integer,
    failed_calls integer,
    avg_buy_rate numeric(30,10),
    avg_sell_rate numeric(30,10),
    total_buy_volume integer,
    total_sell_volume integer,
    stat_time timestamp with time zone
);


ALTER TABLE code_stats OWNER TO postgres;

--
-- Name: COLUMN code_stats.asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_stats.asr IS 'success_calls/ca';


--
-- Name: COLUMN code_stats.acd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_stats.acd IS 'call_duration/success_calls';


--
-- Name: COLUMN code_stats.failed_calls; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN code_stats.failed_calls IS 'ca-success_calls';


--
-- Name: code_stats_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE code_stats_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE code_stats_id_seq OWNER TO postgres;

--
-- Name: code_stats_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE code_stats_id_seq OWNED BY code_stats.id;


--
-- Name: codecs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE codecs (
    id integer NOT NULL,
    name character varying(40) NOT NULL,
    detail character varying(100)
);


ALTER TABLE codecs OWNER TO postgres;

--
-- Name: TABLE codecs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE codecs IS 'ç¼–ç ';


--
-- Name: COLUMN codecs.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN codecs.id IS 'ä¸»é”®';


--
-- Name: COLUMN codecs.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN codecs.name IS 'åç§°';


--
-- Name: COLUMN codecs.detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN codecs.detail IS 'æè¿°';


--
-- Name: contract; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE contract (
    id integer NOT NULL,
    contract_type integer,
    order_id integer NOT NULL,
    order_response_id integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    status integer,
    expire_time timestamp with time zone,
    is_commit boolean DEFAULT false NOT NULL,
    commit_minutes integer,
    client_id integer NOT NULL,
    is_private boolean DEFAULT false NOT NULL,
    resource_id integer NOT NULL,
    confirm_order_number integer NOT NULL,
    user_id integer NOT NULL,
    resource_prefix prefix_range DEFAULT ''::prefix_range NOT NULL,
    order_response_rate numeric(30,10) NOT NULL,
    auto_match boolean DEFAULT false NOT NULL,
    finance_rate real,
    actioned boolean DEFAULT false
);


ALTER TABLE contract OWNER TO postgres;

--
-- Name: COLUMN contract.contract_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN contract.contract_type IS 'åˆåŒç±»åž‹
1ï¼ï¼buy orderå‘å¸ƒ
2ï¼ï¼sell orderå‘å¸ƒ';


--
-- Name: COLUMN contract.order_response_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN contract.order_response_id IS 'è·Ÿä»–äº¤æ˜“çš„order_id';


--
-- Name: COLUMN contract.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN contract.status IS '1ï¼ï¼active
2ï¼ï¼expired
3ï¼ï¼order creater hold
4ï¼ï¼order responser hold
5ï¼ï¼è¢«æ”¹åŠ¨è‡ªåŠ¨hold
6ï¼ï¼å‡†å¤‡åˆ é™¤
7ï¼ï¼ä»·æ ¼å˜åŠ¨';


--
-- Name: COLUMN contract.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN contract.client_id IS 'è·Ÿä»–äº¤æ˜“çš„client_id';


--
-- Name: COLUMN contract.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN contract.resource_id IS 'è·Ÿä»–äº¤æ˜“çš„resource_id';


--
-- Name: COLUMN contract.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN contract.user_id IS 'è·Ÿä»–äº¤æ˜“çš„user_id';


--
-- Name: COLUMN contract.order_response_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN contract.order_response_rate IS 'åŠ è¿‡æœåŠ¡è´¹çš„æˆäº¤ä»·æ ¼';


--
-- Name: contract_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE contract_code (
    id integer NOT NULL,
    contract_id integer NOT NULL,
    code character varying(100),
    code_name character varying(100),
    country character varying(100)
);


ALTER TABLE contract_code OWNER TO postgres;

--
-- Name: contract_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE contract_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE contract_code_id_seq OWNER TO postgres;

--
-- Name: contract_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE contract_code_id_seq OWNED BY contract_code.id;


--
-- Name: contract_confirm_order_number_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE contract_confirm_order_number_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE contract_confirm_order_number_seq OWNER TO postgres;

--
-- Name: contract_confirm_order_number_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE contract_confirm_order_number_seq OWNED BY contract.confirm_order_number;


--
-- Name: contract_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE contract_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE contract_id_seq OWNER TO postgres;

--
-- Name: contract_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE contract_id_seq OWNED BY contract.id;


--
-- Name: contract_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE contract_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE contract_record_record_id_seq OWNER TO postgres;

--
-- Name: contract_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE contract_record (
    id integer,
    contract_type integer,
    order_id integer,
    order_response_id integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    status integer,
    expire_time timestamp with time zone,
    is_commit boolean,
    commit_minutes integer,
    client_id integer,
    is_private boolean,
    resource_id integer,
    confirm_order_number integer,
    user_id integer,
    resource_prefix prefix_range,
    order_response_rate numeric(30,10),
    auto_match boolean,
    finance_rate real,
    actioned boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('contract_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE contract_record OWNER TO postgres;

--
-- Name: credit_application; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE credit_application (
    id integer NOT NULL,
    user_id integer,
    client_id integer,
    legal_name character varying(500),
    register_number character varying(500),
    established character varying(500),
    country_incorporation character varying(500),
    gross_annual_revenue character varying(500),
    principals character varying(500),
    head_office_address character varying(500),
    phone character varying(500),
    email character varying(500),
    company_url character varying(500),
    annual_sales_volumes character varying(500),
    d_b character varying(500),
    bank_name character varying(500),
    address character varying(500),
    city character varying(500),
    postal_code character varying(500),
    country character varying(500),
    bank_officer character varying(500),
    account_type character varying(500),
    account character varying(500),
    swift character varying(500),
    bank_phone character varying(500),
    bank_email character varying(500),
    company_name_1 character varying(500),
    years_doing_business_1 character varying(500),
    contact_person_1 character varying(500),
    position_1 character varying(500),
    trade_phone_1 character varying(500),
    trade_fax_1 character varying(500),
    trade_email_1 character varying(500),
    company_name_2 character varying(500),
    years_doing_business_2 character varying(500),
    contact_person_2 character varying(500),
    position_2 character varying(500),
    trade_phone_2 character varying(500),
    trade_fax_2 character varying(500),
    trade_email_2 character varying(500),
    company_name_3 character varying(500),
    years_doing_business_3 character varying(500),
    contact_person_3 character varying(500),
    position_3 character varying(500),
    trade_phone_3 character varying(500),
    trade_fax_3 character varying(500),
    trade_email_3 character varying(500),
    application_name character varying(100),
    application_position character varying(500),
    application_date timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    flag integer DEFAULT 0 NOT NULL
);


ALTER TABLE credit_application OWNER TO postgres;

--
-- Name: COLUMN credit_application.flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN credit_application.flag IS '0æ–°çš„ç”³è¯·
1æ‰¹å‡†ç”³è¯·';


--
-- Name: credit_application_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE credit_application_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE credit_application_id_seq OWNER TO postgres;

--
-- Name: credit_application_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE credit_application_id_seq OWNED BY credit_application.id;


--
-- Name: credit_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE credit_log (
    id integer NOT NULL,
    modified_by character varying(200),
    modified_from numeric(30,10),
    modified_to numeric(30,10),
    modified_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    carrier_name character varying(200)
);


ALTER TABLE credit_log OWNER TO postgres;

--
-- Name: credit_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE credit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE credit_log_id_seq OWNER TO postgres;

--
-- Name: credit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE credit_log_id_seq OWNED BY credit_log.id;


--
-- Name: currency_currency_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE currency_currency_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE currency_currency_id_seq OWNER TO postgres;

--
-- Name: currency; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE currency (
    currency_id integer DEFAULT nextval('currency_currency_id_seq'::regclass) NOT NULL,
    code character varying(100) NOT NULL,
    active boolean DEFAULT true NOT NULL,
    update_by character varying
);


ALTER TABLE currency OWNER TO postgres;

--
-- Name: TABLE currency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE currency IS 'è´§å¸';


--
-- Name: COLUMN currency.currency_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN currency.currency_id IS 'ä¸»é”®';


--
-- Name: COLUMN currency.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN currency.code IS 'è´§å¸å›½å®¶ä»£å·';


--
-- Name: COLUMN currency.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN currency.active IS 'æ˜¯å¦å¯ç”¨';


--
-- Name: currency_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE currency_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE currency_record_record_id_seq OWNER TO postgres;

--
-- Name: currency_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE currency_record (
    currency_id integer,
    code character varying(100),
    active boolean,
    update_by character varying,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('currency_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE currency_record OWNER TO postgres;

--
-- Name: currency_updates_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE currency_updates_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999999
    CACHE 1;


ALTER TABLE currency_updates_id_seq OWNER TO postgres;

--
-- Name: currency_updates; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE currency_updates (
    currency_id integer NOT NULL,
    modify_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    rate numeric(30,6) NOT NULL,
    last_rate numeric(30,10),
    currency_updates_id integer DEFAULT nextval('currency_updates_id_seq'::regclass) NOT NULL
);


ALTER TABLE currency_updates OWNER TO postgres;

--
-- Name: TABLE currency_updates; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE currency_updates IS 'è´§å¸æ±‡çŽ‡æ›´æ–°è®°å½•';


--
-- Name: COLUMN currency_updates.currency_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN currency_updates.currency_id IS 'è´§å¸';


--
-- Name: COLUMN currency_updates.modify_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN currency_updates.modify_time IS 'ä¿®æ”¹æ—¶é—´';


--
-- Name: COLUMN currency_updates.rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN currency_updates.rate IS 'æ±‡çŽ‡';


--
-- Name: COLUMN currency_updates.last_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN currency_updates.last_rate IS 'ä¸Šæ¬¡æ±‡çŽ‡';


--
-- Name: COLUMN currency_updates.currency_updates_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN currency_updates.currency_updates_id IS 'ä¸»é”®

//currency_updates_currency_updates_id_seq';


--
-- Name: currency_updates_currency_updates_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE currency_updates_currency_updates_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE currency_updates_currency_updates_id_seq OWNER TO postgres;

--
-- Name: currency_updates_currency_updates_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE currency_updates_currency_updates_id_seq OWNED BY currency_updates.currency_updates_id;


--
-- Name: currency_updates_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE currency_updates_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE currency_updates_record_record_id_seq OWNER TO postgres;

--
-- Name: currency_updates_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE currency_updates_record (
    currency_id integer,
    modify_time timestamp with time zone,
    rate numeric(30,6),
    last_rate numeric(30,10),
    currency_updates_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('currency_updates_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE currency_updates_record OWNER TO postgres;

--
-- Name: currency_updates_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE currency_updates_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE currency_updates_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: currency_updates_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE currency_updates_record_tmp (
    currency_id integer,
    modify_time timestamp with time zone,
    rate numeric(30,6),
    last_rate numeric(30,10),
    currency_updates_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('currency_updates_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE currency_updates_record_tmp OWNER TO postgres;

--
-- Name: current_dashboard_data; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE current_dashboard_data (
    id integer NOT NULL,
    cps integer DEFAULT 0,
    channel integer DEFAULT 0,
    call integer DEFAULT 0,
    create_time timestamp without time zone,
    select_time timestamp with time zone,
    identifier integer,
    server character varying(100)
);


ALTER TABLE current_dashboard_data OWNER TO postgres;

--
-- Name: current_dashboard_data_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE current_dashboard_data_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE current_dashboard_data_id_seq OWNER TO postgres;

--
-- Name: current_dashboard_data_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE current_dashboard_data_id_seq OWNED BY current_dashboard_data.id;


--
-- Name: daily_cdr_fields; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE daily_cdr_fields (
    id integer NOT NULL,
    type smallint,
    field character varying,
    label character varying
);


ALTER TABLE daily_cdr_fields OWNER TO postgres;

--
-- Name: TABLE daily_cdr_fields; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE daily_cdr_fields IS 'daily cdr æ¯å¤©å‘é€é‚®ä»¶';


--
-- Name: daily_cdr_fields_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE daily_cdr_fields_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE daily_cdr_fields_id_seq OWNER TO postgres;

--
-- Name: daily_cdr_fields_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE daily_cdr_fields_id_seq OWNED BY daily_cdr_fields.id;


--
-- Name: email_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE email_log (
    id integer NOT NULL,
    send_time timestamp with time zone,
    client_id integer,
    email_addresses character varying(500),
    files character varying(500),
    type smallint,
    email_res text,
    alert_block_egress_id integer,
    alert_block_code_name text,
    status smallint,
    error text,
    resend_email text,
    subject character varying(100),
    content text,
    is_view integer DEFAULT 0 NOT NULL,
    alert_rule character varying(500)
);


ALTER TABLE email_log OWNER TO postgres;

--
-- Name: COLUMN email_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN email_log.type IS '1,low balance
2,daily summary
3,auto delivery
4,alert_route
5,cdr_down
6,exchange_alert_route
7,invoice
21, Payment Received
22, Rule Alert
';


--
-- Name: COLUMN email_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN email_log.status IS '0ï¼Œnull-successï¼›1-fail';


--
-- Name: COLUMN email_log.error; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN email_log.error IS 'email error';


--
-- Name: COLUMN email_log.is_view; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN email_log.is_view IS 'æ˜¯å¦åœ¨è‡ªåŠ©é¡µé¢æŸ¥çœ‹';


--
-- Name: daily_email_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE daily_email_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE daily_email_log_id_seq OWNER TO postgres;

--
-- Name: daily_email_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE daily_email_log_id_seq OWNED BY email_log.id;


--
-- Name: dashboard_time_option; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dashboard_time_option (
    id integer NOT NULL,
    admin_point_time timestamp with time zone,
    client_point_time timestamp with time zone,
    iden character varying(30)
);


ALTER TABLE dashboard_time_option OWNER TO postgres;

--
-- Name: COLUMN dashboard_time_option.iden; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dashboard_time_option.iden IS 'user_id + _Ymd + _His';


--
-- Name: dashboard_time_option_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dashboard_time_option_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dashboard_time_option_id_seq OWNER TO postgres;

--
-- Name: dashboard_time_option_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE dashboard_time_option_id_seq OWNED BY dashboard_time_option.id;


--
-- Name: default_fields; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE default_fields (
    report_name character varying(255),
    fields text
);


ALTER TABLE default_fields OWNER TO postgres;

--
-- Name: dex; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dex (
    id integer NOT NULL,
    dex_name character varying(100),
    dex_prefix character varying(100)
);


ALTER TABLE dex OWNER TO postgres;

--
-- Name: dex_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dex_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dex_id_seq OWNER TO postgres;

--
-- Name: dex_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE dex_id_seq OWNED BY dex.id;


--
-- Name: dex_resource; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dex_resource (
    dex_id integer NOT NULL,
    resource_id integer NOT NULL,
    id integer NOT NULL
);


ALTER TABLE dex_resource OWNER TO postgres;

--
-- Name: dex_resource_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dex_resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dex_resource_id_seq OWNER TO postgres;

--
-- Name: dex_resource_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE dex_resource_id_seq OWNED BY dex_resource.id;


--
-- Name: dex_resource_unactive_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dex_resource_unactive_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dex_resource_unactive_id_seq OWNER TO postgres;

--
-- Name: dex_resource_unactive; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dex_resource_unactive (
    id integer DEFAULT nextval('dex_resource_unactive_id_seq'::regclass) NOT NULL,
    dex_id integer,
    dex_resource integer,
    ingress_id integer
);


ALTER TABLE dex_resource_unactive OWNER TO postgres;

--
-- Name: dex_resource_uactive_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dex_resource_uactive_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dex_resource_uactive_id_seq OWNER TO postgres;

--
-- Name: dex_resource_uactive_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE dex_resource_uactive_id_seq OWNED BY dex_resource_unactive.id;


--
-- Name: dialer_detection; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dialer_detection (
    ani_scope integer,
    ani_within_mins smallint,
    dialer_detection_type smallint DEFAULT 0 NOT NULL,
    unblock_ani_mins integer,
    sent_type smallint,
    id integer NOT NULL,
    action boolean DEFAULT false NOT NULL,
    ani_pid integer,
    dnis_scope integer,
    dnis_within_second smallint,
    dnis_pid integer,
    trunk_type smallint,
    name character varying(100),
    trunk character varying(100),
    min_call integer,
    unblock_ani_type smallint,
    last_run_time timestamp without time zone,
    dialer_detection_subject text,
    dialer_detection_content text,
    send_email integer,
    block_ani integer
);


ALTER TABLE dialer_detection OWNER TO postgres;

--
-- Name: TABLE dialer_detection; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE dialer_detection IS 'monitoring dialer_detectionçš„æ•°æ®';


--
-- Name: COLUMN dialer_detection.ani_scope; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.ani_scope IS 'Number of Occurrence of an ANI >=(ani_scope)';


--
-- Name: COLUMN dialer_detection.ani_within_mins; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.ani_within_mins IS 'Number of Occurrence of an ANI >=    _______   within _(within_second)_ mins';


--
-- Name: COLUMN dialer_detection.dialer_detection_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.dialer_detection_type IS '0:Email to Ingress Carrier
1:Block ANI ';


--
-- Name: COLUMN dialer_detection.unblock_ani_mins; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.unblock_ani_mins IS 'Unblock ANI: Never / After _____ mins';


--
-- Name: COLUMN dialer_detection.sent_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.sent_type IS '0:Your Own NOC
1:Partnerâ€™s NOC
2:Both';


--
-- Name: COLUMN dialer_detection.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.action IS 'æ˜¯å¦å¼€å¯';


--
-- Name: COLUMN dialer_detection.ani_pid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.ani_pid IS 'pid  aniåˆ¤æ–­';


--
-- Name: COLUMN dialer_detection.dnis_scope; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.dnis_scope IS 'Number of Occurrence of an DNIS >=(dnis_scope)';


--
-- Name: COLUMN dialer_detection.dnis_within_second; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.dnis_within_second IS 'Number of Occurrence of an dnis >=    _______ ';


--
-- Name: COLUMN dialer_detection.dnis_pid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.dnis_pid IS 'pid  dnisåˆ¤æ–­';


--
-- Name: COLUMN dialer_detection.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.trunk_type IS '1:ingress
2:egress';


--
-- Name: COLUMN dialer_detection.trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.trunk IS 'trunk alias or ALL';


--
-- Name: COLUMN dialer_detection.min_call; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.min_call IS 'è‡³å°‘æœ‰å¤šå°‘ä¸ªç”µè¯æ‰ç®—æ˜¯ç¬¦åˆæ¡ä»¶';


--
-- Name: COLUMN dialer_detection.unblock_ani_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.unblock_ani_type IS '0ä¸ºNever
1ä¸ºAfter';


--
-- Name: COLUMN dialer_detection.last_run_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.last_run_time IS 'ä¸Šæ¬¡æ‰§è¡Œæ—¶é—´';


--
-- Name: COLUMN dialer_detection.send_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.send_email IS 'o false
1 true';


--
-- Name: COLUMN dialer_detection.block_ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN dialer_detection.block_ani IS '0 false
1 true';


--
-- Name: dialer_detection_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dialer_detection_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dialer_detection_id_seq OWNER TO postgres;

--
-- Name: dialer_detection_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE dialer_detection_id_seq OWNED BY dialer_detection.id;


--
-- Name: did_assign; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE did_assign (
    number prefix_range NOT NULL,
    egress_id integer NOT NULL,
    created_time timestamp with time zone,
    assigned_time timestamp with time zone,
    status smallint DEFAULT 0,
    ingress_id integer
);


ALTER TABLE did_assign OWNER TO postgres;

--
-- Name: did_billing_plan; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE did_billing_plan (
    id integer NOT NULL,
    did_price real DEFAULT 0,
    min_price real DEFAULT 0,
    name character varying(255),
    payphone_subcharge character varying,
    monthly_charge numeric,
    rate_table_id integer,
    rate_type integer,
    pay_type smallint DEFAULT 0,
    fee_per_port numeric DEFAULT 0,
    price_type smallint default 0
);


ALTER TABLE did_billing_plan OWNER TO postgres;

--
-- Name: COLUMN did_billing_plan.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN did_billing_plan.rate_type IS '1 - Fixed rate; 2 - Variable rate';

--
-- Name: COLUMN did_billing_plan.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN did_billing_plan.pay_type IS '0 - Weekly; 1 - Monthly';


--
-- Name: did_billing_plan_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE did_billing_plan_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE did_billing_plan_id_seq OWNER TO postgres;

--
-- Name: did_billing_plan_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE did_billing_plan_id_seq OWNED BY did_billing_plan.id;


--
-- Name: did_billing_rel; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE did_billing_rel (
    id integer NOT NULL,
    did character varying(50),
    sell_billing_plan_id integer,
    buy_billing_plan_id integer,
    did_billing_id integer,
    start_date date,
    ingress_res_id integer,
    egress_res_id integer,
    end_date date,
    enable_for_clients boolean DEFAULT false,
    rate_id integer
);


ALTER TABLE did_billing_rel OWNER TO postgres;

--
-- Name: did_billing_rel_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE did_billing_rel_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE did_billing_rel_id_seq OWNER TO postgres;

--
-- Name: did_billing_rel_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE did_billing_rel_id_seq OWNED BY did_billing_rel.id;


--
-- Name: did_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE did_report (
    report_time timestamp with time zone,
    duration integer,
    ingress_bill_time integer,
    ingress_call_cost numeric(15,6),
    ingress_total_calls integer,
    not_zero_calls integer,
    ingress_success_calls integer,
    ingress_client_id integer,
    ingress_id integer,
    egress_client_id integer,
    egress_id integer,
    egress_bill_time integer,
    egress_call_cost numeric(15,6),
    egress_total_calls integer,
    egress_success_calls integer,
    did character varying(100),
    ingress_ip character varying(20),
    egress_ip character varying(20),
    pdd integer,
    ingress_busy_calls integer,
    egress_busy_calls integer,
    ingress_cancel_calls integer,
    egress_cancel_calls integer,
    cdr_date character varying(24)
);


ALTER TABLE did_report OWNER TO postgres;

--
-- Name: did_request; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE did_request (
    id integer NOT NULL,
    user_id integer,
    created_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status integer DEFAULT 0
);


ALTER TABLE did_request OWNER TO postgres;

--
-- Name: did_request_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE did_request_detail (
    id integer NOT NULL,
    did_request_id integer,
    number character varying(255),
    egress_id integer,
    status integer DEFAULT 0 NOT NULL,
    assigned_time timestamp with time zone
);


ALTER TABLE did_request_detail OWNER TO postgres;

--
-- Name: did_request_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE did_request_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE did_request_detail_id_seq OWNER TO postgres;

--
-- Name: did_request_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE did_request_detail_id_seq OWNED BY did_request_detail.id;


--
-- Name: did_request_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE did_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE did_request_id_seq OWNER TO postgres;

--
-- Name: did_request_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE did_request_id_seq OWNED BY did_request.id;


--
-- Name: did_special_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE did_special_code (
    id integer NOT NULL,
    code prefix_range NOT NULL,
    pricing real DEFAULT 0
);


ALTER TABLE did_special_code OWNER TO postgres;

--
-- Name: did_special_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE did_special_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE did_special_code_id_seq OWNER TO postgres;

--
-- Name: did_special_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE did_special_code_id_seq OWNED BY did_special_code.id;


--
-- Name: digit_translation_translation_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE digit_translation_translation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE digit_translation_translation_id_seq OWNER TO postgres;

--
-- Name: digit_translation; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE digit_translation (
    translation_id integer DEFAULT nextval('digit_translation_translation_id_seq'::regclass) NOT NULL,
    translation_name character varying(100) NOT NULL,
    translation timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL
);


ALTER TABLE digit_translation OWNER TO postgres;

--
-- Name: TABLE digit_translation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE digit_translation IS 'ä¸»è¢«å«å·ç è½¬æ¢';


--
-- Name: COLUMN digit_translation.translation_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN digit_translation.translation_id IS 'ä¸»é”®';


--
-- Name: COLUMN digit_translation.translation_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN digit_translation.translation_name IS 'åç§°';


--
-- Name: COLUMN digit_translation.translation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN digit_translation.translation IS 'æ›´æ–°æ—¶é—´';


--
-- Name: direct_seller_enrollment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE direct_seller_enrollment (
    id integer NOT NULL,
    user_id integer,
    request_time timestamp with time zone,
    action integer
);


ALTER TABLE direct_seller_enrollment OWNER TO postgres;

--
-- Name: direct_seller_enrollment_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE direct_seller_enrollment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE direct_seller_enrollment_id_seq OWNER TO postgres;

--
-- Name: direct_seller_enrollment_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE direct_seller_enrollment_id_seq OWNED BY direct_seller_enrollment.id;


--
-- Name: disabled_trunk; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW disabled_trunk AS
 SELECT ( SELECT alert_rule.name
           FROM alert_rule
          WHERE (alert_rule.id = alert_event.alert_rule_id)) AS name,
    alert_event.event_type,
    resource.alias,
    resource.ingress,
    resource.egress,
    alert_event.disable_code,
    alert_event.event_time,
    (alert_event.event_time + ((alert_event.disable_duration)::double precision * '00:01:00'::interval)) AS enable_time
   FROM (alert_event
     JOIN resource ON ((resource.resource_id = alert_event.res_id)))
  WHERE (alert_event.disable_duration IS NOT NULL);


ALTER TABLE disabled_trunk OWNER TO postgres;

--
-- Name: dynamic_route_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_items_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE dynamic_route_items_id_seq OWNED BY dynamic_route_items.id;


--
-- Name: dynamic_route_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_items_record_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_items_record (
    id integer,
    dynamic_route_id integer,
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('dynamic_route_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE dynamic_route_items_record OWNER TO postgres;

--
-- Name: dynamic_route_items_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_items_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_items_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_items_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_items_record_tmp (
    id integer,
    dynamic_route_id integer,
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('dynamic_route_items_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE dynamic_route_items_record_tmp OWNER TO postgres;

--
-- Name: dynamic_route_old_dynamic_route_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_old_dynamic_route_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_old_dynamic_route_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_override; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_override (
    id integer NOT NULL,
    dynamic_route_id integer NOT NULL,
    digits prefix_range DEFAULT ''::prefix_range NOT NULL,
    resource_id integer NOT NULL,
    percentage integer NOT NULL
);


ALTER TABLE dynamic_route_override OWNER TO postgres;

--
-- Name: dynamic_route_override_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_override_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_override_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_override_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE dynamic_route_override_id_seq OWNED BY dynamic_route_override.id;


--
-- Name: dynamic_route_override_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_override_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_override_record_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_override_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_override_record (
    id integer,
    dynamic_route_id integer,
    digits prefix_range,
    resource_id integer,
    percentage integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('dynamic_route_override_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE dynamic_route_override_record OWNER TO postgres;

--
-- Name: dynamic_route_override_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_override_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_override_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_override_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_override_record_tmp (
    id integer,
    dynamic_route_id integer,
    digits prefix_range,
    resource_id integer,
    percentage integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('dynamic_route_override_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE dynamic_route_override_record_tmp OWNER TO postgres;

--
-- Name: dynamic_route_pri; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_pri (
    id integer NOT NULL,
    dynamic_route_id integer NOT NULL,
    digits prefix_range DEFAULT ''::prefix_range NOT NULL,
    resource_id integer NOT NULL,
    resource_pri integer DEFAULT 0 NOT NULL
);


ALTER TABLE dynamic_route_pri OWNER TO postgres;

--
-- Name: dynamic_route_pri_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_pri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_pri_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_pri_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE dynamic_route_pri_id_seq OWNED BY dynamic_route_pri.id;


--
-- Name: dynamic_route_pri_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_pri_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_pri_record_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_pri_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_pri_record (
    id integer,
    dynamic_route_id integer,
    digits prefix_range,
    resource_id integer,
    resource_pri integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('dynamic_route_pri_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE dynamic_route_pri_record OWNER TO postgres;

--
-- Name: dynamic_route_pri_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_pri_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_pri_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_pri_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_pri_record_tmp (
    id integer,
    dynamic_route_id integer,
    digits prefix_range,
    resource_id integer,
    resource_pri integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('dynamic_route_pri_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE dynamic_route_pri_record_tmp OWNER TO postgres;

--
-- Name: dynamic_route_qos; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_qos (
    id integer NOT NULL,
    dynamic_route_id integer NOT NULL,
    digits prefix_range DEFAULT ''::prefix_range NOT NULL,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real
);


ALTER TABLE dynamic_route_qos OWNER TO postgres;

--
-- Name: dynamic_route_qos_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_qos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_qos_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_qos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE dynamic_route_qos_id_seq OWNED BY dynamic_route_qos.id;


--
-- Name: dynamic_route_qos_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_qos_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_qos_record_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_qos_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_qos_record (
    id integer,
    dynamic_route_id integer,
    digits prefix_range,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('dynamic_route_qos_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE dynamic_route_qos_record OWNER TO postgres;

--
-- Name: dynamic_route_qos_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_qos_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_qos_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_qos_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_qos_record_tmp (
    id integer,
    dynamic_route_id integer,
    digits prefix_range,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('dynamic_route_qos_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE dynamic_route_qos_record_tmp OWNER TO postgres;

--
-- Name: dynamic_route_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_record_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_record (
    dynamic_route_id integer,
    name character varying(100),
    routing_rule integer,
    time_profile_id integer,
    update_at timestamp with time zone,
    update_by character varying,
    lcr_flag integer,
    is_virtual boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('dynamic_route_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE dynamic_route_record OWNER TO postgres;

--
-- Name: dynamic_route_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dynamic_route_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE dynamic_route_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE dynamic_route_record_tmp (
    dynamic_route_id integer,
    name character varying(100),
    routing_rule integer,
    time_profile_id integer,
    update_at timestamp with time zone,
    update_by character varying,
    lcr_flag integer,
    is_virtual boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('dynamic_route_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE dynamic_route_record_tmp OWNER TO postgres;

--
-- Name: egress_profile; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE egress_profile (
    id integer NOT NULL,
    egress_id integer,
    profile_id integer,
    server_name character varying(200),
    ingress_id integer
);


ALTER TABLE egress_profile OWNER TO postgres;

--
-- Name: COLUMN egress_profile.ingress_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_profile.ingress_id IS 'ï¼ï¼ ingress_id + egress_id + server_nameéœ€è¦å”¯ä¸€';


--
-- Name: egress_profile_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE egress_profile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE egress_profile_id_seq OWNER TO postgres;

--
-- Name: egress_profile_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE egress_profile_id_seq OWNED BY egress_profile.id;


--
-- Name: egress_profile_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE egress_profile_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE egress_profile_record_record_id_seq OWNER TO postgres;

--
-- Name: egress_profile_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE egress_profile_record (
    id integer,
    egress_id integer,
    profile_id integer,
    server_name character varying(200),
    ingress_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('egress_profile_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE egress_profile_record OWNER TO postgres;

--
-- Name: egress_profile_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE egress_profile_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE egress_profile_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: egress_profile_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE egress_profile_record_tmp (
    id integer,
    egress_id integer,
    profile_id integer,
    server_name character varying(200),
    ingress_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('egress_profile_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE egress_profile_record_tmp OWNER TO postgres;

--
-- Name: egress_test; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE egress_test (
    id integer NOT NULL,
    egress_id integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    code_name character varying(100),
    success_calls integer,
    total_calls integer,
    fas real,
    asr real,
    pdd integer,
    ingress_id integer,
    ingress_client_id integer,
    agent_id integer,
    product_id integer,
    public_link_key character varying,
    fas_calls integer,
    total_pdd integer,
    is_send_email integer,
    sec integer,
    create_by character varying(100)
);


ALTER TABLE egress_test OWNER TO postgres;

--
-- Name: COLUMN egress_test.success_calls; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test.success_calls IS 'success_calls / total_calls = asr';


--
-- Name: COLUMN egress_test.fas_calls; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test.fas_calls IS 'fas_calls / total_call = fas';


--
-- Name: COLUMN egress_test.total_pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test.total_pdd IS 'total_pdd/total_calls = pdd';


--
-- Name: egress_test_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE egress_test_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE egress_test_id_seq OWNER TO postgres;

--
-- Name: egress_test_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE egress_test_id_seq OWNED BY egress_test.id;


--
-- Name: egress_test_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE egress_test_result (
    id integer NOT NULL,
    egress_test_id integer NOT NULL,
    ani character varying(100),
    dnis character varying(100),
    start_time timestamp with time zone,
    answer_time timestamp with time zone,
    end_time timestamp with time zone,
    pdd integer,
    call_result character varying(100),
    sip_file text,
    ring_file text,
    media_file text,
    sip_view_file text,
    ring_wav_file text,
    media_wav_file text,
    call_result_code character varying(100),
    media_packets integer,
    call_id character varying,
    pcap_id character varying,
    cdr_time timestamp with time zone,
    duration integer,
    switch_ip character varying(100)
);


ALTER TABLE egress_test_result OWNER TO postgres;

--
-- Name: COLUMN egress_test_result.ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test_result.ani IS 'SRC Number';


--
-- Name: COLUMN egress_test_result.dnis; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test_result.dnis IS 'DEST Number';


--
-- Name: COLUMN egress_test_result.start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test_result.start_time IS 'DUR = end_time - answer_time';


--
-- Name: COLUMN egress_test_result.answer_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test_result.answer_time IS 'Ring Time = answer_time - start_time';


--
-- Name: COLUMN egress_test_result.end_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test_result.end_time IS 'Initiated';


--
-- Name: COLUMN egress_test_result.call_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test_result.call_result IS 'Result';


--
-- Name: COLUMN egress_test_result.ring_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test_result.ring_file IS 'RBT';


--
-- Name: COLUMN egress_test_result.media_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test_result.media_file IS 'Audio';


--
-- Name: COLUMN egress_test_result.call_result_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test_result.call_result_code IS 'Diconnect Code/Reason';


--
-- Name: COLUMN egress_test_result.media_packets; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN egress_test_result.media_packets IS 'Media Packets';


--
-- Name: egress_test_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE egress_test_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE egress_test_result_id_seq OWNER TO postgres;

--
-- Name: egress_test_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE egress_test_result_id_seq OWNED BY egress_test_result.id;


--
-- Name: egress_trunk_trace_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE egress_trunk_trace_report (
    report_time timestamp with time zone,
    total_record integer,
    egress_id integer,
    carrier_call_limit integer,
    carrier_cps_limit integer,
    trunk_call_limit integer,
    trunk_cps_limit integer,
    no_profitable_route integer,
    no_capacity integer,
    egress_trunk_block integer,
    code_block integer
);


ALTER TABLE egress_trunk_trace_report OWNER TO postgres;

--
-- Name: email_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE email_record (
    id integer NOT NULL,
    mail_to character varying(100),
    mail_subject character varying(1000),
    mail_body text,
    mail_var character varying(1000),
    send_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status integer DEFAULT 0
);


ALTER TABLE email_record OWNER TO postgres;

--
-- Name: email_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE email_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE email_record_id_seq OWNER TO postgres;

--
-- Name: email_record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE email_record_id_seq OWNED BY email_record.id;


--
-- Name: mail_sender; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE mail_sender (
    id integer NOT NULL,
    smtp_host character varying(255),
    smtp_port character varying(255),
    username character varying(255),
    password character varying(255),
    email character varying(255),
    name character varying(255),
    secure integer DEFAULT 0 NOT NULL,
    loginemail character varying(12),
    last_modified_on timestamp with time zone,
    modified_by character varying(40)
);


ALTER TABLE mail_sender OWNER TO postgres;

--
-- Name: emails_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE emails_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE emails_id_seq OWNER TO postgres;

--
-- Name: emails_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE emails_id_seq OWNED BY mail_sender.id;


--
-- Name: error_info_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE error_info_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE error_info_id_seq OWNER TO postgres;

--
-- Name: error_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE error_info (
    id integer DEFAULT nextval('error_info_id_seq'::regclass) NOT NULL,
    uploadtime timestamp with time zone,
    downloadtime timestamp with time zone,
    filename character varying(80),
    errorfilename character varying(80),
    status smallint,
    objectives character varying(80),
    filepath character varying(300),
    filesize integer,
    realfilename character varying(80),
    reseller_id integer,
    type integer,
    upload_param integer,
    user_id integer,
    download_sql text,
    delimiter integer,
    header integer,
    upload_table character varying(50),
    upload_table_id integer,
    upload_real_table character varying(20),
    client_id integer,
    account_id integer
);


ALTER TABLE error_info OWNER TO postgres;

--
-- Name: TABLE error_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE error_info IS 'ä¸Šä¼ æˆ–è€…ä¸‹è½½æ–‡ä»¶åŽçš„ä¿¡æ¯ï¼Œæ˜¯å¦æˆåŠŸ';


--
-- Name: COLUMN error_info.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.id IS 'ä¸»é”®';


--
-- Name: COLUMN error_info.uploadtime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.uploadtime IS 'ä¸Šä¼ å¼€å§‹æ—¶é—´';


--
-- Name: COLUMN error_info.downloadtime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.downloadtime IS 'ä¸Šä¼ å®Œæˆæ—¶é—´
ä¸‹è½½æ—¶é—´';


--
-- Name: COLUMN error_info.filename; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.filename IS 'ä¸Šä¼ æ–‡ä»¶å';


--
-- Name: COLUMN error_info.errorfilename; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.errorfilename IS 'ä¸Šä¼ å¤±è´¥æ—¶è¿”å›žçš„é”™è¯¯æ–‡ä»¶å';


--
-- Name: COLUMN error_info.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.status IS '
 0â€”æ–‡ä»¶ä¸Šä¼ æˆåŠŸã€‚ æ•°æ®è¿˜æ²¡éªŒè¯ã€‚

1  -ä¸Šä¼ çš„æ–‡ä»¶è¶…è¿‡äº† php.ini ä¸­ upload_max_filesize é€‰é¡¹é™åˆ¶çš„å€¼ã€‚

2-    ä¸Šä¼ æ–‡ä»¶çš„å¤§å°è¶…è¿‡äº† HTML è¡¨å•ä¸­ MAX_FILE_SIZE é€‰é¡¹æŒ‡å®šçš„å€¼ã€‚

status==3    æ–‡ä»¶åªæœ‰éƒ¨åˆ†è¢«ä¸Šä¼
.status==4      æ²¡æœ‰æ–‡ä»¶è¢«ä¸Šä¼

status==5æ–‡ä»¶ä¸Šä¼ taida
status==6æ–‡ä»¶å·²ç»å­˜åœ¨

7  --14--æ–‡ä»¶ä¸Šä¼ æˆåŠŸå·²ç»è¢«åˆ é™¤
status==8æ–‡ä»¶å·²ç»éªŒè¯å®Œæ¯•ï¼ŒæˆåŠŸå¯¼å…¥ä¸»è¡¨



ä¸‹è½½çŠ¶æ€
12---ä¸‹è½½å®Œæˆ
11--ä¸‹è½½å¤±è´¥
13ï¼æ–‡ä»¶å·²ç»è¢«åˆ é™¤
14--æ–‡ä»¶ä¸Šä¼ æˆåŠŸå·²ç»è¢«åˆ é™¤						    ';


--
-- Name: COLUMN error_info.objectives; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.objectives IS 'ä¸Šä¼ ï¼Œä¸‹è½½çš„ç§ç±»
';


--
-- Name: COLUMN error_info.filepath; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.filepath IS 'æ–‡ä»¶è·¯å¾„';


--
-- Name: COLUMN error_info.filesize; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.filesize IS 'æ–‡ä»¶å¤§å°';


--
-- Name: COLUMN error_info.realfilename; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.realfilename IS 'ä¸Šä¼ åŽä¿å­˜çš„æ–‡ä»¶å';


--
-- Name: COLUMN error_info.reseller_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.reseller_id IS 'æ˜¯å“ªä¸ªä»£ç†å•†ä¸Šä¼ çš„';


--
-- Name: COLUMN error_info.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.type IS '1--ä¸Šä¼
2--ä¸‹è½½';


--
-- Name: COLUMN error_info.upload_param; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.upload_param IS 'ä¸Šä¼ å‚æ•°
1--è¦†ç›–é‡å¤çš„ï¼Œä¸Šä¼ æ‰€æœ‰çš„
2-å¿½ç•¥é‡å¤çš„ï¼Œåªä¸Šä¼ ä¸å­˜åœ¨çš„
3--åˆ é™¤é‡å¤çš„
4-å‡ºé”™è¿”å›žé”™è¯¯ä¿¡æ¯
';


--
-- Name: COLUMN error_info.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.user_id IS 'ç”¨æˆ·';


--
-- Name: COLUMN error_info.download_sql; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.download_sql IS 'ä¸‹è½½ä½¿ç”¨çš„sql';


--
-- Name: COLUMN error_info.delimiter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.delimiter IS 'å¯¼å‡ºç”¨åˆ°çš„åˆ†éš”ç¬¦
1--,
2--|
3--;
';


--
-- Name: COLUMN error_info.header; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.header IS 'å¯¼å‡ºæ˜¯å¦è¦å­—æ®µå¤´
1--æ˜¯
2--å¦';


--
-- Name: COLUMN error_info.upload_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.upload_table IS 'ä¸Šä¼ è¡¨';


--
-- Name: COLUMN error_info.upload_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.upload_table_id IS 'å·ç ç»„IDï¼Œ
è´¹çŽ‡æ¨¡æ¿ID';


--
-- Name: COLUMN error_info.upload_real_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_info.upload_real_table IS 'ä¸Šä¼ çš„çœŸå®žè¡¨';


--
-- Name: error_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE error_log (
    id integer NOT NULL,
    detail character varying(500),
    error_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    sent boolean DEFAULT false,
    users character varying(100)
);


ALTER TABLE error_log OWNER TO postgres;

--
-- Name: COLUMN error_log.sent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN error_log.sent IS '1:å·²å‘é€é‚®ä»¶
0ï¼šæœªå‘é€é‚®ä»¶';


--
-- Name: error_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE error_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE error_log_id_seq OWNER TO postgres;

--
-- Name: error_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE error_log_id_seq OWNED BY error_log.id;


--
-- Name: event_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE event_log (
    event_log_id integer NOT NULL,
    type integer,
    message text,
    action_date timestamp with time zone,
    sender integer
);


ALTER TABLE event_log OWNER TO postgres;

--
-- Name: TABLE event_log; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE event_log IS 'äº‹ä»¶æ—¥å¿—';


--
-- Name: COLUMN event_log.event_log_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN event_log.event_log_id IS 'ä¸»é”®';


--
-- Name: COLUMN event_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN event_log.type IS 'ç±»åž‹ï¼š
1 ï¼ æç¤º
2 ï¼ è­¦å‘Š
3 ï¼ é”™è¯¯';


--
-- Name: COLUMN event_log.message; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN event_log.message IS 'å†…å®¹';


--
-- Name: COLUMN event_log.action_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN event_log.action_date IS 'æ—¥æœŸ';


--
-- Name: event_log_event_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE event_log_event_log_id_seq
    START WITH 3
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE event_log_event_log_id_seq OWNER TO postgres;

--
-- Name: event_log_event_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE event_log_event_log_id_seq OWNED BY event_log.event_log_id;


--
-- Name: exchange_agent_email_type; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_email_type (
    id integer NOT NULL,
    email_type integer NOT NULL,
    email_action integer NOT NULL
);


ALTER TABLE exchange_agent_email_type OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_email_type.email_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_email_type.email_type IS '1:Primary Email
2:Technical Email
3:Billing Email
4:Rate Email';


--
-- Name: COLUMN exchange_agent_email_type.email_action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_email_type.email_action IS '1:push list
2:target list
3:Trouble Ticket
4:Invoice
5:Finance Alert
6:Rate';


--
-- Name: exchange_agent_email_type_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_email_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_email_type_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_email_type_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_email_type_id_seq OWNED BY exchange_agent_email_type.id;


--
-- Name: exchange_agent_exchange_push_list_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_exchange_push_list_log (
    id integer NOT NULL,
    create_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    finish_time timestamp without time zone,
    product_id integer,
    status integer,
    rate_type integer,
    day_num integer,
    agent_id integer
);


ALTER TABLE exchange_agent_exchange_push_list_log OWNER TO postgres;

--
-- Name: exchange_agent_exchange_push_list_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_exchange_push_list_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_exchange_push_list_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_exchange_push_list_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_exchange_push_list_log_id_seq OWNED BY exchange_agent_exchange_push_list_log.id;


--
-- Name: exchange_agent_exchange_push_list_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_exchange_push_list_result (
    id integer NOT NULL,
    code_name character varying,
    min_rate numeric,
    max_rate numeric,
    asr_1_day numeric,
    acd_1_day numeric,
    asr_3_day numeric,
    acd_3_day numeric,
    asr_7_day numeric,
    acd_7_day numeric,
    exchange_push_log_id integer,
    trunk_id character varying,
    product_id integer,
    date_time timestamp with time zone,
    file_target character varying,
    type integer,
    file_push_list character varying
);


ALTER TABLE exchange_agent_exchange_push_list_result OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_exchange_push_list_result.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_exchange_push_list_result.type IS '0:a-z
1:us
2:All(a-z:White)
3:All(a-z:Grey)
4:All(a-z:White Non CLI)
5:US(DNIS)
6:US(LRN)
7:ALL a-z product
8:ALL us product';


--
-- Name: exchange_agent_exchange_push_list_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_exchange_push_list_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_exchange_push_list_result_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_exchange_push_list_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_exchange_push_list_result_id_seq OWNED BY exchange_agent_exchange_push_list_result.id;


--
-- Name: exchange_agent_exchange_push_list_send_member; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_exchange_push_list_send_member (
    id integer NOT NULL,
    exchange_push_list_log_id integer,
    status integer,
    client_id integer,
    email_templete integer
);


ALTER TABLE exchange_agent_exchange_push_list_send_member OWNER TO postgres;

--
-- Name: exchange_agent_exchange_push_list_send_member_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_exchange_push_list_send_member_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_exchange_push_list_send_member_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_exchange_push_list_send_member_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_exchange_push_list_send_member_id_seq OWNED BY exchange_agent_exchange_push_list_send_member.id;


--
-- Name: exchange_agent_generate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_generate (
    id integer NOT NULL,
    country character varying(256),
    code_name character varying(256),
    code character varying(256),
    current_rate numeric,
    "interval" integer,
    min_time integer,
    effective_date timestamp with time zone,
    product_id integer,
    new_rate numeric,
    status integer,
    new_inter_rate numeric,
    new_intra_rate numeric,
    current_inter_rate numeric,
    current_intra_rate numeric
);


ALTER TABLE exchange_agent_generate OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_generate.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_generate.status IS '0:new
1:increase
2:decrease
3:invariant';


--
-- Name: exchange_agent_generate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_generate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_generate_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_generate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_generate_id_seq OWNED BY exchange_agent_generate.id;


--
-- Name: exchange_agent_generate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_generate_log (
    id integer NOT NULL,
    product_id integer,
    status integer,
    create_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    finish_time timestamp without time zone,
    error_file_path character varying,
    upload integer
);


ALTER TABLE exchange_agent_generate_log OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_generate_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_generate_log.status IS '0:
1:
2:
-1:';


--
-- Name: COLUMN exchange_agent_generate_log.upload; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_generate_log.upload IS '1-upload to rate table';


--
-- Name: exchange_agent_generate_insert_send_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_generate_insert_send_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_generate_insert_send_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_generate_insert_send_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_generate_insert_send_log_id_seq OWNED BY exchange_agent_generate_log.id;


--
-- Name: exchange_agent_import_target_push; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_import_target_push (
    id integer NOT NULL,
    file_path character varying NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    status integer DEFAULT 1 NOT NULL,
    job_name character varying NOT NULL,
    agent_id integer NOT NULL,
    create_by character varying
);


ALTER TABLE exchange_agent_import_target_push OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_import_target_push.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_import_target_push.status IS '1:loading
2:success';


--
-- Name: exchange_agent_import_target_push_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_import_target_push_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_import_target_push_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_import_target_push_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_import_target_push_id_seq OWNED BY exchange_agent_import_target_push.id;


--
-- Name: exchange_agent_import_target_push_job; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_import_target_push_job (
    id integer NOT NULL,
    code_name character varying,
    rate numeric,
    import_id integer,
    type integer DEFAULT 0 NOT NULL,
    agent_id integer,
    old_code_name character varying
);


ALTER TABLE exchange_agent_import_target_push_job OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_import_target_push_job.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_import_target_push_job.type IS '0:right
1:error';


--
-- Name: exchange_agent_import_target_push_job_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_import_target_push_job_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_import_target_push_job_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_import_target_push_job_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_import_target_push_job_id_seq OWNED BY exchange_agent_import_target_push_job.id;


--
-- Name: exchange_agent_mail_tmplate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_mail_tmplate (
    id integer NOT NULL,
    generate_email_content text,
    generate_email_subject text,
    target_email_content text,
    target_email_subject text,
    agent_id integer,
    exchange_push_list_email_content text,
    exchange_push_list_email_subject text,
    product_push_list_email_content text,
    product_push_list_email_subject text,
    type integer,
    email_name character varying,
    email_content character varying,
    email_subject character varying,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_time timestamp with time zone,
    par_id integer,
    carbon_copy text
);


ALTER TABLE exchange_agent_mail_tmplate OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_mail_tmplate.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_mail_tmplate.type IS '0:send rate
1:target
2:product push list
3:exchange push list
4:tech_info
5:block
6:vinder test
7:send test message to client(product job)
8:send valuable destination';


--
-- Name: exchange_agent_mail_tmplate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_mail_tmplate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_mail_tmplate_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_mail_tmplate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_mail_tmplate_id_seq OWNED BY exchange_agent_mail_tmplate.id;


--
-- Name: exchange_agent_partition_login_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_partition_login_log (
    id integer NOT NULL,
    login_name character varying,
    login_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    login_type integer DEFAULT 1 NOT NULL,
    login_ip character varying,
    login_browser character varying
);


ALTER TABLE exchange_agent_partition_login_log OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_partition_login_log.login_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_partition_login_log.login_type IS '1:exchange
2:agent
3:partition';


--
-- Name: exchange_agent_partition_login_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_partition_login_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_partition_login_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_partition_login_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_partition_login_log_id_seq OWNED BY exchange_agent_partition_login_log.id;


--
-- Name: exchange_agent_product_agent_mapping; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_product_agent_mapping (
    id integer NOT NULL,
    product_id integer,
    agent_id integer
);


ALTER TABLE exchange_agent_product_agent_mapping OWNER TO postgres;

--
-- Name: exchange_agent_product_agent_mapping_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_product_agent_mapping_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_product_agent_mapping_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_agent_mapping_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_product_agent_mapping_id_seq OWNED BY exchange_agent_product_agent_mapping.id;


--
-- Name: exchange_agent_product_client_mapping; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_product_client_mapping (
    id integer NOT NULL,
    product_id integer,
    client_id integer
);


ALTER TABLE exchange_agent_product_client_mapping OWNER TO postgres;

--
-- Name: exchange_agent_product_client_mapping_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_product_client_mapping_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_product_client_mapping_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_client_mapping_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_product_client_mapping_id_seq OWNED BY exchange_agent_product_client_mapping.id;


--
-- Name: exchange_agent_product_no_route; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_product_no_route (
    id integer NOT NULL,
    destination character varying,
    min_sell_rate numeric,
    max_sell_rate numeric,
    min_buy_rate numeric,
    max_buy_rate numeric,
    product_id integer,
    is_new boolean DEFAULT false NOT NULL,
    total_call_1hr integer,
    not_zero_calls_1hr integer,
    duration_1hr integer,
    total_call_24hr integer,
    not_zero_calls_24hr integer,
    duration_24hr integer,
    total_call_3d integer,
    not_zero_calls_3d integer,
    duration_3d integer
);


ALTER TABLE exchange_agent_product_no_route OWNER TO postgres;

--
-- Name: exchange_agent_product_no_route_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_product_no_route_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_product_no_route_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_no_route_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_product_no_route_id_seq OWNED BY exchange_agent_product_no_route.id;


--
-- Name: exchange_agent_product_no_route_now; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_product_no_route_now (
    id integer NOT NULL,
    product_id integer,
    status smallint DEFAULT 0 NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone
);


ALTER TABLE exchange_agent_product_no_route_now OWNER TO postgres;

--
-- Name: exchange_agent_product_no_route_now_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_product_no_route_now_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_product_no_route_now_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_no_route_now_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_product_no_route_now_id_seq OWNED BY exchange_agent_product_no_route_now.id;


--
-- Name: exchange_agent_product_push_list_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_product_push_list_log (
    id integer NOT NULL,
    create_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    finish_time timestamp without time zone,
    product_id integer,
    status integer
);


ALTER TABLE exchange_agent_product_push_list_log OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_product_push_list_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_product_push_list_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_product_push_list_log_id_seq OWNED BY exchange_agent_product_push_list_log.id;


--
-- Name: exchange_agent_product_push_list_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_product_push_list_result (
    id integer NOT NULL,
    code_name character varying,
    min_rate numeric,
    max_rate numeric,
    asr_1_day numeric,
    acd_1_day numeric,
    asr_3_day numeric,
    acd_3_day numeric,
    asr_7_day numeric,
    acd_7_day numeric,
    product_push_log_id integer
);


ALTER TABLE exchange_agent_product_push_list_result OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_product_push_list_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_product_push_list_result_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_product_push_list_result_id_seq OWNED BY exchange_agent_product_push_list_result.id;


--
-- Name: exchange_agent_product_push_list_send_member; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_product_push_list_send_member (
    id integer NOT NULL,
    product_push_list_log_id integer,
    status integer,
    client_id integer,
    email_templete integer
);


ALTER TABLE exchange_agent_product_push_list_send_member OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_send_member_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_product_push_list_send_member_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_product_push_list_send_member_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_send_member_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_product_push_list_send_member_id_seq OWNED BY exchange_agent_product_push_list_send_member.id;


--
-- Name: exchange_agent_rout_country_mapping; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_rout_country_mapping (
);


ALTER TABLE exchange_agent_rout_country_mapping OWNER TO postgres;

--
-- Name: exchange_agent_send_mail_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_send_mail_log (
    id integer NOT NULL,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    email_template integer,
    create_by character varying,
    end_time timestamp with time zone,
    status integer
);


ALTER TABLE exchange_agent_send_mail_log OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_send_mail_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_send_mail_log.status IS '1:loading
2:success';


--
-- Name: exchange_agent_send_mail_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_send_mail_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_send_mail_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_send_mail_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_send_mail_log_id_seq OWNED BY exchange_agent_send_mail_log.id;


--
-- Name: exchange_agent_send_mail_log_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_send_mail_log_list (
    id integer NOT NULL,
    client_id integer,
    status integer,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    error_msg text,
    log_id integer,
    email character varying
);


ALTER TABLE exchange_agent_send_mail_log_list OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_send_mail_log_list.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_send_mail_log_list.status IS '0:success
1:error
';


--
-- Name: exchange_agent_send_mail_log_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_send_mail_log_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_send_mail_log_list_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_send_mail_log_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_send_mail_log_list_id_seq OWNED BY exchange_agent_send_mail_log_list.id;


--
-- Name: exchange_agent_send_rate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_send_rate_log (
    id integer NOT NULL,
    last_rate_delivery timestamp without time zone,
    product_id integer,
    client_id integer,
    status integer,
    send_changed_rates boolean,
    send_all_rates boolean,
    email_templete integer,
    email character varying,
    email_file character varying,
    rate_type integer,
    error_msg text,
    from_where integer DEFAULT 0 NOT NULL
);


ALTER TABLE exchange_agent_send_rate_log OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_send_rate_log.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_send_rate_log.rate_type IS '0-generate rate
1-rate table rate';


--
-- Name: COLUMN exchange_agent_send_rate_log.from_where; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_send_rate_log.from_where IS '0:agent
1:partition';


--
-- Name: exchange_agent_send_rate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_send_rate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_send_rate_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_send_rate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_send_rate_log_id_seq OWNED BY exchange_agent_send_rate_log.id;


--
-- Name: exchange_agent_target_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_target_log (
    id integer NOT NULL,
    create_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    finish_time timestamp without time zone,
    product_id integer,
    status integer
);


ALTER TABLE exchange_agent_target_log OWNER TO postgres;

--
-- Name: exchange_agent_target_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_target_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_target_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_target_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_target_log_id_seq OWNED BY exchange_agent_target_log.id;


--
-- Name: exchange_agent_target_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_target_result (
    id integer NOT NULL,
    code_name character varying,
    min_rate numeric,
    max_rate character varying,
    day_1_vo numeric,
    day_7_vo numeric,
    target_log_id integer
);


ALTER TABLE exchange_agent_target_result OWNER TO postgres;

--
-- Name: exchange_agent_target_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_target_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_target_result_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_target_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_target_result_id_seq OWNED BY exchange_agent_target_result.id;


--
-- Name: exchange_agent_target_send_member; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_target_send_member (
    id integer NOT NULL,
    status integer,
    target_log_id integer,
    client_id integer,
    email_templete integer,
    email character varying
);


ALTER TABLE exchange_agent_target_send_member OWNER TO postgres;

--
-- Name: exchange_agent_target_send_member_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_target_send_member_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_target_send_member_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_target_send_member_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_target_send_member_id_seq OWNED BY exchange_agent_target_send_member.id;


--
-- Name: exchange_agent_user; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_user (
    id integer NOT NULL,
    name character varying,
    pwd character varying,
    status integer DEFAULT 1 NOT NULL,
    agent_client_id integer NOT NULL,
    last_login_time timestamp with time zone,
    role_id integer
);


ALTER TABLE exchange_agent_user OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_user.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_user.status IS '0:unactive
1:active';


--
-- Name: exchange_agent_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_user_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_user_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_user_id_seq OWNED BY exchange_agent_user.id;


--
-- Name: exchange_agent_vendor_test_number; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_vendor_test_number (
    dnis character varying(40),
    code character varying(20),
    code_name character varying(100),
    country character varying(100)
);


ALTER TABLE exchange_agent_vendor_test_number OWNER TO postgres;

--
-- Name: exchange_agent_vendor_test_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_agent_vendor_test_result (
    id integer NOT NULL,
    egress_id integer,
    client_id integer,
    egress_ip character varying(30),
    egress_alias character varying(100),
    country character varying(100),
    code_name character varying(100),
    code character varying(20),
    dnis character varying(40),
    result_code integer,
    duration integer,
    test_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    type integer DEFAULT 0 NOT NULL,
    ani character varying(100),
    start_time timestamp with time zone,
    answer_time timestamp with time zone,
    end_time timestamp with time zone,
    pdd timestamp with time zone,
    call_result character varying(100),
    call_result_code character varying(100),
    sip_file text,
    ring_file text,
    media_file text,
    sip_view_file text,
    ring_wav_file text,
    media_wav_file text,
    media_packets integer,
    test_id integer
);


ALTER TABLE exchange_agent_vendor_test_result OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_vendor_test_result.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_agent_vendor_test_result.type IS '0:no connect
1:connect';


--
-- Name: exchange_agent_vendor_test_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_agent_vendor_test_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_agent_vendor_test_result_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_vendor_test_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_agent_vendor_test_result_id_seq OWNED BY exchange_agent_vendor_test_result.id;


--
-- Name: exchange_block_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_block_log (
    id integer NOT NULL,
    create_time timestamp with time zone,
    destination character varying(256),
    code character varying(256),
    egress_trunk character varying(256),
    ingress_trunk character varying(256),
    client_id integer,
    action integer,
    buy_client_id integer
);


ALTER TABLE exchange_block_log OWNER TO postgres;

--
-- Name: COLUMN exchange_block_log.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_block_log.action IS '0:add
1:delete';


--
-- Name: exchange_block_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_block_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_block_log_id_seq OWNER TO postgres;

--
-- Name: exchange_block_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_block_log_id_seq OWNED BY exchange_block_log.id;


--
-- Name: exchange_ci_sessions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_ci_sessions (
    session_id character varying DEFAULT '0'::character varying NOT NULL,
    ip_address character varying DEFAULT '0'::character varying NOT NULL,
    user_agent character varying NOT NULL,
    last_activity integer DEFAULT 0 NOT NULL,
    user_data text DEFAULT ''::text NOT NULL
);


ALTER TABLE exchange_ci_sessions OWNER TO postgres;

--
-- Name: exchange_client_user_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_client_user_list (
    id integer NOT NULL,
    client_id integer,
    user_id integer
);


ALTER TABLE exchange_client_user_list OWNER TO postgres;

--
-- Name: exchange_client_user_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_client_user_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_client_user_list_id_seq OWNER TO postgres;

--
-- Name: exchange_client_user_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_client_user_list_id_seq OWNED BY exchange_client_user_list.id;


--
-- Name: exchange_code_name_mapping; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_code_name_mapping (
    id integer NOT NULL,
    client_code_name character varying,
    our_code_name character varying,
    client_id integer
);


ALTER TABLE exchange_code_name_mapping OWNER TO postgres;

--
-- Name: exchange_code_name_mapping_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_code_name_mapping_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_code_name_mapping_id_seq OWNER TO postgres;

--
-- Name: exchange_code_name_mapping_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_code_name_mapping_id_seq OWNED BY exchange_code_name_mapping.id;


--
-- Name: exchange_egress_did; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_egress_did (
    id integer NOT NULL,
    number character varying,
    egress_id integer
);


ALTER TABLE exchange_egress_did OWNER TO postgres;

--
-- Name: exchange_egress_did_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_egress_did_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_egress_did_id_seq OWNER TO postgres;

--
-- Name: exchange_egress_did_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_egress_did_id_seq OWNED BY exchange_egress_did.id;


--
-- Name: exchange_false_del; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_false_del (
    id integer NOT NULL,
    resource_id integer
);


ALTER TABLE exchange_false_del OWNER TO postgres;

--
-- Name: exchange_false_del_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_false_del_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_false_del_id_seq OWNER TO postgres;

--
-- Name: exchange_false_del_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_false_del_id_seq OWNED BY exchange_false_del.id;


--
-- Name: exchange_finance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_finance (
    id integer NOT NULL,
    client_id integer,
    action_type integer,
    action_time timestamp with time zone,
    status integer DEFAULT 1 NOT NULL,
    amount numeric(30,10),
    actual_amount numeric(30,10),
    complete_time timestamp with time zone,
    action_method integer,
    action_fee numeric(30,10),
    action_number character varying(100),
    descript character varying(1000),
    vali_code character varying(32),
    pay_flag boolean DEFAULT false,
    account character varying(200),
    payer_company character varying(255),
    payer_email character varying(255)
);


ALTER TABLE exchange_finance OWNER TO postgres;

--
-- Name: COLUMN exchange_finance.action_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_finance.action_type IS '1--è½¬å‡º
2--è½¬å…¥';


--
-- Name: COLUMN exchange_finance.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_finance.status IS '1: waiting
2: complete
3: refuse
4:In Process
';


--
-- Name: COLUMN exchange_finance.vali_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_finance.vali_code IS 'å‘é€é‚®ç®±åŽé¢è·Ÿçš„ç¼–ç•Œç ';


--
-- Name: COLUMN exchange_finance.pay_flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_finance.pay_flag IS 'æ”¯ä»˜çŠ¶æ€  FALSE æœªæ”¯ä»˜  TRUE å·²æ”¯ä»˜';


--
-- Name: COLUMN exchange_finance.account; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_finance.account IS 'è½¬å¸åˆ°icxçš„é“¶è¡Œæˆ–paypalå¸å·';


--
-- Name: exchange_finance_agent; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_finance_agent (
    id integer NOT NULL,
    agent_id integer,
    total_amount numeric,
    status integer,
    action_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    complete_time timestamp with time zone,
    action_method integer DEFAULT 1 NOT NULL,
    action_number character varying,
    actual_amount numeric DEFAULT 0 NOT NULL,
    action_fee numeric DEFAULT 0 NOT NULL
);


ALTER TABLE exchange_finance_agent OWNER TO postgres;

--
-- Name: COLUMN exchange_finance_agent.action_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_finance_agent.action_method IS '1:paypal
2:wire';


--
-- Name: exchange_finance_agent_clients; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_finance_agent_clients (
    id integer NOT NULL,
    exchange_finance_agent_id integer,
    client_id integer,
    amount numeric,
    actual_amount numeric DEFAULT 0 NOT NULL,
    action_fee numeric DEFAULT 0 NOT NULL
);


ALTER TABLE exchange_finance_agent_clients OWNER TO postgres;

--
-- Name: exchange_finance_agent_clients_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_finance_agent_clients_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_finance_agent_clients_id_seq OWNER TO postgres;

--
-- Name: exchange_finance_agent_clients_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_finance_agent_clients_id_seq OWNED BY exchange_finance_agent_clients.id;


--
-- Name: exchange_finance_agent_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_finance_agent_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_finance_agent_id_seq OWNER TO postgres;

--
-- Name: exchange_finance_agent_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_finance_agent_id_seq OWNED BY exchange_finance_agent.id;


--
-- Name: exchange_finance_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_finance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_finance_id_seq OWNER TO postgres;

--
-- Name: exchange_finance_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_finance_id_seq OWNED BY exchange_finance.id;


--
-- Name: exchange_interpeering_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_interpeering_log (
    id integer NOT NULL,
    resource_id integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    file_path character varying,
    end_time timestamp with time zone,
    status integer DEFAULT 1 NOT NULL,
    error_message text,
    do_type integer DEFAULT 1 NOT NULL
);


ALTER TABLE exchange_interpeering_log OWNER TO postgres;

--
-- Name: COLUMN exchange_interpeering_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_interpeering_log.status IS '1:loading
2:success,
3:error';


--
-- Name: COLUMN exchange_interpeering_log.do_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_interpeering_log.do_type IS '1:Remove Existing
2:Append to Existing';


--
-- Name: exchange_interpeering_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_interpeering_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_interpeering_log_id_seq OWNER TO postgres;

--
-- Name: exchange_interpeering_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_interpeering_log_id_seq OWNED BY exchange_interpeering_log.id;


--
-- Name: exchange_job; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_job (
    id integer NOT NULL,
    type integer,
    test_for_fas boolean,
    block_working_route boolean DEFAULT false NOT NULL,
    block_non_working_route boolean DEFAULT true NOT NULL,
    start_time timestamp with time zone,
    test_method integer,
    low_rate_num integer,
    hig_rate_num integer,
    "position" integer,
    block_asr_xiao boolean,
    xiao_asr numeric,
    unblock_asr_da boolean,
    da_asr numeric,
    auto_block_fas boolean,
    job_name character varying,
    scheduler character varying,
    number_number integer DEFAULT 1 NOT NULL,
    trunk_type integer DEFAULT 3 NOT NULL,
    test_block integer DEFAULT 1 NOT NULL,
    product_id integer,
    buy_route_da boolean DEFAULT false,
    remove_route_xiao boolean DEFAULT false,
    test_method_first integer DEFAULT 0,
    buy_route_da_asr numeric,
    remove_route_xiao_asr numeric,
    just_test_num_ok_asr numeric,
    test_ok_num integer,
    is_test_ok_num boolean,
    active integer,
    auto_method integer,
    select_code_name_first integer,
    product_code_name_type integer,
    product_asr numeric,
    product_acd numeric,
    product_pdd integer,
    product_att integer,
    target_push_job_id integer,
    last_test_time timestamp with time zone
);


ALTER TABLE exchange_job OWNER TO postgres;

--
-- Name: COLUMN exchange_job.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job.type IS '0: code name
1:by trunk
2:by product
3:by block';


--
-- Name: COLUMN exchange_job.test_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job.test_method IS '1:Test All Vendors
2:Test the bottom .... Vendors with lowest rates
3:Test the top Vendors with highest rates
4:Test All Destinations
5:All Destinations that are within position of LCR
';


--
-- Name: COLUMN exchange_job.scheduler; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job.scheduler IS '1:M
2:T
3:W
4:Th
5:Fri
6:Sa
7:Su ';


--
-- Name: COLUMN exchange_job.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job.trunk_type IS '0:White
1:White Non-CLI
2:Grey
3:all
';


--
-- Name: COLUMN exchange_job.test_block; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job.test_block IS '1:test
2:no test';


--
-- Name: COLUMN exchange_job.test_method_first; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job.test_method_first IS '0:all
1:just buy
2:just not buy
3:just select trunk in page
';


--
-- Name: COLUMN exchange_job.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job.active IS '0: not start
1:start';


--
-- Name: COLUMN exchange_job.auto_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job.auto_method IS '3:3hour
6:6hour
12:12hour
24:hour
';


--
-- Name: COLUMN exchange_job.select_code_name_first; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job.select_code_name_first IS '0:all
1:select now';


--
-- Name: COLUMN exchange_job.product_code_name_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job.product_code_name_type IS '0:page select code name
1:report select code name';


--
-- Name: exchange_job_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_job_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_job_id_seq OWNER TO postgres;

--
-- Name: exchange_job_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_job_id_seq OWNED BY exchange_job.id;


--
-- Name: exchange_job_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_job_list (
    id integer NOT NULL,
    job_id integer,
    trunk_id integer,
    code_name character varying
);


ALTER TABLE exchange_job_list OWNER TO postgres;

--
-- Name: exchange_job_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_job_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_job_list_id_seq OWNER TO postgres;

--
-- Name: exchange_job_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_job_list_id_seq OWNED BY exchange_job_list.id;


--
-- Name: exchange_job_session; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_job_session (
    id integer NOT NULL,
    job_id integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    status integer,
    message text,
    group_number integer,
    block_group_number integer,
    create_by character varying,
    stop integer,
    stop_by character varying
);


ALTER TABLE exchange_job_session OWNER TO postgres;

--
-- Name: COLUMN exchange_job_session.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job_session.status IS '1:loading
2:success
3:error
';


--
-- Name: COLUMN exchange_job_session.stop; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job_session.stop IS '-1:stop';


--
-- Name: exchange_job_session_block_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_job_session_block_log (
    id integer NOT NULL,
    session_id integer,
    trunk_id integer,
    code_name character varying,
    type integer DEFAULT 1 NOT NULL,
    be_msg character varying
);


ALTER TABLE exchange_job_session_block_log OWNER TO postgres;

--
-- Name: COLUMN exchange_job_session_block_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job_session_block_log.type IS '1:block
2:unblock';


--
-- Name: exchange_job_session_block_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_job_session_block_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_job_session_block_log_id_seq OWNER TO postgres;

--
-- Name: exchange_job_session_block_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_job_session_block_log_id_seq OWNED BY exchange_job_session_block_log.id;


--
-- Name: exchange_job_session_buy_route_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_job_session_buy_route_log (
    id integer NOT NULL,
    session_id integer,
    trunk_id integer,
    code_name character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    product_id integer,
    type integer DEFAULT 0 NOT NULL
);


ALTER TABLE exchange_job_session_buy_route_log OWNER TO postgres;

--
-- Name: COLUMN exchange_job_session_buy_route_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job_session_buy_route_log.type IS '0:add
1:remove';


--
-- Name: exchange_job_session_buy_route_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_job_session_buy_route_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_job_session_buy_route_log_id_seq OWNER TO postgres;

--
-- Name: exchange_job_session_buy_route_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_job_session_buy_route_log_id_seq OWNED BY exchange_job_session_buy_route_log.id;


--
-- Name: exchange_job_session_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_job_session_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_job_session_id_seq OWNER TO postgres;

--
-- Name: exchange_job_session_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_job_session_id_seq OWNED BY exchange_job_session.id;


--
-- Name: exchange_job_session_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_job_session_list (
    id integer NOT NULL,
    code character varying,
    code_name character varying,
    trunk_id integer,
    total_calls integer,
    success_calls integer,
    pdd integer,
    session_id integer,
    fas boolean,
    asr boolean,
    status integer,
    error_message text,
    caller_id character varying,
    port_msg character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE exchange_job_session_list OWNER TO postgres;

--
-- Name: COLUMN exchange_job_session_list.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_job_session_list.status IS '0:not connect
1:connect';


--
-- Name: exchange_job_session_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_job_session_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_job_session_list_id_seq OWNER TO postgres;

--
-- Name: exchange_job_session_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_job_session_list_id_seq OWNED BY exchange_job_session_list.id;


--
-- Name: exchange_job_session_remove_route_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_job_session_remove_route_log (
    id integer NOT NULL,
    session_id integer,
    trunk_id integer,
    code_name character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    product_id integer
);


ALTER TABLE exchange_job_session_remove_route_log OWNER TO postgres;

--
-- Name: exchange_job_session_remove_route_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_job_session_remove_route_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_job_session_remove_route_log_id_seq OWNER TO postgres;

--
-- Name: exchange_job_session_remove_route_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_job_session_remove_route_log_id_seq OWNED BY exchange_job_session_remove_route_log.id;


--
-- Name: exchange_mass_edit_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_mass_edit_log (
    id integer NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    status integer,
    log_msg text,
    ingress_trunk_id integer,
    mass_edit_for integer,
    select_num integer,
    routes_buy integer,
    rate_type integer,
    set_price_limit_using integer,
    per numeric,
    client_id integer,
    complete boolean DEFAULT false,
    agent_id integer,
    product_id integer,
    sell_trunks text,
    trunk_type character varying,
    ingress_prefix character varying(10),
    route_strategy_id integer,
    par_id integer,
    set_rate integer,
    rate_par numeric,
    send_email integer DEFAULT 0 NOT NULL,
    select_type integer,
    email_value character varying
);


ALTER TABLE exchange_mass_edit_log OWNER TO postgres;

--
-- Name: TABLE exchange_mass_edit_log; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE exchange_mass_edit_log IS 'mass_edit
';


--
-- Name: COLUMN exchange_mass_edit_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_mass_edit_log.status IS '1-running
2-done';


--
-- Name: COLUMN exchange_mass_edit_log.routes_buy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_mass_edit_log.routes_buy IS '1:Lowest ASR
2:Highest ASR
3:Lowest Cost
4:Highest Cost';


--
-- Name: COLUMN exchange_mass_edit_log.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_mass_edit_log.rate_type IS '1:ASR
2:ACD or LCR';


--
-- Name: COLUMN exchange_mass_edit_log.send_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_mass_edit_log.send_email IS '1:send
0:no send';


--
-- Name: COLUMN exchange_mass_edit_log.select_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_mass_edit_log.select_type IS '1:min
2:max';


--
-- Name: exchange_mass_edit_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_mass_edit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_mass_edit_log_id_seq OWNER TO postgres;

--
-- Name: exchange_mass_edit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_mass_edit_log_id_seq OWNED BY exchange_mass_edit_log.id;


--
-- Name: exchange_member_egress_test; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_member_egress_test (
    id integer NOT NULL,
    code character varying,
    code_name character varying,
    trunk_id integer,
    session_id integer,
    fas boolean,
    asr boolean,
    status integer,
    error_message text,
    caller_id character varying,
    port_msg character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE exchange_member_egress_test OWNER TO postgres;

--
-- Name: COLUMN exchange_member_egress_test.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_member_egress_test.status IS '0:not connect
1:connect';


--
-- Name: exchange_member_egress_test_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_member_egress_test_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_member_egress_test_id_seq OWNER TO postgres;

--
-- Name: exchange_member_egress_test_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_member_egress_test_id_seq OWNED BY exchange_member_egress_test.id;


--
-- Name: exchange_my_route_download_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_my_route_download_log (
    id integer NOT NULL,
    client_id integer,
    file_name character varying,
    ingress_trunk_id integer,
    status integer DEFAULT 0 NOT NULL,
    route_strategy_id integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone
);


ALTER TABLE exchange_my_route_download_log OWNER TO postgres;

--
-- Name: COLUMN exchange_my_route_download_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_my_route_download_log.status IS '0:waiting
1:running
2:success
-1:error';


--
-- Name: exchange_my_route_download_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_my_route_download_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_my_route_download_log_id_seq OWNER TO postgres;

--
-- Name: exchange_my_route_download_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_my_route_download_log_id_seq OWNED BY exchange_my_route_download_log.id;


--
-- Name: exchange_opp_email; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_opp_email (
    id integer NOT NULL,
    "from" text,
    subject text,
    header text,
    footer text,
    email_name character varying,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_time timestamp with time zone,
    agent_id integer,
    par_id integer
);


ALTER TABLE exchange_opp_email OWNER TO postgres;

--
-- Name: exchange_opp_email_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_opp_email_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_opp_email_id_seq OWNER TO postgres;

--
-- Name: exchange_opp_email_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_opp_email_id_seq OWNED BY exchange_opp_email.id;


--
-- Name: exchange_par_account; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_par_account (
    id integer NOT NULL,
    username character varying,
    pwd character varying,
    company_name character varying,
    paypal_account character varying,
    balance numeric,
    domain_name character varying,
    status integer DEFAULT 1 NOT NULL,
    logo character varying,
    last_login_time character varying,
    email character varying,
    phone_number character varying,
    invoice_text text,
    service_ip_id integer,
    ip character varying,
    par_name character varying,
    primary_email character varying,
    technical_email character varying,
    rate_send_to character varying,
    billing_email character varying,
    rate_send_from character varying,
    static_ip integer,
    static_port integer,
    service_ip_start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    service_ip_end_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    role_id integer,
    port_type integer DEFAULT 3 NOT NULL,
    smtp_email character varying,
    smtp_pwd character varying,
    host character varying,
    port character varying,
    admin_login_key character varying,
    invoice_logo character varying,
    cps integer DEFAULT 0,
    cap integer DEFAULT 2
);


ALTER TABLE exchange_par_account OWNER TO postgres;

--
-- Name: COLUMN exchange_par_account.port_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_par_account.port_type IS '0:by month
1:by minutes
3:no selected(default)';


--
-- Name: exchange_par_account_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_par_account_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_par_account_id_seq OWNER TO postgres;

--
-- Name: exchange_par_account_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_par_account_id_seq OWNED BY exchange_par_account.id;


--
-- Name: exchange_par_account_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_par_account_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_par_account_record_record_id_seq OWNER TO postgres;

--
-- Name: exchange_par_account_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_par_account_record (
    id integer,
    username character varying,
    pwd character varying,
    company_name character varying,
    paypal_account character varying,
    balance numeric,
    domain_name character varying,
    status integer,
    logo character varying,
    last_login_time character varying,
    email character varying,
    phone_number character varying,
    invoice_text text,
    service_ip_id integer,
    ip character varying,
    par_name character varying,
    primary_email character varying,
    technical_email character varying,
    rate_send_to character varying,
    billing_email character varying,
    rate_send_from character varying,
    static_ip integer,
    static_port integer,
    service_ip_start_time timestamp with time zone,
    service_ip_end_time timestamp with time zone,
    role_id integer,
    port_type integer,
    smtp_email character varying,
    smtp_pwd character varying,
    host character varying,
    port character varying,
    admin_login_key character varying,
    invoice_logo character varying,
    cps integer,
    cap integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('exchange_par_account_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE exchange_par_account_record OWNER TO postgres;

--
-- Name: exchange_par_account_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_par_account_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_par_account_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: exchange_par_account_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_par_account_record_tmp (
    id integer,
    username character varying,
    pwd character varying,
    company_name character varying,
    paypal_account character varying,
    balance numeric,
    domain_name character varying,
    status integer,
    logo character varying,
    last_login_time character varying,
    email character varying,
    phone_number character varying,
    invoice_text text,
    service_ip_id integer,
    ip character varying,
    par_name character varying,
    primary_email character varying,
    technical_email character varying,
    rate_send_to character varying,
    billing_email character varying,
    rate_send_from character varying,
    static_ip integer,
    static_port integer,
    service_ip_start_time timestamp with time zone,
    service_ip_end_time timestamp with time zone,
    role_id integer,
    port_type integer,
    smtp_email character varying,
    smtp_pwd character varying,
    host character varying,
    port character varying,
    admin_login_key character varying,
    invoice_logo character varying,
    cps integer,
    cap integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('exchange_par_account_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE exchange_par_account_record_tmp OWNER TO postgres;

--
-- Name: exchange_par_active_ips; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_par_active_ips (
    id integer NOT NULL,
    ip_port character varying,
    status integer DEFAULT 0 NOT NULL,
    to_buy_start_time timestamp with time zone
);


ALTER TABLE exchange_par_active_ips OWNER TO postgres;

--
-- Name: COLUMN exchange_par_active_ips.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_par_active_ips.status IS '0:no userd
1:be userd';


--
-- Name: exchange_par_active_ips_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_par_active_ips_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_par_active_ips_id_seq OWNER TO postgres;

--
-- Name: exchange_par_active_ips_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_par_active_ips_id_seq OWNED BY exchange_par_active_ips.id;


--
-- Name: exchange_par_plan; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_par_plan (
    id integer NOT NULL,
    remain_minute numeric,
    cost_min numeric,
    money numeric,
    type integer DEFAULT 0 NOT NULL,
    port integer,
    minutes numeric,
    cps integer
);


ALTER TABLE exchange_par_plan OWNER TO postgres;

--
-- Name: COLUMN exchange_par_plan.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_par_plan.type IS '0:by Month
1:by Minute';


--
-- Name: exchange_par_plan_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_par_plan_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_par_plan_id_seq OWNER TO postgres;

--
-- Name: exchange_par_plan_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_par_plan_id_seq OWNED BY exchange_par_plan.id;


--
-- Name: exchange_par_plan_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_par_plan_record (
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    exchange_par_plan_id integer,
    status integer DEFAULT 0 NOT NULL,
    par_id integer,
    des character varying,
    id integer NOT NULL,
    amount numeric,
    month_num integer,
    action_fee numeric DEFAULT 0 NOT NULL,
    ip_id integer,
    icx_get_amount numeric,
    error_status integer,
    unit_price numeric
);


ALTER TABLE exchange_par_plan_record OWNER TO postgres;

--
-- Name: COLUMN exchange_par_plan_record.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_par_plan_record.status IS '0:plan uncommitted
1:plan success
2:new ip uncommitted
3:new ip success
4:extend exists ip uncommitted
5:extend exists ip success';


--
-- Name: COLUMN exchange_par_plan_record.error_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_par_plan_record.error_status IS '0:payment but no exchange_par_switch_profiles log
1:zhe ip overdate
2:actived ip (exchange_par_active_ips)
3.partition account error
4.partition port_type error
5:port plan no find
6:extend ip --->not has ip_id
7:extend ip----->not has ip';


--
-- Name: exchange_par_plan_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_par_plan_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_par_plan_record_id_seq OWNER TO postgres;

--
-- Name: exchange_par_plan_record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_par_plan_record_id_seq OWNED BY exchange_par_plan_record.id;


--
-- Name: exchange_par_port; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_par_port (
    id integer NOT NULL,
    par_id integer,
    port integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    minutes numeric
);


ALTER TABLE exchange_par_port OWNER TO postgres;

--
-- Name: exchange_par_port_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_par_port_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_par_port_id_seq OWNER TO postgres;

--
-- Name: exchange_par_port_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_par_port_id_seq OWNED BY exchange_par_port.id;


--
-- Name: exchange_par_script; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_par_script (
    id integer NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    error text,
    message text,
    type integer DEFAULT 0 NOT NULL
);


ALTER TABLE exchange_par_script OWNER TO postgres;

--
-- Name: COLUMN exchange_par_script.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_par_script.type IS '0:check_switch_ip
1:check_par_port';


--
-- Name: exchange_par_script_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_par_script_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_par_script_id_seq OWNER TO postgres;

--
-- Name: exchange_par_script_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_par_script_id_seq OWNED BY exchange_par_script.id;


--
-- Name: exchange_par_switch_profiles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_par_switch_profiles (
    id integer NOT NULL,
    par_id integer,
    service_ip_id integer,
    service_ip_start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    service_ip_end_time timestamp with time zone,
    type integer DEFAULT 0 NOT NULL
);


ALTER TABLE exchange_par_switch_profiles OWNER TO postgres;

--
-- Name: COLUMN exchange_par_switch_profiles.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_par_switch_profiles.type IS '0:public
1:private';


--
-- Name: exchange_par_switch_profiles_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_par_switch_profiles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_par_switch_profiles_id_seq OWNER TO postgres;

--
-- Name: exchange_par_switch_profiles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_par_switch_profiles_id_seq OWNED BY exchange_par_switch_profiles.id;


--
-- Name: exchange_par_system_parm; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_par_system_parm (
    id integer NOT NULL,
    ip_month_money numeric
);


ALTER TABLE exchange_par_system_parm OWNER TO postgres;

--
-- Name: exchange_par_system_parm_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_par_system_parm_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_par_system_parm_id_seq OWNER TO postgres;

--
-- Name: exchange_par_system_parm_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_par_system_parm_id_seq OWNED BY exchange_par_system_parm.id;


--
-- Name: exchange_partition_payment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_partition_payment (
    id integer,
    par_id integer,
    total_amount numeric,
    status integer,
    action_time timestamp with time zone,
    complete_time timestamp with time zone,
    action_method integer,
    action_number character varying,
    actual_amount numeric,
    action_fee numeric
);


ALTER TABLE exchange_partition_payment OWNER TO postgres;

--
-- Name: exchange_product_copy_rate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_product_copy_rate_log (
    id integer NOT NULL,
    agent_id integer,
    product_id integer,
    from_product_id integer,
    status integer DEFAULT 0 NOT NULL,
    par_id integer
);


ALTER TABLE exchange_product_copy_rate_log OWNER TO postgres;

--
-- Name: exchange_product_copy_rate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_product_copy_rate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_product_copy_rate_log_id_seq OWNER TO postgres;

--
-- Name: exchange_product_copy_rate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_product_copy_rate_log_id_seq OWNED BY exchange_product_copy_rate_log.id;


--
-- Name: exchange_product_copy_route_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_product_copy_route_log (
    id integer NOT NULL,
    agent_id integer,
    product_id integer,
    from_product_id integer,
    status integer DEFAULT 0 NOT NULL,
    par_id integer
);


ALTER TABLE exchange_product_copy_route_log OWNER TO postgres;

--
-- Name: exchange_product_copy_route_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_product_copy_route_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_product_copy_route_log_id_seq OWNER TO postgres;

--
-- Name: exchange_product_copy_route_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_product_copy_route_log_id_seq OWNED BY exchange_product_copy_route_log.id;


--
-- Name: exchange_product_copy_route_rate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_product_copy_route_rate_log (
    id integer NOT NULL,
    agent_id integer,
    product_id integer,
    from_product_id integer,
    status integer,
    par_id integer
);


ALTER TABLE exchange_product_copy_route_rate_log OWNER TO postgres;

--
-- Name: exchange_product_copy_route_rate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_product_copy_route_rate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_product_copy_route_rate_log_id_seq OWNER TO postgres;

--
-- Name: exchange_product_copy_route_rate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_product_copy_route_rate_log_id_seq OWNED BY exchange_product_copy_route_rate_log.id;


--
-- Name: exchange_product_user_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_product_user_list (
    id integer NOT NULL,
    product_id integer,
    user_id integer
);


ALTER TABLE exchange_product_user_list OWNER TO postgres;

--
-- Name: exchange_public_user_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_public_user_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_public_user_list_id_seq OWNER TO postgres;

--
-- Name: exchange_public_user_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_public_user_list_id_seq OWNED BY exchange_product_user_list.id;


--
-- Name: exchange_reg_country; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_reg_country (
    id integer NOT NULL,
    country character varying
);


ALTER TABLE exchange_reg_country OWNER TO postgres;

--
-- Name: exchange_reg_country_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_reg_country_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_reg_country_id_seq OWNER TO postgres;

--
-- Name: exchange_reg_country_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_reg_country_id_seq OWNED BY exchange_reg_country.id;


--
-- Name: exchange_resource_private; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_resource_private (
    id integer NOT NULL,
    ingress_trunk_id integer,
    code_name character varying,
    egress_trunk_id integer,
    create_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    change_key character varying,
    status integer DEFAULT 0 NOT NULL
);


ALTER TABLE exchange_resource_private OWNER TO postgres;

--
-- Name: exchange_resource_private_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_resource_private_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_resource_private_id_seq OWNER TO postgres;

--
-- Name: exchange_resource_private_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_resource_private_id_seq OWNED BY exchange_resource_private.id;


--
-- Name: exchange_simple_session; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_simple_session (
    id integer NOT NULL,
    status integer DEFAULT 1,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    message text,
    group_number integer,
    create_by character varying
);


ALTER TABLE exchange_simple_session OWNER TO postgres;

--
-- Name: exchange_simple_session_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_simple_session_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_simple_session_id_seq OWNER TO postgres;

--
-- Name: exchange_simple_session_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_simple_session_id_seq OWNED BY exchange_simple_session.id;


--
-- Name: exchange_simple_session_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_simple_session_list (
    id integer NOT NULL,
    code character varying,
    code_name character varying,
    trunk_id integer,
    total_calls integer,
    success_calls integer,
    pdd integer,
    session_id integer,
    fas boolean,
    asr boolean,
    status integer,
    error_message text,
    caller_id character varying,
    port_msg character varying,
    "time" integer
);


ALTER TABLE exchange_simple_session_list OWNER TO postgres;

--
-- Name: COLUMN exchange_simple_session_list.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_simple_session_list.status IS '0: not content
1:content';


--
-- Name: exchange_simple_session_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_simple_session_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_simple_session_list_id_seq OWNER TO postgres;

--
-- Name: exchange_simple_session_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_simple_session_list_id_seq OWNED BY exchange_simple_session_list.id;


--
-- Name: exchange_sys_module; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_sys_module (
    id integer NOT NULL,
    module_name character varying,
    order_num integer,
    type integer
);


ALTER TABLE exchange_sys_module OWNER TO postgres;

--
-- Name: COLUMN exchange_sys_module.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_sys_module.type IS '0:exchange
1:agent
2:partition
';


--
-- Name: exchange_sys_module_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_sys_module_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_sys_module_id_seq OWNER TO postgres;

--
-- Name: exchange_sys_module_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_sys_module_id_seq OWNED BY exchange_sys_module.id;


--
-- Name: exchange_sys_pri; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_sys_pri (
    id integer NOT NULL,
    pri_name character varying(100) NOT NULL,
    module_id integer,
    pri_val character varying(100) NOT NULL,
    flag boolean DEFAULT true NOT NULL,
    pri_url character varying(200)
);


ALTER TABLE exchange_sys_pri OWNER TO postgres;

--
-- Name: TABLE exchange_sys_pri; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE exchange_sys_pri IS 'ç³»ç»ŸåŠ¨ä½œï¼Œæœ¬ç³»ç»Ÿè®¤ä¸ºæ˜¯å„æ ç›®';


--
-- Name: COLUMN exchange_sys_pri.pri_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_sys_pri.pri_name IS 'æ¨¡å—åï¼Œå†…éƒ¨ä½¿ç”¨';


--
-- Name: COLUMN exchange_sys_pri.pri_val; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_sys_pri.pri_val IS 'æ¨¡å—æ˜¾ç¤ºå';


--
-- Name: COLUMN exchange_sys_pri.pri_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_sys_pri.pri_url IS 'æ¨¡å—çš„urlæŒ‡å‘';


--
-- Name: exchange_sys_pri_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_sys_pri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_sys_pri_id_seq OWNER TO postgres;

--
-- Name: exchange_sys_pri_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_sys_pri_id_seq OWNED BY exchange_sys_pri.id;


--
-- Name: exchange_sys_role; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_sys_role (
    role_id integer NOT NULL,
    role_name character varying(100),
    role_info character varying(1000),
    view_all boolean DEFAULT false,
    delete_invoice smallint DEFAULT 0,
    delete_payment smallint DEFAULT 0,
    delete_credit_note smallint DEFAULT 0,
    delete_debit_note smallint DEFAULT 0,
    reset_balance smallint DEFAULT 0,
    modify_credit_limit smallint DEFAULT 0,
    modify_min_profit smallint DEFAULT 0,
    type integer DEFAULT 1 NOT NULL,
    agent_id integer,
    client_id integer,
    par_id integer
);


ALTER TABLE exchange_sys_role OWNER TO postgres;

--
-- Name: COLUMN exchange_sys_role.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN exchange_sys_role.type IS '0:exchange
1:agent
2:partition

3:agent_user
4:exchange_user
5:partition_user';


--
-- Name: exchange_sys_role_pri; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_sys_role_pri (
    id integer NOT NULL,
    role_id integer,
    pri_name character varying(100) NOT NULL,
    model_r boolean DEFAULT false NOT NULL,
    model_w boolean DEFAULT false NOT NULL,
    model_x boolean DEFAULT false NOT NULL,
    pri_id integer
);


ALTER TABLE exchange_sys_role_pri OWNER TO postgres;

--
-- Name: exchange_sys_role_pri_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_sys_role_pri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_sys_role_pri_id_seq OWNER TO postgres;

--
-- Name: exchange_sys_role_pri_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_sys_role_pri_id_seq OWNED BY exchange_sys_role_pri.id;


--
-- Name: exchange_sys_role_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE exchange_sys_role_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE exchange_sys_role_role_id_seq OWNER TO postgres;

--
-- Name: exchange_sys_role_role_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE exchange_sys_role_role_id_seq OWNED BY exchange_sys_role.role_id;


--
-- Name: exchange_vendor_test_number; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE exchange_vendor_test_number (
    id integer NOT NULL,
    code_name character varying(100),
    code character varying(100)
);


ALTER TABLE exchange_vendor_test_number OWNER TO postgres;

--
-- Name: execution_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE execution_log (
    id integer NOT NULL,
    rule_name character varying(100),
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    ani_find character varying(500),
    of_calls character varying(100),
    msg text,
    status integer,
    exec_type integer
);


ALTER TABLE execution_log OWNER TO postgres;

--
-- Name: TABLE execution_log; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE execution_log IS 'dialer detection æ¯æ¬¡æ‰§è¡Œçš„æ—¶é—´å’Œç»“æžœ';


--
-- Name: COLUMN execution_log.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN execution_log.id IS 'ä¸»é”®';


--
-- Name: execution_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE execution_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE execution_log_id_seq OWNER TO postgres;

--
-- Name: execution_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE execution_log_id_seq OWNED BY execution_log.id;


--
-- Name: export_task_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE export_task_log (
    id bigint NOT NULL,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    ingress_carrier_id numeric,
    egress_carrier_id numeric,
    egress_trunk_id numeric,
    ingress_code_name character varying,
    egress_code_name character varying,
    ingress_code numeric,
    egress_code numeric,
    ingress_country character varying,
    non_zero boolean,
    switch_profile_ip character varying,
    ingress_ani character varying,
    egress_ani character varying,
    ingress_dnis character varying,
    egress_dnis character varying,
    routing_digit character varying,
    ingress_call_id numeric,
    egress_call_id numeric,
    unauthorized_ip boolean DEFAULT true,
    status numeric DEFAULT 0,
    progress numeric DEFAULT 0,
    path character varying,
    requested_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    started_on timestamp with time zone,
    finished_on timestamp with time zone,
    ingress_trunk_id numeric,
    egress_country character varying,
    return_filter character varying,
    gcs_url character varying,
    error character varying,
    websocket_files text,
    use_client_cdr boolean DEFAULT true,
    task_type numeric DEFAULT 1,
    rate_table_id integer,
    routing_plan_id integer,
    group_by text,
    time_group_by text,
    cause integer,
    carrier_id integer,
    trunk_id integer,
    code_name integer
);


ALTER TABLE export_task_log OWNER TO postgres;

--
-- Name: COLUMN export_task_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN export_task_log.status IS '0: Waiting. 1: in progress ,2: success 3: failed';


--
-- Name: export_task_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE export_task_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE export_task_log_id_seq OWNER TO postgres;

--
-- Name: export_task_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE export_task_log_id_seq OWNED BY export_task_log.id;


--
-- Name: fas_check_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE fas_check_result (
    id integer NOT NULL,
    callid character varying(255) NOT NULL,
    calltime character varying(255) NOT NULL,
    result smallint
);


ALTER TABLE fas_check_result OWNER TO postgres;

--
-- Name: fas_check_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fas_check_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fas_check_result_id_seq OWNER TO postgres;

--
-- Name: fas_check_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fas_check_result_id_seq OWNED BY fas_check_result.id;


--
-- Name: fraud_detection; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE fraud_detection (
    id integer NOT NULL,
    rule_name character varying(100),
    active boolean,
    hourly_minute integer,
    hourly_revenue integer,
    daily_minute integer,
    daily_revenue integer,
    is_block boolean,
    is_send_mail boolean,
    email_to integer,
    ingress_ids character varying(500),
    update_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying(100)
);


ALTER TABLE fraud_detection OWNER TO postgres;

--
-- Name: COLUMN fraud_detection.hourly_minute; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fraud_detection.hourly_minute IS '1å°æ—¶å†…çš„åˆ†é’Ÿæ•°';


--
-- Name: COLUMN fraud_detection.hourly_revenue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fraud_detection.hourly_revenue IS '1å°æ—¶å†…çš„åˆ©æ¶¦';


--
-- Name: COLUMN fraud_detection.daily_minute; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fraud_detection.daily_minute IS '24å°æ—¶å†…çš„åˆ†é’Ÿæ•°';


--
-- Name: COLUMN fraud_detection.daily_revenue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fraud_detection.daily_revenue IS '24å°æ—¶å†…çš„åˆ©æ¶¦';


--
-- Name: COLUMN fraud_detection.email_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fraud_detection.email_to IS '0: switch NOC
1: Partnerâ€™s NOC
2:both';


--
-- Name: fraud_detection_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fraud_detection_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fraud_detection_id_seq OWNER TO postgres;

--
-- Name: fraud_detection_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fraud_detection_id_seq OWNED BY fraud_detection.id;


--
-- Name: fraud_detection_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE fraud_detection_log (
    id integer NOT NULL,
    fraud_detection_id integer,
    create_on timestamp with time zone,
    create_by integer,
    status integer,
    finish_time timestamp with time zone,
    "time" numeric DEFAULT date_part('epoch'::text, ('now'::text)::timestamp(0) with time zone)
);


ALTER TABLE fraud_detection_log OWNER TO postgres;

--
-- Name: COLUMN fraud_detection_log.create_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fraud_detection_log.create_by IS '0 auto
1 Manual';


--
-- Name: COLUMN fraud_detection_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fraud_detection_log.status IS '0 normal
1 over limit';


--
-- Name: fraud_detection_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE fraud_detection_log_detail (
    id integer NOT NULL,
    fraud_detection_log_id integer,
    ingress_id integer,
    block_type integer,
    limit_value integer,
    actual_value character varying(50),
    partner_email_msg text,
    partner_email_status boolean,
    partner_email character varying(200),
    system_email_msg text,
    system_email_status boolean,
    system_email character varying(200),
    is_block boolean DEFAULT false,
    is_send_email boolean DEFAULT false
);


ALTER TABLE fraud_detection_log_detail OWNER TO postgres;

--
-- Name: COLUMN fraud_detection_log_detail.block_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fraud_detection_log_detail.block_type IS '0 1h minute
1 1h revenue
2 24h minute
3 24h revenue
';


--
-- Name: fraud_detection_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fraud_detection_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fraud_detection_log_detail_id_seq OWNER TO postgres;

--
-- Name: fraud_detection_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fraud_detection_log_detail_id_seq OWNED BY fraud_detection_log_detail.id;


--
-- Name: fraud_detection_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fraud_detection_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fraud_detection_log_id_seq OWNER TO postgres;

--
-- Name: fraud_detection_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fraud_detection_log_id_seq OWNED BY fraud_detection_log.id;


--
-- Name: ftp_cdr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ftp_cdr (
    ftp_user character varying(100),
    ftp_pw character varying(100),
    run_freq integer,
    cdr_fields text,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    last_run_time timestamp with time zone,
    cdr_alias text
);


ALTER TABLE ftp_cdr OWNER TO postgres;

--
-- Name: ftp_cdr_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ftp_cdr_log (
    id integer NOT NULL,
    ftp_start_time timestamp with time zone,
    ftp_end_time timestamp with time zone,
    status integer,
    ftp_ip character varying(255),
    ftp_dir character varying,
    alias character varying(255),
    ftp_conf_id integer,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    pid integer,
    detail text
);


ALTER TABLE ftp_cdr_log OWNER TO postgres;

--
-- Name: COLUMN ftp_cdr_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ftp_cdr_log.status IS '-1--ftp error
-2--cdr file error
-3--db error
1--done';


--
-- Name: ftp_cdr_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ftp_cdr_log_detail (
    id integer NOT NULL,
    ftp_cdr_log_id integer,
    create_time timestamp with time zone,
    file_name character varying,
    ftp_ip character varying(255),
    ftp_dir character varying,
    detail text,
    local_file_path character varying(500)
);


ALTER TABLE ftp_cdr_log_detail OWNER TO postgres;

--
-- Name: ftp_cdr_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ftp_cdr_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ftp_cdr_log_detail_id_seq OWNER TO postgres;

--
-- Name: ftp_cdr_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ftp_cdr_log_detail_id_seq OWNED BY ftp_cdr_log_detail.id;


--
-- Name: ftp_cdr_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ftp_cdr_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ftp_cdr_log_id_seq OWNER TO postgres;

--
-- Name: ftp_cdr_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ftp_cdr_log_id_seq OWNED BY ftp_cdr_log.id;


--
-- Name: ftp_conf; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ftp_conf (
    id integer NOT NULL,
    server_ip character varying(100),
    server_port character varying(100),
    username character varying(100),
    password character varying(100),
    frequency smallint DEFAULT 0,
    fields text,
    headers text,
    contain_headers boolean,
    file_type integer,
    ingress_carriers text,
    egress_carriers text,
    ingress_carriers_all boolean DEFAULT false,
    egress_carriers_all boolean DEFAULT false,
    duration integer,
    ingress_release_cause text,
    egress_release_cause text,
    conditions text,
    ingresses text,
    egresses text,
    ingresses_all boolean DEFAULT false,
    egresses_all boolean DEFAULT false,
    "time" character varying(255),
    alias character varying(255),
    server_dir character varying(255),
    max_lines integer DEFAULT 10000 NOT NULL,
    active boolean DEFAULT true,
    every_hours integer DEFAULT 1,
    file_breakdown integer DEFAULT 0,
    every_minutes integer DEFAULT 15,
    every_day integer
);


ALTER TABLE ftp_conf OWNER TO postgres;

--
-- Name: COLUMN ftp_conf.file_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ftp_conf.file_type IS '1--gz
2--tar.gz
3--tar.bz2';


--
-- Name: ftp_conf_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ftp_conf_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ftp_conf_id_seq OWNER TO postgres;

--
-- Name: ftp_conf_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ftp_conf_id_seq OWNED BY ftp_conf.id;


--
-- Name: ftp_server_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ftp_server_log (
    id integer NOT NULL,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    cmd text,
    response text
);


ALTER TABLE ftp_server_log OWNER TO postgres;

--
-- Name: ftp_server_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ftp_server_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ftp_server_log_id_seq OWNER TO postgres;

--
-- Name: ftp_server_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ftp_server_log_id_seq OWNED BY ftp_server_log.id;


--
-- Name: global_failover; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE global_failover (
    id integer NOT NULL,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100)
);


ALTER TABLE global_failover OWNER TO postgres;

--
-- Name: global_failover_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE global_failover_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE global_failover_id_seq OWNER TO postgres;

--
-- Name: global_failover_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE global_failover_id_seq OWNED BY global_failover.id;


--
-- Name: global_route_error; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE global_route_error (
    id integer NOT NULL,
    error_code integer,
    error_description character varying(100),
    to_sip_code integer,
    to_sip_string character varying(100),
    default_to_sip_code integer,
    default_to_sip_string character varying(100)
);


ALTER TABLE global_route_error OWNER TO postgres;

--
-- Name: TABLE global_route_error; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE global_route_error IS 'class4æ— æ³•è·¯ç”±é”™è¯¯ä¸Žè¿”å›žç»™ä¸»å«çš„é”™è¯¯ç å…¨å±€é…ç½®

baohq20140423';


--
-- Name: COLUMN global_route_error.error_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN global_route_error.error_code IS 'route error type

baohq20140423';


--
-- Name: COLUMN global_route_error.error_description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN global_route_error.error_description IS 'route error description

baohq20140423';


--
-- Name: COLUMN global_route_error.to_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN global_route_error.to_sip_code IS 'è¿”å›žç»™ä¸»å«çš„sipé”™è¯¯ç 

baohq20140423';


--
-- Name: COLUMN global_route_error.to_sip_string; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN global_route_error.to_sip_string IS 'è¿”å›žç»™ä¸»å«çš„sipæè¿°

baohq20140423';


--
-- Name: COLUMN global_route_error.default_to_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN global_route_error.default_to_sip_code IS 'baohq20140423';


--
-- Name: COLUMN global_route_error.default_to_sip_string; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN global_route_error.default_to_sip_string IS 'baohq20140423';


--
-- Name: global_route_error_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE global_route_error_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE global_route_error_id_seq OWNER TO postgres;

--
-- Name: global_route_error_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE global_route_error_id_seq OWNED BY global_route_error.id;


--
-- Name: global_route_error_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE global_route_error_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE global_route_error_record_record_id_seq OWNER TO postgres;

--
-- Name: global_route_error_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE global_route_error_record (
    id integer,
    error_code integer,
    error_description character varying(100),
    to_sip_code integer,
    to_sip_string character varying(100),
    default_to_sip_code integer,
    default_to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('global_route_error_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE global_route_error_record OWNER TO postgres;

--
-- Name: global_route_error_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE global_route_error_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE global_route_error_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: global_route_error_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE global_route_error_record_tmp (
    id integer,
    error_code integer,
    error_description character varying(100),
    to_sip_code integer,
    to_sip_string character varying(100),
    default_to_sip_code integer,
    default_to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('global_route_error_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE global_route_error_record_tmp OWNER TO postgres;

--
-- Name: hang_calls_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE hang_calls_history (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    total_cdrs integer,
    huang_cdr_counts integer
);


ALTER TABLE hang_calls_history OWNER TO postgres;

--
-- Name: hang_calls_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE hang_calls_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hang_calls_history_id_seq OWNER TO postgres;

--
-- Name: hang_calls_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE hang_calls_history_id_seq OWNED BY hang_calls_history.id;


--
-- Name: hang_calls_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE hang_calls_list (
    hang_calls_history_id integer,
    "time" timestamp with time zone,
    duration integer,
    ingress_trunk character varying(20),
    egress_trunk character varying(20),
    ingresss_ip character varying(20),
    egress_ip character varying(20),
    ingress_profile_ip character varying(20),
    egress_profile_ip character varying(20),
    orig_ani character varying(20),
    orig_dnis character varying(20),
    term_ani character varying(20),
    term_dnis character varying(20)
);


ALTER TABLE hang_calls_list OWNER TO postgres;

--
-- Name: host_based_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE host_based_report (
    report_time timestamp with time zone,
    duration integer,
    ingress_bill_time integer,
    ingress_call_cost numeric(15,6),
    ingress_total_calls integer,
    not_zero_calls integer,
    ingress_success_calls integer,
    ingress_busy_calls integer,
    pdd bigint,
    ingress_cancel_calls integer,
    ingress_client_id integer,
    egress_client_id integer,
    egress_bill_time integer,
    egress_call_cost numeric(15,6),
    egress_total_calls integer,
    egress_success_calls integer,
    egress_busy_calls integer,
    egress_cancel_calls integer,
    ingress_ip character varying(50),
    egress_ip character varying(50),
    ingress_avg_rate double precision,
    egress_avg_rate double precision,
    cdr_date character varying(24)
);


ALTER TABLE host_based_report OWNER TO postgres;

--
-- Name: host_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE host_info (
    "time" character varying(100),
    res_id character varying(100),
    ip_id character varying(100),
    acd character varying(100),
    asr character varying(100),
    ca character varying(100),
    call_count character varying(100),
    direction character varying(100),
    call_count_asr character varying(100),
    pdd character varying(100),
    ip character varying(100)
);


ALTER TABLE host_info OWNER TO postgres;

--
-- Name: TABLE host_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE host_info IS 'host monitor';


--
-- Name: COLUMN host_info."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info."time" IS 'æ—¶é—´';


--
-- Name: COLUMN host_info.res_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info.res_id IS 'ç½‘å…³';


--
-- Name: COLUMN host_info.ip_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info.ip_id IS 'host';


--
-- Name: COLUMN host_info.acd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info.acd IS 'å¹³å‡é€šè¯æ—¶é•¿';


--
-- Name: COLUMN host_info.asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info.asr IS 'æŽ¥é€šæˆåŠŸçŽ‡';


--
-- Name: COLUMN host_info.ca; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info.ca IS 'ca';


--
-- Name: COLUMN host_info.call_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info.call_count IS 'call_count';


--
-- Name: COLUMN host_info.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info.direction IS 'ingress,egress
direction = 0 æ‰“è¿›
ingress
direction = 1æ‰“å‡º
egress';


--
-- Name: COLUMN host_info.call_count_asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info.call_count_asr IS 'call_count_asr';


--
-- Name: COLUMN host_info.pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info.pdd IS 'å‘¼å«å»¶è¿Ÿæ—¶é—´';


--
-- Name: COLUMN host_info.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN host_info.ip IS 'æœåŠ¡æœŸåœ°å€';


--
-- Name: hung_calls_detection_configuration; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE hung_calls_detection_configuration (
    id integer NOT NULL,
    duration integer,
    "interval" smallint,
    day_of_week integer,
    "time" character varying(50),
    action smallint,
    receiver character varying(200)
);


ALTER TABLE hung_calls_detection_configuration OWNER TO postgres;

--
-- Name: hung_calls_detection_configuration_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE hung_calls_detection_configuration_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hung_calls_detection_configuration_id_seq OWNER TO postgres;

--
-- Name: hung_calls_detection_configuration_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE hung_calls_detection_configuration_id_seq OWNED BY hung_calls_detection_configuration.id;


--
-- Name: hung_calls_report_delete_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE hung_calls_report_delete_log (
    id integer NOT NULL,
    bak_ids character varying(500),
    delete_time timestamp with time zone,
    delete_by character varying(50)
);


ALTER TABLE hung_calls_report_delete_log OWNER TO postgres;

--
-- Name: hung_calls_report_delete_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE hung_calls_report_delete_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hung_calls_report_delete_log_id_seq OWNER TO postgres;

--
-- Name: hung_calls_report_delete_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE hung_calls_report_delete_log_id_seq OWNED BY hung_calls_report_delete_log.id;


--
-- Name: import_code_constraints_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE import_code_constraints_log (
    id integer NOT NULL,
    create_time timestamp with time zone,
    file_path character varying(256),
    file_name character varying(256),
    status integer DEFAULT 0,
    client_id integer,
    file_header character varying(256),
    file_start_line integer
);


ALTER TABLE import_code_constraints_log OWNER TO postgres;

--
-- Name: import_code_constraints_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE import_code_constraints_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE import_code_constraints_log_id_seq OWNER TO postgres;

--
-- Name: import_code_constraints_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE import_code_constraints_log_id_seq OWNED BY import_code_constraints_log.id;


--
-- Name: import_export_logs_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE import_export_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE import_export_logs_id_seq OWNER TO postgres;

--
-- Name: import_export_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE import_export_logs (
    id integer DEFAULT nextval('import_export_logs_id_seq'::regclass) NOT NULL,
    file_path character varying(300) DEFAULT ''::character varying NOT NULL,
    error_file_path character varying(300) DEFAULT ''::character varying NOT NULL,
    status integer DEFAULT 0 NOT NULL,
    user_id integer DEFAULT 0 NOT NULL,
    obj character varying(80),
    log_type integer DEFAULT 0 NOT NULL,
    "time" timestamp with time zone,
    finished_time timestamp with time zone,
    duplicate_type character varying(16),
    ext_attributes text,
    server_id integer DEFAULT 0 NOT NULL,
    upload_table character varying(100),
    upload_type integer,
    db_error_file_path character varying(100),
    duplicate_numbers integer DEFAULT 0,
    foreign_id integer,
    success_numbers integer DEFAULT 0,
    error_row integer DEFAULT 0,
    error_rollback boolean DEFAULT false,
    php_process_number bigint DEFAULT 0,
    db_process_number bigint DEFAULT 0,
    foreign_name character varying(80),
    auto_enddate integer DEFAULT 0,
    custom_end_date timestamp with time zone,
    pid integer,
    myfile_filename character varying(100)
);


ALTER TABLE import_export_logs OWNER TO postgres;

--
-- Name: TABLE import_export_logs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE import_export_logs IS 'ä¸Šè½½ï¼ä¸‹è½½ï¼Œæ—¥å¿—';


--
-- Name: COLUMN import_export_logs.file_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.file_path IS 'ä¸Šä¼  ä¸‹è½½ çš„æ–‡ä»¶çš„è·¯å¾„';


--
-- Name: COLUMN import_export_logs.error_file_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.error_file_path IS 'ä¸Šä¼ æ–‡ä»¶æ—¶ï¼Œ å¤„ç†å‡ºé”™è®°å½•æ–‡ä»¶è·¯å¾„ ';


--
-- Name: COLUMN import_export_logs.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.status IS 'status==0ä¸Šä¼ æ–‡ä»¶åˆ°æœåŠ¡å™¨
status==10
status==8æ–‡ä»¶å·²ç»éªŒè¯å®Œæ¯•ï¼ŒæˆåŠŸå¯¼å…¥ä¸´æ—¶è¡¨
status==9  PHPå¼€å§‹éªŒè¯ ï¼ï¼å¯¼å…¥ä¸´æ—¶è¡¨å¤„ç†ä¸­
status==7æ­£åœ¨è¿›è¡Œæ•°æ®åº“éªŒè¯
status==6æ•°æ®åº“éªŒè¯å®Œæˆ  ä¸Šä¼ å®Œæˆ
status==-1è¡¨æœ‰é”™è¯¯(å¤–é”®ä¸å­˜åœ¨)

1--processing
2--done
-2--upload file open error
-3--upload error file open error
-4--csv head error
-5--database error';


--
-- Name: COLUMN import_export_logs.log_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.log_type IS 'LOG_TYPE_EXPORT = 0;
LOG_TYPE_IMPORT = 1;';


--
-- Name: COLUMN import_export_logs."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs."time" IS 'ä¸Šä¼  ä¸‹è½½çš„æ—¶é—´';


--
-- Name: COLUMN import_export_logs.finished_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.finished_time IS 'ä¸Šä¼  å¤„ç†å®Œçš„æ—¶é—´';


--
-- Name: COLUMN import_export_logs.duplicate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.duplicate_type IS 'ä¸Šä¼ æ—¶ï¼Œ é‡å¤çš„å¤„ç†æ–¹å¼';


--
-- Name: COLUMN import_export_logs.ext_attributes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.ext_attributes IS 'ä¿å­˜ä¸€äº›å…¶å®ƒå‚æ•°ï¼Œ ä¿å­˜ serializeä¹‹åŽçš„æ ¼å¼';


--
-- Name: COLUMN import_export_logs.upload_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.upload_table IS 'ä¸´æ—¶è¡¨å';


--
-- Name: COLUMN import_export_logs.upload_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.upload_type IS '1-ingress
2-egress
3-host
4-resource action
5-resource digit mapping
6-digit translation
7-resource block
8-jurisdiction
9-code deck
10-rate
11-static route
12-route plan';


--
-- Name: COLUMN import_export_logs.db_error_file_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.db_error_file_path IS 'æ•°æ®åº“éªŒè¯é”™è¯¯æ–‡ä»¶ç›®å½•';


--
-- Name: COLUMN import_export_logs.duplicate_numbers; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.duplicate_numbers IS 'é‡å¤çš„è¡Œæ•°';


--
-- Name: COLUMN import_export_logs.foreign_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.foreign_id IS 'å¤–é”®çš„id
6-digit translation
9-code deck
10-rate
11-static route
12-route plan';


--
-- Name: COLUMN import_export_logs.error_row; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.error_row IS 'é”™è¯¯å¤šå°‘è¡Œ';


--
-- Name: COLUMN import_export_logs.php_process_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.php_process_number IS 'php éªŒè¯å¤„ç†å¤šå°‘è¡Œ';


--
-- Name: COLUMN import_export_logs.db_process_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.db_process_number IS 'æ•°æ®åº“éªŒè¯å¤„ç†å¤šå°‘è¡Œ';


--
-- Name: COLUMN import_export_logs.foreign_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_export_logs.foreign_name IS 'å¤–é”®å¯¹åº”çš„name';


--
-- Name: import_rate_file_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE import_rate_file_log (
    id integer NOT NULL,
    file_path character varying(256),
    file_name character varying(225),
    client_id integer,
    egress_trunk_id integer,
    end_date character varying(225),
    date_format character varying(225),
    sample_do character varying(225),
    ratetable_id integer,
    status integer DEFAULT 1,
    product_id integer,
    agent_id integer,
    par_id integer,
    old_file_path character varying
);


ALTER TABLE import_rate_file_log OWNER TO postgres;

--
-- Name: import_rate_file_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE import_rate_file_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE import_rate_file_log_id_seq OWNER TO postgres;

--
-- Name: import_rate_file_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE import_rate_file_log_id_seq OWNED BY import_rate_file_log.id;


--
-- Name: import_rate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE import_rate_log (
    id integer NOT NULL,
    import_file character varying(300),
    status integer DEFAULT 0 NOT NULL,
    cli_type integer,
    dtmf boolean,
    g729 boolean,
    resource_id integer,
    prefix character varying(30),
    order_type integer DEFAULT 1 NOT NULL,
    client_id integer,
    error_file integer,
    create_time timestamp with time zone,
    duplicate_type character varying(30),
    code_deck_id integer DEFAULT 1
);


ALTER TABLE import_rate_log OWNER TO postgres;

--
-- Name: COLUMN import_rate_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_rate_log.status IS '0:æ–‡ä»¶ä¸Šä¼ å®Œæˆ
1:orderç”Ÿæˆå®Œæˆ';


--
-- Name: COLUMN import_rate_log.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_rate_log.order_type IS '1ï¼šbuy
2ï¼šsell';


--
-- Name: import_rate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE import_rate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE import_rate_log_id_seq OWNER TO postgres;

--
-- Name: import_rate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE import_rate_log_id_seq OWNED BY import_rate_log.id;


--
-- Name: import_rate_status; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE import_rate_status (
    id integer NOT NULL,
    rate_table_id integer,
    status integer DEFAULT 0,
    delete_queue integer DEFAULT 0,
    update_queue integer DEFAULT 0,
    insert_queue integer DEFAULT 0,
    error_counter integer DEFAULT 0,
    reimport_counter integer DEFAULT 0,
    error_log_file character varying(256),
    reimport_log_file character varying(256),
    "time" timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    upload_file_name character varying(256),
    local_file character varying(256),
    method integer DEFAULT 0,
    user_id integer,
    start_epoch bigint,
    end_epoch bigint,
    sql_record text,
    default_info character varying(200)
);


ALTER TABLE import_rate_status OWNER TO postgres;

--
-- Name: TABLE import_rate_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE import_rate_status IS 'exchange ä¸Šä¼ è´¹çŽ‡çš„log';


--
-- Name: COLUMN import_rate_status.reimport_counter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_rate_status.reimport_counter IS 'é”™è¯¯çš„åˆå‡ºé‡æ–°ä¸Šä¼ å¤šå°‘è®°å½•';


--
-- Name: COLUMN import_rate_status.reimport_log_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_rate_status.reimport_log_file IS 'é”™è¯¯ å¹¶ä¸”é‡æ–°ä¸Šä¼ çš„é”™çŽ°çš„é”™è¯¯æ–‡ä»¶';


--
-- Name: COLUMN import_rate_status.start_epoch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_rate_status.start_epoch IS 'å¼€å§‹ä¸Šä¼ æ—¶é—´';


--
-- Name: COLUMN import_rate_status.end_epoch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_rate_status.end_epoch IS 'ç»“æŸä¸Šä¼ æ—¶é—´';


--
-- Name: COLUMN import_rate_status.sql_record; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_rate_status.sql_record IS 'è®°å½•ä¸Šä¼ æ“ä½œçš„cmd';


--
-- Name: COLUMN import_rate_status.default_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN import_rate_status.default_info IS 'example:Effective Date:yyyy-mm-dd hh:ii:ss<br />Min Time:1<br />Interval:2';


--
-- Name: import_rate_status_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE import_rate_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE import_rate_status_id_seq OWNER TO postgres;

--
-- Name: import_rate_status_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE import_rate_status_id_seq OWNED BY import_rate_status.id;


--
-- Name: import_target_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE import_target_log (
    id integer NOT NULL,
    status integer DEFAULT 1,
    client_id integer,
    create_time timestamp without time zone,
    file_name character varying(256),
    file_path character varying(256),
    error_message character varying(256)
);


ALTER TABLE import_target_log OWNER TO postgres;

--
-- Name: import_target_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE import_target_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE import_target_log_id_seq OWNER TO postgres;

--
-- Name: import_target_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE import_target_log_id_seq OWNED BY import_target_log.id;


--
-- Name: ingress_did_repository; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ingress_did_repository (
    number character varying(255) NOT NULL,
    ingress_id integer,
    egress_id integer,
    created_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    updated_time timestamp with time zone,
    state character varying(200),
    country character varying(200),
    city character varying(200),
    rate_center character varying(200),
    status smallint DEFAULT 0,
    type smallint,
    lata character varying(100)
);


ALTER TABLE ingress_did_repository OWNER TO postgres;

--
-- Name: COLUMN ingress_did_repository.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ingress_did_repository.type IS '(''Local'' => 1, ''TollFree'' => 2)';


--
-- Name: ingress_test; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ingress_test (
    id integer NOT NULL,
    ingress_id integer,
    code_name character varying(100),
    dnis character varying(1000),
    ani character varying(100),
    call_duration integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    status integer DEFAULT 0,
    ingress_ip character varying(100)
);


ALTER TABLE ingress_test OWNER TO postgres;

--
-- Name: COLUMN ingress_test.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ingress_test.status IS '0-wait
1-running
2-done
-1-open file error';


--
-- Name: ingress_test_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ingress_test_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ingress_test_id_seq OWNER TO postgres;

--
-- Name: ingress_test_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ingress_test_id_seq OWNED BY ingress_test.id;


--
-- Name: invalid_detection_block_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invalid_detection_block_log (
    id integer NOT NULL,
    created_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    number_type integer,
    ingress_id integer,
    number character varying,
    rule_id integer,
    block_type integer,
    blocked_on timestamp with time zone
);


ALTER TABLE invalid_detection_block_log OWNER TO postgres;

--
-- Name: COLUMN invalid_detection_block_log.block_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_detection_block_log.block_type IS '1 block;2unblock';


--
-- Name: invalid_detection_block_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invalid_detection_block_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invalid_detection_block_log_id_seq OWNER TO postgres;

--
-- Name: invalid_detection_block_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invalid_detection_block_log_id_seq OWNED BY invalid_detection_block_log.id;


--
-- Name: invalid_number_detection; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invalid_number_detection (
    id integer NOT NULL,
    rule_name character varying(100),
    update_by character varying(100),
    update_at timestamp with time zone,
    active boolean,
    ani_check_all boolean,
    ani_ingress character varying(500),
    ani_check_cycle integer,
    ani_threshold integer,
    ani_limit_percent integer,
    ani_return_codes character varying(100),
    dnis_check_all boolean,
    dnis_ingress character varying(500),
    dnis_check_cycle integer,
    dnis_threshold integer,
    dnis_limit_percent integer,
    dnis_return_codes character varying(100),
    block integer,
    unblock integer,
    unblock_min integer,
    send_email integer,
    email_to integer,
    subject text,
    content text,
    ani_last_run_time timestamp with time zone,
    dnis_last_run_time timestamp with time zone
);


ALTER TABLE invalid_number_detection OWNER TO postgres;

--
-- Name: COLUMN invalid_number_detection.ani_check_cycle; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection.ani_check_cycle IS 'å¾ªçŽ¯çš„åˆ†é’Ÿ';


--
-- Name: COLUMN invalid_number_detection.ani_threshold; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection.ani_threshold IS 'æœ€å°çš„æ¬¡æ•°';


--
-- Name: COLUMN invalid_number_detection.ani_limit_percent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection.ani_limit_percent IS 'é”™è¯¯codeçš„ç™¾åˆ†æ¯”';


--
-- Name: COLUMN invalid_number_detection.dnis_check_cycle; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection.dnis_check_cycle IS 'å¾ªçŽ¯æ—¶é—´';


--
-- Name: COLUMN invalid_number_detection.dnis_threshold; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection.dnis_threshold IS 'æœ€å°æ¬¡æ•°';


--
-- Name: COLUMN invalid_number_detection.dnis_limit_percent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection.dnis_limit_percent IS 'æœ€å°ç™¾åˆ†æ¯”';


--
-- Name: COLUMN invalid_number_detection.block; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection.block IS 'æ˜¯å¦block';


--
-- Name: COLUMN invalid_number_detection.unblock; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection.unblock IS 'æ˜¯å¦unblock';


--
-- Name: COLUMN invalid_number_detection.unblock_min; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection.unblock_min IS 'unblockçš„æ—¶é—´';


--
-- Name: COLUMN invalid_number_detection.send_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection.send_email IS 'æ˜¯å¦å‘é‚®ä»¶';


--
-- Name: invalid_number_detection_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invalid_number_detection_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invalid_number_detection_id_seq OWNER TO postgres;

--
-- Name: invalid_number_detection_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invalid_number_detection_id_seq OWNED BY invalid_number_detection.id;


--
-- Name: invalid_number_detection_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invalid_number_detection_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    finished_time timestamp with time zone,
    code_type integer,
    ingress_id integer,
    total_num integer,
    invalid_num integer,
    detection_id integer
);


ALTER TABLE invalid_number_detection_log OWNER TO postgres;

--
-- Name: COLUMN invalid_number_detection_log.code_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection_log.code_type IS '1:ANI
2:DNIS';


--
-- Name: invalid_number_detection_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invalid_number_detection_log_detail (
    id integer NOT NULL,
    log_id integer,
    ingress_id integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    total_call integer,
    count404 integer,
    count503 integer,
    count200 integer,
    others_call integer,
    code_type integer,
    number character varying(100)
);


ALTER TABLE invalid_number_detection_log_detail OWNER TO postgres;

--
-- Name: COLUMN invalid_number_detection_log_detail.code_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invalid_number_detection_log_detail.code_type IS '1:ANI
2:DNIS';


--
-- Name: invalid_number_detection_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invalid_number_detection_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invalid_number_detection_log_detail_id_seq OWNER TO postgres;

--
-- Name: invalid_number_detection_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invalid_number_detection_log_detail_id_seq OWNED BY invalid_number_detection_log_detail.id;


--
-- Name: invalid_number_detection_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invalid_number_detection_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invalid_number_detection_log_id_seq OWNER TO postgres;

--
-- Name: invalid_number_detection_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invalid_number_detection_log_id_seq OWNED BY invalid_number_detection_log.id;


--
-- Name: invocie_item_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invocie_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invocie_item_id_seq OWNER TO postgres;

--
-- Name: invoice; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice (
    invoice_id integer NOT NULL,
    invoice_number character varying(20) NOT NULL,
    state integer DEFAULT 0 NOT NULL,
    type integer,
    client_id integer,
    invoice_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    invoice_start timestamp with time zone NOT NULL,
    invoice_end timestamp with time zone NOT NULL,
    total_amount numeric(30,5) DEFAULT 0 NOT NULL,
    paid boolean DEFAULT false NOT NULL,
    due_date date,
    pay_amount numeric(30,5) DEFAULT 0 NOT NULL,
    current_balance numeric(30,10) NOT NULL,
    total_minutes real,
    disputed integer DEFAULT 0,
    send_time timestamp with time zone,
    create_type integer DEFAULT 0,
    buy_total numeric(30,10),
    sell_total numeric(30,10),
    buy_minutes real,
    sell_minutes real,
    buy_service_charge numeric(30,10),
    sell_service_charge numeric(30,10),
    link_cdr character varying(50),
    credit_amount numeric(30,5) DEFAULT 0,
    pdf_path character varying(300),
    cdr_path character varying(300),
    lrn_numbers integer,
    lrn_rate numeric(30,10),
    lrn_cost numeric(30,10),
    disputed_amount numeric(30,10),
    credit_note numeric(30,10),
    invoice_zone character varying(10),
    reconcile_file_path character varying,
    reconcile_state integer DEFAULT 0,
    output_type integer DEFAULT 0,
    status integer,
    include_detail boolean DEFAULT true,
    generate_start_time timestamp with time zone,
    generate_copy_time timestamp with time zone,
    generate_stats_time timestamp with time zone,
    generate_end_time timestamp with time zone,
    invoice_jurisdictional_detail boolean DEFAULT true,
    previous_balance numeric(30,10),
    payment_credit numeric(30,10),
    finance_charge numeric(30,10),
    decurring_charge numeric(30,10),
    non_recurring_charge numeric(30,10),
    tax numeric(30,10),
    decimal_place integer DEFAULT 5,
    rate_value integer DEFAULT 0,
    scc_cost numeric(30,5),
    is_invoice_account_summary boolean DEFAULT false,
    new_balance numeric(30,10),
    is_show_daily_usage boolean DEFAULT false,
    scc_calls integer,
    scc_per real,
    invoice_include_payment boolean,
    scc_sec integer,
    is_short_duration_call_surcharge_detail boolean DEFAULT false,
    usage_detail_fields text,
    ingress_cdr_file character varying(255),
    egress_cdr_file character varying(255),
    current_charge numeric(30,10),
    invoice_log_id integer,
    invoice_use_balance_type integer DEFAULT 0,
    invoice_balance_time timestamp with time zone,
    total_calls integer DEFAULT 0,
    decimals_num integer,
    please_pay numeric(20,5),
    credit_remaining numeric(20,5),
    unlimited_credit_unlimited boolean DEFAULT false,
    payment_term character varying,
    is_show_total_trunk boolean DEFAULT false,
    is_show_detail_trunk boolean DEFAULT false,
    is_show_code_100 boolean DEFAULT false,
    is_show_code_name boolean DEFAULT false,
    is_show_country boolean DEFAULT false,
    is_show_by_date boolean DEFAULT false,
    is_send_as_link boolean DEFAULT false,
    cdr_link text,
    cdr_token text,
    api_requests integer DEFAULT 0,
    api_params text
);


ALTER TABLE invoice OWNER TO postgres;

--
-- Name: TABLE invoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE invoice IS 'å‘ç¥¨';


--
-- Name: COLUMN invoice.invoice_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.invoice_id IS 'ä¸»é”®';


--
-- Name: COLUMN invoice.invoice_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.invoice_number IS 'å‘ç¥¨å·ç ';


--
-- Name: COLUMN invoice.state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.state IS '-1:void
0:normal
1:verify
9:send';


--
-- Name: COLUMN invoice.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.type IS '0:sent(out--buy)
1:received(in--sell)
2:sent(all)
3:incoming ';


--
-- Name: COLUMN invoice.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN invoice.invoice_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.invoice_time IS 'ç”Ÿæˆæ—¶é—´';


--
-- Name: COLUMN invoice.invoice_start; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.invoice_start IS 'å¼€å§‹æ—¥æœŸ';


--
-- Name: COLUMN invoice.invoice_end; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.invoice_end IS 'æˆªæ­¢æ—¥æœŸ';


--
-- Name: COLUMN invoice.total_amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.total_amount IS 'å‘ç¥¨é‡‘é¢';


--
-- Name: COLUMN invoice.paid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.paid IS 'æ˜¯å¦ä»˜æ¸…';


--
-- Name: COLUMN invoice.due_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.due_date IS 'ä»˜æ¬¾æ—¥æœŸ ---è¿‡æœŸæ—¶é—´';


--
-- Name: COLUMN invoice.pay_amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.pay_amount IS 'è·¯ç”±ä¼™ä¼´çš„ä»˜æ¬¾é‡‘é¢';


--
-- Name: COLUMN invoice.current_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.current_balance IS 'å½“å‰ä½™é¢';


--
-- Name: COLUMN invoice.disputed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.disputed IS '0-Non-Disputed
1-Disputed
2-Dispute Resolved';


--
-- Name: COLUMN invoice.send_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.send_time IS 'å‘é€invoiceæ—¶é—´';


--
-- Name: COLUMN invoice.create_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.create_type IS '0-Auto-generated Invoice
1-Manual Invoice';


--
-- Name: COLUMN invoice.pdf_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.pdf_path IS 'pdfå­˜å‚¨è·¯å¾„';


--
-- Name: COLUMN invoice.cdr_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.cdr_path IS 'cdrå­˜å‚¨è·¯å¾„';


--
-- Name: COLUMN invoice.reconcile_state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.reconcile_state IS '0: æœ‰å¯æ¯”è¾ƒçš„æ–‡ä»¶
1: è¿›è¡Œä¸­
2: å·²ç»å®Œæˆ';


--
-- Name: COLUMN invoice.output_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.output_type IS '0 ------- pdf
1 ------- excel
2 ------- html';


--
-- Name: COLUMN invoice.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice.status IS '0--creating
1--zero cdr
2--done
-1--only support buy/sell';


--
-- Name: invoice_calls; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_calls (
    invoice_calls_id integer NOT NULL,
    calls_count integer,
    total_minutes real,
    avg_rate numeric(30,10),
    cost numeric(30,10),
    code_name character varying(100),
    invoice_no character varying(100),
    invoice_type integer,
    country character varying(100),
    effective_date character varying(100),
    contract_number character varying(20),
    inter_minutes real,
    intra_minutes real,
    inter_rate numeric(30,10),
    intra_rate numeric(30,10),
    inter_cost numeric(30,10),
    intra_cost numeric(30,10),
    trunk_name integer,
    prefix character varying(200)
);


ALTER TABLE invoice_calls OWNER TO postgres;

--
-- Name: invoice_calls_detail_by_trunk; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_calls_detail_by_trunk (
    resource_id integer,
    prefix character varying(50),
    calls integer,
    minutes real,
    amount numeric(30,10),
    invoice_no character varying(100)
);


ALTER TABLE invoice_calls_detail_by_trunk OWNER TO postgres;

--
-- Name: invoice_calls_invoice_calls_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_calls_invoice_calls_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_calls_invoice_calls_id_seq OWNER TO postgres;

--
-- Name: invoice_calls_invoice_calls_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_calls_invoice_calls_id_seq OWNED BY invoice_calls.invoice_calls_id;


--
-- Name: invoice_calls_total_by_trunk; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_calls_total_by_trunk (
    resource_id integer,
    prefix character varying(50),
    inter_calls integer,
    inter_minutes real,
    inter_acd real,
    inter_amount numeric(30,10),
    intra_calls integer,
    intra_minutes real,
    intra_acd real,
    intra_amount numeric(30,10),
    indeter_calls integer,
    indeter_minutes real,
    indeter_acd real,
    indeter_amount numeric(30,10),
    invoice_no character varying(100),
    amount numeric(30,10),
    no_call_6 integer
);


ALTER TABLE invoice_calls_total_by_trunk OWNER TO postgres;

--
-- Name: invoice_cdr_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_cdr_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    type integer,
    invoice_number character varying(255),
    carrier_name character varying(255)
);


ALTER TABLE invoice_cdr_log OWNER TO postgres;

--
-- Name: invoice_cdr_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_cdr_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_cdr_log_id_seq OWNER TO postgres;

--
-- Name: invoice_cdr_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_cdr_log_id_seq OWNED BY invoice_cdr_log.id;


--
-- Name: invoice_credit_note; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_credit_note (
    id integer NOT NULL,
    invoice_no character varying(20),
    credit_amount numeric(30,10),
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    note character varying(100)
);


ALTER TABLE invoice_credit_note OWNER TO postgres;

--
-- Name: invoice_credit_note_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_credit_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_credit_note_id_seq OWNER TO postgres;

--
-- Name: invoice_credit_note_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_credit_note_id_seq OWNED BY invoice_credit_note.id;


--
-- Name: invoice_daily_cost; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_daily_cost (
    id integer NOT NULL,
    invoice_no character varying(100),
    invoice_date timestamp with time zone,
    intra_mins real,
    inter_mins real,
    other_mins real,
    intra_cost numeric(30,10),
    inter_cost numeric(30,10),
    other_cost numeric(30,10)
);


ALTER TABLE invoice_daily_cost OWNER TO postgres;

--
-- Name: invoice_daily_cost_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_daily_cost_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_daily_cost_id_seq OWNER TO postgres;

--
-- Name: invoice_daily_cost_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_daily_cost_id_seq OWNED BY invoice_daily_cost.id;


--
-- Name: invoice_did; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_did (
    id integer NOT NULL,
    invoice_number character varying(50),
    did_rate real,
    did_total_count integer,
    did_total_cost real,
    did_plan character varying(100),
    channel_rate real,
    channel_total_count integer,
    channel_total_cost real
);


ALTER TABLE invoice_did OWNER TO postgres;

--
-- Name: invoice_did_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_did_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_did_id_seq OWNER TO postgres;

--
-- Name: invoice_did_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_did_id_seq OWNED BY invoice_did.id;


--
-- Name: invoice_email; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_email (
    id integer NOT NULL,
    invoice_no character varying(20),
    mail_content character varying(1000),
    send_time timestamp with time zone,
    pdf_file character varying(100),
    send_address character varying(100),
    mail_sub character varying(100)
);


ALTER TABLE invoice_email OWNER TO postgres;

--
-- Name: invoice_email_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_email_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_email_id_seq OWNER TO postgres;

--
-- Name: invoice_email_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_email_id_seq OWNED BY invoice_email.id;


--
-- Name: invoice_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_history (
    id integer NOT NULL,
    client_id integer NOT NULL,
    last_invoice_for date DEFAULT ('now'::text)::date,
    reminders_count integer DEFAULT 0,
    next_reminder_timestamp integer DEFAULT 0,
    invoice_filename character varying(500),
    start_time timestamp without time zone,
    end_time timestamp without time zone
);


ALTER TABLE invoice_history OWNER TO postgres;

--
-- Name: invoice_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_history_id_seq OWNER TO postgres;

--
-- Name: invoice_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_history_id_seq OWNED BY invoice_history.id;


--
-- Name: invoice_invoice_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_invoice_id_seq OWNER TO postgres;

--
-- Name: invoice_invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_invoice_id_seq OWNED BY invoice.invoice_id;


--
-- Name: invoice_item; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_item (
    id integer DEFAULT nextval('invocie_item_id_seq'::regclass) NOT NULL,
    invoice_id integer,
    item character varying(20),
    price numeric(20,10)
);


ALTER TABLE invoice_item OWNER TO postgres;

--
-- Name: invoice_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    status integer DEFAULT 0,
    cnt integer DEFAULT 1
);


ALTER TABLE invoice_log OWNER TO postgres;

--
-- Name: COLUMN invoice_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice_log.status IS '0 begin
1 progress
2 done
3 error';


--
-- Name: COLUMN invoice_log.cnt; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN invoice_log.cnt IS 'invoice æ€»æ•°
';


--
-- Name: invoice_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_log_id_seq OWNER TO postgres;

--
-- Name: invoice_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_log_id_seq OWNED BY invoice_log.id;


--
-- Name: invoice_payment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_payment (
    id integer NOT NULL,
    invoice_no character varying(50),
    payment_time timestamp with time zone,
    payment_amount numeric(30,10)
);


ALTER TABLE invoice_payment OWNER TO postgres;

--
-- Name: invoice_payment_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_payment_id_seq OWNER TO postgres;

--
-- Name: invoice_payment_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_payment_id_seq OWNED BY invoice_payment.id;


--
-- Name: invoice_reconcile; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_reconcile (
    id integer NOT NULL,
    code prefix_range,
    minute numeric,
    cost numeric,
    sys_minute numeric,
    sys_cost numeric,
    minute_diff_amt numeric,
    minute_diff_per numeric,
    cost_diff_amt numeric,
    cost_diff_per numeric,
    invoice_id bigint
);


ALTER TABLE invoice_reconcile OWNER TO postgres;

--
-- Name: invoice_reconcile_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_reconcile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_reconcile_id_seq OWNER TO postgres;

--
-- Name: invoice_reconcile_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_reconcile_id_seq OWNED BY invoice_reconcile.id;


--
-- Name: invoice_service_charge; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_service_charge (
    invoice_service_charge_id integer NOT NULL,
    invoice_no character varying(100),
    invoice_type integer,
    rate numeric(30,10),
    less_rate_minutes integer,
    greater_rate_minutes integer,
    less_rate_usage_fee numeric(30,10),
    less_rate_charges numeric(30,10),
    greater_rate_usage_fee numeric(30,10),
    greater_rate_charges numeric(30,10),
    greater_max_rate_minutes integer,
    greater_max_rate_usage_fee numeric(30,10),
    greater_max_rate_charges numeric(30,10),
    max_rate numeric(30,10)
);


ALTER TABLE invoice_service_charge OWNER TO postgres;

--
-- Name: invoice_service_charge_invoice_service_charge_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE invoice_service_charge_invoice_service_charge_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE invoice_service_charge_invoice_service_charge_id_seq OWNER TO postgres;

--
-- Name: invoice_service_charge_invoice_service_charge_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE invoice_service_charge_invoice_service_charge_id_seq OWNED BY invoice_service_charge.invoice_service_charge_id;


--
-- Name: invoice_show_code_100; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_show_code_100 (
    code character varying(100),
    calls integer,
    minutes real,
    amount numeric(30,10),
    invoice_no character varying(100)
);


ALTER TABLE invoice_show_code_100 OWNER TO postgres;

--
-- Name: invoice_show_code_name; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_show_code_name (
    code_name character varying(100),
    calls integer,
    minutes real,
    amount numeric(30,10),
    invoice_no character varying(100)
);


ALTER TABLE invoice_show_code_name OWNER TO postgres;

--
-- Name: invoice_show_country; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_show_country (
    country character varying(100),
    calls integer,
    minutes real,
    amount numeric(30,10),
    invoice_no character varying(100)
);


ALTER TABLE invoice_show_country OWNER TO postgres;

--
-- Name: invoice_show_date; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE invoice_show_date (
    time_day character varying(50),
    calls integer,
    minutes real,
    amount numeric(30,10),
    invoice_no character varying(100)
);


ALTER TABLE invoice_show_date OWNER TO postgres;

--
-- Name: ip_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ip_info (
    "time" character varying(100),
    ip_id character varying(100),
    value character varying(100),
    direction character varying(100),
    ip character varying(100)
);


ALTER TABLE ip_info OWNER TO postgres;

--
-- Name: TABLE ip_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ip_info IS 'ip monitor';


--
-- Name: COLUMN ip_info."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_info."time" IS 'æ—¶é—´';


--
-- Name: COLUMN ip_info.ip_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_info.ip_id IS 'ip';


--
-- Name: COLUMN ip_info.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_info.value IS 'é€šè¯æ•°';


--
-- Name: COLUMN ip_info.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_info.direction IS 'ingress,egress';


--
-- Name: COLUMN ip_info.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_info.ip IS 'æœåŠ¡å™¨åœ°å€';


--
-- Name: ip_modif_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ip_modif_log (
    modify integer,
    detail character(100),
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    trunk_id integer,
    id integer NOT NULL,
    email character varying(100),
    old character varying(100),
    new character varying(100)
);


ALTER TABLE ip_modif_log OWNER TO postgres;

--
-- Name: TABLE ip_modif_log; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ip_modif_log IS 'ipçš„å¢žåˆ æ”¹çš„ è®°å½•';


--
-- Name: COLUMN ip_modif_log.modify; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_modif_log.modify IS '0-- ä¿®æ”¹
1-- add
2-- delete';


--
-- Name: COLUMN ip_modif_log.detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_modif_log.detail IS 'addã€deleteä¸ºæ‰€æ”¹ip
modify ä¸º oldip=ã€‹newip
';


--
-- Name: COLUMN ip_modif_log.update_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_modif_log.update_at IS 'ä¿®æ”¹æ—¶é—´';


--
-- Name: COLUMN ip_modif_log.update_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_modif_log.update_by IS 'æ“ä½œäºº';


--
-- Name: COLUMN ip_modif_log.old; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_modif_log.old IS 'old values';


--
-- Name: COLUMN ip_modif_log.new; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ip_modif_log.new IS 'new values';


--
-- Name: ip_modif_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ip_modif_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ip_modif_log_id_seq OWNER TO postgres;

--
-- Name: ip_modif_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ip_modif_log_id_seq OWNED BY ip_modif_log.id;


--
-- Name: jurisdiction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE jurisdiction_id_seq
    START WITH 40
    INCREMENT BY 1
    MINVALUE 40
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jurisdiction_id_seq OWNER TO postgres;

--
-- Name: jurisdiction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE jurisdiction (
    id integer DEFAULT nextval('jurisdiction_id_seq'::regclass) NOT NULL,
    alias character varying(40),
    name character varying(100),
    jurisdiction_country_id integer
);


ALTER TABLE jurisdiction OWNER TO postgres;

--
-- Name: TABLE jurisdiction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE jurisdiction IS 'è®¡è´¹åŒºåŸŸç®¡ç†';


--
-- Name: COLUMN jurisdiction.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction.id IS 'ä¸»é”®';


--
-- Name: COLUMN jurisdiction.alias; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction.alias IS 'åˆ«å';


--
-- Name: COLUMN jurisdiction.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction.name IS 'åç§°';


--
-- Name: jurisdiction_country; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE jurisdiction_country (
    id integer NOT NULL,
    name character varying(100)
);


ALTER TABLE jurisdiction_country OWNER TO postgres;

--
-- Name: jurisdiction_country_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE jurisdiction_country_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jurisdiction_country_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_country_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE jurisdiction_country_id_seq OWNED BY jurisdiction_country.id;


--
-- Name: jurisdiction_id_seq1; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE jurisdiction_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jurisdiction_id_seq1 OWNER TO postgres;

--
-- Name: jurisdiction_id_seq1; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE jurisdiction_id_seq1 OWNED BY jurisdiction.id;


--
-- Name: jurisdiction_prefix_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE jurisdiction_prefix_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jurisdiction_prefix_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_prefix; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE jurisdiction_prefix (
    id integer DEFAULT nextval('jurisdiction_prefix_id_seq'::regclass) NOT NULL,
    alias character varying(40),
    prefix prefix_range NOT NULL,
    jurisdiction_id integer,
    jurisdiction_country_id integer,
    jurisdiction_name character varying(100),
    jurisdiction_country_name character varying(100),
    ocn character varying(10),
    lata character varying(10),
    block_id character(1),
    effective_date timestamp with time zone
);


ALTER TABLE jurisdiction_prefix OWNER TO postgres;

--
-- Name: TABLE jurisdiction_prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE jurisdiction_prefix IS 'è®¡è´¹åŒºåŸŸå‰ç¼€';


--
-- Name: COLUMN jurisdiction_prefix.alias; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_prefix.alias IS 'åˆ«å';


--
-- Name: COLUMN jurisdiction_prefix.prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_prefix.prefix IS 'å‰ç¼€';


--
-- Name: COLUMN jurisdiction_prefix.jurisdiction_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_prefix.jurisdiction_id IS 'æ‰€å±žè®¡è´¹åŒºåŸŸ';


--
-- Name: COLUMN jurisdiction_prefix.jurisdiction_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_prefix.jurisdiction_name IS 'åŒºåŸŸ';


--
-- Name: COLUMN jurisdiction_prefix.jurisdiction_country_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_prefix.jurisdiction_country_name IS 'guojia ';


--
-- Name: jurisdiction_prefix_id_seq1; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE jurisdiction_prefix_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jurisdiction_prefix_id_seq1 OWNER TO postgres;

--
-- Name: jurisdiction_prefix_id_seq1; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE jurisdiction_prefix_id_seq1 OWNED BY jurisdiction_prefix.id;


--
-- Name: jurisdiction_prefix_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE jurisdiction_prefix_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jurisdiction_prefix_record_record_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_prefix_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE jurisdiction_prefix_record (
    id integer,
    alias character varying(40),
    prefix prefix_range,
    jurisdiction_id integer,
    jurisdiction_country_id integer,
    jurisdiction_name character varying(100),
    jurisdiction_country_name character varying(100),
    ocn character varying(10),
    lata character varying(10),
    block_id character(1),
    effective_date timestamp with time zone,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('jurisdiction_prefix_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE jurisdiction_prefix_record OWNER TO postgres;

--
-- Name: jurisdiction_prefix_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE jurisdiction_prefix_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jurisdiction_prefix_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_prefix_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE jurisdiction_prefix_record_tmp (
    id integer,
    alias character varying(40),
    prefix prefix_range,
    jurisdiction_id integer,
    jurisdiction_country_id integer,
    jurisdiction_name character varying(100),
    jurisdiction_country_name character varying(100),
    ocn character varying(10),
    lata character varying(10),
    block_id character(1),
    effective_date timestamp with time zone,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('jurisdiction_prefix_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE jurisdiction_prefix_record_tmp OWNER TO postgres;

--
-- Name: jurisdiction_update_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE jurisdiction_update_history (
    id integer NOT NULL,
    task_id integer NOT NULL,
    prefix_count integer NOT NULL,
    status smallint DEFAULT 0 NOT NULL,
    create_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE jurisdiction_update_history OWNER TO postgres;

--
-- Name: COLUMN jurisdiction_update_history.task_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_update_history.task_id IS 'Jurisdiction upload task ID of the jurisdiction_upload_task table';


--
-- Name: COLUMN jurisdiction_update_history.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_update_history.status IS '0 - Successfully; 1 - Failed';


--
-- Name: jurisdiction_update_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE jurisdiction_update_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jurisdiction_update_history_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_update_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE jurisdiction_update_history_id_seq OWNED BY jurisdiction_update_history.id;


--
-- Name: jurisdiction_update_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE jurisdiction_update_log (
    id integer NOT NULL,
    tigger_time timestamp with time zone,
    is_new_file boolean,
    import_log_id integer,
    file_update_time_flg character varying(10),
    status integer
);


ALTER TABLE jurisdiction_update_log OWNER TO postgres;

--
-- Name: COLUMN jurisdiction_update_log.tigger_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_update_log.tigger_time IS 'è„šæœ¬æ‰§è¡Œæ—¶é—´';


--
-- Name: COLUMN jurisdiction_update_log.import_log_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_update_log.import_log_id IS 'imports_export_log è¡¨çš„ID';


--
-- Name: COLUMN jurisdiction_update_log.file_update_time_flg; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_update_log.file_update_time_flg IS 'ftpæœåŠ¡å™¨ä¸Šçš„æ–‡ä»¶çš„ä¿®æ”¹æ—¶é—´æ ‡å¿—egï¼šApr1408:57';


--
-- Name: COLUMN jurisdiction_update_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN jurisdiction_update_log.status IS '1 succeed
-1 connect failed
-2 login failed
-3 Insufficient permissions
-4 file is not found
-5 import failed
-6 import log insert failed';


--
-- Name: jurisdiction_update_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE jurisdiction_update_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jurisdiction_update_log_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_update_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE jurisdiction_update_log_id_seq OWNED BY jurisdiction_update_log.id;


--
-- Name: jurisdiction_upload_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE jurisdiction_upload_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE jurisdiction_upload_id_seq OWNER TO postgres;

--
-- Name: kill_pg_sql_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE kill_pg_sql_log (
    id integer NOT NULL,
    query text,
    start_time timestamp with time zone,
    kill_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE kill_pg_sql_log OWNER TO postgres;

--
-- Name: COLUMN kill_pg_sql_log.query; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN kill_pg_sql_log.query IS 'killæŽ‰çš„sql';


--
-- Name: COLUMN kill_pg_sql_log.start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN kill_pg_sql_log.start_time IS 'query å¼€å§‹æ‰§è¡Œçš„æ—¶å€™';


--
-- Name: COLUMN kill_pg_sql_log.kill_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN kill_pg_sql_log.kill_time IS 'kill æŽ‰çš„æ—¶å€™';


--
-- Name: kill_pg_sql_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE kill_pg_sql_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE kill_pg_sql_log_id_seq OWNER TO postgres;

--
-- Name: kill_pg_sql_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE kill_pg_sql_log_id_seq OWNED BY kill_pg_sql_log.id;


--
-- Name: lcr_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lcr_record (
    id integer NOT NULL,
    type character varying(50) DEFAULT 0 NOT NULL,
    file character varying(300),
    rate_tables character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status smallint DEFAULT 0
);


ALTER TABLE lcr_record OWNER TO postgres;

--
-- Name: lcr_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lcr_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lcr_record_id_seq OWNER TO postgres;

--
-- Name: lcr_record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE lcr_record_id_seq OWNED BY lcr_record.id;


--
-- Name: lcr_reports; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lcr_reports (
    id integer NOT NULL,
    start_time timestamp without time zone,
    end_time timestamp without time zone,
    status integer DEFAULT 0,
    file_path character varying(200)
);


ALTER TABLE lcr_reports OWNER TO postgres;

--
-- Name: lcr_reports_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lcr_reports_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lcr_reports_id_seq OWNER TO postgres;

--
-- Name: lcr_reports_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE lcr_reports_id_seq OWNED BY lcr_reports.id;


--
-- Name: license_modification_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE license_modification_log (
    id integer NOT NULL,
    modify_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    modify_by character(200),
    old_value integer,
    new_value integer,
    type integer,
    switch_name character(200)
);


ALTER TABLE license_modification_log OWNER TO postgres;

--
-- Name: COLUMN license_modification_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN license_modification_log.type IS '1 ä¸º call_limit
2 ä¸º cps_limit';


--
-- Name: COLUMN license_modification_log.switch_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN license_modification_log.switch_name IS 'ä¿®æ”¹çš„switch_name';


--
-- Name: license_modification_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE license_modification_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE license_modification_log_id_seq OWNER TO postgres;

--
-- Name: license_modification_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE license_modification_log_id_seq OWNED BY license_modification_log.id;


--
-- Name: lnp_request; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lnp_request (
    id integer NOT NULL,
    user_id integer,
    request_date timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status integer DEFAULT 0,
    count integer DEFAULT 0 NOT NULL,
    type integer DEFAULT 0,
    file text
);


ALTER TABLE lnp_request OWNER TO postgres;

--
-- Name: lnp_request_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lnp_request_detail (
    id integer NOT NULL,
    request_id integer,
    number character varying(255) NOT NULL,
    status integer DEFAULT 0 NOT NULL
);


ALTER TABLE lnp_request_detail OWNER TO postgres;

--
-- Name: lnp_request_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lnp_request_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lnp_request_detail_id_seq OWNER TO postgres;

--
-- Name: lnp_request_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE lnp_request_detail_id_seq OWNED BY lnp_request_detail.id;


--
-- Name: lnp_request_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lnp_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lnp_request_id_seq OWNER TO postgres;

--
-- Name: lnp_request_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE lnp_request_id_seq OWNED BY lnp_request.id;


--
-- Name: logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE logs (
    user_id integer NOT NULL,
    ip character varying(100),
    act_type character varying(100),
    act_info character varying(1000),
    "time" timestamp with time zone,
    model character varying(100)
);


ALTER TABLE logs OWNER TO postgres;

--
-- Name: loop_detection; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE loop_detection (
    id integer NOT NULL,
    rule_name character varying,
    number integer,
    counter_time integer,
    block_time integer
);


ALTER TABLE loop_detection OWNER TO postgres;

--
-- Name: loop_detection_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE loop_detection_detail (
    loop_detection_id integer,
    resource_id integer,
    id integer NOT NULL
);


ALTER TABLE loop_detection_detail OWNER TO postgres;

--
-- Name: loop_detection_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE loop_detection_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE loop_detection_detail_id_seq OWNER TO postgres;

--
-- Name: loop_detection_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE loop_detection_detail_id_seq OWNED BY loop_detection_detail.id;


--
-- Name: loop_detection_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE loop_detection_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE loop_detection_id_seq OWNER TO postgres;

--
-- Name: loop_detection_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE loop_detection_id_seq OWNED BY loop_detection.id;


--
-- Name: lrn; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lrn (
    lrn_id integer NOT NULL,
    ip1 ip4r,
    port1 integer,
    ip2 ip4r,
    port2 integer,
    timeout1 integer,
    timeout2 integer
);


ALTER TABLE lrn OWNER TO postgres;

--
-- Name: TABLE lrn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE lrn IS 'lrn';


--
-- Name: COLUMN lrn.lrn_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn.lrn_id IS 'ä¸»é”®';


--
-- Name: COLUMN lrn.ip1; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn.ip1 IS 'ip';


--
-- Name: COLUMN lrn.port1; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn.port1 IS 'port';


--
-- Name: COLUMN lrn.ip2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn.ip2 IS 'ip';


--
-- Name: COLUMN lrn.port2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn.port2 IS 'port';


--
-- Name: COLUMN lrn.timeout1; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn.timeout1 IS 'timeout';


--
-- Name: COLUMN lrn.timeout2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn.timeout2 IS 'timeout';


--
-- Name: lrn_groups; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lrn_groups (
    id integer NOT NULL,
    rule integer,
    name character varying(100),
    active integer DEFAULT 1
);


ALTER TABLE lrn_groups OWNER TO postgres;

--
-- Name: TABLE lrn_groups; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE lrn_groups IS 'ä¸€ä¸ªgroupå¯ä»¥æœ‰å¤šä¸ªitemï¼Œéƒ½åœ¨lrn_itemsè¡¨å±•å¼€ï¼Œä¸€å¯¹å¤šã€‚';


--
-- Name: COLUMN lrn_groups.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_groups.id IS 'group idé€’å¢ž';


--
-- Name: COLUMN lrn_groups.rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_groups.rule IS '0 -- tobdown
1 -- roundrobin
2 -- minpdd

ä¸€ä¸ªç»„å†…è®¿é—®lrnç­–ç•¥ï¼Œç»„ä¹‹é—´æ˜¯tobdownã€‚';


--
-- Name: COLUMN lrn_groups.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_groups.name IS 'ç»„çš„åå­—';


--
-- Name: COLUMN lrn_groups.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_groups.active IS '0 -- false
1 -- true

groupçš„æš‚æ—¶æ€§çš„å¼€å…³ã€‚';


--
-- Name: lrn_groups_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lrn_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lrn_groups_id_seq OWNER TO postgres;

--
-- Name: lrn_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE lrn_groups_id_seq OWNED BY lrn_groups.id;


--
-- Name: lrn_groups_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lrn_groups_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lrn_groups_record_record_id_seq OWNER TO postgres;

--
-- Name: lrn_groups_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lrn_groups_record (
    id integer,
    rule integer,
    name character varying(100),
    active integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('lrn_groups_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE lrn_groups_record OWNER TO postgres;

--
-- Name: lrn_groups_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lrn_groups_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lrn_groups_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: lrn_groups_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lrn_groups_record_tmp (
    id integer,
    rule integer,
    name character varying(100),
    active integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('lrn_groups_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE lrn_groups_record_tmp OWNER TO postgres;

--
-- Name: lrn_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lrn_items (
    id integer NOT NULL,
    group_id integer,
    ip ip4,
    port integer,
    timeout integer,
    retry integer,
    dynamic_timeout integer,
    filter_timeout integer,
    option integer,
    option_interval integer,
    domian_name character varying(100),
    active integer DEFAULT 1
);


ALTER TABLE lrn_items OWNER TO postgres;

--
-- Name: TABLE lrn_items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE lrn_items IS 'ä¸Žlrn_groupè¡¨å…³è”ï¼Œä¸€ä¸ªlrn_groupå¯ä»¥å¯¹åº”å¤šä¸ªlrn_itme';


--
-- Name: COLUMN lrn_items.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.id IS 'è‡ªå¢žçš„id';


--
-- Name: COLUMN lrn_items.group_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.group_id IS 'å…³è”lrn_groupsè¡¨id';


--
-- Name: COLUMN lrn_items.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.ip IS 'lrnæœåŠ¡å™¨ip';


--
-- Name: COLUMN lrn_items.port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.port IS 'lrnæœåŠ¡å™¨ç«¯å£';


--
-- Name: COLUMN lrn_items.timeout; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.timeout IS 'ç­‰å¾…lrnæœåŠ¡å™¨å›žåº”æ—¶é—´ï¼Œæ¯«ç§’ä¸ºå•ä½ï¼Œä¹Ÿå¯ä»¥æ ¹æ®æ­¤è®¾ç½®è¿‡æ»¤ç½‘ç»œå»¶è¿Ÿé«˜çš„lrnæœåŠ¡å™¨ã€‚';


--
-- Name: COLUMN lrn_items.retry; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.retry IS 'ç­‰å¾…lrnæœåŠ¡å™¨è¶…æ—¶ï¼Œæœ€å¤šé‡å‘æ¬¡æ•°ã€‚';


--
-- Name: COLUMN lrn_items.dynamic_timeout; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.dynamic_timeout IS '0 -- false
1 -- ture

æ ¹æ®å®žé™…çŽ¯å¢ƒè®¾ç½®ç­‰å¾…lrnæœåŠ¡å™¨è¶…æ—¶æ—¶é•¿ã€‚
ç½‘ç»œè¶…æ—¶ä»Žoptionå‘å‡ºåˆ°å¾—åˆ°200çš„æ—¶é—´å·®ã€‚';


--
-- Name: COLUMN lrn_items.filter_timeout; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.filter_timeout IS '0 -- false
1 -- true

å®žé™…ç½‘ç»œå»¶è¿Ÿå¤§äºŽtimeoutå€¼æ—¶å¿½ç•¥æ­¤lrnæœåŠ¡å™¨ï¼Œé¿å…è¶…æ—¶ï¼Œå¦‚æžœç½‘ç»œå»¶è¿Ÿå›žå¤åˆ°timeoutï¼Œå¯ä»¥è®¿é—®æ­¤lrnæœåŠ¡å™¨ã€‚';


--
-- Name: COLUMN lrn_items.option; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.option IS '0 -- false
1 -- true

æ˜¯å¦optionçš„å¼€å…³ã€‚';


--
-- Name: COLUMN lrn_items.option_interval; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.option_interval IS 'optionåˆ°lrnæœåŠ¡å™¨çš„é—´éš”ï¼Œç§’ä½å•ä½ã€‚æœ€å°å€¼ä¸º1ç§’ï¼Œ 0ç§’å½“åš3ç§’ã€‚';


--
-- Name: COLUMN lrn_items.domian_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.domian_name IS 'lrnæœåŠ¡å™¨åŸŸå';


--
-- Name: COLUMN lrn_items.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items.active IS '0 -- false
1 -- true

æ­¤itemæš‚æ—¶å…³é—­è¿˜æ˜¯å¼€å¯ã€‚';


--
-- Name: lrn_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lrn_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lrn_items_id_seq OWNER TO postgres;

--
-- Name: lrn_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE lrn_items_id_seq OWNED BY lrn_items.id;


--
-- Name: lrn_items_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lrn_items_logs (
    id integer NOT NULL,
    group_id integer,
    item_id integer,
    state integer,
    pdd integer,
    "time" character varying(100)
);


ALTER TABLE lrn_items_logs OWNER TO postgres;

--
-- Name: TABLE lrn_items_logs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE lrn_items_logs IS 'è®°å½•lrnæœåŠ¡å™¨çŠ¶æ€ï¼Œä¾‹å¦‚æ˜¯å¦åœ¨è¿è¡Œï¼Œç½‘ç»œå»¶è¿Ÿå¤šå°‘ç­‰';


--
-- Name: COLUMN lrn_items_logs.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items_logs.id IS 'è‡ªå¢žid';


--
-- Name: COLUMN lrn_items_logs.group_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items_logs.group_id IS 'ç»„id';


--
-- Name: COLUMN lrn_items_logs.state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items_logs.state IS 'lrnæœåŠ¡å™¨æ˜¯å¦å¯ç”¨çš„æ ‡å¿—

0 -- false (off line)
1 -- true (on line)';


--
-- Name: COLUMN lrn_items_logs.pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items_logs.pdd IS 'æŸä¸ªæ—¶é—´ç‚¹çš„pddï¼Œæ¯«ç§’å•ä½ã€‚';


--
-- Name: COLUMN lrn_items_logs."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN lrn_items_logs."time" IS 'å‘optionæ—¶é—´';


--
-- Name: lrn_items_logs_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lrn_items_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lrn_items_logs_id_seq OWNER TO postgres;

--
-- Name: lrn_items_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE lrn_items_logs_id_seq OWNED BY lrn_items_logs.id;


--
-- Name: lrn_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lrn_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lrn_items_record_record_id_seq OWNER TO postgres;

--
-- Name: lrn_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lrn_items_record (
    id integer,
    group_id integer,
    ip ip4,
    port integer,
    timeout integer,
    retry integer,
    dynamic_timeout integer,
    filter_timeout integer,
    option integer,
    option_interval integer,
    domian_name character varying(100),
    active integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('lrn_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE lrn_items_record OWNER TO postgres;

--
-- Name: lrn_items_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lrn_items_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lrn_items_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: lrn_items_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lrn_items_record_tmp (
    id integer,
    group_id integer,
    ip ip4,
    port integer,
    timeout integer,
    retry integer,
    dynamic_timeout integer,
    filter_timeout integer,
    option integer,
    option_interval integer,
    domian_name character varying(100),
    active integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('lrn_items_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE lrn_items_record_tmp OWNER TO postgres;

--
-- Name: lrn_lrn_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lrn_lrn_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lrn_lrn_id_seq OWNER TO postgres;

--
-- Name: lrn_lrn_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE lrn_lrn_id_seq OWNED BY lrn.lrn_id;


--
-- Name: lrn_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lrn_report (
    report_time timestamp with time zone,
    ingress_id integer,
    total_count integer,
    client_count integer,
    lrn_server_count integer,
    cache_count integer,
    lrn_same integer,
    lrn_no_response integer,
    lnp_charge real
);


ALTER TABLE lrn_report OWNER TO postgres;

--
-- Name: lrn_servers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE lrn_servers (
    id integer NOT NULL,
    ip ip4r,
    port integer
);


ALTER TABLE lrn_servers OWNER TO postgres;

--
-- Name: lrn_servers_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE lrn_servers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE lrn_servers_id_seq OWNER TO postgres;

--
-- Name: lrn_servers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE lrn_servers_id_seq OWNED BY lrn_servers.id;


--
-- Name: mail_cdr_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE mail_cdr_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    cdr_counts integer,
    user_id integer,
    finish_time timestamp with time zone,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    file_counts integer,
    mail_content text,
    mail_subject character varying(500),
    status integer
);


ALTER TABLE mail_cdr_log OWNER TO postgres;

--
-- Name: COLUMN mail_cdr_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_cdr_log.status IS '1-success
-1-open file error
-2-copy cdr error
-3-send mail error';


--
-- Name: mail_cdr_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE mail_cdr_log_detail (
    id integer NOT NULL,
    mail_cdr_log_id integer,
    "order" integer,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    file_size integer,
    filename character varying(255)
);


ALTER TABLE mail_cdr_log_detail OWNER TO postgres;

--
-- Name: mail_cdr_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE mail_cdr_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mail_cdr_log_detail_id_seq OWNER TO postgres;

--
-- Name: mail_cdr_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE mail_cdr_log_detail_id_seq OWNED BY mail_cdr_log_detail.id;


--
-- Name: mail_cdr_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE mail_cdr_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mail_cdr_log_id_seq OWNER TO postgres;

--
-- Name: mail_cdr_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE mail_cdr_log_id_seq OWNED BY mail_cdr_log.id;


--
-- Name: mail_tmplate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE mail_tmplate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mail_tmplate_id_seq OWNER TO postgres;

--
-- Name: mail_tmplate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE mail_tmplate (
    id integer DEFAULT nextval('mail_tmplate_id_seq'::regclass) NOT NULL,
    invoice_from text,
    invoice_to text,
    invoice_subject text,
    invoice_content text,
    payment_from text,
    payment_to text,
    payment_subject text,
    payment_content text,
    lowbalance_subject text,
    lowbalance_content text,
    noc_email_subject text,
    noc_email_content text,
    carrier_email_subject text,
    carrier_email_content text,
    alert_email_subject text,
    alert_email_content text,
    carrier_invoice_subject text DEFAULT 'Invoice form {start_Date} â€“ {end_date}'::text,
    carrier_invoice_content text DEFAULT 'Dear {carrier_name},
	  This is invoice {invoice_number} for {start_date} â€“ {end_date}.
	Please remit your due balance within the terms of your contractual
	agreement to avoid disconnection of service.
--
Autogenerated by billing system'::text,
    auto_summary_subject character varying,
    auto_summary_content text,
    auto_balance_subject character varying,
    auto_balance_content text,
    auto_delivery_subject character varying(200),
    auto_delivery_content text,
    auto_cdr_subject character varying(255),
    auto_cdr_content text,
    no_route_available_alert_email_subject character varying(225),
    no_route_available_alert_email_content text,
    target_match_alert_email_subject character varying(225),
    target_match_alert_email_content text,
    rate_watch_alert_email_subject character varying(225),
    rate_watch_alert_email_content text,
    route_update_alert_email_subject character varying(225),
    route_update_alert_email_content text,
    rate_update_alert_email_subject character varying(225),
    rate_update_alert_email_content text,
    low_balance_alert_email_subject character varying(225),
    low_balance_alert_email_content text,
    new_invoice_posted_mail_alert_email_subject character varying(225),
    new_invoice_posted_mail_alert_email_content text,
    payment_sent_subject character varying(255),
    payment_sent_content text,
    payment_received_subject character varying(255),
    payment_received_content text,
    trouble_ticket_subject character varying(255),
    trouble_ticket_content text,
    send_cdr_subject character varying(255),
    send_cdr_content text,
    select_route_up_email_subject text,
    select_route_up_email_content text,
    exchange_auto_summary_subject text,
    exchange_auto_summary_content text,
    finance_alert_subject text,
    finance_alert_content text,
    buy_qos_alert_subject text,
    buy_qos_alert_content text,
    sell_qos_alert_subject text,
    sell_qos_alert_content text,
    lowbalance_from character varying,
    noc_email_from character varying,
    carrier_email_from character varying,
    alert_email_from character varying,
    auto_summary_from character varying,
    auto_balance_from character varying,
    auto_cdr_from character varying,
    payment_sent_from character varying,
    payment_received_from character varying,
    trouble_ticket_from character varying,
    send_cdr_from character varying,
    no_route_available_alert_email_from character varying,
    target_match_alert_email_from character varying,
    rate_watch_alert_email_from character varying,
    route_update_alert_email_from character varying,
    rate_update_alert_email_from character varying,
    low_balance_alert_email_from character varying,
    select_route_up_email_from character varying,
    new_invoice_posted_mail_alert_email_from character varying,
    exchange_auto_summary_from character varying,
    finance_alert_from character varying,
    buy_qos_alert_from character varying,
    sell_qos_alert_from character varying,
    rate_mail_success_subject text,
    rate_mail_success_content text,
    rate_mail_success_from character varying,
    rate_mail_fail_subject text,
    rate_mail_fail_content text,
    rate_mail_fail_from character varying,
    invoice_cc text,
    payment_from_cc text,
    lowbalance_cc text,
    alert_email_cc text,
    auto_summary_cc text,
    auto_balance_cc text,
    auto_cdr_cc text,
    send_cdr_cc text,
    payment_sent_cc text,
    payment_received_cc text,
    rate_from character varying,
    rate_subject character varying,
    rate_content text,
    dialer_detection_subject character varying,
    dialer_detection_content text,
    retrieve_password_subject text,
    retrieve_password_content text,
    retrieve_password_from text,
    registration_subject text,
    registration_content text,
    registration_from text,
    registration_success text,
    registration_failure text,
    trunk_change_from character varying(50),
    trunk_change_subject character varying(200),
    trunk_change_content text,
    fraud_detection_from character varying(50),
    fraud_detection_subject text,
    fraud_detection_content text,
    welcom_from text,
    welcom_subject text,
    welcom_content text,
    download_rate_notice_from character varying(50),
    download_rate_notice_subject text,
    download_rate_notice_content text,
    no_download_rate_from text,
    no_download_rate_subject text,
    no_download_rate_content text,
    download_cdr_from text,
    download_cdr_subject text,
    download_cdr_content text,
    download_cdr_cc text,
    vendor_invoice_dispute_from text,
    vendor_invoice_dispute_subject text,
    vendor_invoice_dispute_content text,
    vendor_invoice_dispute_cc text,
    trunk_interop_from text,
    trunk_interop_subject text,
    trunk_interop_content text,
    trunk_interop_cc text,
    regletter_from text,
    regletter_subject text,
    regletter_content text,
    regletter_cc text,
    paymresvd_from text,
    paymresvd_subject text,
    paymresvd_content text,
    paymresvd_cc text,
    regconf_from text,
    regconf_subject text,
    regconf_content text,
    regconf_cc text,
    daily_payment_from character varying,
    daily_payment_subject character varying,
    daily_payment_content text,
    daily_payment_cc text,
    zerobalance_content text,
    zerobalance_from text,
    zerobalance_cc text,
    zerobalance_subject text,
    trunk_change_cc text,
    did_order_from character varying,
    did_order_cc character varying,
    did_order_subject text,
    did_order_content text,
    pending_trunk_content text,
    pending_trunk_cc text,
    pending_trunk_subject character varying,
    pending_trunk_from character varying,
    did_order_c character varying,
    welcom_cc text,
    retrieve_password_cc text,
    hour_from_48 text,
    hour_subject_48 text,
    hour_content_48 text,
    hour_cc_48 text,
    hour_from_24 text,
    hour_subject_24 text,
    hour_content_24 text,
    hour_cc_24 text,
    hour_from_3 text,
    hour_subject_3 text,
    hour_content_3 text,
    hour_cc_3 text,
    hour_from_1 text,
    hour_subject_1 text,
    hour_content_1 text,
    hour_cc_1 text
);


ALTER TABLE mail_tmplate OWNER TO postgres;

--
-- Name: TABLE mail_tmplate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE mail_tmplate IS 'é‚®ä»¶æ¨¡æ¿';


--
-- Name: COLUMN mail_tmplate.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.id IS 'ä¸»é”®';


--
-- Name: COLUMN mail_tmplate.invoice_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.invoice_from IS 'invoice_from';


--
-- Name: COLUMN mail_tmplate.invoice_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.invoice_to IS 'invoice_to';


--
-- Name: COLUMN mail_tmplate.invoice_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.invoice_subject IS 'invoice_subject';


--
-- Name: COLUMN mail_tmplate.invoice_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.invoice_content IS 'invoice_content';


--
-- Name: COLUMN mail_tmplate.payment_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.payment_from IS 'payment_from';


--
-- Name: COLUMN mail_tmplate.payment_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.payment_to IS 'payment_to';


--
-- Name: COLUMN mail_tmplate.payment_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.payment_subject IS 'payment_subject';


--
-- Name: COLUMN mail_tmplate.payment_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.payment_content IS 'payment_content';


--
-- Name: COLUMN mail_tmplate.lowbalance_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.lowbalance_subject IS 'lowbalance_subject';


--
-- Name: COLUMN mail_tmplate.lowbalance_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.lowbalance_content IS 'lowbalance_content';


--
-- Name: COLUMN mail_tmplate.rate_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.rate_from IS 'å‘é€rate tableçš„æ¨¡æ¿ å‘ä»¶äºº';


--
-- Name: COLUMN mail_tmplate.rate_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.rate_subject IS 'rate å‘é€æ¨¡æ¿ ä¸»é¢˜';


--
-- Name: COLUMN mail_tmplate.rate_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.rate_content IS 'rateå‘é€æ¨¡æ¿  å†…å®¹';


--
-- Name: COLUMN mail_tmplate.dialer_detection_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.dialer_detection_subject IS 'monitoring dialer_detection çš„é‚®ä»¶ä¸»é¢˜';


--
-- Name: COLUMN mail_tmplate.dialer_detection_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.dialer_detection_content IS 'monitoring dialer_detection çš„é‚®ä»¶å†…å®¹';


--
-- Name: COLUMN mail_tmplate.retrieve_password_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.retrieve_password_subject IS 'retrieve_password_subject';


--
-- Name: COLUMN mail_tmplate.retrieve_password_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.retrieve_password_content IS 'retrieve_password_content';


--
-- Name: COLUMN mail_tmplate.retrieve_password_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN mail_tmplate.retrieve_password_from IS 'retrieve_password_from';


--
-- Name: modif_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE modif_log (
    id integer NOT NULL,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    module character varying(100),
    type smallint,
    name character varying(100),
    detail text,
    rollback text,
    rollback_msg character varying(500),
    rollback_flg smallint,
    rollback_extra_info text
);


ALTER TABLE modif_log OWNER TO postgres;

--
-- Name: COLUMN modif_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN modif_log.type IS '0 -- creation
1-- deletion
2 -- modification';


--
-- Name: COLUMN modif_log.rollback; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN modif_log.rollback IS 'è®°å½•å›žæ»šçš„sql';


--
-- Name: COLUMN modif_log.rollback_msg; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN modif_log.rollback_msg IS 'è®°å½•å›žæ»šçš„æç¤ºä¿¡æ¯';


--
-- Name: COLUMN modif_log.rollback_flg; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN modif_log.rollback_flg IS '0ï¼šè¿˜æ²¡æœ‰å›žæ»š
1ï¼šæˆåŠŸå›žæ»š
2ï¼šå›žæ»šå¤±è´¥';


--
-- Name: COLUMN modif_log.rollback_extra_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN modif_log.rollback_extra_info IS 'å‚¨å­˜jsonæ ¼å¼
è®°å½•rollback_type:
1ï¼šç›´æŽ¥è¿è¡Œrollback_sql
2ï¼šDigit Mappingçš„åˆ é™¤å›žæ»š
3ï¼šStatic Routeçš„åˆ é™¤å›žæ»š';


--
-- Name: modif_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE modif_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE modif_log_id_seq OWNER TO postgres;

--
-- Name: modif_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE modif_log_id_seq OWNED BY modif_log.id;


--
-- Name: mutual_transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE mutual_transaction (
    "time" date,
    amount real,
    client_id character varying,
    type integer,
    id integer NOT NULL,
    balance real
);


ALTER TABLE mutual_transaction OWNER TO postgres;

--
-- Name: mutual_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE mutual_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE mutual_transaction_id_seq OWNER TO postgres;

--
-- Name: mutual_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE mutual_transaction_id_seq OWNED BY mutual_transaction.id;


--
-- Name: myvar; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE myvar (
    date date
);


ALTER TABLE myvar OWNER TO postgres;

--
-- Name: no_dest_trunk; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW no_dest_trunk AS
 SELECT dynamic_route.name,
    ''::prefix_range AS digits,
    'Dynamic Route'::text AS type
   FROM dynamic_route
  WHERE ((NOT (EXISTS ( SELECT dynamic_route_items.id,
            dynamic_route_items.dynamic_route_id,
            dynamic_route_items.resource_id
           FROM dynamic_route_items
          WHERE (dynamic_route_items.dynamic_route_id = dynamic_route.dynamic_route_id)))) OR (EXISTS ( SELECT dynamic_route_items.id,
            dynamic_route_items.dynamic_route_id,
            dynamic_route_items.resource_id,
            resource.resource_id,
            resource.name,
            resource.ingress,
            resource.egress,
            resource.active,
            resource.rfc_2833,
            resource.t38,
            resource.alias,
            resource.res_strategy,
            resource.cps_limit,
            resource.capacity,
            resource.lnp,
            resource.lrn_block,
            resource.client_id,
            resource.tdm,
            resource.rate_table_id,
            resource.transnexus,
            resource.route_strategy_id,
            resource.media_type,
            resource.pass_through,
            resource.profit_margin,
            resource.enough_balance,
            resource.egress_bill_after_action,
            resource.proto,
            resource.dnis_only,
            resource.ring_timeout,
            resource.ignore_ring,
            resource.ignore_early_media,
            resource.disable_by_alert,
            resource.priority,
            resource.last_priority,
            resource.create_time,
            resource.update_time,
            resource.status,
            resource.wait_ringtime180,
            resource.profit_type,
            resource.lnp_dipping,
            resource.lnp_dipping_rate,
            resource.update_at,
            resource.update_by
           FROM (dynamic_route_items
             JOIN resource ON ((dynamic_route_items.resource_id = resource.resource_id)))
          WHERE ((dynamic_route_items.dynamic_route_id = dynamic_route.dynamic_route_id) AND (resource.active = false) AND (resource.egress = true)))))
UNION ALL
 SELECT product.name,
    product_items.digits,
    'Static Route'::text AS type
   FROM (product
     LEFT JOIN product_items ON ((product.product_id = product_items.product_id)))
  WHERE ((NOT (EXISTS ( SELECT product_items_resource.id,
            product_items_resource.item_id,
            product_items_resource.resource_id,
            product_items_resource.by_percentage,
            product_items_resource.order_id,
            product_items_resource.order_type
           FROM product_items_resource
          WHERE (product_items.item_id = product_items_resource.item_id)))) OR (EXISTS ( SELECT product_items_resource.id,
            product_items_resource.item_id,
            product_items_resource.resource_id,
            product_items_resource.by_percentage,
            product_items_resource.order_id,
            product_items_resource.order_type,
            resource.resource_id,
            resource.name,
            resource.ingress,
            resource.egress,
            resource.active,
            resource.rfc_2833,
            resource.t38,
            resource.alias,
            resource.res_strategy,
            resource.cps_limit,
            resource.capacity,
            resource.lnp,
            resource.lrn_block,
            resource.client_id,
            resource.tdm,
            resource.rate_table_id,
            resource.transnexus,
            resource.route_strategy_id,
            resource.media_type,
            resource.pass_through,
            resource.profit_margin,
            resource.enough_balance,
            resource.egress_bill_after_action,
            resource.proto,
            resource.dnis_only,
            resource.ring_timeout,
            resource.ignore_ring,
            resource.ignore_early_media,
            resource.disable_by_alert,
            resource.priority,
            resource.last_priority,
            resource.create_time,
            resource.update_time,
            resource.status,
            resource.wait_ringtime180,
            resource.profit_type,
            resource.lnp_dipping,
            resource.lnp_dipping_rate,
            resource.update_at,
            resource.update_by
           FROM (product_items_resource
             JOIN resource ON ((product_items_resource.resource_id = resource.resource_id)))
          WHERE ((product_items.item_id = product_items_resource.item_id) AND (resource.active = false) AND (resource.egress = true)))))
UNION ALL
 SELECT route_strategy.name,
    route.digits,
    'Route Plan'::text AS type
   FROM (route_strategy
     LEFT JOIN route ON ((route_strategy.route_strategy_id = route.route_strategy_id)))
  WHERE ((EXISTS ( SELECT dynamic_route_items.id,
            dynamic_route_items.dynamic_route_id,
            dynamic_route_items.resource_id,
            resource.resource_id,
            resource.name,
            resource.ingress,
            resource.egress,
            resource.active,
            resource.rfc_2833,
            resource.t38,
            resource.alias,
            resource.res_strategy,
            resource.cps_limit,
            resource.capacity,
            resource.lnp,
            resource.lrn_block,
            resource.client_id,
            resource.tdm,
            resource.rate_table_id,
            resource.transnexus,
            resource.route_strategy_id,
            resource.media_type,
            resource.pass_through,
            resource.profit_margin,
            resource.enough_balance,
            resource.egress_bill_after_action,
            resource.proto,
            resource.dnis_only,
            resource.ring_timeout,
            resource.ignore_ring,
            resource.ignore_early_media,
            resource.disable_by_alert,
            resource.priority,
            resource.last_priority,
            resource.create_time,
            resource.update_time,
            resource.status,
            resource.wait_ringtime180,
            resource.profit_type,
            resource.lnp_dipping,
            resource.lnp_dipping_rate,
            resource.update_at,
            resource.update_by
           FROM (dynamic_route_items
             JOIN resource ON ((dynamic_route_items.resource_id = resource.resource_id)))
          WHERE ((dynamic_route_items.dynamic_route_id = route.dynamic_route_id) AND (resource.active = false) AND (resource.egress = true)))) OR (EXISTS ( SELECT product_items.item_id,
            product_items.product_id,
            product_items.alias,
            product_items.digits,
            product_items.strategy,
            product_items.time_profile_id,
            product_items.min_len,
            product_items.max_len,
            product_items_resource.id,
            product_items_resource.item_id,
            product_items_resource.resource_id,
            product_items_resource.by_percentage,
            product_items_resource.order_id,
            product_items_resource.order_type,
            resource.resource_id,
            resource.name,
            resource.ingress,
            resource.egress,
            resource.active,
            resource.rfc_2833,
            resource.t38,
            resource.alias,
            resource.res_strategy,
            resource.cps_limit,
            resource.capacity,
            resource.lnp,
            resource.lrn_block,
            resource.client_id,
            resource.tdm,
            resource.rate_table_id,
            resource.transnexus,
            resource.route_strategy_id,
            resource.media_type,
            resource.pass_through,
            resource.profit_margin,
            resource.enough_balance,
            resource.egress_bill_after_action,
            resource.proto,
            resource.dnis_only,
            resource.ring_timeout,
            resource.ignore_ring,
            resource.ignore_early_media,
            resource.disable_by_alert,
            resource.priority,
            resource.last_priority,
            resource.create_time,
            resource.update_time,
            resource.status,
            resource.wait_ringtime180,
            resource.profit_type,
            resource.lnp_dipping,
            resource.lnp_dipping_rate,
            resource.update_at,
            resource.update_by
           FROM ((product_items
             LEFT JOIN product_items_resource ON ((product_items.item_id = product_items_resource.item_id)))
             LEFT JOIN resource ON ((product_items_resource.resource_id = resource.resource_id)))
          WHERE ((product_items.product_id = route.static_route_id) AND (resource.active = false) AND (resource.egress = true)))));


ALTER TABLE no_dest_trunk OWNER TO postgres;

--
-- Name: ocn_lata; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ocn_lata (
    id integer NOT NULL,
    ocn character varying(20),
    lata character varying(20),
    intra_rate numeric(30,10),
    inter_rate numeric(30,10),
    rate numeric(30,10),
    effective_date timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    "interval" integer DEFAULT 1,
    min_time integer DEFAULT 0,
    rate_table_id integer
);


ALTER TABLE ocn_lata OWNER TO postgres;

--
-- Name: ocn_lata_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ocn_lata_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ocn_lata_id_seq OWNER TO postgres;

--
-- Name: ocn_lata_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ocn_lata_id_seq OWNED BY ocn_lata.id;


--
-- Name: online_users_online_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE online_users_online_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE online_users_online_id_seq OWNER TO postgres;

--
-- Name: online_users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE online_users (
    user_id integer,
    reseller_id integer,
    login_time timestamp with time zone DEFAULT now(),
    online_id integer DEFAULT nextval('online_users_online_id_seq'::regclass) NOT NULL,
    card_id integer,
    client_id integer,
    user_type integer,
    user_name character varying(40)
);


ALTER TABLE online_users OWNER TO postgres;

--
-- Name: TABLE online_users; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE online_users IS 'åœ¨çº¿ç”¨æˆ·è¡¨';


--
-- Name: COLUMN online_users.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN online_users.user_id IS 'ç”¨æˆ·';


--
-- Name: COLUMN online_users.reseller_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN online_users.reseller_id IS 'ä»£ç†å•†';


--
-- Name: COLUMN online_users.login_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN online_users.login_time IS 'ç™»å½•æ—¶é—´';


--
-- Name: COLUMN online_users.online_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN online_users.online_id IS 'ä¸»é”®';


--
-- Name: COLUMN online_users.card_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN online_users.card_id IS 'è´¦å·å¡';


--
-- Name: COLUMN online_users.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN online_users.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN online_users.user_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN online_users.user_type IS '1--ç®¡ç†å‘˜
2--ä»£ç†å•†
3--å®¢æˆ·(æ‰¹å‘)
4--å¸å·å¡(account)
5--æ™®é€šç”¨æˆ·
6--ä½“éªŒç”¨æˆ·
';


--
-- Name: COLUMN online_users.user_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN online_users.user_name IS 'ç™»å½•ç”¨æˆ·å';


--
-- Name: opentact_balance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE opentact_balance (
    id integer NOT NULL,
    ingress_id integer NOT NULL,
    balance numeric(30,10) DEFAULT 0
);


ALTER TABLE opentact_balance OWNER TO postgres;

--
-- Name: opentact_balance_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE opentact_balance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE opentact_balance_id_seq OWNER TO postgres;

--
-- Name: opentact_balance_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE opentact_balance_id_seq OWNED BY opentact_balance.id;


--
-- Name: options_of_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE options_of_record (
    id integer NOT NULL,
    "time" bigint,
    state integer,
    sip_code integer,
    resource_id integer,
    resource_ip_id integer,
    pdd integer
);


ALTER TABLE options_of_record OWNER TO postgres;

--
-- Name: TABLE options_of_record; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE options_of_record IS 'è®°å½•optionsçŠ¶æ€æ”¹å˜æƒ…å†µ

baohq20140419';


--
-- Name: COLUMN options_of_record.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN options_of_record.id IS 'é€’å¢žçš„åºåˆ—';


--
-- Name: COLUMN options_of_record."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN options_of_record."time" IS 'æ’å…¥æ—¶é—´ï¼Œé•¿æ•´åž‹ï¼Œç§’å•ä½

baohq20140419';


--
-- Name: COLUMN options_of_record.state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN options_of_record.state IS 'çŠ¶æ€æ”¹å˜æ—¶è¢«æ’å…¥ä¸€æ¡ï¼Œåˆ†ç»„åŽidæœ€å¤§çš„æ˜¯æœ€æ–°çš„çŠ¶æ€
0 -- false ä¸åœ¨çº¿
1 -- true åœ¨çº¿

baohq20140419';


--
-- Name: COLUMN options_of_record.sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN options_of_record.sip_code IS 'æœ€åŽä¸€æ¬¡æ”¶åˆ°çš„sipç ï¼Œ 0ä¸ºè¡¨ç¤ºæ²¡æ”¶åˆ°ã€‚

baohq20140419';


--
-- Name: COLUMN options_of_record.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN options_of_record.resource_id IS 'å¯¹åº”resourceå’Œresource_ipè¡¨çš„resource_id

baohq20140419';


--
-- Name: COLUMN options_of_record.resource_ip_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN options_of_record.resource_ip_id IS 'å¯¹åº”resource_ipè¡¨resource_ip_id

baohq20140419';


--
-- Name: COLUMN options_of_record.pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN options_of_record.pdd IS 'æœ€è¿‘10æ¬¡optionçš„å¹³å‡pdd

baohq20140419';


--
-- Name: options_of_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE options_of_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE options_of_record_id_seq OWNER TO postgres;

--
-- Name: options_of_record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE options_of_record_id_seq OWNED BY options_of_record.id;


--
-- Name: order_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE order_code (
    order_id integer NOT NULL,
    code prefix_range NOT NULL,
    order_type integer NOT NULL,
    id integer NOT NULL,
    code_name character varying(100) NOT NULL,
    code_id integer,
    country character varying(100) NOT NULL,
    client_id integer
);


ALTER TABLE order_code OWNER TO postgres;

--
-- Name: COLUMN order_code.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_code.code IS 'code  è¡¨ä¸­çš„code';


--
-- Name: COLUMN order_code.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_code.order_type IS '1ï¼ï¼buy
2ï¼ï¼sell';


--
-- Name: order_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE order_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE order_code_id_seq OWNER TO postgres;

--
-- Name: order_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE order_code_id_seq OWNED BY order_code.id;


--
-- Name: order_partern; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE order_partern (
    id integer NOT NULL,
    order_id integer,
    order_type integer,
    partern_id integer,
    status integer DEFAULT 1
);


ALTER TABLE order_partern OWNER TO postgres;

--
-- Name: COLUMN order_partern.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_partern.order_type IS '1-buy
2-sell';


--
-- Name: COLUMN order_partern.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_partern.status IS '1-default
2-accept
3-reject';


--
-- Name: order_partern_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE order_partern_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE order_partern_id_seq OWNER TO postgres;

--
-- Name: order_partern_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE order_partern_id_seq OWNED BY order_partern.id;


--
-- Name: order_user; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE order_user (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    password character varying(100) NOT NULL,
    question character varying(1000) NOT NULL,
    answer character varying(1000) NOT NULL,
    company_name character varying NOT NULL,
    addr1 character varying(100) NOT NULL,
    addr2 character varying(100),
    city character varying(100) NOT NULL,
    province character varying(100),
    post_code character varying(40) NOT NULL,
    country character varying(100) NOT NULL,
    corporate_contact_name character varying(100) NOT NULL,
    corporate_contact_phone character varying(100) NOT NULL,
    corporate_contact_cell character varying(100),
    corporate_contact_email character varying(100) NOT NULL,
    alternate_emails character varying(1000),
    corporate_contact_fax character varying(100),
    corporate_registration_id character varying(100),
    corporate_registration_country character varying(100) NOT NULL,
    billing_contact_name character varying(100),
    billing_contact_phone character varying(100),
    billing_contact_email character varying(100),
    billing_contact_fax character varying(100),
    bank_name character varying(100) NOT NULL,
    bank_address character varying(100),
    bank_city character varying(100),
    bank_province character varying(100),
    bank_country character varying(100),
    bank_post_code character varying DEFAULT 100,
    bank_account_name character varying(100) NOT NULL,
    bank_routing_number character varying(100) NOT NULL,
    bank_account_number character varying(100) NOT NULL,
    bank_swift character varying(100) NOT NULL,
    bank_notes character varying(1000),
    status integer DEFAULT 1 NOT NULL,
    client_id integer,
    noc_contract_phone character varying(100),
    noc_contract_email character varying(100),
    noc_contract_im character varying(1000),
    mail_validate_code character varying(32),
    paypal character varying(100),
    currency_preference character varying(100),
    noc_contract_type integer,
    intermediately_bank character varying(100),
    ach character varying(100),
    primary_contact_name character varying(100),
    primary_job_tite character varying(100),
    primary_email character varying(100),
    primary_fax character varying(100),
    primary_phone character varying(100),
    primary_mobile character varying(100),
    primary_yahoo character varying(100),
    primary_msn character varying(100),
    primary_skype character varying(100),
    primary_aql character varying(100),
    primary_icq character varying(100),
    primary_qq character varying(100),
    technical_contact_name character varying(100),
    technical_job_tite character varying(100),
    technical_email character varying(100),
    technical_fax character varying(100),
    technical_phone character varying(100),
    technical_mobile character varying(100),
    technical_yahoo character varying(100),
    technical_msn character varying(100),
    technical_skype character varying(100),
    technical_aql character varying(100),
    technical_icq character varying(100),
    technical_qq character varying(100),
    billing_job_tite character varying(100),
    billing_email character varying(100),
    billing_fax character varying(100),
    billing_phone character varying(100),
    billing_mobile character varying(100),
    billing_yahoo character varying(100),
    billing_msn character varying(100),
    billing_skype character varying(100),
    billing_aql character varying(100),
    billing_icq character varying(100),
    billing_qq character varying(100),
    pwd_code character varying(2000),
    last_login_time timestamp with time zone,
    admin_login_key character varying(100),
    create_time timestamp with time zone,
    email_key character varying(100),
    agent_email text,
    rate_send_from text,
    rate_contact_name character varying,
    rate_contact_phone character varying,
    role_id integer,
    client_type integer DEFAULT 1 NOT NULL,
    edit_trunk integer DEFAULT 1 NOT NULL,
    is_reg boolean DEFAULT false,
    app_time timestamp with time zone,
    app_status integer,
    app_key character varying
);


ALTER TABLE order_user OWNER TO postgres;

--
-- Name: COLUMN order_user.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user.status IS '1:New
2:Hold
3:Accepted
4:mail validated';


--
-- Name: COLUMN order_user.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user.client_id IS 'æ³¨å†ŒæˆåŠŸåŽçš„carrirçš„ç›¸å…³client_idå­—æ®µ';


--
-- Name: COLUMN order_user.noc_contract_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user.noc_contract_type IS '1-msn
2-skype
3-other';


--
-- Name: COLUMN order_user.client_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user.client_type IS '1:exchange user
2:class4 user';


--
-- Name: COLUMN order_user.edit_trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user.edit_trunk IS '1:can edit
2:can not edit';


--
-- Name: COLUMN order_user.app_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user.app_status IS '1:watiing email
2:wating for app
3:complete';


--
-- Name: order_user_alert; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE order_user_alert (
    id integer NOT NULL,
    user_id integer,
    order_type integer,
    alert_type integer,
    freq_type integer,
    freq_value character varying(100),
    email character varying(100),
    last_email_time timestamp with time zone,
    last_run_time timestamp with time zone,
    client_id integer,
    agent_id integer,
    allow_sent integer DEFAULT 0
);


ALTER TABLE order_user_alert OWNER TO postgres;

--
-- Name: TABLE order_user_alert; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE order_user_alert IS 'exchange_alert';


--
-- Name: COLUMN order_user_alert.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user_alert.order_type IS '1--buy
2--sell';


--
-- Name: COLUMN order_user_alert.alert_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user_alert.alert_type IS '1-rate update
2-route update
3-request route match
4-select route update
5-no route available
6-invoice post
7-rate watch
8-auto summary
9-buy qos
10-sell qos
11-finance';


--
-- Name: COLUMN order_user_alert.freq_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user_alert.freq_type IS '0-never
1-real time
2-30 m
3-1 h
4-3 h
5-6 h
6-12 h
7-24 h';


--
-- Name: order_user_alert_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE order_user_alert_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE order_user_alert_id_seq OWNER TO postgres;

--
-- Name: order_user_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE order_user_alert_id_seq OWNED BY order_user_alert.id;


--
-- Name: order_user_finance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE order_user_finance (
    id integer NOT NULL,
    order_user_alert_id integer,
    finance_type integer,
    finance_value real,
    finance_condition integer,
    client_id integer,
    name character varying(100)
);


ALTER TABLE order_user_finance OWNER TO postgres;

--
-- Name: COLUMN order_user_finance.finance_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user_finance.finance_type IS '0-remaining balance
1-daily buy
2-daily sell';


--
-- Name: COLUMN order_user_finance.finance_condition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user_finance.finance_condition IS '1-<
2->=';


--
-- Name: order_user_finance_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE order_user_finance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE order_user_finance_id_seq OWNER TO postgres;

--
-- Name: order_user_finance_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE order_user_finance_id_seq OWNED BY order_user_finance.id;


--
-- Name: order_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE order_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE order_user_id_seq OWNER TO postgres;

--
-- Name: order_user_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE order_user_id_seq OWNED BY order_user.id;


--
-- Name: order_user_qos; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE order_user_qos (
    id integer NOT NULL,
    order_user_alert_id integer,
    asr_condition integer,
    acd_condition integer,
    pdd_condition integer,
    asr_value real,
    acd_value real,
    pdd_value real,
    resource_id integer,
    client_id integer,
    name character varying(100)
);


ALTER TABLE order_user_qos OWNER TO postgres;

--
-- Name: COLUMN order_user_qos.asr_condition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user_qos.asr_condition IS '0-don''t care
1->=
2-<';


--
-- Name: order_user_qos_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE order_user_qos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE order_user_qos_id_seq OWNER TO postgres;

--
-- Name: order_user_qos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE order_user_qos_id_seq OWNED BY order_user_qos.id;


--
-- Name: order_user_rate_watch; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE order_user_rate_watch (
    id integer NOT NULL,
    order_user_alert_id integer,
    code_name character varying(100),
    rate_type integer,
    rate_less real,
    rate_more real,
    code text,
    new_route_available boolean,
    rate_increases boolean,
    rate_decreases boolean,
    no_route_available boolean,
    rate_greater_than numeric,
    rate_less_than numeric,
    new_target_available boolean,
    client_id integer
);


ALTER TABLE order_user_rate_watch OWNER TO postgres;

--
-- Name: COLUMN order_user_rate_watch.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN order_user_rate_watch.rate_type IS '1-white
2-grey';


--
-- Name: order_user_rate_watch_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE order_user_rate_watch_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE order_user_rate_watch_id_seq OWNER TO postgres;

--
-- Name: order_user_rate_watch_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE order_user_rate_watch_id_seq OWNED BY order_user_rate_watch.id;


--
-- Name: orig_invoice; Type: TABLE; Schema: public; Owner: class4_user
--

CREATE TABLE orig_invoice (
    invoice_id integer NOT NULL,
    invoice_number text NOT NULL,
    state integer DEFAULT 1 NOT NULL,
    client_id integer NOT NULL,
    invoice_time timestamp without time zone NOT NULL,
    invoice_start timestamp without time zone NOT NULL,
    invoice_end timestamp without time zone NOT NULL,
    total_amount numeric(15,2) NOT NULL,
    pdf_path text NOT NULL,
    create_type integer DEFAULT 0
);


ALTER TABLE orig_invoice OWNER TO class4_user;

--
-- Name: orig_invoice_invoice_id_seq; Type: SEQUENCE; Schema: public; Owner: class4_user
--

CREATE SEQUENCE orig_invoice_invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE orig_invoice_invoice_id_seq OWNER TO class4_user;

--
-- Name: orig_invoice_invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: class4_user
--

ALTER SEQUENCE orig_invoice_invoice_id_seq OWNED BY orig_invoice.invoice_id;


--
-- Name: orig_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE orig_log (
    log_id integer NOT NULL,
    update_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying(100),
    module character varying(100),
    type smallint,
    detail character varying(500)
);


ALTER TABLE orig_log OWNER TO postgres;

--
-- Name: COLUMN orig_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN orig_log.type IS '0 -- creation
1-- deletion
2 -- modification';


--
-- Name: orig_log_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE orig_log_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE orig_log_log_id_seq OWNER TO postgres;

--
-- Name: orig_log_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE orig_log_log_id_seq OWNED BY orig_log.log_id;


--
-- Name: origination_global_failover; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE origination_global_failover (
    id integer NOT NULL,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100)
);


ALTER TABLE origination_global_failover OWNER TO postgres;

--
-- Name: TABLE origination_global_failover; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE origination_global_failover IS 'ä¸»å«æ–¹è·³è½¬ç­–ç•¥

baohq20140422';


--
-- Name: COLUMN origination_global_failover.failover_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN origination_global_failover.failover_strategy IS 'è·³è½¬ç­–ç•¥ç±»åž‹

baohq20140422';


--
-- Name: COLUMN origination_global_failover.from_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN origination_global_failover.from_sip_code IS 'ä»Žè¢«å«æ”¶åˆ°çš„sipç 

baohq20140422';


--
-- Name: COLUMN origination_global_failover.to_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN origination_global_failover.to_sip_code IS 'è¿”å›žç»™ä¸»å«çš„sipç 

baohq20140422';


--
-- Name: COLUMN origination_global_failover.to_sip_string; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN origination_global_failover.to_sip_string IS 'è¿”å›žç»™ä¸»å«çš„sipæè¿°å­—ç¬¦ä¸²

baohq20140422';


--
-- Name: origination_global_failover_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE origination_global_failover_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE origination_global_failover_id_seq OWNER TO postgres;

--
-- Name: origination_global_failover_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE origination_global_failover_id_seq OWNED BY origination_global_failover.id;


--
-- Name: origination_global_failover_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE origination_global_failover_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE origination_global_failover_record_record_id_seq OWNER TO postgres;

--
-- Name: origination_global_failover_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE origination_global_failover_record (
    id integer,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('origination_global_failover_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE origination_global_failover_record OWNER TO postgres;

--
-- Name: origination_global_failover_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE origination_global_failover_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE origination_global_failover_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: origination_global_failover_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE origination_global_failover_record_tmp (
    id integer,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('origination_global_failover_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE origination_global_failover_record_tmp OWNER TO postgres;

--
-- Name: par_user; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE par_user (
    name character varying(100),
    password character varying(100),
    question character varying(1000),
    answer character varying(1000),
    company_name character varying,
    addr1 character varying(100),
    addr2 character varying(100),
    city character varying(100),
    province character varying(100),
    post_code character varying(40),
    country character varying(100),
    corporate_contact_name character varying(100),
    corporate_contact_phone character varying(100),
    corporate_contact_cell character varying(100),
    corporate_contact_email character varying(100),
    alternate_emails character varying(1000),
    corporate_contact_fax character varying(100),
    corporate_registration_id character varying(100),
    corporate_registration_country character varying(100),
    billing_contact_name character varying(100),
    billing_contact_phone character varying(100),
    billing_contact_email character varying(100),
    billing_contact_fax character varying(100),
    bank_name character varying(100),
    bank_address character varying(100),
    bank_city character varying(100),
    bank_province character varying(100),
    bank_country character varying(100),
    bank_post_code character varying,
    bank_account_name character varying(100),
    bank_routing_number character varying(100),
    bank_account_number character varying(100),
    bank_swift character varying(100),
    bank_notes character varying(1000),
    status integer DEFAULT 1 NOT NULL,
    client_id integer,
    noc_contract_phone character varying(100),
    noc_contract_email character varying(100),
    noc_contract_im character varying(1000),
    mail_validate_code character varying(32),
    paypal character varying(100),
    currency_preference character varying(100),
    noc_contract_type integer,
    intermediately_bank character varying(100),
    ach character varying(100),
    primary_contact_name character varying(100),
    primary_job_tite character varying(100),
    primary_email character varying(100),
    primary_fax character varying(100),
    primary_phone character varying(100),
    primary_mobile character varying(100),
    primary_yahoo character varying(100),
    primary_msn character varying(100),
    primary_skype character varying(100),
    primary_aql character varying(100),
    primary_icq character varying(100),
    primary_qq character varying(100),
    technical_contact_name character varying(100),
    technical_job_tite character varying(100),
    technical_email character varying(100),
    technical_fax character varying(100),
    technical_phone character varying(100),
    technical_mobile character varying(100),
    technical_yahoo character varying(100),
    technical_msn character varying(100),
    technical_skype character varying(100),
    technical_aql character varying(100),
    technical_icq character varying(100),
    technical_qq character varying(100),
    billing_job_tite character varying(100),
    billing_email character varying(100),
    billing_fax character varying(100),
    billing_phone character varying(100),
    billing_mobile character varying(100),
    billing_yahoo character varying(100),
    billing_msn character varying(100),
    billing_skype character varying(100),
    billing_aql character varying(100),
    billing_icq character varying(100),
    billing_qq character varying(100),
    pwd_code character varying(2000),
    last_login_time timestamp with time zone,
    admin_login_key character varying(100),
    create_time timestamp with time zone,
    email_key character varying(100),
    agent_email text,
    id integer NOT NULL,
    rate_send_from text,
    rate_contact_name character varying,
    rate_contact_phone character varying,
    client_type integer
);


ALTER TABLE par_user OWNER TO postgres;

--
-- Name: COLUMN par_user.client_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN par_user.client_type IS '1: Client  (buy)
2:Vendor (sell)
';


--
-- Name: par_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE par_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE par_user_id_seq OWNER TO postgres;

--
-- Name: par_user_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE par_user_id_seq OWNED BY par_user.id;


--
-- Name: partition_gateway_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE partition_gateway_ref (
    id integer NOT NULL,
    partition_id integer,
    gateway_ip ip4,
    gateway_port integer
);


ALTER TABLE partition_gateway_ref OWNER TO postgres;

--
-- Name: TABLE partition_gateway_ref; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE partition_gateway_ref IS 'partitionå’Œswitch_profileè¡¨çš„æ˜ å°„å…³ç³»';


--
-- Name: COLUMN partition_gateway_ref.gateway_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN partition_gateway_ref.gateway_ip IS 'è·Ÿswitch_profileè¡¨sip_ipå¯¹åº”';


--
-- Name: COLUMN partition_gateway_ref.gateway_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN partition_gateway_ref.gateway_port IS 'è·Ÿswitch_profileè¡¨sip_portå¯¹åº”';


--
-- Name: partition_gateway_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE partition_gateway_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE partition_gateway_ref_id_seq OWNER TO postgres;

--
-- Name: partition_gateway_ref_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE partition_gateway_ref_id_seq OWNED BY partition_gateway_ref.id;


--
-- Name: partition_gateway_ref_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE partition_gateway_ref_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE partition_gateway_ref_record_record_id_seq OWNER TO postgres;

--
-- Name: partition_gateway_ref_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE partition_gateway_ref_record (
    id integer,
    partition_id integer,
    gateway_ip ip4,
    gateway_port integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('partition_gateway_ref_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE partition_gateway_ref_record OWNER TO postgres;

--
-- Name: partition_gateway_ref_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE partition_gateway_ref_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE partition_gateway_ref_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: partition_gateway_ref_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE partition_gateway_ref_record_tmp (
    id integer,
    partition_id integer,
    gateway_ip ip4,
    gateway_port integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('partition_gateway_ref_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE partition_gateway_ref_record_tmp OWNER TO postgres;

--
-- Name: partition_invoice; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE partition_invoice (
    id integer NOT NULL,
    invoice_no character varying(20),
    total_calls integer,
    total_minutes integer,
    rate numeric(30,10),
    total_cost numeric(30,10),
    invoice_start timestamp with time zone,
    invoice_end timestamp with time zone,
    invoice_time timestamp with time zone,
    customer_name character varying(100),
    due_date timestamp with time zone
);


ALTER TABLE partition_invoice OWNER TO postgres;

--
-- Name: partition_invoice_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE partition_invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE partition_invoice_id_seq OWNER TO postgres;

--
-- Name: partition_invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE partition_invoice_id_seq OWNED BY partition_invoice.id;


--
-- Name: partner; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE partner (
    id integer NOT NULL,
    client_id integer,
    partner_id integer
);


ALTER TABLE partner OWNER TO postgres;

--
-- Name: TABLE partner; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE partner IS 'è¿è¥å•†çš„partner';


--
-- Name: partner_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE partner_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE partner_id_seq OWNER TO postgres;

--
-- Name: partner_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE partner_id_seq OWNED BY partner.id;


--
-- Name: payline_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE payline_history (
    chargetotal numeric,
    method smallint,
    cardnumber character varying,
    cardexpmonth character varying,
    cardexpyear character varying,
    created_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    modified_time timestamp without time zone,
    error character varying,
    confirmed boolean DEFAULT false,
    client_id integer,
    fee numeric,
    status smallint DEFAULT 0,
    id integer NOT NULL,
    invoice_id character varying(255),
    par_id integer,
    address1 character varying(255),
    address2 character varying(255),
    city character varying(255),
    state_province character varying(255),
    zip_code character varying(255),
    country character varying(255),
    credit_card_type integer,
    paypal_id character varying(100),
    transaction_id character varying(100),
    return_code character varying(100),
    charge_type numeric DEFAULT 0,
    charge_amount numeric DEFAULT 0,
    response text
);


ALTER TABLE payline_history OWNER TO postgres;

--
-- Name: COLUMN payline_history.method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN payline_history.method IS '0 - paypal

1- yourpay';


--
-- Name: COLUMN payline_history.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN payline_history.status IS '0 initial

1 error

2 success';


--
-- Name: payline_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE payline_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE payline_history_id_seq OWNER TO postgres;

--
-- Name: payline_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE payline_history_id_seq OWNED BY payline_history.id;


--
-- Name: payment_invoice; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE payment_invoice (
    id integer NOT NULL,
    payment_id integer,
    invoice_id integer,
    amount numeric(20,5)
);


ALTER TABLE payment_invoice OWNER TO postgres;

--
-- Name: payment_invoice_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE payment_invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE payment_invoice_id_seq OWNER TO postgres;

--
-- Name: payment_invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE payment_invoice_id_seq OWNED BY payment_invoice.id;


--
-- Name: payment_term_payment_term_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE payment_term_payment_term_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999
    CACHE 1;


ALTER TABLE payment_term_payment_term_id_seq OWNER TO postgres;

--
-- Name: payment_term; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE payment_term (
    payment_term_id integer DEFAULT nextval('payment_term_payment_term_id_seq'::regclass) NOT NULL,
    name character varying(100) NOT NULL,
    type integer NOT NULL,
    days integer NOT NULL,
    grace_days integer,
    notify_days integer,
    more_days character varying(100),
    finance_rate real
);


ALTER TABLE payment_term OWNER TO postgres;

--
-- Name: TABLE payment_term; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE payment_term IS 'ç¼´è´¹è®¾ç½®';


--
-- Name: COLUMN payment_term.payment_term_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN payment_term.payment_term_id IS 'ä¸»é”®';


--
-- Name: COLUMN payment_term.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN payment_term.name IS 'åå­—';


--
-- Name: COLUMN payment_term.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN payment_term.type IS 'ä»˜æ¬¾æ—¶é—´ï¼š1ï¼æ¯éš”å¤šå°‘å¤©ï¼Œ2ï¼æ¯æœˆå“ªä¸€å¤©
3ï¼æ¯å‘¨å‡ ï¼Œ4ï¼æ¯æœˆå“ªå‡ å¤©';


--
-- Name: COLUMN payment_term.days; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN payment_term.days IS 'å¤©æ•°æˆ–æ—¥æœŸ';


--
-- Name: COLUMN payment_term.grace_days; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN payment_term.grace_days IS 'ç¼´æ¬¾çš„å®½é™å¤©æ•°';


--
-- Name: COLUMN payment_term.notify_days; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN payment_term.notify_days IS 'å®½é™æœŸç»“æŸå‰ï¼Œå¤šå°å¤©å‰é€šçŸ¥';


--
-- Name: payment_term_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE payment_term_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE payment_term_record_record_id_seq OWNER TO postgres;

--
-- Name: payment_term_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE payment_term_record (
    payment_term_id integer,
    name character varying(100),
    type integer,
    days integer,
    grace_days integer,
    notify_days integer,
    more_days character varying(100),
    finance_rate real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('payment_term_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE payment_term_record OWNER TO postgres;

--
-- Name: payment_term_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE payment_term_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE payment_term_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: payment_term_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE payment_term_record_tmp (
    payment_term_id integer,
    name character varying(100),
    type integer,
    days integer,
    grace_days integer,
    notify_days integer,
    more_days character varying(100),
    finance_rate real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('payment_term_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE payment_term_record_tmp OWNER TO postgres;

--
-- Name: pex_offer_pending_rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE pex_offer_pending_rate (
    id integer NOT NULL,
    offer_id integer,
    rate_id integer,
    new_rate numeric(30,10),
    new_inteval integer,
    new_min_period integer,
    created_date timestamp with time zone,
    status integer DEFAULT 1 NOT NULL,
    effective_date timestamp with time zone,
    closed_date timestamp with time zone
);


ALTER TABLE pex_offer_pending_rate OWNER TO postgres;

--
-- Name: COLUMN pex_offer_pending_rate.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN pex_offer_pending_rate.status IS '1:pending
2:rejected';


--
-- Name: pex_offer_pending_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE pex_offer_pending_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pex_offer_pending_rate_id_seq OWNER TO postgres;

--
-- Name: pex_offer_pending_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE pex_offer_pending_rate_id_seq OWNED BY pex_offer_pending_rate.id;


--
-- Name: pex_offers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE pex_offers (
    id integer NOT NULL,
    client_id integer,
    type integer NOT NULL,
    trunk_id integer NOT NULL,
    rate_table_id integer,
    created_date timestamp with time zone,
    close_date timestamp with time zone,
    accepted_date timestamp with time zone,
    rejected_date timestamp with time zone,
    status integer DEFAULT 1 NOT NULL,
    exchange_escrow boolean,
    allowed_credit numeric(30,10),
    partner_client_id integer,
    partner_trunk_id integer,
    closed_by integer
);


ALTER TABLE pex_offers OWNER TO postgres;

--
-- Name: COLUMN pex_offers.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN pex_offers.status IS '1:pending
2:active
3:rejectd
4:closed';


--
-- Name: COLUMN pex_offers.closed_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN pex_offers.closed_by IS '1:owner
2:partner';


--
-- Name: pex_offers_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE pex_offers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pex_offers_id_seq OWNER TO postgres;

--
-- Name: pex_offers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE pex_offers_id_seq OWNED BY pex_offers.id;


--
-- Name: prefix_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE prefix_info (
    "time" character varying(100),
    pro_id character varying(100),
    prefix_id character varying(100),
    acd character varying(100),
    asr character varying(100),
    ca character varying(100),
    call_count character varying(100),
    direction character varying(100),
    call_count_asr character varying(100),
    pdd character varying(100),
    ip character varying(100)
);


ALTER TABLE prefix_info OWNER TO postgres;

--
-- Name: TABLE prefix_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE prefix_info IS 'prefix monitor';


--
-- Name: COLUMN prefix_info."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info."time" IS 'æ—¶é—´';


--
-- Name: COLUMN prefix_info.pro_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info.pro_id IS 'é™æ€è·¯ç”±è¡¨';


--
-- Name: COLUMN prefix_info.prefix_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info.prefix_id IS 'prefix';


--
-- Name: COLUMN prefix_info.acd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info.acd IS 'å¹³å‡é€šè¯æ—¶é—´';


--
-- Name: COLUMN prefix_info.asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info.asr IS 'å‘¼å«æˆåŠŸçŽ‡';


--
-- Name: COLUMN prefix_info.ca; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info.ca IS 'ca';


--
-- Name: COLUMN prefix_info.call_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info.call_count IS 'call_count';


--
-- Name: COLUMN prefix_info.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info.direction IS 'ingress,egress';


--
-- Name: COLUMN prefix_info.call_count_asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info.call_count_asr IS 'call_count_asr';


--
-- Name: COLUMN prefix_info.pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info.pdd IS 'å‘¼å«å»¶è¿Ÿ';


--
-- Name: COLUMN prefix_info.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN prefix_info.ip IS 'æœåŠ¡å™¨åœ°å€';


--
-- Name: priority_view; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW priority_view AS
 SELECT ( SELECT alert_rule.name
           FROM alert_rule
          WHERE (alert_rule.id = alert_event.alert_rule_id)) AS rule_name,
    ( SELECT resource.alias
           FROM resource
          WHERE (resource.resource_id = alert_event.res_id)) AS resource,
    alert_event.disable_code AS code,
    alert_event.event_time,
    (alert_event.event_time + ((alert_event.disable_duration)::double precision * '00:01:00'::interval)) AS enabled_time,
    alert_event.old_priority,
    alert_event.new_priority
   FROM alert_event
  WHERE (alert_event.event_type = 7);


ALTER TABLE priority_view OWNER TO postgres;

--
-- Name: private_invite; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE private_invite (
    id integer NOT NULL,
    sender_user_id integer,
    sender_first_name character varying(100),
    sender_last_name character varying(100),
    sender_phone character varying(100),
    sender_email character varying(100),
    invite_content character varying(1000),
    receiver_first_name character varying(100),
    receiver_last_name character varying(100),
    receiver_company character varying(100),
    receiver_email character varying(100),
    receiver_user_id integer,
    send_time timestamp with time zone,
    accept_time timestamp with time zone,
    status integer DEFAULT 0,
    invite_no character varying(100)
);


ALTER TABLE private_invite OWNER TO postgres;

--
-- Name: COLUMN private_invite.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN private_invite.status IS '0ï¼šå‘å‡ºé‚€è¯·
1ï¼šå‘é€é‚®ä»¶
2ï¼šæŽ¥å—é‚€è¯·
3ï¼šå–æ¶ˆé‚€è¯·
4ï¼šæ‹’ç»é‚€è¯·';


--
-- Name: private_invite_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE private_invite_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE private_invite_id_seq OWNER TO postgres;

--
-- Name: private_invite_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE private_invite_id_seq OWNED BY private_invite.id;


--
-- Name: product_agents_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_agents_ref (
    id integer NOT NULL,
    product_id integer,
    agent_id integer
);


ALTER TABLE product_agents_ref OWNER TO postgres;

--
-- Name: product_agents_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_agents_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_agents_ref_id_seq OWNER TO postgres;

--
-- Name: product_agents_ref_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE product_agents_ref_id_seq OWNED BY product_agents_ref.id;


--
-- Name: product_clients_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_clients_ref (
    id integer NOT NULL,
    product_id integer,
    client_id integer
);


ALTER TABLE product_clients_ref OWNER TO postgres;

--
-- Name: product_clients_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_clients_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_clients_ref_id_seq OWNER TO postgres;

--
-- Name: product_clients_ref_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE product_clients_ref_id_seq OWNED BY product_clients_ref.id;


--
-- Name: product_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_info (
    "time" character varying(100),
    product_id character varying(100),
    value character varying(100),
    ip character varying(100)
);


ALTER TABLE product_info OWNER TO postgres;

--
-- Name: TABLE product_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE product_info IS 'product monitor';


--
-- Name: COLUMN product_info."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product_info."time" IS 'æ—¶é—´';


--
-- Name: COLUMN product_info.product_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product_info.product_id IS 'product';


--
-- Name: COLUMN product_info.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product_info.value IS 'é€šè¯æ•°';


--
-- Name: COLUMN product_info.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product_info.ip IS 'æœåŠ¡å™¨åœ°å€';


--
-- Name: product_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_items_record_record_id_seq OWNER TO postgres;

--
-- Name: product_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_items_record (
    item_id integer,
    product_id integer,
    alias character varying(100),
    digits prefix_range,
    strategy integer,
    time_profile_id integer,
    min_len integer,
    max_len integer,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real,
    update_at timestamp with time zone,
    update_by character varying,
    code_name character(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('product_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE product_items_record OWNER TO postgres;

--
-- Name: product_items_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_items_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_items_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: product_items_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_items_record_tmp (
    item_id integer,
    product_id integer,
    alias character varying(100),
    digits prefix_range,
    strategy integer,
    time_profile_id integer,
    min_len integer,
    max_len integer,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real,
    update_at timestamp with time zone,
    update_by character varying,
    code_name character(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('product_items_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE product_items_record_tmp OWNER TO postgres;

--
-- Name: product_items_resource_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_items_resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_items_resource_id_seq OWNER TO postgres;

--
-- Name: product_items_resource_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE product_items_resource_id_seq OWNED BY product_items_resource.id;


--
-- Name: product_items_resource_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_items_resource_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_items_resource_record_record_id_seq OWNER TO postgres;

--
-- Name: product_items_resource_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_items_resource_record (
    id integer,
    item_id integer,
    resource_id integer,
    by_percentage integer,
    order_id integer,
    order_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('product_items_resource_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE product_items_resource_record OWNER TO postgres;

--
-- Name: product_items_resource_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_items_resource_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_items_resource_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: product_items_resource_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_items_resource_record_tmp (
    id integer,
    item_id integer,
    resource_id integer,
    by_percentage integer,
    order_id integer,
    order_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('product_items_resource_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE product_items_resource_record_tmp OWNER TO postgres;

--
-- Name: product_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_record_record_id_seq OWNER TO postgres;

--
-- Name: product_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_record (
    product_id integer,
    name character varying(100),
    modify_time timestamp with time zone,
    introduction character varying(80),
    dynamic_route_id integer,
    update_by character varying,
    code_type integer,
    code_deck_id integer,
    route_lrn integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('product_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE product_record OWNER TO postgres;

--
-- Name: product_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: product_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_record_tmp (
    product_id integer,
    name character varying(100),
    modify_time timestamp with time zone,
    introduction character varying(80),
    dynamic_route_id integer,
    update_by character varying,
    code_type integer,
    code_deck_id integer,
    route_lrn integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('product_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE product_record_tmp OWNER TO postgres;

--
-- Name: product_rout_rate_table; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_rout_rate_table (
    id integer NOT NULL,
    rout_id integer NOT NULL,
    rate_table_id integer NOT NULL,
    product_name character varying(256) NOT NULL,
    agent_id integer,
    status integer DEFAULT 1,
    type integer DEFAULT 0,
    marketplace integer DEFAULT 0,
    par_id integer,
    prefix character varying
);


ALTER TABLE product_rout_rate_table OWNER TO postgres;

--
-- Name: TABLE product_rout_rate_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE product_rout_rate_table IS 'product';


--
-- Name: COLUMN product_rout_rate_table.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product_rout_rate_table.status IS '0:Inactive
1:Active';


--
-- Name: COLUMN product_rout_rate_table.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product_rout_rate_table.type IS '0:Public
1:Private';


--
-- Name: COLUMN product_rout_rate_table.marketplace; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN product_rout_rate_table.marketplace IS '0:A-Z
1:US';


--
-- Name: product_rout_rate_table_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_rout_rate_table_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_rout_rate_table_id_seq OWNER TO postgres;

--
-- Name: product_rout_rate_table_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE product_rout_rate_table_id_seq OWNED BY product_rout_rate_table.id;


--
-- Name: product_rout_rate_table_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_rout_rate_table_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_rout_rate_table_record_record_id_seq OWNER TO postgres;

--
-- Name: product_rout_rate_table_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_rout_rate_table_record (
    id integer,
    rout_id integer,
    rate_table_id integer,
    product_name character varying(256),
    agent_id integer,
    status integer,
    type integer,
    marketplace integer,
    par_id integer,
    prefix character varying,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('product_rout_rate_table_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE product_rout_rate_table_record OWNER TO postgres;

--
-- Name: product_route_rate_table; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE product_route_rate_table (
    id integer NOT NULL,
    product_name character varying(100),
    route_strategy_id integer,
    rate_table_id integer,
    update_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_by character varying(100),
    tech_prefix prefix_range DEFAULT ''::prefix_range NOT NULL,
    is_private boolean DEFAULT false NOT NULL,
    description character varying(255)
);


ALTER TABLE product_route_rate_table OWNER TO postgres;

--
-- Name: product_route_rate_table_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE product_route_rate_table_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE product_route_rate_table_id_seq OWNER TO postgres;

--
-- Name: product_route_rate_table_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE product_route_rate_table_id_seq OWNED BY product_route_rate_table.id;


--
-- Name: qos_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE qos_ip (
    report_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    ip_id integer,
    call integer,
    cps integer,
    direction integer,
    server_ip character varying(50),
    server_port integer,
    channels integer
);


ALTER TABLE qos_ip OWNER TO postgres;

--
-- Name: qos_resource; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE qos_resource (
    report_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    res_id integer,
    call integer,
    cps integer,
    direction integer,
    server_ip character varying(50),
    server_port integer,
    channels integer
);


ALTER TABLE qos_resource OWNER TO postgres;

--
-- Name: qos_route_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE qos_route_report (
    report_time timestamp with time zone NOT NULL,
    resource_id integer,
    code character varying(32),
    not_zero_calls integer,
    total_calls integer,
    bill_time integer,
    cancel_calls integer,
    busy_calls integer,
    direction integer,
    server_ip character varying(36),
    pdd integer,
    cost numeric(12,6),
    call_duration integer,
    total_pdd integer
);


ALTER TABLE qos_route_report OWNER TO postgres;

--
-- Name: TABLE qos_route_report; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE qos_route_report IS 'ç»Ÿè®¡resource + codeçš„asr, acdç­‰ï¼Œä¿å­˜æ—¶é—´å¯ä»¥é™åˆ¶åœ¨ä¸€ä¸ªå°æ—¶ï¼Œä¸€ä¸ªå°æ—¶ä»¥å‰çš„åœ¨æŠ¥è¡¨æœåŠ¡å™¨å¯ä»¥æŸ¥è¯¢ã€‚';


--
-- Name: COLUMN qos_route_report.report_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN qos_route_report.report_time IS 'äº§ç”ŸæŠ¥è¡¨æ•°æ®çš„æ—¶é—´';


--
-- Name: COLUMN qos_route_report.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN qos_route_report.code IS 'ä¾‹å¦‚ï¼š86ï¼Œ86755ç­‰';


--
-- Name: COLUMN qos_route_report.bill_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN qos_route_report.bill_time IS 'ç§’å•ä½';


--
-- Name: COLUMN qos_route_report.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN qos_route_report.direction IS '0 --- ingress
1 --- egress';


--
-- Name: COLUMN qos_route_report.server_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN qos_route_report.server_ip IS 'switchçš„sip profile IP';


--
-- Name: qos_route_report_unlogged; Type: TABLE; Schema: public; Owner: postgres
--

CREATE UNLOGGED TABLE qos_route_report_unlogged (
    report_time timestamp with time zone NOT NULL,
    resource_id integer,
    code character varying(32),
    not_zero_calls integer,
    total_calls integer,
    bill_time integer,
    cancel_calls integer,
    busy_calls integer,
    direction integer,
    server_ip character varying(36),
    pdd integer,
    cost numeric(12,6)
);


ALTER TABLE qos_route_report_unlogged OWNER TO postgres;

--
-- Name: qos_total; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE qos_total (
    report_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    call integer,
    cps integer,
    server_ip character varying(50),
    server_port integer,
    channels integer,
    ingress_channels integer,
    egress_channels integer,
    ingress_cps integer,
    egress_cps integer
);


ALTER TABLE qos_total OWNER TO postgres;

--
-- Name: quick_cdr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE quick_cdr (
    id integer NOT NULL,
    status integer DEFAULT 0,
    start_date date,
    end_date date,
    file_path character varying(200),
    user_id integer,
    type integer,
    client_id integer
);


ALTER TABLE quick_cdr OWNER TO postgres;

--
-- Name: quick_cdr_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE quick_cdr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE quick_cdr_id_seq OWNER TO postgres;

--
-- Name: quick_cdr_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE quick_cdr_id_seq OWNED BY quick_cdr.id;


--
-- Name: random_ani_generation; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE random_ani_generation (
    id integer NOT NULL,
    ani_number character varying(32),
    random_table_id integer
);


ALTER TABLE random_ani_generation OWNER TO postgres;

--
-- Name: TABLE random_ani_generation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE random_ani_generation IS 'éšæœºæ›¿æ¢å‘¼å‡ºä¸»è§’å·ç ï¼Œé’ˆå¯¹ä¸åŒä¾›åº”å•†ä½¿ç”¨ä¸åŒå·ç ã€‚';


--
-- Name: COLUMN random_ani_generation.ani_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN random_ani_generation.ani_number IS 'éšæœºæ›¿æ¢çš„å·ç ã€‚';


--
-- Name: random_ani_generation_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE random_ani_generation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE random_ani_generation_id_seq OWNER TO postgres;

--
-- Name: random_ani_generation_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE random_ani_generation_id_seq OWNED BY random_ani_generation.id;


--
-- Name: random_ani_generation_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE random_ani_generation_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE random_ani_generation_record_record_id_seq OWNER TO postgres;

--
-- Name: random_ani_generation_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE random_ani_generation_record (
    id integer,
    ani_number character varying(32),
    random_table_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('random_ani_generation_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE random_ani_generation_record OWNER TO postgres;

--
-- Name: random_ani_populated_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE random_ani_populated_log (
    id integer NOT NULL,
    start_time timestamp without time zone,
    finsh_time timestamp without time zone,
    prefix character varying(32),
    number_of_digits integer,
    total_num integer,
    success_num integer,
    duplicate_num integer,
    pid integer,
    status integer,
    random_table_id integer
);


ALTER TABLE random_ani_populated_log OWNER TO postgres;

--
-- Name: COLUMN random_ani_populated_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN random_ani_populated_log.status IS '"Waiting", "In Progress", "Done",''Killed''';


--
-- Name: random_ani_populated_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE random_ani_populated_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE random_ani_populated_log_id_seq OWNER TO postgres;

--
-- Name: random_ani_populated_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE random_ani_populated_log_id_seq OWNED BY random_ani_populated_log.id;


--
-- Name: random_ani_table; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE random_ani_table (
    id integer NOT NULL,
    name character varying(100),
    create_time timestamp with time zone
);


ALTER TABLE random_ani_table OWNER TO postgres;

--
-- Name: COLUMN random_ani_table.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN random_ani_table.name IS 'ä¸»å«éšæœºæ›¿æ¢è¡¨åå­—';


--
-- Name: random_ani_table_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE random_ani_table_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE random_ani_table_id_seq OWNER TO postgres;

--
-- Name: random_ani_table_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE random_ani_table_id_seq OWNED BY random_ani_table.id;


--
-- Name: rate_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_rate_id_seq OWNER TO postgres;

--
-- Name: rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate (
    rate_id integer DEFAULT nextval('rate_rate_id_seq'::regclass) NOT NULL,
    rate_table_id integer NOT NULL,
    code prefix_range DEFAULT ''::prefix_range NOT NULL,
    rate numeric(30,10),
    setup_fee numeric(30,10) DEFAULT 0 NOT NULL,
    effective_date timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_date timestamp with time zone,
    min_time integer DEFAULT 1 NOT NULL,
    grace_time integer DEFAULT 0 NOT NULL,
    "interval" integer DEFAULT 1 NOT NULL,
    time_profile_id integer,
    seconds integer DEFAULT 60 NOT NULL,
    code_name character varying(100),
    basic_percentages real DEFAULT 0,
    gift_percentages real DEFAULT 0,
    rate_type integer DEFAULT 3 NOT NULL,
    intra_rate numeric(30,10),
    inter_rate numeric(30,10),
    local_rate numeric(30,10),
    country character varying(1000),
    zone character varying(10) DEFAULT 0,
    ocn character varying(10),
    lata character varying(10),
    create_time timestamp with time zone,
    did_type integer
);


ALTER TABLE rate OWNER TO postgres;

--
-- Name: TABLE rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rate IS 'è¯¦ç»†è´¹çŽ‡';


--
-- Name: COLUMN rate.rate_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.rate_id IS 'ä¸»é”®';


--
-- Name: COLUMN rate.rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.rate_table_id IS 'rate_table';


--
-- Name: COLUMN rate.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.code IS 'å‰ç¼€å·ç 
å’Œcdrè¡¨çš„è¢«å«å·åŒ¹é… ';


--
-- Name: COLUMN rate.rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.rate IS 'æ¯åˆ†é’Ÿè´¹ç”¨';


--
-- Name: COLUMN rate.setup_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.setup_fee IS 'å›ºå®šè´¹ç”¨';


--
-- Name: COLUMN rate.effective_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.effective_date IS 'å¼€å§‹æ—¶é—´

';


--
-- Name: COLUMN rate.end_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.end_date IS 'ç»“æŸæ—¶é—´';


--
-- Name: COLUMN rate.min_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.min_time IS 'é¦–æ¬¡æ—¶é•¿(ç§’)';


--
-- Name: COLUMN rate.grace_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.grace_time IS 'å…è´¹æ—¶é•¿(ç§’)';


--
-- Name: COLUMN rate."interval"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate."interval" IS 'è®¡è´¹å‘¨æœŸ
6ç§’è®¡è´¹
ä¸è¶³6ç§’çš„è¦è¡¥
8ç§’ç®—2ä¸ª6ç§’

';


--
-- Name: COLUMN rate.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.time_profile_id IS 'æ—¶é—´æ®µè®¾ç½®';


--
-- Name: COLUMN rate.seconds; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.seconds IS 'æ¯åˆ†é’Ÿå¤šå°‘ç§’';


--
-- Name: COLUMN rate.code_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.code_name IS 'å·ç åç§°';


--
-- Name: COLUMN rate.basic_percentages; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.basic_percentages IS 'åŸºç¡€é‡‘æ¯”ä¾‹';


--
-- Name: COLUMN rate.gift_percentages; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.gift_percentages IS 'èµ é€é‡‘æ¯”ä¾‹';


--
-- Name: COLUMN rate.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.rate_type IS '1ï¼ï¼interstateï¼Œä¸åŒçš„åœ°åŒº
2ï¼ï¼intrastateï¼ŒåŒä¸€ä¸ªåœ°åŒº
3ï¼ï¼othersï¼Œå…¶ä»–';


--
-- Name: COLUMN rate.intra_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.intra_rate IS '2ï¼ï¼intrastateï¼ŒåŒä¸€ä¸ªåœ°åŒº';


--
-- Name: COLUMN rate.inter_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.inter_rate IS '1ï¼ï¼interstateï¼Œä¸åŒçš„åœ°åŒº';


--
-- Name: COLUMN rate.did_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate.did_type IS '1:æœªåˆ†é…;2:å·²åˆ†é…';


--
-- Name: rate_auto_create; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_auto_create (
    id integer NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    ingress_id integer,
    status integer DEFAULT 0,
    rate_order integer,
    result_file character varying,
    client_id integer,
    rate_effective_date timestamp with time zone,
    product_id integer,
    code_name text,
    decrease_days integer,
    increase_days integer,
    keep_old_rate integer,
    rate_min_time integer,
    rate_interval integer,
    mass_edit_log_id integer,
    new_days integer,
    remove_code integer,
    us_trunks character varying,
    rate_from integer DEFAULT 1 NOT NULL,
    us_type integer DEFAULT 1 NOT NULL
);


ALTER TABLE rate_auto_create OWNER TO postgres;

--
-- Name: TABLE rate_auto_create; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rate_auto_create IS 'agent è‡ªåŠ¨ç”Ÿæˆè´¹çŽ‡';


--
-- Name: COLUMN rate_auto_create.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_auto_create.status IS '0-waiting
1-running
2-done
-1-open file error
-2-args not set';


--
-- Name: COLUMN rate_auto_create.rate_order; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_auto_create.rate_order IS '0-max';


--
-- Name: COLUMN rate_auto_create.keep_old_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_auto_create.keep_old_rate IS '1-old rate no change';


--
-- Name: COLUMN rate_auto_create.us_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_auto_create.us_type IS '1;us jd (has intre,intra)
2:us no jd(no intre,intra)';


--
-- Name: rate_auto_create_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_auto_create_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_auto_create_id_seq OWNER TO postgres;

--
-- Name: rate_auto_create_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_auto_create_id_seq OWNED BY rate_auto_create.id;


--
-- Name: rate_auto_create_interval; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_auto_create_interval (
    id integer NOT NULL,
    rate_auto_create_id integer,
    rate_min_time integer,
    rate_interval integer,
    rate_country character varying(256)
);


ALTER TABLE rate_auto_create_interval OWNER TO postgres;

--
-- Name: rate_auto_create_interval_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_auto_create_interval_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_auto_create_interval_id_seq OWNER TO postgres;

--
-- Name: rate_auto_create_interval_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_auto_create_interval_id_seq OWNED BY rate_auto_create_interval.id;


--
-- Name: rate_auto_create_profit; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_auto_create_profit (
    id integer NOT NULL,
    rate_auto_create_id integer,
    profit_type integer,
    profit_amount real,
    min_rate real,
    max_rate real,
    rate_type integer,
    is_default boolean DEFAULT false NOT NULL
);


ALTER TABLE rate_auto_create_profit OWNER TO postgres;

--
-- Name: COLUMN rate_auto_create_profit.profit_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_auto_create_profit.profit_type IS '0-percent
1-amout';


--
-- Name: COLUMN rate_auto_create_profit.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_auto_create_profit.rate_type IS '0 : percenage
1  :  fixed profit ç›´æŽ¥ç›¸åŠ ';


--
-- Name: rate_auto_create_profit_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_auto_create_profit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_auto_create_profit_id_seq OWNER TO postgres;

--
-- Name: rate_auto_create_profit_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_auto_create_profit_id_seq OWNED BY rate_auto_create_profit.id;


--
-- Name: rate_auto_diff; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_auto_diff (
    id integer NOT NULL,
    source_file character varying(100),
    diff_file character varying(100),
    result_file character varying(100),
    effective_date timestamp with time zone,
    decrease_days integer,
    increase_days integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    status integer DEFAULT 0,
    client_id integer
);


ALTER TABLE rate_auto_diff OWNER TO postgres;

--
-- Name: COLUMN rate_auto_diff.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_auto_diff.status IS '0-waiting
1-running
2-done
-1-open file error
-2-csv file error';


--
-- Name: rate_auto_diff_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_auto_diff_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_auto_diff_id_seq OWNER TO postgres;

--
-- Name: rate_auto_diff_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_auto_diff_id_seq OWNED BY rate_auto_diff.id;


--
-- Name: rate_download_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_download_log (
    id integer NOT NULL,
    resource_id integer,
    file_path character varying,
    download_time timestamp with time zone,
    download_ip character varying,
    log_detail_id integer
);


ALTER TABLE rate_download_log OWNER TO postgres;

--
-- Name: rate_download_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_download_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_download_log_id_seq OWNER TO postgres;

--
-- Name: rate_download_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_download_log_id_seq OWNED BY rate_download_log.id;


--
-- Name: rate_email_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_email_template (
    id integer NOT NULL,
    email_cc character varying(200),
    subject text,
    content text,
    email_from character varying(20),
    name character varying(50),
    headers character varying(500),
    download_method integer
);


ALTER TABLE rate_email_template OWNER TO postgres;

--
-- Name: COLUMN rate_email_template.download_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_email_template.download_method IS '1:Send as attachment;2:Send as link';


--
-- Name: rate_email_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_email_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_email_template_id_seq OWNER TO postgres;

--
-- Name: rate_email_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_email_template_id_seq OWNED BY rate_email_template.id;


--
-- Name: rate_generate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_generate (
    id integer NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    rate_type integer NOT NULL,
    max_selected integer NOT NULL,
    result_file character varying(256),
    client_id integer,
    rate_deck_file character varying(100),
    status integer DEFAULT 0 NOT NULL,
    finish_time timestamp with time zone,
    rate_deck_csv_heads character varying,
    rate_deck_csv_line integer,
    active integer DEFAULT 1 NOT NULL,
    analysis_file character varying
);


ALTER TABLE rate_generate OWNER TO postgres;

--
-- Name: COLUMN rate_generate.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_generate.status IS '0-waiting
1-processing
2-complete
-1-open file error
-2-csv file head error';


--
-- Name: rate_generate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_generate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_generate_id_seq OWNER TO postgres;

--
-- Name: rate_generate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_generate_id_seq OWNED BY rate_generate.id;


--
-- Name: rate_generation_code_deck; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_generation_code_deck (
    rate_generation_template_id integer,
    code character varying(30),
    code_name character varying(100),
    country character varying(100)
);


ALTER TABLE rate_generation_code_deck OWNER TO postgres;

--
-- Name: rate_generation_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_generation_history (
    id integer NOT NULL,
    is_applied boolean DEFAULT false,
    rate_generation_template_id integer,
    status smallint DEFAULT 0 NOT NULL,
    finished_time timestamp with time zone,
    rate_count integer DEFAULT 0 NOT NULL,
    processing_time integer DEFAULT 0 NOT NULL,
    progress character varying(200),
    create_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    create_by character varying(100),
    rate_table_type integer
);


ALTER TABLE rate_generation_history OWNER TO postgres;

--
-- Name: COLUMN rate_generation_history.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_generation_history.status IS '0 for initial; 1 for in process, 2 for finished; 3 for error';


--
-- Name: rate_generation_history_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_generation_history_detail (
    id integer NOT NULL,
    rate_table_id integer,
    effective_date_new timestamp with time zone,
    effective_date_increase timestamp with time zone,
    effective_date_decrease timestamp with time zone,
    is_send_mail boolean,
    end_date date,
    email_template_id integer,
    rate_generation_history_id integer,
    create_on timestamp with time zone,
    create_by character varying(100),
    finished_time timestamp with time zone,
    end_date_method integer DEFAULT 1,
    rand_flg character varying(100),
    new_rate_end_date date
);


ALTER TABLE rate_generation_history_detail OWNER TO postgres;

--
-- Name: COLUMN rate_generation_history_detail.end_date_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_generation_history_detail.end_date_method IS '1   => ''Duplicated Codes Only'',
2   =>  ''Code with Rate Changed Only'',
3   =>  ''All Codes''';


--
-- Name: rate_generation_history_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_generation_history_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_generation_history_detail_id_seq OWNER TO postgres;

--
-- Name: rate_generation_history_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_generation_history_detail_id_seq OWNED BY rate_generation_history_detail.id;


--
-- Name: rate_generation_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_generation_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_generation_history_id_seq OWNER TO postgres;

--
-- Name: rate_generation_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_generation_history_id_seq OWNED BY rate_generation_history.id;


--
-- Name: rate_generation_rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_generation_rate (
    rate_generation_history_id integer NOT NULL,
    code prefix_range DEFAULT ''::prefix_range NOT NULL,
    rate numeric(30,10),
    setup_fee numeric(30,10) DEFAULT 0 NOT NULL,
    effective_date timestamp with time zone,
    end_date timestamp with time zone,
    min_time integer DEFAULT 0 NOT NULL,
    grace_time integer DEFAULT 0 NOT NULL,
    "interval" integer DEFAULT 1 NOT NULL,
    time_profile_id integer,
    seconds integer DEFAULT 60 NOT NULL,
    code_name character varying(100),
    rate_type integer DEFAULT 3 NOT NULL,
    intra_rate numeric(30,10),
    inter_rate numeric(30,10),
    local_rate numeric(30,10),
    country character varying(1000),
    zone character varying(10) DEFAULT 0,
    ocn character varying(10),
    lata character varying(10),
    generation_rate_id integer NOT NULL,
    lcr_rate character varying(100),
    lcr_intra_rate character varying(100),
    lcr_inter_rate character varying(100),
    lcr_local_rate character varying(100)
);


ALTER TABLE rate_generation_rate OWNER TO postgres;

--
-- Name: rate_generation_rate_generation_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_generation_rate_generation_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_generation_rate_generation_rate_id_seq OWNER TO postgres;

--
-- Name: rate_generation_rate_generation_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_generation_rate_generation_rate_id_seq OWNED BY rate_generation_rate.generation_rate_id;


--
-- Name: rate_generation_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_generation_template (
    id integer NOT NULL,
    name character varying(50),
    include_blocked_route boolean DEFAULT false,
    rate_table_type integer DEFAULT 1 NOT NULL,
    lcr_digit integer,
    default_rate numeric(30,10),
    margin_default_type integer,
    margin_default_value character varying(30),
    default_interval integer,
    default_min_time integer,
    create_by character varying(100),
    create_on timestamp with time zone,
    last_generated timestamp with time zone,
    code_deck_id integer,
    egress_str character varying(500),
    include_local_rate boolean DEFAULT false,
    effective_days integer DEFAULT 0,
    decimal_places integer DEFAULT 0,
    user_defined_code_deck boolean DEFAULT false
);


ALTER TABLE rate_generation_template OWNER TO postgres;

--
-- Name: COLUMN rate_generation_template.rate_table_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_generation_template.rate_table_type IS '0 for A-Z; 1 for US Jurisdictional; 2 for US Non Jurisdictional, 3 for OCN-LATA';


--
-- Name: COLUMN rate_generation_template.lcr_digit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_generation_template.lcr_digit IS 'Which LCR selection';


--
-- Name: COLUMN rate_generation_template.default_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_generation_template.default_rate IS 'Default rate if no egress is available';


--
-- Name: COLUMN rate_generation_template.margin_default_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_generation_template.margin_default_type IS '1 for Percentage; 2 for Fix Value';


--
-- Name: COLUMN rate_generation_template.egress_str; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_generation_template.egress_str IS 'Egress trunk list, format: trunk_1_id,trunk_1_rate_table_id;trunk_2_id,trunk_2_rate_table_id;...';


--
-- Name: COLUMN rate_generation_template.decimal_places; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_generation_template.decimal_places IS '0 for use system default, other is rate decimal places';


--
-- Name: rate_generation_template_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_generation_template_detail (
    id integer NOT NULL,
    rate_generation_template_id integer,
    rate_interval integer,
    min_time integer,
    code character varying(50)
);


ALTER TABLE rate_generation_template_detail OWNER TO postgres;

--
-- Name: rate_generation_template_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_generation_template_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_generation_template_detail_id_seq OWNER TO postgres;

--
-- Name: rate_generation_template_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_generation_template_detail_id_seq OWNED BY rate_generation_template_detail.id;


--
-- Name: rate_generation_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_generation_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_generation_template_id_seq OWNER TO postgres;

--
-- Name: rate_generation_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_generation_template_id_seq OWNED BY rate_generation_template.id;


--
-- Name: rate_generation_template_margin; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_generation_template_margin (
    id integer NOT NULL,
    rate_generation_template_id integer,
    min_rate numeric(30,10),
    max_rate numeric(30,10),
    markup_type integer,
    markup_value numeric(30,10)
);


ALTER TABLE rate_generation_template_margin OWNER TO postgres;

--
-- Name: COLUMN rate_generation_template_margin.markup_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_generation_template_margin.markup_type IS '1 for Percentage; 2 for Fix Value';


--
-- Name: rate_generation_template_margin_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_generation_template_margin_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_generation_template_margin_id_seq OWNER TO postgres;

--
-- Name: rate_generation_template_margin_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_generation_template_margin_id_seq OWNED BY rate_generation_template_margin.id;


--
-- Name: rate_handler; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_handler (
    id integer NOT NULL,
    rate_delivery_to character varying(255) NOT NULL,
    mail_password character varying(255),
    imap_host character varying(255),
    imap_port integer,
    mail_ssl smallint DEFAULT 0,
    smtp_port integer,
    mail_tls smallint DEFAULT 0,
    smtp_host character varying(255)
);


ALTER TABLE rate_handler OWNER TO postgres;

--
-- Name: rate_handler_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_handler_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_handler_id_seq OWNER TO postgres;

--
-- Name: rate_handler_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_handler_id_seq OWNED BY rate_handler.id;


--
-- Name: rate_import_error_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_import_error_log (
    id integer NOT NULL,
    import_log_id integer,
    error_line integer,
    rate numeric(30,10),
    effective_date timestamp with time zone,
    error_info character varying(500)
);


ALTER TABLE rate_import_error_log OWNER TO postgres;

--
-- Name: rate_import_error_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_import_error_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_import_error_log_id_seq OWNER TO postgres;

--
-- Name: rate_import_error_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_import_error_log_id_seq OWNED BY rate_import_error_log.id;


--
-- Name: rate_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_info (
    "time" character varying(100),
    asr character varying(100),
    asr_count character varying(100),
    acd character varying(100),
    acd_count character varying(100),
    code character varying(100),
    rate_table_id character varying(100),
    call_count character varying(100)
);


ALTER TABLE rate_info OWNER TO postgres;

--
-- Name: rate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_log (
    user_id integer NOT NULL,
    old_rateinfo character varying(500),
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    rate_id integer,
    rate numeric(30,10),
    setup_fee numeric(30,10),
    effective_date timestamp without time zone,
    end_date timestamp without time zone
);


ALTER TABLE rate_log OWNER TO postgres;

--
-- Name: rate_mail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_mail (
    id integer NOT NULL,
    from_address character varying(100) NOT NULL,
    from_name character varying(100) NOT NULL,
    subject character varying(100) NOT NULL,
    content text NOT NULL,
    mail_password character varying(100),
    name character varying
);


ALTER TABLE rate_mail OWNER TO postgres;

--
-- Name: rate_mail_decks; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_mail_decks (
    id integer NOT NULL,
    type integer,
    received_time timestamp with time zone,
    client_id integer,
    from_address character varying(255),
    num_of_attachment integer,
    success integer,
    fail integer,
    mail_content text,
    mail_subject character varying(255),
    "to" character varying(255)
);


ALTER TABLE rate_mail_decks OWNER TO postgres;

--
-- Name: COLUMN rate_mail_decks.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_mail_decks.type IS '0 --- process&unproccess
1 -- unrecognized';


--
-- Name: rate_mail_decks_files; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_mail_decks_files (
    id integer NOT NULL,
    file_name character varying(255),
    upload_time timestamp with time zone,
    rate_mail_decks_id integer,
    rate_upload_id integer,
    original_filename character varying(255),
    file_type integer DEFAULT 0,
    file_size integer
);


ALTER TABLE rate_mail_decks_files OWNER TO postgres;

--
-- Name: COLUMN rate_mail_decks_files.file_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_mail_decks_files.file_type IS '0 - csv
1 - xls';


--
-- Name: rate_mail_decks_files_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_mail_decks_files_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_mail_decks_files_id_seq OWNER TO postgres;

--
-- Name: rate_mail_decks_files_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_mail_decks_files_id_seq OWNED BY rate_mail_decks_files.id;


--
-- Name: rate_mail_decks_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_mail_decks_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_mail_decks_id_seq OWNER TO postgres;

--
-- Name: rate_mail_decks_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_mail_decks_id_seq OWNED BY rate_mail_decks.id;


--
-- Name: rate_mail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_mail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_mail_id_seq OWNER TO postgres;

--
-- Name: rate_mail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_mail_id_seq OWNED BY rate_mail.id;


--
-- Name: rate_management; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_management (
    id integer NOT NULL,
    received_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    from_address character varying(255),
    to_address character varying(255),
    mail_subject character varying,
    mail_content character varying,
    success integer DEFAULT 0,
    failed integer DEFAULT 0
);


ALTER TABLE rate_management OWNER TO postgres;

--
-- Name: rate_management_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_management_detail (
    id integer NOT NULL,
    rate_management_id integer,
    status integer DEFAULT 0,
    upload_time timestamp with time zone,
    file_path character varying,
    log_id integer,
    email_when_done integer DEFAULT 0,
    file_type smallint DEFAULT 0,
    orig_file_name character varying,
    server_id integer,
    rate_table_id integer,
    rate_table_name character varying(255),
    rate_handler_id integer
);


ALTER TABLE rate_management_detail OWNER TO postgres;

--
-- Name: rate_management_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_management_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_management_detail_id_seq OWNER TO postgres;

--
-- Name: rate_management_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_management_detail_id_seq OWNED BY rate_management_detail.id;


--
-- Name: rate_management_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_management_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_management_id_seq OWNER TO postgres;

--
-- Name: rate_management_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_management_id_seq OWNED BY rate_management.id;


--
-- Name: rate_management_option; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_management_option (
    id integer NOT NULL,
    rate_table_id integer,
    email_received_from character varying(100),
    subject_keyword character varying(100),
    filename_keyword character varying(100),
    start_from_line integer,
    headers character varying(200),
    effective_date_default timestamp without time zone,
    end_date_default timestamp without time zone,
    min_time_default integer,
    interval_default integer,
    increase_handle_type integer,
    increase_rule_time integer,
    newcode_handle_type integer,
    newcode_rule_time integer,
    success_notification_to integer,
    failure_notification_to integer,
    effective_date_format character varying(50),
    dup_method integer,
    dup_end_date timestamp without time zone,
    dup_end_date_tz character(5),
    dup_end_date_all timestamp without time zone,
    dup_end_date_all_tz character(5),
    with_header boolean DEFAULT false,
    code_name_match integer
);


ALTER TABLE rate_management_option OWNER TO postgres;

--
-- Name: COLUMN rate_management_option.increase_handle_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.increase_handle_type IS '1:Reject Specific Rate Record
2:Entire Rate Notice';


--
-- Name: COLUMN rate_management_option.increase_rule_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.increase_rule_time IS 'days';


--
-- Name: COLUMN rate_management_option.newcode_handle_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.newcode_handle_type IS '1:Reject Specific Rate Record
2:Entire Rate Notice';


--
-- Name: COLUMN rate_management_option.newcode_rule_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.newcode_rule_time IS 'days';


--
-- Name: COLUMN rate_management_option.success_notification_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.success_notification_to IS '1:Vendor
2:Owner Email
3:both';


--
-- Name: COLUMN rate_management_option.failure_notification_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.failure_notification_to IS '1:Vendor
2:Owner Email
3:both';


--
-- Name: COLUMN rate_management_option.effective_date_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.effective_date_format IS '''mm/dd/yyyy'',
''yyyy-mm-dd'',
''mm/dd/yyyy'',
''dd/mm/yyyy'',
''yyyy/mm/dd''';


--
-- Name: COLUMN rate_management_option.dup_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.dup_method IS '1:Delete Existing Records
2:End-Date Existing Records
0:End-Date All Records';


--
-- Name: COLUMN rate_management_option.dup_end_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.dup_end_date IS 'when dup_method =2(End-Date Existing Records)';


--
-- Name: COLUMN rate_management_option.dup_end_date_tz; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.dup_end_date_tz IS 'when dup_method =2(End-Date Existing Records)';


--
-- Name: COLUMN rate_management_option.dup_end_date_all; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.dup_end_date_all IS 'when dup_method =0(End-Date All Records)';


--
-- Name: COLUMN rate_management_option.dup_end_date_all_tz; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.dup_end_date_all_tz IS 'when dup_method =0(End-Date All Records)';


--
-- Name: COLUMN rate_management_option.code_name_match; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_management_option.code_name_match IS '1:Re-populate Country and Code Name with Selected Code Deck
2:Re-populate Country and Code Name with Selected Code Deck if not available';


--
-- Name: rate_management_option_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_management_option_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_management_option_id_seq OWNER TO postgres;

--
-- Name: rate_management_option_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_management_option_id_seq OWNED BY rate_management_option.id;


--
-- Name: rate_mass_edit_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_mass_edit_log (
    id integer NOT NULL,
    action_time timestamp with time zone,
    client_id integer,
    action_type smallint,
    down_file_path text,
    rate_table_id integer,
    action_rate_rows integer
);


ALTER TABLE rate_mass_edit_log OWNER TO postgres;

--
-- Name: COLUMN rate_mass_edit_log.action_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_mass_edit_log.action_type IS '0 => ''delete found rates'',
1 => ''insert as new rates'',
2 => ''update current rates'',
3 => ''update all rates'',';


--
-- Name: rate_mass_edit_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_mass_edit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_mass_edit_log_id_seq OWNER TO postgres;

--
-- Name: rate_mass_edit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_mass_edit_log_id_seq OWNED BY rate_mass_edit_log.id;


--
-- Name: rate_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_record_record_id_seq OWNER TO postgres;

--
-- Name: rate_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_record (
    rate_id integer,
    rate_table_id integer,
    code prefix_range,
    rate numeric(30,10),
    setup_fee numeric(30,10),
    effective_date timestamp with time zone,
    end_date timestamp with time zone,
    min_time integer,
    grace_time integer,
    "interval" integer,
    time_profile_id integer,
    seconds integer,
    code_name character varying(100),
    basic_percentages real,
    gift_percentages real,
    rate_type integer,
    intra_rate numeric(30,10),
    inter_rate numeric(30,10),
    local_rate numeric(30,10),
    country character varying(1000),
    zone character varying(10),
    ocn character varying(10),
    lata character varying(10),
    create_time timestamp with time zone,
    did_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('rate_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE rate_record OWNER TO postgres;

--
-- Name: rate_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: rate_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_record_tmp (
    rate_id integer,
    rate_table_id integer,
    code prefix_range,
    rate numeric(30,10),
    setup_fee numeric(30,10),
    effective_date timestamp with time zone,
    end_date timestamp with time zone,
    min_time integer,
    grace_time integer,
    "interval" integer,
    time_profile_id integer,
    seconds integer,
    code_name character varying(100),
    basic_percentages real,
    gift_percentages real,
    rate_type integer,
    intra_rate numeric(30,10),
    inter_rate numeric(30,10),
    local_rate numeric(30,10),
    country character varying(1000),
    zone character varying(10),
    ocn character varying(10),
    lata character varying(10),
    create_time timestamp with time zone,
    did_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('rate_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE rate_record_tmp OWNER TO postgres;

--
-- Name: rate_send_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_send_log (
    rate_table_id integer NOT NULL,
    status smallint NOT NULL,
    zip smallint,
    file character varying(500),
    error character varying(500),
    format smallint NOT NULL,
    id integer NOT NULL,
    email_template_id integer NOT NULL,
    create_time timestamp with time zone,
    effective_date character varying(50),
    start_effective_date character varying(50),
    download_deadline date,
    is_email_alert boolean DEFAULT false NOT NULL,
    is_disable boolean DEFAULT false NOT NULL,
    is_temp boolean DEFAULT false,
    headers character varying(500),
    send_type integer DEFAULT 0,
    send_specify_email character varying,
    resource_ids character varying(500),
    download_method integer DEFAULT 1,
    total_records integer,
    completed_records integer,
    sent_area integer DEFAULT 1
);


ALTER TABLE rate_send_log OWNER TO postgres;

--
-- Name: COLUMN rate_send_log.rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_send_log.rate_table_id IS 'å‘é€è´¹çŽ‡çš„ rate table id ';


--
-- Name: COLUMN rate_send_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_send_log.status IS '1:æ­£åœ¨æ‰§è¡Œ
2:å‘é€æˆåŠŸ
3:å‘é€å¤±è´¥';


--
-- Name: COLUMN rate_send_log.zip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_send_log.zip IS '1ï¼šæ‰“åŒ…
2ï¼šæ²¡æœ‰æ‰“åŒ…';


--
-- Name: COLUMN rate_send_log.file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_send_log.file IS 'å‘é€çš„rateæ–‡ä»¶';


--
-- Name: COLUMN rate_send_log.error; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_send_log.error IS 'é”™è¯¯çš„æç¤º';


--
-- Name: COLUMN rate_send_log.format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_send_log.format IS '1:csv
2:xls';


--
-- Name: COLUMN rate_send_log.effective_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_send_log.effective_date IS 'å‘å‡ºåŽ»è´¹çŽ‡çš„ç”Ÿæ•ˆæ—¥æœŸèŒƒå›´';


--
-- Name: COLUMN rate_send_log.download_deadline; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_send_log.download_deadline IS 'ä¸‹è½½æˆªè‡³æ—¥æœŸ';


--
-- Name: rate_send_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_send_log_detail (
    id integer NOT NULL,
    log_id integer,
    resource_id integer,
    send_to character varying(100),
    status integer,
    error text,
    salt character varying,
    download_date date,
    sent_on timestamp with time zone
);


ALTER TABLE rate_send_log_detail OWNER TO postgres;

--
-- Name: rate_send_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_send_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_send_log_detail_id_seq OWNER TO postgres;

--
-- Name: rate_send_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_send_log_detail_id_seq OWNED BY rate_send_log_detail.id;


--
-- Name: rate_send_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_send_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_send_log_id_seq OWNER TO postgres;

--
-- Name: rate_send_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_send_log_id_seq OWNED BY rate_send_log.id;


--
-- Name: rate_send_logging; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_send_logging (
    id integer NOT NULL,
    log_datetime timestamp with time zone,
    data text,
    file character varying(500),
    status integer
);


ALTER TABLE rate_send_logging OWNER TO postgres;

--
-- Name: COLUMN rate_send_logging.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_send_logging.status IS '0 - succeed
1- db error
2- smtp error
3- other error';


--
-- Name: rate_send_logging_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_send_logging_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_send_logging_id_seq OWNER TO postgres;

--
-- Name: rate_send_logging_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_send_logging_id_seq OWNED BY rate_send_logging.id;


--
-- Name: rate_send_rules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_send_rules (
    from_email text,
    subject_keyword text,
    mail_server_ip character varying,
    file_type smallint DEFAULT 0,
    start_from_row smallint DEFAULT 0,
    effect_rate_keyword character varying,
    rate_col smallint,
    code_col smallint,
    code_name_col smallint,
    country_code text,
    effective_date_col smallint,
    end_date_col smallint,
    inter_rate_col smallint,
    intra_rate_col smallint,
    local_rate_col smallint,
    rate_status_col smallint,
    id integer NOT NULL,
    resource_id integer DEFAULT 0 NOT NULL,
    date_pattern character varying,
    violation_action smallint DEFAULT 0,
    min_lead_time smallint DEFAULT 7,
    special_rule_case character varying,
    special boolean DEFAULT false,
    rule_name character varying,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    min_time integer DEFAULT 1,
    "interval" integer DEFAULT 1,
    country_col smallint,
    multiple_codes boolean DEFAULT false,
    code_delimiter character varying,
    min_lead_time_del_code integer,
    min_lead_time_new_code integer,
    min_lead_time_inc_rate integer,
    active boolean,
    read_effective_rate_from_subject smallint DEFAULT 0,
    blocked boolean DEFAULT false
);


ALTER TABLE rate_send_rules OWNER TO postgres;

--
-- Name: COLUMN rate_send_rules.file_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_send_rules.file_type IS '0: xls, 1: xlsx,2: csv';


--
-- Name: rate_send_rules_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_send_rules_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_send_rules_id_seq OWNER TO postgres;

--
-- Name: rate_send_rules_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_send_rules_id_seq OWNED BY rate_send_rules.id;


--
-- Name: rate_table_rate_table_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_table_rate_table_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE rate_table_rate_table_id_seq OWNER TO postgres;

--
-- Name: rate_table; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_table (
    rate_table_id integer DEFAULT nextval('rate_table_rate_table_id_seq'::regclass) NOT NULL,
    name character varying(100) NOT NULL,
    modify_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    code_deck_id integer,
    currency_id integer NOT NULL,
    rate_type integer DEFAULT 0,
    jurisdiction_country_id integer,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    lnp_dipping_rate real,
    jurisdiction_prefix prefix_range,
    noprefix_min_length integer,
    noprefix_max_length integer,
    prefix_min_length integer,
    prefix_max_length integer,
    jur_type smallint DEFAULT 0,
    origination boolean DEFAULT false,
    is_virtual boolean,
    define_by integer DEFAULT 0
);


ALTER TABLE rate_table OWNER TO postgres;

--
-- Name: TABLE rate_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rate_table IS 'è´¹çŽ‡æ¨¡æ¿';


--
-- Name: COLUMN rate_table.rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table.rate_table_id IS 'ä¸»é”®';


--
-- Name: COLUMN rate_table.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table.name IS 'åç§°';


--
-- Name: COLUMN rate_table.modify_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table.modify_time IS 'ä¸Šæ¬¡ä¿®æ”¹æ—¶é—´';


--
-- Name: COLUMN rate_table.create_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table.create_time IS 'ç”Ÿæˆæ—¶é—´';


--
-- Name: COLUMN rate_table.code_deck_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table.code_deck_id IS 'å‰ç¼€å·ç ç»„';


--
-- Name: COLUMN rate_table.currency_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table.currency_id IS 'è´§å¸';


--
-- Name: COLUMN rate_table.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table.rate_type IS '0-dnis
1-lrn
2-lrn block';


--
-- Name: COLUMN rate_table.jurisdiction_country_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table.jurisdiction_country_id IS 'è®¡è´¹åŒºåŸŸå›½å®¶ï¼Œæœ‰å€¼è¡¨ç¤ºè´¹çŽ‡æ˜¯æŒ‰ç…§intra/interæ¥è®¡ç®—ï¼Œæ²¡æœ‰å€¼è¡¨ç¤ºdnisè®¡è´¹ã€‚';


--
-- Name: rate_table_code_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_table_code_ref (
    "time" bigint,
    rate_table_id integer,
    code character varying(100),
    rate numeric,
    code_name character varying(100)
);


ALTER TABLE rate_table_code_ref OWNER TO postgres;

--
-- Name: TABLE rate_table_code_ref; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rate_table_code_ref IS 'exchangeä½¿ç”¨ï¼Œrate tableå’Œcodeï¼Œrateå¯¹åº”è¡¨';


--
-- Name: COLUMN rate_table_code_ref."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table_code_ref."time" IS 'è®°å½•äº§ç”Ÿæ—¶é—´';


--
-- Name: COLUMN rate_table_code_ref.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table_code_ref.code IS 'å¯¹åº”è´¹çŽ‡è¡¨é‡Œçš„codeï¼Œè€Œä¸æ˜¯code_decké‡Œçš„code';


--
-- Name: COLUMN rate_table_code_ref.rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_table_code_ref.rate IS 'codeçš„è´¹çŽ‡';


--
-- Name: rate_table_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_table_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_table_record_record_id_seq OWNER TO postgres;

--
-- Name: rate_table_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_table_record (
    rate_table_id integer,
    name character varying(100),
    modify_time timestamp with time zone,
    create_time timestamp with time zone,
    code_deck_id integer,
    currency_id integer,
    rate_type integer,
    jurisdiction_country_id integer,
    update_at timestamp with time zone,
    update_by character varying,
    lnp_dipping_rate real,
    jurisdiction_prefix prefix_range,
    noprefix_min_length integer,
    noprefix_max_length integer,
    prefix_min_length integer,
    prefix_max_length integer,
    jur_type smallint,
    origination boolean,
    is_virtual boolean,
    define_by integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('rate_table_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE rate_table_record OWNER TO postgres;

--
-- Name: rate_table_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_table_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_table_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: rate_table_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_table_record_tmp (
    rate_table_id integer,
    name character varying(100),
    modify_time timestamp with time zone,
    create_time timestamp with time zone,
    code_deck_id integer,
    currency_id integer,
    rate_type integer,
    jurisdiction_country_id integer,
    update_at timestamp with time zone,
    update_by character varying,
    lnp_dipping_rate real,
    jurisdiction_prefix prefix_range,
    noprefix_min_length integer,
    noprefix_max_length integer,
    prefix_min_length integer,
    prefix_max_length integer,
    jur_type smallint,
    origination boolean,
    is_virtual boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('rate_table_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE rate_table_record_tmp OWNER TO postgres;

--
-- Name: rate_upload_fail_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_upload_fail_log (
    id integer NOT NULL,
    file_name character varying(255),
    received_time timestamp with time zone,
    processed_time timestamp with time zone,
    error_cause integer
);


ALTER TABLE rate_upload_fail_log OWNER TO postgres;

--
-- Name: rate_upload_fail_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_upload_fail_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_upload_fail_log_id_seq OWNER TO postgres;

--
-- Name: rate_upload_fail_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_upload_fail_log_id_seq OWNED BY rate_upload_fail_log.id;


--
-- Name: rate_upload_queue; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_upload_queue (
    id integer NOT NULL,
    cmd text,
    rate_table_id integer,
    status integer DEFAULT 0,
    end_date timestamp with time zone,
    log_id integer,
    is_ocn_lata smallint DEFAULT 0,
    date_format character varying(255),
    rates_file_cmd character varying(500),
    rates_file character varying(500),
    code_name_match character(2)
);


ALTER TABLE rate_upload_queue OWNER TO postgres;

--
-- Name: rate_upload_queue_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_upload_queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_upload_queue_id_seq OWNER TO postgres;

--
-- Name: rate_upload_queue_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_upload_queue_id_seq OWNED BY rate_upload_queue.id;


--
-- Name: rate_upload_success_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_upload_success_log (
    id integer NOT NULL,
    file_name character varying(255),
    received_time timestamp with time zone,
    imported_time timestamp with time zone,
    record_loaded integer
);


ALTER TABLE rate_upload_success_log OWNER TO postgres;

--
-- Name: rate_upload_success_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_upload_success_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_upload_success_log_id_seq OWNER TO postgres;

--
-- Name: rate_upload_success_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_upload_success_log_id_seq OWNED BY rate_upload_success_log.id;


--
-- Name: rate_upload_task; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_upload_task (
    id integer NOT NULL,
    operator_user character varying(40),
    upload_file_path character varying(256),
    upload_orig_file character varying(100),
    upload_format_file character varying(100),
    result_file_path character varying(256),
    rate_table_id integer NOT NULL,
    rate_table_code_deck_id integer,
    rate_date_format character varying(40),
    rate_end_date character varying(40),
    reduplicate_rate_action smallint DEFAULT 0 NOT NULL,
    code_deck_flag smallint DEFAULT 0 NOT NULL,
    use_ocn_lata_code smallint DEFAULT 0 NOT NULL,
    status smallint DEFAULT 0 NOT NULL,
    progress character varying(200),
    expense_detail character varying(100),
    create_time bigint,
    start_time bigint,
    end_time bigint,
    default_info character varying(200),
    all_rate_end_date timestamp with time zone,
    start_from integer DEFAULT 1,
    code_name_match integer
);


ALTER TABLE rate_upload_task OWNER TO postgres;

--
-- Name: COLUMN rate_upload_task.rate_date_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_task.rate_date_format IS 'Upload rate date format';


--
-- Name: COLUMN rate_upload_task.rate_end_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_task.rate_end_date IS 'Rate end date, a specified date or NULL(use current time)';


--
-- Name: COLUMN rate_upload_task.reduplicate_rate_action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_task.reduplicate_rate_action IS 'reduplicate rate action: 0 for Ingore, 1 for Delete, 2 for Update';


--
-- Name: COLUMN rate_upload_task.code_deck_flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_task.code_deck_flag IS 'Use system code deck, 0 for use rate code, 1 for use system global code deck';


--
-- Name: COLUMN rate_upload_task.use_ocn_lata_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_task.use_ocn_lata_code IS 'Use OCN code deck, 0 for No, 1 for Yes';


--
-- Name: COLUMN rate_upload_task.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_task.status IS '0 for initial; 1 for download rate; 2 for process rate, 3 for commit rate to db; 4 for finished; 5 for error';


--
-- Name: COLUMN rate_upload_task.expense_detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_task.expense_detail IS 'Detailed processing time: download, process, delete, update, copy action elapsed time';


--
-- Name: rate_upload_task_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_upload_task_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_upload_task_id_seq OWNER TO postgres;

--
-- Name: rate_upload_task_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_upload_task_id_seq OWNED BY rate_upload_task.id;


--
-- Name: rate_upload_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rate_upload_template (
    id integer NOT NULL,
    dup_method integer,
    end_date timestamp without time zone,
    end_date_gmt character(5) DEFAULT (+ 0),
    end_date_all timestamp without time zone,
    end_date_all_gmt character(5) DEFAULT (+ 0),
    effective_date_format character varying(50),
    has_code_deck boolean,
    code_name_match integer,
    with_header boolean,
    header_fields character varying(200),
    effective_date_default timestamp with time zone,
    min_time_default integer,
    interval_default integer,
    name character varying(100),
    create_by character varying(100),
    update_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    create_on timestamp with time zone,
    rate_increase_days integer,
    new_code_days integer,
    check_effective boolean DEFAULT false,
    reject_rate integer,
    send_error_email_to integer DEFAULT 0,
    append_prefix boolean,
    append_prefix_value character varying(20)
);


ALTER TABLE rate_upload_template OWNER TO postgres;

--
-- Name: COLUMN rate_upload_template.dup_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_template.dup_method IS '1 => ''Delete Existing Records''
2 => ''End-Date Existing Records'',
0 => ''End-Date All Records'',';


--
-- Name: COLUMN rate_upload_template.effective_date_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_template.effective_date_format IS '''mm/dd/yyyy'' => ''mm/dd/yyyy'',
''yyyy-mm-dd'' => ''yyyy-mm-dd'',
''dd-mm-yyyy'' => ''dd-mm-yyyy'',
''dd/mm/yyyy'' => ''dd/mm/yyyy'',
''yyyy/mm/dd'' => ''yyyy/mm/dd''';


--
-- Name: COLUMN rate_upload_template.code_name_match; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_template.code_name_match IS '1 => ''Re-populate Country and Code Name with Selected Code Deck'',
2 => ''Re-populate Country and Code Name with Selected Code Deck if not available''';


--
-- Name: COLUMN rate_upload_template.reject_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_template.reject_rate IS '0 no 1 yes';


--
-- Name: COLUMN rate_upload_template.send_error_email_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rate_upload_template.send_error_email_to IS '0 none;1 Carrier Rate Contact;2 Switchâ€™s Rate Contact';


--
-- Name: rate_upload_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rate_upload_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rate_upload_template_id_seq OWNER TO postgres;

--
-- Name: rate_upload_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rate_upload_template_id_seq OWNED BY rate_upload_template.id;


--
-- Name: ratemail_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE ratemail_history (
    id integer NOT NULL,
    send_date timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    send_to text NOT NULL,
    mail_content text,
    files text,
    client_id integer
);


ALTER TABLE ratemail_history OWNER TO postgres;

--
-- Name: ratemail_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ratemail_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ratemail_history_id_seq OWNER TO postgres;

--
-- Name: ratemail_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ratemail_history_id_seq OWNED BY ratemail_history.id;


--
-- Name: rawlerg6; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rawlerg6 (
    line character varying
);


ALTER TABLE rawlerg6 OWNER TO postgres;

--
-- Name: real_cdr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE real_cdr (
    real_cdr_id integer NOT NULL,
    uuid_a character varying(100),
    uuid_b character varying(100),
    ans_time_a character varying(100),
    ans_time_b character varying(100),
    ani character varying(100),
    dnis character varying(100),
    call_type character varying(100),
    egress_id character varying(100),
    client_id character varying(100),
    codec_id character varying(100),
    ingress_id character varying(100),
    caller_ip_address character varying(100),
    callee_ip_address character varying(100),
    callee_ani character varying(100),
    callee_dnis character varying(100),
    caller_media_port character varying(100),
    caller_media_ip character varying(100),
    callee_media_port character varying(100),
    callee_media_ip character varying(100),
    server_orig_port character varying(100),
    server_term_port character varying(100),
    orig_caller_packets character varying(100),
    orig_caller_bytes character varying(100),
    orig_callee_packets character varying(100),
    orig_callee_bytes character varying(100),
    term_caller_packets character varying(100),
    term_caller_bytes character varying(100),
    term_callee_packets character varying(100),
    term_callee_bytes character varying(100),
    ingress_codec character varying(100),
    egress_codec character varying(100),
    server_ip character varying(100),
    ani_code_id integer,
    dnis_code_id integer,
    signaling_server_ip character varying(100),
    signaling_server_port character varying(100),
    media_server_ip character varying(100),
    media_server_port character varying(100),
    application_server_ip character varying(100),
    application_server_port character varying(100),
    a_seconds character varying(100),
    a_interval character varying(100),
    a_min_time character varying(100),
    a_grace_time character varying(100),
    a_rate character varying(100),
    a_setup_fee character varying(100),
    b_seconds character varying(100),
    b_interval character varying(100),
    b_min_time character varying(100),
    b_grace_time character varying(100),
    b_rate character varying(100),
    b_setup_fee character varying(100),
    orig_code character varying(100),
    orig_code_name character varying(100),
    orig_country character varying(100),
    term_code character varying(100),
    term_code_name character varying(100),
    term_country character varying(100),
    ingress_currency_id character varying(10),
    egress_currency_id character varying(10)
);


ALTER TABLE real_cdr OWNER TO postgres;

--
-- Name: COLUMN real_cdr.server_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN real_cdr.server_ip IS 'æœåŠ¡å™¨ip';


--
-- Name: real_cdr_real_cdr_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE real_cdr_real_cdr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE real_cdr_real_cdr_id_seq OWNER TO postgres;

--
-- Name: real_cdr_real_cdr_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE real_cdr_real_cdr_id_seq OWNED BY real_cdr.real_cdr_id;


--
-- Name: redirect_carrier; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE redirect_carrier (
    id integer NOT NULL,
    ip ip4,
    active integer DEFAULT 1 NOT NULL,
    max_cps integer,
    type integer
);


ALTER TABLE redirect_carrier OWNER TO postgres;

--
-- Name: TABLE redirect_carrier; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE redirect_carrier IS 'è¢«dnl_redirect_serverç¨‹åºæ‰€ä½¿ç”¨';


--
-- Name: COLUMN redirect_carrier.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN redirect_carrier.id IS 'é€’å¢žçš„åºåˆ—å·';


--
-- Name: COLUMN redirect_carrier.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN redirect_carrier.ip IS 'å‘¼å…¥å®¢æˆ·ipï¼Œæ ¹æ®æ­¤ipå†³å®šè¦ä¸è¦æŽ¥å—å¤„ç†æ­¤INVITEã€‚';


--
-- Name: COLUMN redirect_carrier.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN redirect_carrier.active IS 'å¼€å…³ï¼Œ 0 â€”â€” falseå…³é—­ï¼Œ 1 â€”â€” trueæ‰“å¼€ï¼Œå…³é—­çŠ¶æ€ä¸‹æ‹’ç»æ­¤ipæ¥çš„INVITE';


--
-- Name: COLUMN redirect_carrier.max_cps; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN redirect_carrier.max_cps IS 'æ²¡ç§’é’Ÿå¤„ç†å‘¼å«æ•°ï¼Œè¶…è¿‡æ­¤é™åˆ¶ï¼Œåˆ™æ‹’ç»æ­¤ipæ¥çš„å‘¼å«ã€‚';


--
-- Name: COLUMN redirect_carrier.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN redirect_carrier.type IS 'åˆ¤æ–­å·ç çš„ç±»åž‹ï¼Œ0 â€”â€” è¢«å«å·ï¼Œ 1 â€”â€” ä¸»å«å·ï¼ŒæŸ¥è¯¢å‰ç¼€codeçš„æ—¶å€™ç”¨ã€‚';


--
-- Name: redirect_carrier_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE redirect_carrier_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE redirect_carrier_id_seq OWNER TO postgres;

--
-- Name: redirect_carrier_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE redirect_carrier_id_seq OWNED BY redirect_carrier.id;


--
-- Name: redirect_host; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE redirect_host (
    id integer NOT NULL,
    ip ip4,
    port integer,
    code prefix_range
);


ALTER TABLE redirect_host OWNER TO postgres;

--
-- Name: TABLE redirect_host; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE redirect_host IS 'è¢«dnl_redirect_serverç¨‹åºæ‰€ä½¿ç”¨';


--
-- Name: COLUMN redirect_host.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN redirect_host.id IS 'é€’å¢žçš„åºåˆ—';


--
-- Name: COLUMN redirect_host.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN redirect_host.ip IS 'æ ¹ç»å‰ç¼€codeé‡å®šå‘çš„æœåŠ¡å™¨ip';


--
-- Name: COLUMN redirect_host.port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN redirect_host.port IS 'æ ¹ç»å‰ç¼€codeé‡å®šå‘çš„æœåŠ¡å™¨ç«¯å£';


--
-- Name: COLUMN redirect_host.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN redirect_host.code IS 'æ ¹æ®æ¬¡å‰ç¼€é‡å®šå‘å‘¼å«åˆ°ipæŒ‡å®šçš„æœåŠ¡å™¨ä¸Šã€‚';


--
-- Name: redirect_host_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE redirect_host_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE redirect_host_id_seq OWNER TO postgres;

--
-- Name: redirect_host_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE redirect_host_id_seq OWNED BY redirect_host.id;


--
-- Name: register_of_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE register_of_record (
    id integer NOT NULL,
    "time" bigint,
    state smallint,
    username character varying(100),
    direction integer,
    ip ip4,
    port integer,
    expires_time bigint
);


ALTER TABLE register_of_record OWNER TO postgres;

--
-- Name: TABLE register_of_record; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE register_of_record IS 'æ³¨å†Œä¿¡æ¯è¡¨';


--
-- Name: COLUMN register_of_record."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN register_of_record."time" IS 'äº§ç”Ÿè®°å½•æ—¶é—´ï¼Œç§’å•ä½ï¼Œé•¿æ•´åž‹æ—¶é—´ã€‚';


--
-- Name: COLUMN register_of_record.state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN register_of_record.state IS 'æ³¨å†ŒçŠ¶æ€ï¼Œ0 æœªæ³¨å†Œï¼Œ1 å·²æ³¨å†Œ';


--
-- Name: COLUMN register_of_record.username; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN register_of_record.username IS 'æ³¨å†Œç”¨æˆ·åï¼Œingressé‡Œå”¯ä¸€ï¼Œå¯ä»¥è·Ÿegressé‡å¤';


--
-- Name: COLUMN register_of_record.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN register_of_record.direction IS '0 ingress 1 egress';


--
-- Name: COLUMN register_of_record.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN register_of_record.ip IS 'å¯¹ä¸»å«ï¼šæ˜¯æ³¨å†Œè¿‡æ¥çš„IP
å¯¹è¢«å«ï¼šæ˜¯æ³¨å†Œç›®æ ‡æœåŠ¡å™¨IP';


--
-- Name: COLUMN register_of_record.port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN register_of_record.port IS 'å¯¹ä¸»å«ï¼šæ˜¯æ³¨å†Œè¿‡æ¥çš„ç«¯å£
å¯¹è¢«å«ï¼šæ˜¯æ³¨å†Œç›®æ ‡æœåŠ¡å™¨ç«¯å£';


--
-- Name: register_of_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE register_of_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE register_of_record_id_seq OWNER TO postgres;

--
-- Name: register_of_record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE register_of_record_id_seq OWNED BY register_of_record.id;


--
-- Name: report_delivery_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE report_delivery_history (
    id integer NOT NULL,
    report_delivery_id integer,
    sent_time timestamp without time zone,
    email_to character(150),
    content character(200)
);


ALTER TABLE report_delivery_history OWNER TO postgres;

--
-- Name: COLUMN report_delivery_history.content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN report_delivery_history.content IS 'ä¿å­˜è·¯å¾„åœ°å€';


--
-- Name: rerate_cdr_download_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rerate_cdr_download_log (
    id integer NOT NULL,
    task_id integer,
    create_by character varying(100),
    create_on timestamp with time zone,
    download_file character varying(200),
    finished_time timestamp with time zone,
    status integer DEFAULT 0
);


ALTER TABLE rerate_cdr_download_log OWNER TO postgres;

--
-- Name: rerate_cdr_download_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rerate_cdr_download_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rerate_cdr_download_log_id_seq OWNER TO postgres;

--
-- Name: rerate_cdr_download_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rerate_cdr_download_log_id_seq OWNED BY rerate_cdr_download_log.id;


--
-- Name: rerate_cdr_task; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rerate_cdr_task (
    id integer NOT NULL,
    from_time bigint,
    to_time bigint,
    timezone integer DEFAULT 0 NOT NULL,
    update_lrn smallint DEFAULT 0 NOT NULL,
    update_us_jurisdiction smallint DEFAULT 0 NOT NULL,
    ingress_trunk character varying(1024),
    egress_trunk character varying(1024),
    lrn_server_ip character varying(16),
    lrn_server_port integer DEFAULT 5060 NOT NULL,
    cdr_file character varying(4096),
    err_code integer DEFAULT 0 NOT NULL,
    include_q850 smallint DEFAULT 0 NOT NULL,
    progress character varying(200),
    status smallint DEFAULT 0 NOT NULL,
    load_cdr_elapsed_sec integer DEFAULT 0 NOT NULL,
    load_rate_elapsed_sec integer DEFAULT 0 NOT NULL,
    rerate_elapsed_sec integer DEFAULT 0 NOT NULL,
    create_time bigint,
    start_time bigint,
    end_time bigint,
    cdr_file_path character varying(100),
    download_file character varying(200),
    client_ids character varying(1024),
    update_local_rate smallint DEFAULT 1 NOT NULL
);


ALTER TABLE rerate_cdr_task OWNER TO postgres;

--
-- Name: COLUMN rerate_cdr_task.from_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rerate_cdr_task.from_time IS 'rerate cdr start time';


--
-- Name: COLUMN rerate_cdr_task.to_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rerate_cdr_task.to_time IS 'rerate cdr end time';


--
-- Name: COLUMN rerate_cdr_task.ingress_trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rerate_cdr_task.ingress_trunk IS 'ingress trunk info, format: trunk_id,update_rate,rate_table_id,rate_effective_date;trunk_id_1,...';


--
-- Name: COLUMN rerate_cdr_task.egress_trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rerate_cdr_task.egress_trunk IS 'egress trunk info, format: trunk_id,update_rate,rate_table_id,rate_effective_date;trunk_id_1,...  (update_rate: 0 for No, 1 for Yes; rate_effective_date:a specified date or 0(same as CDR time) )';


--
-- Name: COLUMN rerate_cdr_task.include_q850; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rerate_cdr_task.include_q850 IS 'Rerate CDR MUST include Q.850 column, 0 for none; 1 for include';


--
-- Name: COLUMN rerate_cdr_task.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rerate_cdr_task.status IS '0 for initial; 1 for download cdr; 2 for load rate, 3 for rerate cdr; 4 for finished; 5 for error';


--
-- Name: rerate_cdr_task_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rerate_cdr_task_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rerate_cdr_task_id_seq OWNER TO postgres;

--
-- Name: rerate_cdr_task_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rerate_cdr_task_id_seq OWNED BY rerate_cdr_task.id;


--
-- Name: rerate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rerate_log (
    rerate_log_id integer NOT NULL,
    start_datetime timestamp with time zone,
    end_datetime timestamp with time zone,
    update_lrn integer,
    update_us_jurisdiction integer,
    update_ingress_rate integer,
    ingress_rate integer,
    ingress_rate_effective_date_type integer,
    ingress_rate_effective_date date,
    update_egress_rate integer,
    egress_rate integer,
    egress_rate_effective_date_type integer,
    egress_rate_effective_date integer,
    ingress_trunks character varying(200),
    egress_trunks character varying(200),
    pid integer,
    process_start timestamp without time zone,
    process_end timestamp without time zone,
    status integer
);


ALTER TABLE rerate_log OWNER TO postgres;

--
-- Name: rerate_log_rerate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rerate_log_rerate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rerate_log_rerate_log_id_seq OWNER TO postgres;

--
-- Name: rerate_log_rerate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rerate_log_rerate_log_id_seq OWNED BY rerate_log.rerate_log_id;


--
-- Name: rerate_report_exec_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE rerate_report_exec_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    finish_time timestamp with time zone,
    create_by character varying(100),
    status integer,
    exec_type integer,
    task_id integer,
    total_files_count integer,
    success_files_count integer,
    create_on timestamp with time zone
);


ALTER TABLE rerate_report_exec_log OWNER TO postgres;

--
-- Name: COLUMN rerate_report_exec_log.exec_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rerate_report_exec_log.exec_type IS '1:report;2:balance';


--
-- Name: rerate_report_exec_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rerate_report_exec_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rerate_report_exec_log_id_seq OWNER TO postgres;

--
-- Name: rerate_report_exec_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rerate_report_exec_log_id_seq OWNED BY rerate_report_exec_log.id;


--
-- Name: reseller; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE reseller (
    id integer NOT NULL,
    name character varying(255),
    password character varying(32),
    email character varying(255),
    login_id character varying(255)
);


ALTER TABLE reseller OWNER TO postgres;

--
-- Name: reseller_client; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE reseller_client (
    id integer NOT NULL,
    login_id character varying(255),
    password character varying(32),
    email character varying(255),
    reseller_id integer,
    client_id integer,
    prefix character varying(255)
);


ALTER TABLE reseller_client OWNER TO postgres;

--
-- Name: reseller_client_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE reseller_client_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reseller_client_id_seq OWNER TO postgres;

--
-- Name: reseller_client_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE reseller_client_id_seq OWNED BY reseller_client.id;


--
-- Name: reseller_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE reseller_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE reseller_id_seq OWNER TO postgres;

--
-- Name: reseller_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE reseller_id_seq OWNED BY reseller.id;


--
-- Name: resoruce_block_itmes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resoruce_block_itmes (
);


ALTER TABLE resoruce_block_itmes OWNER TO postgres;

--
-- Name: TABLE resoruce_block_itmes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resoruce_block_itmes IS 'åªæœ‰ingress trunkæ‰æœ‰æ­¤è¡¨ï¼Œä¸€ä¸ªingresså¯ä»¥è®¾ç½®å¤šä¸ªä¸èƒ½åŽ»çš„egressã€‚';


--
-- Name: resource_auth; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_auth (
    id integer NOT NULL,
    resource_id integer,
    client_id integer
);


ALTER TABLE resource_auth OWNER TO postgres;

--
-- Name: TABLE resource_auth; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource_auth IS 'resource æƒé™';


--
-- Name: resource_auth_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_auth_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_auth_id_seq OWNER TO postgres;

--
-- Name: resource_auth_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_auth_id_seq OWNED BY resource_auth.id;


--
-- Name: resource_block_res_block_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_block_res_block_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_block_res_block_id_seq OWNER TO postgres;

--
-- Name: resource_block; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_block (
    ingress_res_id integer,
    engress_res_id integer,
    digit prefix_range DEFAULT ''::prefix_range,
    res_block_id integer DEFAULT nextval('resource_block_res_block_id_seq'::regclass) NOT NULL,
    time_profile_id integer,
    ingress_client_id integer,
    egress_client_id integer,
    disable_by_alert boolean DEFAULT false,
    ani_prefix prefix_range,
    ani_length integer,
    dnis_length integer,
    ani_method integer,
    dnis_method integer,
    ani_empty boolean DEFAULT false,
    action_type integer DEFAULT 0,
    block_log_id integer,
    loop_block_id integer,
    ticket_log_id integer,
    code_name character varying,
    country character varying,
    create_by character varying,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_by character varying,
    dialer_detection_id integer,
    ani_max_length integer DEFAULT 32,
    dnis_max_length integer DEFAULT 32,
    ingress_group_id integer,
    egress_group_id integer,
    full_match integer DEFAULT 0,
    unblock_at numeric,
    type integer,
    block_at numeric,
    unblock_after numeric
);


ALTER TABLE resource_block OWNER TO postgres;

--
-- Name: TABLE resource_block; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource_block IS 'æ‹’ç»å·ç ç®¡ç†';


--
-- Name: COLUMN resource_block.ingress_res_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block.ingress_res_id IS 'æŽ¥å…¥ç½‘å…³';


--
-- Name: COLUMN resource_block.engress_res_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block.engress_res_id IS 'è½åœ°ç½‘å…³';


--
-- Name: COLUMN resource_block.digit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block.digit IS 'åŒ¹é…çš„å‰ç¼€';


--
-- Name: COLUMN resource_block.res_block_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block.res_block_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_block.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block.time_profile_id IS 'æ—¶é—´æ®µ';


--
-- Name: COLUMN resource_block.ani_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block.ani_method IS '0:<
1:=
2:>';


--
-- Name: COLUMN resource_block.dnis_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block.dnis_method IS '0:<
1:=
2:>';


--
-- Name: COLUMN resource_block.action_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block.action_type IS '
0 - manual

1 - automatic';


--
-- Name: COLUMN resource_block.ani_max_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block.ani_max_length IS 'è·Ÿani_prefix, ani_lengthï¼ˆæœ€å°é•¿åº¦ï¼‰ä¸€èµ·ä½¿ç”¨ï¼Œå¼€åˆã€‚';


--
-- Name: COLUMN resource_block.dnis_max_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block.dnis_max_length IS 'è·Ÿdigit, dnis_lengthï¼ˆæœ€å°é•¿åº¦ï¼‰ä¸€èµ·ä½¿ç”¨ï¼Œå¼€åˆã€‚';


--
-- Name: resource_block_group; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_block_group (
    id integer NOT NULL,
    name character varying(100),
    trunk_type smallint DEFAULT 0 NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL
);


ALTER TABLE resource_block_group OWNER TO postgres;

--
-- Name: COLUMN resource_block_group.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block_group.trunk_type IS '0 for ingress trunk; 1 for egress trunk';


--
-- Name: resource_block_group_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_block_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_block_group_id_seq OWNER TO postgres;

--
-- Name: resource_block_group_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_block_group_id_seq OWNED BY resource_block_group.id;


--
-- Name: resource_block_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_block_items (
    id integer NOT NULL,
    resource_id integer,
    block_resource_id integer,
    active smallint DEFAULT 1
);


ALTER TABLE resource_block_items OWNER TO postgres;

--
-- Name: TABLE resource_block_items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource_block_items IS 'åªæœ‰ingressæ—¶æœ‰æ•ˆï¼Œä¸€ä¸ªingresså¯ä»¥è®¾ç½®å¤šä¸ªä¸èƒ½åŽ»çš„egress';


--
-- Name: COLUMN resource_block_items.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block_items.resource_id IS 'ingress id';


--
-- Name: COLUMN resource_block_items.block_resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block_items.block_resource_id IS 'è¢«è¿‡æ»¤çš„resource_idï¼Œä¹Ÿå°±æ˜¯egress_id';


--
-- Name: COLUMN resource_block_items.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_block_items.active IS '0 -- false, 1 -- true';


--
-- Name: resource_block_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_block_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_block_items_id_seq OWNER TO postgres;

--
-- Name: resource_block_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_block_items_id_seq OWNED BY resource_block_items.id;


--
-- Name: resource_block_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_block_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_block_items_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_block_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_block_items_record (
    id integer,
    resource_id integer,
    block_resource_id integer,
    active smallint,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_block_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_block_items_record OWNER TO postgres;

--
-- Name: resource_block_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_block_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_block_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_block_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_block_record (
    ingress_res_id integer,
    engress_res_id integer,
    digit prefix_range,
    res_block_id integer,
    time_profile_id integer,
    ingress_client_id integer,
    egress_client_id integer,
    disable_by_alert boolean,
    ani_prefix prefix_range,
    ani_length integer,
    dnis_length integer,
    ani_method integer,
    dnis_method integer,
    ani_empty boolean,
    action_type integer,
    block_log_id integer,
    loop_block_id integer,
    ticket_log_id integer,
    code_name character varying,
    country character varying,
    create_by character varying,
    create_time timestamp with time zone,
    update_by character varying,
    dialer_detection_id integer,
    ani_max_length integer,
    dnis_max_length integer,
    ingress_group_id integer,
    egress_group_id integer,
    full_match integer,
    unblock_at numeric,
    type integer,
    block_at numeric,
    unblock_after numeric,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_block_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_block_record OWNER TO postgres;

--
-- Name: resource_block_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_block_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_block_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_block_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_block_record_tmp (
    ingress_res_id integer,
    engress_res_id integer,
    digit prefix_range,
    res_block_id integer,
    time_profile_id integer,
    ingress_client_id integer,
    egress_client_id integer,
    disable_by_alert boolean,
    ani_prefix prefix_range,
    ani_length integer,
    dnis_length integer,
    ani_method integer,
    dnis_method integer,
    ani_empty boolean,
    action_type integer,
    block_log_id integer,
    loop_block_id integer,
    ticket_log_id integer,
    code_name character varying,
    country character varying,
    create_by character varying,
    create_time timestamp with time zone,
    update_by character varying,
    dialer_detection_id integer,
    ani_max_length integer,
    dnis_max_length integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_block_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_block_record_tmp OWNER TO postgres;

--
-- Name: resource_capacity; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_capacity (
    id bigint NOT NULL,
    egress_id integer,
    ingress_id integer,
    max_cps integer,
    max_cap integer
);


ALTER TABLE resource_capacity OWNER TO postgres;

--
-- Name: resource_capacity_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_capacity_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_capacity_id_seq OWNER TO postgres;

--
-- Name: resource_capacity_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_capacity_id_seq OWNED BY resource_capacity.id;


--
-- Name: resource_capacity_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_capacity_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_capacity_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_capacity_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_capacity_record (
    id bigint,
    egress_id integer,
    ingress_id integer,
    max_cps integer,
    max_cap integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_capacity_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_capacity_record OWNER TO postgres;

--
-- Name: resource_codecs_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_codecs_ref (
    id integer NOT NULL,
    resource_id integer NOT NULL,
    codec_id integer
);


ALTER TABLE resource_codecs_ref OWNER TO postgres;

--
-- Name: TABLE resource_codecs_ref; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource_codecs_ref IS 'codes';


--
-- Name: COLUMN resource_codecs_ref.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_codecs_ref.id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_codecs_ref.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_codecs_ref.resource_id IS 'ç½‘å…³ç»„';


--
-- Name: resource_codecs_ref_codec_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_codecs_ref_codec_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE resource_codecs_ref_codec_id_seq OWNER TO postgres;

--
-- Name: resource_codecs_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_codecs_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_codecs_ref_id_seq OWNER TO postgres;

--
-- Name: resource_codecs_ref_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_codecs_ref_id_seq OWNED BY resource_codecs_ref.id;


--
-- Name: resource_codecs_ref_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_codecs_ref_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_codecs_ref_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_codecs_ref_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_codecs_ref_record (
    id integer,
    resource_id integer,
    codec_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_codecs_ref_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_codecs_ref_record OWNER TO postgres;

--
-- Name: resource_codecs_ref_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_codecs_ref_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_codecs_ref_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_codecs_ref_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_codecs_ref_record_tmp (
    id integer,
    resource_id integer,
    codec_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_codecs_ref_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_codecs_ref_record_tmp OWNER TO postgres;

--
-- Name: resource_direction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_direction (
    direction smallint NOT NULL,
    action smallint NOT NULL,
    digits character varying(10) NOT NULL,
    direction_id integer NOT NULL,
    dnis prefix_range DEFAULT ''::prefix_range,
    resource_id integer NOT NULL,
    time_profile_id integer,
    type integer NOT NULL,
    number_length integer,
    number_type integer
);


ALTER TABLE resource_direction OWNER TO postgres;

--
-- Name: TABLE resource_direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource_direction IS 'action(å·ç è½¬æ¢)';


--
-- Name: COLUMN resource_direction.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction.direction IS '0ï¼ï¼ALL
1ï¼ï¼æ‰“è¿›  ingress
2ï¼ï¼æ‰“å‡ºegress';


--
-- Name: COLUMN resource_direction.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction.action IS '1ï¼ï¼åŠ å‰ç¼€
2ï¼ï¼åŠ åŽç¼€
3ï¼ï¼å‡å‰ç¼€
4ï¼ï¼å‡åŽç¼€';


--
-- Name: COLUMN resource_direction.digits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction.digits IS 'è¦æ·»åŠ çš„å­—ç¬¦æˆ–åˆ é™¤çš„ä½æ•°';


--
-- Name: COLUMN resource_direction.direction_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction.direction_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_direction.dnis; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction.dnis IS 'ä¸»å«æˆ–è€…è¢«å«å‰ç¼€';


--
-- Name: COLUMN resource_direction.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction.resource_id IS 'ç½‘å…³ç»„';


--
-- Name: COLUMN resource_direction.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction.time_profile_id IS 'æ—¶é—´æ®µ';


--
-- Name: COLUMN resource_direction.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction.type IS '0ï¼ï¼ä¿®æ”¹ä¸»å«
1ï¼ï¼ä¿®æ”¹è¢«å«';


--
-- Name: COLUMN resource_direction.number_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction.number_length IS 'å·ç çš„é•¿åº¦';


--
-- Name: COLUMN resource_direction.number_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction.number_type IS '0ï¼ï¼æ‰€æœ‰
1ï¼ï¼å¤§äºŽ
2ï¼ï¼ç­‰äºŽ
3ï¼ï¼å°äºŽ';


--
-- Name: resource_direction_direction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_direction_direction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_direction_direction_id_seq OWNER TO postgres;

--
-- Name: resource_direction_direction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_direction_direction_id_seq OWNED BY resource_direction.direction_id;


--
-- Name: resource_direction_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_direction_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_direction_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_direction_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_direction_record (
    direction smallint,
    action smallint,
    digits character varying(10),
    direction_id integer,
    dnis prefix_range,
    resource_id integer,
    time_profile_id integer,
    type integer,
    number_length integer,
    number_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_direction_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_direction_record OWNER TO postgres;

--
-- Name: resource_direction_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_direction_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_direction_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_direction_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_direction_record_tmp (
    direction smallint,
    action smallint,
    digits character varying(10),
    direction_id integer,
    dnis prefix_range,
    resource_id integer,
    time_profile_id integer,
    type integer,
    number_length integer,
    number_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_direction_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_direction_record_tmp OWNER TO postgres;

--
-- Name: resource_direction_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_direction_template (
    direction_id integer NOT NULL,
    direction smallint,
    action smallint NOT NULL,
    digits character varying(10) NOT NULL,
    dnis prefix_range DEFAULT ''::prefix_range,
    resource_template_id integer NOT NULL,
    time_profile_id integer,
    type integer NOT NULL,
    number_length integer,
    number_type integer
);


ALTER TABLE resource_direction_template OWNER TO postgres;

--
-- Name: COLUMN resource_direction_template.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction_template.time_profile_id IS 'æ—¶é—´æ®µ';


--
-- Name: COLUMN resource_direction_template.number_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_direction_template.number_length IS 'å·ç çš„é•¿åº¦';


--
-- Name: resource_direction_template_direction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_direction_template_direction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_direction_template_direction_id_seq OWNER TO postgres;

--
-- Name: resource_direction_template_direction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_direction_template_direction_id_seq OWNED BY resource_direction_template.direction_id;


--
-- Name: resource_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_info (
    "time" character varying(100),
    resource_id character varying(100),
    value character varying(100),
    direction character varying(100),
    ip character varying(100)
);


ALTER TABLE resource_info OWNER TO postgres;

--
-- Name: TABLE resource_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource_info IS 'resource monitor';


--
-- Name: COLUMN resource_info."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_info."time" IS 'æ—¶é—´';


--
-- Name: COLUMN resource_info.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_info.resource_id IS 'ç½‘å…³';


--
-- Name: COLUMN resource_info.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_info.value IS 'é€šè¯æ•°';


--
-- Name: COLUMN resource_info.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_info.direction IS 'ingress,egress';


--
-- Name: COLUMN resource_info.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_info.ip IS 'æœåŠ¡å™¨åœ°å€';


--
-- Name: resource_ip_resource_ip_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_ip_resource_ip_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_ip_resource_ip_id_seq OWNER TO postgres;

--
-- Name: resource_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_ip (
    resource_id integer NOT NULL,
    resource_ip_id integer DEFAULT nextval('resource_ip_resource_ip_id_seq'::regclass) NOT NULL,
    ip character varying(50),
    port integer DEFAULT 5060,
    fqdn character varying(100),
    sip_rpid character varying(64),
    disable_by_alert boolean DEFAULT false,
    priority integer DEFAULT 0,
    last_priority integer DEFAULT 0,
    addr_type integer DEFAULT 0,
    direction integer,
    username character varying(50),
    password character varying(50),
    reg_type smallint DEFAULT 0 NOT NULL,
    reg_status smallint DEFAULT 0 NOT NULL,
    reg_srv_ip character varying(100),
    reg_srv_port integer DEFAULT 5060 NOT NULL,
    expires integer DEFAULT 3600 NOT NULL,
    profile_id integer DEFAULT 0 NOT NULL,
    need_register boolean,
    masked_from integer,
    mask integer,
    options_ping_inv integer
);


ALTER TABLE resource_ip OWNER TO postgres;

--
-- Name: TABLE resource_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource_ip IS 'ç½‘å…³';


--
-- Name: COLUMN resource_ip.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip.resource_id IS 'ç½‘å…³ç»„';


--
-- Name: COLUMN resource_ip.resource_ip_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip.resource_ip_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_ip.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip.ip IS 'ipåœ°å€';


--
-- Name: COLUMN resource_ip.port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip.port IS 'ç«¯å£';


--
-- Name: COLUMN resource_ip.fqdn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip.fqdn IS 'åŸŸå';


--
-- Name: COLUMN resource_ip.sip_rpid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip.sip_rpid IS 'opensips';


--
-- Name: COLUMN resource_ip.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip.direction IS 'æ ‡æ³¨æ­¤ipæ˜¯incomingè¿˜æ˜¯outgoing

0 -- incoming
1 -- outgoing';


--
-- Name: COLUMN resource_ip.reg_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip.reg_type IS 'register user type, 0 for none; 1 for register user; 2 for register gateway account';


--
-- Name: COLUMN resource_ip.reg_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip.reg_status IS '0 for un-register; 1 for registered; 2 for register failed';


--
-- Name: COLUMN resource_ip.need_register; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip.need_register IS '0:Authorized by IP Only;1:Authorized by SIP Registration';


--
-- Name: resource_ip_limit; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_ip_limit (
    limit_id integer NOT NULL,
    ip_id integer NOT NULL,
    cps integer,
    capacity integer,
    time_profile_id integer
);


ALTER TABLE resource_ip_limit OWNER TO postgres;

--
-- Name: TABLE resource_ip_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource_ip_limit IS 'ä¸åŒæ—¶é—´æ®µï¼Œä¸åŒçš„limitå€¼';


--
-- Name: COLUMN resource_ip_limit.limit_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip_limit.limit_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_ip_limit.ip_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip_limit.ip_id IS 'ipåœ°å€ï¼ï¼å¤–é”®';


--
-- Name: COLUMN resource_ip_limit.cps; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip_limit.cps IS 'æ¯ç§’å‘¼å«æ•°';


--
-- Name: COLUMN resource_ip_limit.capacity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip_limit.capacity IS 'åŒæ—¶åœ¨çº¿é€šè¯æ•°';


--
-- Name: COLUMN resource_ip_limit.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_ip_limit.time_profile_id IS 'æ—¶é—´æ®µï¼ï¼å¤–é”®';


--
-- Name: resource_ip_limit_limit_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_ip_limit_limit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_ip_limit_limit_id_seq OWNER TO postgres;

--
-- Name: resource_ip_limit_limit_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_ip_limit_limit_id_seq OWNED BY resource_ip_limit.limit_id;


--
-- Name: resource_ip_limit_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_ip_limit_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_ip_limit_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_ip_limit_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_ip_limit_record (
    limit_id integer,
    ip_id integer,
    cps integer,
    capacity integer,
    time_profile_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_ip_limit_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_ip_limit_record OWNER TO postgres;

--
-- Name: resource_ip_limit_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_ip_limit_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_ip_limit_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_ip_limit_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_ip_limit_record_tmp (
    limit_id integer,
    ip_id integer,
    cps integer,
    capacity integer,
    time_profile_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_ip_limit_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_ip_limit_record_tmp OWNER TO postgres;

--
-- Name: resource_ip_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_ip_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_ip_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_ip_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_ip_record (
    resource_id integer,
    resource_ip_id integer,
    ip character varying(50),
    port integer,
    fqdn character varying(100),
    sip_rpid character varying(64),
    disable_by_alert boolean,
    priority integer,
    last_priority integer,
    addr_type integer,
    direction integer,
    username character varying(50),
    password character varying(50),
    reg_type smallint,
    reg_status smallint,
    reg_srv_ip character varying(100),
    reg_srv_port integer,
    expires integer,
    profile_id integer,
    need_register boolean,
    masked_from integer,
    mask integer,
    options_ping_inv integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_ip_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_ip_record OWNER TO postgres;

--
-- Name: resource_ip_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_ip_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_ip_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_ip_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_ip_record_tmp (
    resource_id integer,
    resource_ip_id integer,
    ip character varying(50),
    port integer,
    fqdn character varying(100),
    sip_rpid character varying(64),
    disable_by_alert boolean,
    priority integer,
    last_priority integer,
    addr_type integer,
    direction integer,
    username character varying(50),
    password character varying(50),
    reg_type smallint,
    reg_status smallint,
    reg_srv_ip character varying(100),
    reg_srv_port integer,
    expires integer,
    profile_id integer,
    need_register boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_ip_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_ip_record_tmp OWNER TO postgres;

--
-- Name: resource_lrn_action; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_lrn_action (
    id integer NOT NULL,
    direction smallint NOT NULL,
    action smallint NOT NULL,
    digits character varying(10) NOT NULL,
    dnis prefix_range DEFAULT ''::prefix_range,
    resource_id integer NOT NULL
);


ALTER TABLE resource_lrn_action OWNER TO postgres;

--
-- Name: COLUMN resource_lrn_action.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_lrn_action.direction IS '1ï¼lrnä¹‹å‰
2ï¼lrnä¹‹åŽ';


--
-- Name: COLUMN resource_lrn_action.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_lrn_action.action IS '1ï¼ï¼åŠ å‰ç¼€
2ï¼ï¼åŠ åŽç¼€
3ï¼ï¼å‡å‰ç¼€
4ï¼ï¼å‡åŽç¼€';


--
-- Name: resource_lrn_action_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_lrn_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_lrn_action_id_seq OWNER TO postgres;

--
-- Name: resource_lrn_action_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_lrn_action_id_seq OWNED BY resource_lrn_action.id;


--
-- Name: resource_lrn_action_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_lrn_action_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_lrn_action_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_lrn_action_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_lrn_action_record (
    id integer,
    direction smallint,
    action smallint,
    digits character varying(10),
    dnis prefix_range,
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_lrn_action_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_lrn_action_record OWNER TO postgres;

--
-- Name: resource_lrn_action_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_lrn_action_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_lrn_action_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_lrn_action_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_lrn_action_record_tmp (
    id integer,
    direction smallint,
    action smallint,
    digits character varying(10),
    dnis prefix_range,
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_lrn_action_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_lrn_action_record_tmp OWNER TO postgres;

--
-- Name: resource_next_route_rule; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_next_route_rule (
    id integer NOT NULL,
    route_type integer,
    reponse_code character varying(100),
    resource_id integer,
    return_code character varying(100),
    return_string character varying(100)
);


ALTER TABLE resource_next_route_rule OWNER TO postgres;

--
-- Name: TABLE resource_next_route_rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource_next_route_rule IS 'next_rule';


--
-- Name: COLUMN resource_next_route_rule.route_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_next_route_rule.route_type IS '1--next host
2--next route
3--stop';


--
-- Name: COLUMN resource_next_route_rule.reponse_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_next_route_rule.reponse_code IS '200,486,404,487';


--
-- Name: resource_next_route_rule_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_next_route_rule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_next_route_rule_id_seq OWNER TO postgres;

--
-- Name: resource_next_route_rule_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_next_route_rule_id_seq OWNED BY resource_next_route_rule.id;


--
-- Name: resource_next_route_rule_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_next_route_rule_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_next_route_rule_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_next_route_rule_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_next_route_rule_record (
    id integer,
    route_type integer,
    reponse_code character varying(100),
    resource_id integer,
    return_code character varying(100),
    return_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_next_route_rule_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_next_route_rule_record OWNER TO postgres;

--
-- Name: resource_next_route_rule_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_next_route_rule_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_next_route_rule_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_next_route_rule_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_next_route_rule_record_tmp (
    id integer,
    route_type integer,
    reponse_code character varying(100),
    resource_id integer,
    return_code character varying(100),
    return_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_next_route_rule_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_next_route_rule_record_tmp OWNER TO postgres;

--
-- Name: resource_next_route_rule_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_next_route_rule_template (
    id integer NOT NULL,
    route_type integer,
    reponse_code character varying(100),
    resource_template_id integer,
    return_code character varying(100),
    return_string character varying(100)
);


ALTER TABLE resource_next_route_rule_template OWNER TO postgres;

--
-- Name: resource_next_route_rule_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_next_route_rule_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_next_route_rule_template_id_seq OWNER TO postgres;

--
-- Name: resource_next_route_rule_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_next_route_rule_template_id_seq OWNED BY resource_next_route_rule_template.id;


--
-- Name: resource_prefix; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_prefix (
    id integer NOT NULL,
    resource_id integer,
    tech_prefix prefix_range DEFAULT ''::prefix_range NOT NULL,
    route_strategy_id integer,
    rate_table_id integer,
    code prefix_range,
    code_cps integer,
    code_cap integer,
    product_id integer
);


ALTER TABLE resource_prefix OWNER TO postgres;

--
-- Name: COLUMN resource_prefix.tech_prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_prefix.tech_prefix IS 'åŒ¹é…å·ç çš„å‰ç¼€';


--
-- Name: COLUMN resource_prefix.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_prefix.code IS 'è¢«å«å·ç å‰ç¼€ï¼Œè·Ÿtech_prefixä¸ä¸€æ ·çš„ï¼Œä¸éœ€è¦åˆ é™¤å‰ç¼€ï¼Œé€‰routing_palanå’Œrate_tableçš„ä½œç”¨ã€‚
åŒä¸€ä¸ªingress+tech_prefixå†…codeå¿…é¡»æ˜¯å”¯ä¸€çš„ã€‚';


--
-- Name: COLUMN resource_prefix.code_cps; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_prefix.code_cps IS 'codeä¸ºåˆ†ç±»çš„cps';


--
-- Name: COLUMN resource_prefix.code_cap; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_prefix.code_cap IS 'codeä¸ºåˆ†ç±»çš„cap';


--
-- Name: resource_prefix_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_prefix_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_prefix_id_seq OWNER TO postgres;

--
-- Name: resource_prefix_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_prefix_id_seq OWNED BY resource_prefix.id;


--
-- Name: resource_prefix_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_prefix_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_prefix_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_prefix_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_prefix_record (
    id integer,
    resource_id integer,
    tech_prefix prefix_range,
    route_strategy_id integer,
    rate_table_id integer,
    code prefix_range,
    code_cps integer,
    code_cap integer,
    product_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_prefix_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_prefix_record OWNER TO postgres;

--
-- Name: resource_prefix_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_prefix_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_prefix_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_prefix_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_prefix_record_tmp (
    id integer,
    resource_id integer,
    tech_prefix prefix_range,
    route_strategy_id integer,
    rate_table_id integer,
    code prefix_range,
    code_cps integer,
    code_cap integer,
    product_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_prefix_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_prefix_record_tmp OWNER TO postgres;

--
-- Name: resource_rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_rate (
    id integer NOT NULL,
    code prefix_range,
    rate numeric(30,10),
    service_rate real,
    finance_rate real,
    resource_id integer,
    order_type integer,
    min_time integer DEFAULT 0 NOT NULL,
    "interval" integer DEFAULT 1 NOT NULL,
    code_name character varying(100),
    country character varying(1000),
    ingress_id integer,
    egress_id integer
);


ALTER TABLE resource_rate OWNER TO postgres;

--
-- Name: COLUMN resource_rate.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_rate.order_type IS '1-buy order
2-sell order';


--
-- Name: resource_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_rate_id_seq OWNER TO postgres;

--
-- Name: resource_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_rate_id_seq OWNED BY resource_rate.id;


--
-- Name: resource_rate_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_rate_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_rate_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_rate_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_rate_record (
    id integer,
    code prefix_range,
    rate numeric(30,10),
    service_rate real,
    finance_rate real,
    resource_id integer,
    order_type integer,
    min_time integer,
    "interval" integer,
    code_name character varying(100),
    country character varying(1000),
    ingress_id integer,
    egress_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_rate_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_rate_record OWNER TO postgres;

--
-- Name: resource_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_record (
    resource_id integer,
    name character varying(100),
    ingress boolean,
    egress boolean,
    active boolean,
    rfc_2833 boolean,
    t38 boolean,
    alias character varying(100),
    res_strategy smallint,
    cps_limit integer,
    capacity integer,
    lnp boolean,
    lrn_block boolean,
    client_id integer,
    tdm boolean,
    rate_table_id integer,
    transnexus integer,
    route_strategy_id integer,
    media_type integer,
    pass_through integer,
    profit_margin double precision,
    enough_balance boolean,
    egress_bill_after_action boolean,
    proto integer,
    dnis_only boolean,
    ring_timeout integer,
    ignore_ring boolean,
    ignore_early_media boolean,
    disable_by_alert boolean,
    priority integer,
    last_priority integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    status integer,
    wait_ringtime180 integer,
    profit_type integer,
    lnp_dipping boolean,
    lnp_dipping_rate real,
    update_at timestamp with time zone,
    update_by character varying,
    cli_type integer,
    auth_type integer,
    delay_bye_second integer,
    delay_bye_limit integer,
    max_duration integer,
    marketplace integer,
    rating_type integer,
    billing_type integer,
    trunk_type integer,
    switch_profile_id integer,
    transaction_fee_id integer,
    service_type integer,
    product_id integer,
    rpid smallint,
    paid smallint,
    oli smallint,
    pci smallint,
    priv smallint,
    div smallint,
    trunk_type2 smallint,
    account_id character(32),
    billing_method smallint,
    amount_per_port numeric,
    billing_rule integer,
    ignore_early_nosdp integer,
    media_timeout integer,
    private integer,
    agent_type integer,
    bill_by integer,
    rate_profile integer,
    us_route integer,
    intl_route integer,
    canada_route integer,
    rate_decimal integer,
    rate_rounding integer,
    us_other integer,
    canada_other integer,
    redirect integer,
    lrn_prefix integer,
    pass_response_code integer,
    is_del integer,
    dtmf_type integer,
    dtmf_detect integer,
    rpid_screen integer,
    rpid_party integer,
    display_name integer,
    rpid_id_type integer,
    rpid_privacy integer,
    counter_time integer,
    number integer,
    block_time integer,
    re_invite integer,
    re_invite_interval integer,
    info integer,
    rfc2833 integer,
    inband integer,
    dummy_trunk boolean,
    random_table_id integer,
    is_virtual boolean,
    rfc_r833_payload integer,
    resource_template_id integer,
    rate_use_rpid boolean,
    group_id integer,
    resource_block_group_id integer,
    block_404_number_time integer,
    billing_port_type integer,
    cost_per_port numeric,
    price_per_actual_channel double precision,
    price_per_max_channel double precision,
    enfource_cid boolean,
    ani_cps_limit integer,
    ani_cap_limit integer,
    dnis_cps_limit integer,
    dnis_cap_limit integer,
    jurisdiction_use_dnis boolean,
    cid_min_asr integer,
    cid_min_acd integer,
    cid_max_sdp integer,
    tech_prefix varchar(255),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_record OWNER TO postgres;

--
-- Name: resource_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_record_tmp (
    resource_id integer,
    name character varying(100),
    ingress boolean,
    egress boolean,
    active boolean,
    rfc_2833 boolean,
    t38 boolean,
    alias character varying(100),
    res_strategy smallint,
    cps_limit integer,
    capacity integer,
    lnp boolean,
    lrn_block boolean,
    client_id integer,
    tdm boolean,
    rate_table_id integer,
    transnexus integer,
    route_strategy_id integer,
    media_type integer,
    pass_through integer,
    profit_margin double precision,
    enough_balance boolean,
    egress_bill_after_action boolean,
    proto integer,
    dnis_only boolean,
    ring_timeout integer,
    ignore_ring boolean,
    ignore_early_media boolean,
    disable_by_alert boolean,
    priority integer,
    last_priority integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    status integer,
    wait_ringtime180 integer,
    profit_type integer,
    lnp_dipping boolean,
    lnp_dipping_rate real,
    update_at timestamp with time zone,
    update_by character varying,
    cli_type integer,
    auth_type integer,
    delay_bye_second integer,
    delay_bye_limit integer,
    max_duration integer,
    marketplace integer,
    rating_type integer,
    billing_type integer,
    trunk_type integer,
    switch_profile_id integer,
    transaction_fee_id integer,
    service_type integer,
    product_id integer,
    rpid smallint,
    paid smallint,
    oli smallint,
    pci smallint,
    priv smallint,
    div smallint,
    trunk_type2 smallint,
    account_id character(32),
    billing_method smallint,
    amount_per_port numeric,
    billing_rule integer,
    ignore_early_nosdp integer,
    media_timeout integer,
    private integer,
    agent_type integer,
    bill_by integer,
    rate_profile integer,
    us_route integer,
    intl_route integer,
    canada_route integer,
    rate_decimal integer,
    rate_rounding integer,
    us_other integer,
    canada_other integer,
    redirect integer,
    lrn_prefix integer,
    pass_response_code integer,
    is_del integer,
    dtmf_type integer,
    dtmf_detect integer,
    rpid_screen integer,
    rpid_party integer,
    display_name integer,
    rpid_id_type integer,
    rpid_privacy integer,
    counter_time integer,
    number integer,
    block_time integer,
    re_invite integer,
    re_invite_interval integer,
    info integer,
    rfc2833 integer,
    inband integer,
    dummy_trunk boolean,
    random_table_id integer,
    is_virtual boolean,
    rfc_r833_payload integer,
    resource_template_id integer,
    rate_use_rpid boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_record_tmp OWNER TO postgres;

--
-- Name: resource_replace_action; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_replace_action (
    id integer NOT NULL,
    resource_id integer,
    ani_prefix character varying(50),
    ani character varying(30),
    ani_min_length integer DEFAULT 1,
    ani_max_length integer,
    type integer,
    dnis_prefix character varying(30),
    dnis character varying(30),
    dnis_min_length integer,
    dnis_max_length integer
);


ALTER TABLE resource_replace_action OWNER TO postgres;

--
-- Name: COLUMN resource_replace_action.ani_min_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_replace_action.ani_min_length IS 'åŒ¹é…çš„ä¸»å«å·æœ€å°é•¿åº¦ï¼Œè·Ÿæœ€å¤§é•¿åº¦å¹¶ä¸”å…³ç³»ï¼Œå¤§äºŽç­‰äºŽã€‚';


--
-- Name: COLUMN resource_replace_action.ani_max_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_replace_action.ani_max_length IS 'åŒ¹é…çš„ä¸»å«å·æœ€å¤§é•¿åº¦ï¼Œè·Ÿæœ€å°é•¿åº¦å¹¶ä¸”å…³ç³»ï¼Œå°äºŽã€‚';


--
-- Name: COLUMN resource_replace_action.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_replace_action.type IS '0 -- ani åªæ›¿æ¢ä¸»å«
1 -- dnis åªæ›¿æ¢è¢«å«
2 -- both æ›¿æ¢ä¸»å«å’Œè¢«å«';


--
-- Name: COLUMN resource_replace_action.dnis_prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_replace_action.dnis_prefix IS 'åŒ¹é…è¢«å«çš„å‰ç¼€';


--
-- Name: COLUMN resource_replace_action.dnis; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_replace_action.dnis IS 'åŒ¹é…æˆåŠŸåŽæ›¿æ¢çš„è¢«å«å·ç ';


--
-- Name: COLUMN resource_replace_action.dnis_min_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_replace_action.dnis_min_length IS 'åŒ¹é…çš„è¢«å«å·æœ€å°é•¿åº¦ï¼Œè·Ÿæœ€å¤§é•¿åº¦å¹¶ä¸”å…³ç³»ï¼Œå¤§äºŽç­‰äºŽã€‚';


--
-- Name: COLUMN resource_replace_action.dnis_max_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_replace_action.dnis_max_length IS 'åŒ¹é…çš„è¢«å«å·æœ€å¤§é•¿åº¦ï¼Œè·Ÿæœ€å°é•¿åº¦å¹¶ä¸”å…³ç³»ï¼Œå°äºŽã€‚';


--
-- Name: resource_replace_action_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_replace_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_replace_action_id_seq OWNER TO postgres;

--
-- Name: resource_replace_action_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_replace_action_id_seq OWNED BY resource_replace_action.id;


--
-- Name: resource_replace_action_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_replace_action_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_replace_action_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_replace_action_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_replace_action_record (
    id integer,
    resource_id integer,
    ani_prefix character varying(50),
    ani character varying(30),
    ani_min_length integer,
    ani_max_length integer,
    type integer,
    dnis_prefix character varying(30),
    dnis character varying(30),
    dnis_min_length integer,
    dnis_max_length integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_replace_action_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_replace_action_record OWNER TO postgres;

--
-- Name: resource_replace_action_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_replace_action_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_replace_action_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_replace_action_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_replace_action_record_tmp (
    id integer,
    resource_id integer,
    ani_prefix character varying(50),
    ani character varying(30),
    ani_min_length integer,
    ani_max_length integer,
    type integer,
    dnis_prefix character varying(30),
    dnis character varying(30),
    dnis_min_length integer,
    dnis_max_length integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_replace_action_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_replace_action_record_tmp OWNER TO postgres;

--
-- Name: resource_replace_action_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_replace_action_template (
    id integer NOT NULL,
    resource_template_id integer,
    ani_prefix character varying(50),
    ani character varying(30),
    ani_min_length integer,
    ani_max_length integer,
    type integer,
    dnis_prefix character varying(30),
    dnis character varying(30),
    dnis_min_length integer,
    dnis_max_length integer
);


ALTER TABLE resource_replace_action_template OWNER TO postgres;

--
-- Name: resource_replace_action_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_replace_action_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_replace_action_template_id_seq OWNER TO postgres;

--
-- Name: resource_replace_action_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_replace_action_template_id_seq OWNED BY resource_replace_action_template.id;


--
-- Name: resource_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_template (
    name character varying(100),
    resource_template_id integer NOT NULL,
    create_by character varying(100),
    update_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    create_on timestamp with time zone,
    trunk_type integer DEFAULT 0 NOT NULL,
    media_type integer,
    profit_margin double precision DEFAULT 0 NOT NULL,
    profit_type integer DEFAULT 1 NOT NULL,
    wait_ringtime180 integer,
    lnp_dipping_rate real,
    lnp_dipping boolean DEFAULT false,
    delay_bye_second integer,
    ignore_early_media boolean DEFAULT false,
    re_invite integer,
    re_invite_interval integer,
    media_timeout integer,
    res_strategy smallint,
    max_duration integer,
    trunk_type2 smallint DEFAULT 0 NOT NULL,
    billing_rule integer,
    billing_method smallint,
    rate_table_id integer,
    random_table_id integer,
    amount_per_port numeric,
    info integer,
    rfc2833 integer,
    inband integer,
    ring_timeout integer DEFAULT 60 NOT NULL,
    codecs_str character varying(200),
    paid smallint,
    oli smallint,
    pci smallint,
    priv smallint,
    div smallint,
    display_name smallint,
    rpid_screen integer DEFAULT 0,
    rpid_party integer DEFAULT 0,
    rpid_id_type integer DEFAULT 0,
    rpid_privacy integer DEFAULT 0,
    rate_rounding integer DEFAULT 0,
    rate_decimal integer DEFAULT 6,
    rate_profile integer DEFAULT 0,
    us_route integer DEFAULT 0,
    us_other integer DEFAULT 0,
    canada_route integer DEFAULT 0,
    canada_other integer DEFAULT 0,
    intl_route integer DEFAULT 0,
    ignore_early_nosdp integer,
    bill_by integer DEFAULT 4,
    ignore_ring boolean DEFAULT false,
    t38 boolean DEFAULT false NOT NULL
);


ALTER TABLE resource_template OWNER TO postgres;

--
-- Name: COLUMN resource_template.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.trunk_type IS '0 ingress
1 egress';


--
-- Name: COLUMN resource_template.re_invite; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.re_invite IS '0 -- false
1 -- true

å‘é€re-INVITEæ£€æµ‹å¯¹æ–¹æ˜¯å¦æ´»è·ƒ';


--
-- Name: COLUMN resource_template.re_invite_interval; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.re_invite_interval IS 'ç§’å•ä½ï¼Œå»ºè®®ä¸å°äºŽ60ç§’';


--
-- Name: COLUMN resource_template.res_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.res_strategy IS 'è½åœ°ç½‘å…³é€‰æ‹©ç­–ç•¥
1ï¼ï¼top-down
2ï¼ï¼round-robin';


--
-- Name: COLUMN resource_template.billing_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.billing_method IS '0 - by minutes

1- by port';


--
-- Name: COLUMN resource_template.rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.rate_table_id IS 'è´¹çŽ‡æ¨¡æ¿';


--
-- Name: COLUMN resource_template.amount_per_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.amount_per_port IS 'money per port';


--
-- Name: COLUMN resource_template.info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.info IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource_template.rfc2833; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.rfc2833 IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource_template.inband; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.inband IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource_template.bill_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_template.bill_by IS '0 -- DNISï¼ŒDNISè®¡è´¹ï¼Œä¸éœ€è¦æŸ¥è¯¢LRN
1 -- LRNï¼ŒLRNè®¡è´¹ï¼Œå¿½ç•¥è¿è¥å•†å˜åŒ–
2 -- LRN Blockï¼ŒLRNè®¡è´¹å·ç è¿è¥å•†æœ‰æ”¹å˜ï¼Œåˆ™æ‹’ç»
3 -- LRN Block Higher Rateï¼ŒLRNè´¹çŽ‡é«˜äºŽDNISè´¹çŽ‡
4 -- Follow Rate Deckï¼Œä½¿ç”¨è´¹çŽ‡è¡¨çš„ä»¥ä¸Šé…ç½®';


--
-- Name: resource_template_resource_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_template_resource_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_template_resource_template_id_seq OWNER TO postgres;

--
-- Name: resource_template_resource_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_template_resource_template_id_seq OWNED BY resource_template.resource_template_id;


--
-- Name: resource_translation_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_translation_ref (
    ref_id integer NOT NULL,
    resource_id integer NOT NULL,
    translation_id integer NOT NULL,
    time_profile_id integer
);


ALTER TABLE resource_translation_ref OWNER TO postgres;

--
-- Name: TABLE resource_translation_ref; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE resource_translation_ref IS 'ä¸åŒæ—¶é—´æ®µï¼Œä¸åŒçš„ä¸»è¢«å«è½¬æ¢';


--
-- Name: COLUMN resource_translation_ref.ref_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_translation_ref.ref_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_translation_ref.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_translation_ref.resource_id IS 'ç½‘å…³ç»„ï¼ï¼å¤–é”®
å¯¹æŽ¥ç½‘å…³';


--
-- Name: COLUMN resource_translation_ref.translation_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_translation_ref.translation_id IS 'è½¬æ¢è§„åˆ™ï¼ï¼å¤–é”®';


--
-- Name: COLUMN resource_translation_ref.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN resource_translation_ref.time_profile_id IS 'æ—¶é—´æ®µï¼ï¼å¤–é”®';


--
-- Name: resource_translation_ref_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_translation_ref_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_translation_ref_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_translation_ref_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_translation_ref_record (
    ref_id integer,
    resource_id integer,
    translation_id integer,
    time_profile_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_translation_ref_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_translation_ref_record OWNER TO postgres;

--
-- Name: resource_translation_ref_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_translation_ref_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_translation_ref_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_translation_ref_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE resource_translation_ref_record_tmp (
    ref_id integer,
    resource_id integer,
    translation_id integer,
    time_profile_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('resource_translation_ref_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE resource_translation_ref_record_tmp OWNER TO postgres;

--
-- Name: resource_translation_ref_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE resource_translation_ref_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE resource_translation_ref_ref_id_seq OWNER TO postgres;

--
-- Name: resource_translation_ref_ref_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE resource_translation_ref_ref_id_seq OWNED BY resource_translation_ref.ref_id;


--
-- Name: retrieve_password_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE retrieve_password_log (
    id integer NOT NULL,
    username character varying(500),
    operation_time timestamp with time zone,
    email_addresses character varying(500),
    modify_time timestamp with time zone,
    status smallint
);


ALTER TABLE retrieve_password_log OWNER TO postgres;

--
-- Name: COLUMN retrieve_password_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN retrieve_password_log.status IS '1,failure

2,E-mail has been sent

3,Modified successfully
';


--
-- Name: retrieve_password_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE retrieve_password_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE retrieve_password_log_id_seq OWNER TO postgres;

--
-- Name: retrieve_password_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE retrieve_password_log_id_seq OWNED BY retrieve_password_log.id;


--
-- Name: role; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE role (
    role_id integer NOT NULL,
    role_name character varying(100) NOT NULL,
    view_pw boolean DEFAULT false,
    default_sysfunc_id integer,
    del_able boolean DEFAULT true,
    edit_able boolean DEFAULT true,
    client_id integer,
    is_carriers boolean DEFAULT true,
    is_transaction boolean DEFAULT true,
    is_mutual_settlements boolean DEFAULT true,
    is_invoices boolean DEFAULT true,
    is_payment boolean DEFAULT true,
    is_spam_report boolean DEFAULT true,
    is_location_report boolean DEFAULT true,
    is_origterm boolean DEFAULT true,
    is_summary_report boolean DEFAULT true,
    is_usage_report boolean DEFAULT true,
    is_cdr_list boolean DEFAULT true,
    is_qos_report boolean DEFAULT true,
    is_disconnect_cause boolean DEFAULT true,
    is_billing_mismatch boolean DEFAULT true,
    is_active_call boolean DEFAULT true,
    is_termination_report boolean DEFAULT true,
    is_rates_analysis boolean DEFAULT true,
    is_call_simulation boolean DEFAULT true,
    is_ingress_trunk_simulation boolean DEFAULT true,
    is_egress_trunk_simulation boolean DEFAULT true,
    is_sip_capture boolean DEFAULT true,
    is_digit_mapping boolean DEFAULT true,
    is_trunk boolean DEFAULT true,
    is_dynamic_routing boolean DEFAULT true,
    is_static_route_table boolean DEFAULT true,
    is_block_list boolean DEFAULT true,
    is_routing_plan boolean DEFAULT true,
    is_active_web_session boolean DEFAULT true,
    is_payment_term boolean DEFAULT true,
    is_jurisdiction boolean DEFAULT true,
    is_capicity boolean DEFAULT true,
    is_rate_table boolean DEFAULT true,
    is_code_deck boolean DEFAULT true,
    is_time_profile boolean DEFAULT true,
    is_currency boolean DEFAULT true,
    is_task_schedulers boolean DEFAULT true,
    is_mail_template boolean DEFAULT true,
    is_role boolean DEFAULT true,
    is_user boolean DEFAULT true,
    is_change_password boolean DEFAULT true,
    is_setting boolean DEFAULT true,
    is_import_log boolean DEFAULT true,
    is_export_log boolean DEFAULT true,
    is_cdr_backup boolean DEFAULT true,
    is_lrn_setting boolean DEFAULT true,
    active boolean DEFAULT true,
    is_unpaid_bills boolean DEFAULT true,
    is_service_charge boolean DEFAULT true,
    is_voip_gateway boolean DEFAULT true,
    is_trouble_shoot boolean DEFAULT true,
    is_event boolean DEFAULT true,
    is_ticket boolean DEFAULT true,
    is_buy_select_country boolean DEFAULT true,
    is_search_private_buy boolean DEFAULT true,
    is_buy_confirm_order boolean DEFAULT true,
    is_sell_select_country boolean DEFAULT true,
    is_search_private_sell boolean DEFAULT true,
    is_sell_confirm_order boolean DEFAULT true,
    role_type integer DEFAULT 1
);


ALTER TABLE role OWNER TO postgres;

--
-- Name: TABLE role; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE role IS 'è§’è‰²';


--
-- Name: COLUMN role.role_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role.role_id IS 'ä¸»é”®';


--
-- Name: COLUMN role.role_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role.role_name IS 'åç§°';


--
-- Name: COLUMN role.view_pw; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role.view_pw IS 'æ˜¯å¦æœ‰æŸ¥çœ‹å¯†ç çš„æƒé™';


--
-- Name: COLUMN role.default_sysfunc_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role.default_sysfunc_id IS 'æƒé™åŠŸèƒ½';


--
-- Name: COLUMN role.del_able; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role.del_able IS 'æ‹¥æœ‰è¿™ä¸ªè§’è‰²çš„ç”¨æˆ·æ˜¯å¦èƒ½è¢«åˆ é™¤';


--
-- Name: COLUMN role.edit_able; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role.edit_able IS 'æ‹¥æœ‰è¿™ä¸ªè§’è‰²çš„ç”¨æˆ·ä¿¡æ¯æ˜¯å¦èƒ½è¢«ä¿®æ”¹';


--
-- Name: COLUMN role.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN role.role_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role.role_type IS '1--adminä½¿ç”¨çš„è§’è‰²
2--carrierä½¿ç”¨çš„è§’è‰²';


--
-- Name: role_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE role_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE role_role_id_seq OWNER TO postgres;

--
-- Name: role_role_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE role_role_id_seq OWNED BY role.role_id;


--
-- Name: role_privilege; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE role_privilege (
    role_id integer DEFAULT nextval('role_role_id_seq'::regclass) NOT NULL,
    system_function_id integer NOT NULL,
    writable boolean DEFAULT false NOT NULL,
    readable boolean DEFAULT false NOT NULL,
    executable boolean DEFAULT false NOT NULL,
    reseller_id integer,
    role_privilege_id integer NOT NULL
);


ALTER TABLE role_privilege OWNER TO postgres;

--
-- Name: TABLE role_privilege; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE role_privilege IS 'è§’è‰²æƒé™';


--
-- Name: COLUMN role_privilege.role_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role_privilege.role_id IS 'role';


--
-- Name: COLUMN role_privilege.system_function_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role_privilege.system_function_id IS 'ç³»ç»ŸåŠŸèƒ½æˆ–é¡µé¢';


--
-- Name: COLUMN role_privilege.writable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role_privilege.writable IS 'å¯å†™æƒé™';


--
-- Name: COLUMN role_privilege.readable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role_privilege.readable IS 'å¯è¯»æƒé™';


--
-- Name: COLUMN role_privilege.executable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role_privilege.executable IS 'å¯æ‰§è¡Œæƒé™';


--
-- Name: COLUMN role_privilege.reseller_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role_privilege.reseller_id IS 'ä»£ç†å•†';


--
-- Name: COLUMN role_privilege.role_privilege_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN role_privilege.role_privilege_id IS 'ä¸»é”®';


--
-- Name: role_privilege_role_privilege_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE role_privilege_role_privilege_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE role_privilege_role_privilege_id_seq OWNER TO postgres;

--
-- Name: role_privilege_role_privilege_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE role_privilege_role_privilege_id_seq OWNED BY role_privilege.role_privilege_id;


--
-- Name: route_block; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE route_block (
    egress_trunk_id integer,
    code_name character varying(256),
    id integer NOT NULL,
    create_by character varying(256),
    create_on timestamp without time zone
);


ALTER TABLE route_block OWNER TO postgres;

--
-- Name: route_block_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE route_block_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE route_block_id_seq OWNER TO postgres;

--
-- Name: route_block_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE route_block_id_seq OWNED BY route_block.id;


--
-- Name: route_qos_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE route_qos_report (
);


ALTER TABLE route_qos_report OWNER TO postgres;

--
-- Name: TABLE route_qos_report; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE route_qos_report IS 'ç»Ÿè®¡resource_id + code çš„asr, acdç­‰ã€‚';


--
-- Name: route_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE route_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE route_record_record_id_seq OWNER TO postgres;

--
-- Name: route_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE route_record (
    route_id integer,
    digits prefix_range,
    dynamic_route_id integer,
    static_route_id integer,
    route_type integer,
    route_strategy_id integer,
    lnp boolean,
    lrn_block boolean,
    dnis_only boolean,
    code_deck_type integer,
    update_at timestamp with time zone,
    update_by character varying,
    intra_static_route_id integer,
    inter_static_route_id integer,
    jurisdiction_country_id integer,
    ani_prefix prefix_range,
    ani_min_length integer,
    ani_max_length integer,
    digits_min_length integer,
    digits_max_length integer,
    code_name character varying,
    country character varying(50),
    route_type_flg integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('route_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE route_record OWNER TO postgres;

--
-- Name: route_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE route_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE route_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: route_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE route_record_tmp (
    route_id integer,
    digits prefix_range,
    dynamic_route_id integer,
    static_route_id integer,
    route_type integer,
    route_strategy_id integer,
    lnp boolean,
    lrn_block boolean,
    dnis_only boolean,
    code_deck_type integer,
    update_at timestamp with time zone,
    update_by character varying,
    intra_static_route_id integer,
    inter_static_route_id integer,
    jurisdiction_country_id integer,
    ani_prefix prefix_range,
    ani_min_length integer,
    ani_max_length integer,
    digits_min_length integer,
    digits_max_length integer,
    code_name character varying,
    country character varying(50),
    route_type_flg integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('route_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE route_record_tmp OWNER TO postgres;

--
-- Name: route_route_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE route_route_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE route_route_id_seq OWNER TO postgres;

--
-- Name: route_route_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE route_route_id_seq OWNED BY route.route_id;


--
-- Name: route_strategy_route_strategy_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE route_strategy_route_strategy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE route_strategy_route_strategy_id_seq OWNER TO postgres;

--
-- Name: route_strategy_route_strategy_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE route_strategy_route_strategy_id_seq OWNED BY route_strategy.route_strategy_id;


--
-- Name: routing_wizard_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE routing_wizard_list (
    id integer NOT NULL,
    client_id integer,
    resource_id integer,
    rate_generation_template_id integer,
    send_rate_on timestamp with time zone,
    create_time timestamp with time zone,
    create_by character varying(50),
    rate_generation_history_id integer,
    virtual_dynamic_route_id integer,
    virtual_route_plan_id integer,
    virtual_route_id integer,
    virtual_rate_table_id integer,
    rollback_sql text,
    rate_generation_history_detail_id integer
);


ALTER TABLE routing_wizard_list OWNER TO postgres;

--
-- Name: routing_wizard_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE routing_wizard_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE routing_wizard_list_id_seq OWNER TO postgres;

--
-- Name: routing_wizard_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE routing_wizard_list_id_seq OWNED BY routing_wizard_list.id;


--
-- Name: scheduled_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE scheduled_report (
    id integer NOT NULL,
    report_name character varying(100),
    email_to character varying(500),
    subject text,
    frequency_type integer,
    time_of_day integer,
    day_of_week integer,
    day_of_months integer,
    action boolean,
    query text,
    query2 text,
    query3 text,
    report_type integer,
    "interval" integer
);


ALTER TABLE scheduled_report OWNER TO postgres;

--
-- Name: TABLE scheduled_report; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE scheduled_report IS 'å‘é€æŠ¥è¡¨';


--
-- Name: COLUMN scheduled_report.email_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report.email_to IS 'å¤šä¸ªä»¥ï¼›åˆ†éš”';


--
-- Name: COLUMN scheduled_report.subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report.subject IS ' å‘é€é‚®ä»¶çš„ä¸»é¢˜';


--
-- Name: COLUMN scheduled_report.frequency_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report.frequency_type IS '1:Daily
2:Weekly
3:Monthly';


--
-- Name: COLUMN scheduled_report.time_of_day; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report.time_of_day IS '0-23 hour';


--
-- Name: COLUMN scheduled_report.day_of_week; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report.day_of_week IS 'Mon, Tue, Wed, Thu, Fri, Sat, Sun
1,2,3,4,5,6,7';


--
-- Name: COLUMN scheduled_report.day_of_months; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report.day_of_months IS 'æ¯æœˆçš„å‡ å·';


--
-- Name: COLUMN scheduled_report.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report.action IS 'æ˜¯å¦å¯ç”¨';


--
-- Name: COLUMN scheduled_report.query; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report.query IS 'æ‰§è¡Œçš„sql';


--
-- Name: COLUMN scheduled_report.query2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report.query2 IS 'åœ¨æŠ¥è¡¨æœ‰ä¸‰ä¸­æƒ…å†µæ—¶è®°å½•';


--
-- Name: COLUMN scheduled_report.report_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report.report_type IS 'ä¸åŒçš„æŠ¥è¡¨';


--
-- Name: COLUMN scheduled_report."interval"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report."interval" IS 'æŠ¥è¡¨æŸ¥è¯¢çš„æ—¶é—´åŒºé—´ï¼Œå•ä½ä¸ºå°æ—¶h';


--
-- Name: scheduled_report_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE scheduled_report_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE scheduled_report_id_seq OWNER TO postgres;

--
-- Name: scheduled_report_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE scheduled_report_id_seq OWNED BY scheduled_report.id;


--
-- Name: scheduled_report_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE scheduled_report_log (
    id integer NOT NULL,
    email_to character varying(500),
    report_name character(50),
    attachment_path character varying(500),
    execute_time timestamp with time zone
);


ALTER TABLE scheduled_report_log OWNER TO postgres;

--
-- Name: COLUMN scheduled_report_log.attachment_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduled_report_log.attachment_path IS 'å‘é€çš„é™„ä»¶è·¯å¾„';


--
-- Name: scheduled_report_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE scheduled_report_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE scheduled_report_log_id_seq OWNER TO postgres;

--
-- Name: scheduled_report_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE scheduled_report_log_id_seq OWNED BY scheduled_report_log.id;


--
-- Name: scheduler; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE scheduler (
    id integer NOT NULL,
    name character varying(255),
    active boolean,
    minute_type integer,
    minute integer,
    hour_type integer,
    hour integer,
    day_type integer,
    day integer,
    week integer,
    last_run timestamp with time zone,
    script_name character varying(255)
);


ALTER TABLE scheduler OWNER TO postgres;

--
-- Name: scheduler_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE scheduler_log (
    id integer NOT NULL,
    script_name character varying(200),
    start_time timestamp without time zone,
    end_time timestamp without time zone
);


ALTER TABLE scheduler_log OWNER TO postgres;

--
-- Name: COLUMN scheduler_log.script_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduler_log.script_name IS 'è„šæœ¬åå­—';


--
-- Name: COLUMN scheduler_log.start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduler_log.start_time IS 'è„šæœ¬å¼€å§‹æ‰§è¡Œæ—¶é—´';


--
-- Name: COLUMN scheduler_log.end_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN scheduler_log.end_time IS 'æ‰§è¡Œç»“æŸæ—¶é—´';


--
-- Name: scheduler_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE scheduler_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE scheduler_log_id_seq OWNER TO postgres;

--
-- Name: scheduler_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE scheduler_log_id_seq OWNED BY scheduler_log.id;


--
-- Name: search_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE search_logs (
    id integer NOT NULL,
    type character varying(100) NOT NULL,
    search_val character varying(100),
    search_time timestamp without time zone,
    client_id integer,
    module character varying(100)
);


ALTER TABLE search_logs OWNER TO postgres;

--
-- Name: COLUMN search_logs.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN search_logs.type IS '--code
--code_name
--country
--order_id';


--
-- Name: COLUMN search_logs.search_val; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN search_logs.search_val IS 'æŸ¥è¯¢çš„å†…å®¹';


--
-- Name: search_logs_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE search_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE search_logs_id_seq OWNER TO postgres;

--
-- Name: search_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE search_logs_id_seq OWNED BY search_logs.id;


--
-- Name: sell_order; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sell_order (
    id integer NOT NULL,
    name character varying(40),
    client_id integer NOT NULL,
    resource_id integer NOT NULL,
    code_deck_id integer DEFAULT 1,
    rate numeric(30,10),
    is_private boolean DEFAULT false NOT NULL,
    is_commit boolean DEFAULT false NOT NULL,
    commit_minutes integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    cli boolean DEFAULT false NOT NULL,
    g729 boolean DEFAULT false NOT NULL,
    fax boolean DEFAULT false NOT NULL,
    active boolean DEFAULT true NOT NULL,
    status integer DEFAULT 0 NOT NULL,
    expire_time timestamp with time zone,
    country character varying(100),
    acd real,
    asr real,
    user_id integer NOT NULL,
    dtmf boolean DEFAULT false NOT NULL,
    state_date timestamp with time zone NOT NULL,
    end_date timestamp with time zone,
    limit_price numeric(30,10),
    g723 boolean DEFAULT false NOT NULL,
    g711 boolean DEFAULT false NOT NULL,
    time_of_date boolean DEFAULT false NOT NULL,
    peak boolean DEFAULT false NOT NULL,
    offpeak boolean DEFAULT false NOT NULL,
    weekend boolean DEFAULT false NOT NULL,
    invite_id integer,
    partner_id integer,
    resource_prefix prefix_range DEFAULT ''::prefix_range NOT NULL,
    route_type integer DEFAULT 1 NOT NULL,
    asr_var real,
    acd_var real,
    rate_only boolean DEFAULT false NOT NULL,
    match_type integer DEFAULT 2 NOT NULL,
    route_priority integer DEFAULT 1 NOT NULL,
    auto_match boolean DEFAULT false NOT NULL,
    auto_match_result integer,
    dialer boolean DEFAULT false NOT NULL,
    "interval" integer DEFAULT 1 NOT NULL,
    "limit" integer,
    is_select integer DEFAULT 0 NOT NULL,
    purged boolean DEFAULT false NOT NULL,
    cli_type integer DEFAULT 0 NOT NULL,
    minimal_duration integer DEFAULT 1 NOT NULL,
    pdd_timeout integer,
    auto_match_time timestamp with time zone,
    is_first integer
);


ALTER TABLE sell_order OWNER TO postgres;

--
-- Name: COLUMN sell_order.route_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sell_order.route_type IS '1: Prime,2:Select,2: Direct
';


--
-- Name: COLUMN sell_order.match_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sell_order.match_type IS '1:var2:soft3:hard';


--
-- Name: COLUMN sell_order.route_priority; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sell_order.route_priority IS '1--quality
2--price';


--
-- Name: COLUMN sell_order.auto_match_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sell_order.auto_match_result IS '0-fail
1-success';


--
-- Name: COLUMN sell_order.is_select; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sell_order.is_select IS '0--æ²¡æœ‰é€‰å®š
1--å–æ¶ˆé€‰å®š
2--é€‰å®š
3--ç¡®è®¤é€‰å®š';


--
-- Name: COLUMN sell_order.cli_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sell_order.cli_type IS '0-white
1-white non cli
2-grey';


--
-- Name: COLUMN sell_order.is_first; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sell_order.is_first IS '1-æŽ’åœ¨ç¬¬ä¸€ä½
2-å¤±åŽ»ç¬¬ä¸€ä½
3-æŽ’åœ¨ç¬¬ä¸€ä½å·²å‘é€é‚®ä»¶
4-å¤±åŽ»ç¬¬ä¸€ä½å·²å‘é€é‚®ä»¶';


--
-- Name: sell_order_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sell_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sell_order_id_seq OWNER TO postgres;

--
-- Name: sell_order_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE sell_order_id_seq OWNED BY sell_order.id;


--
-- Name: sell_order_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sell_order_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sell_order_record_record_id_seq OWNER TO postgres;

--
-- Name: sell_order_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sell_order_record (
    id integer,
    name character varying(40),
    client_id integer,
    resource_id integer,
    code_deck_id integer,
    rate numeric(30,10),
    is_private boolean,
    is_commit boolean,
    commit_minutes integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    cli boolean,
    g729 boolean,
    fax boolean,
    active boolean,
    status integer,
    expire_time timestamp with time zone,
    country character varying(100),
    acd real,
    asr real,
    user_id integer,
    dtmf boolean,
    state_date timestamp with time zone,
    end_date timestamp with time zone,
    limit_price numeric(30,10),
    g723 boolean,
    g711 boolean,
    time_of_date boolean,
    peak boolean,
    offpeak boolean,
    weekend boolean,
    invite_id integer,
    partner_id integer,
    resource_prefix prefix_range,
    route_type integer,
    asr_var real,
    acd_var real,
    rate_only boolean,
    match_type integer,
    route_priority integer,
    auto_match boolean,
    auto_match_result integer,
    dialer boolean,
    "interval" integer,
    "limit" integer,
    is_select integer,
    purged boolean,
    cli_type integer,
    minimal_duration integer,
    pdd_timeout integer,
    auto_match_time timestamp with time zone,
    is_first integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('sell_order_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE sell_order_record OWNER TO postgres;

--
-- Name: sell_order_response; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sell_order_response (
    id integer NOT NULL,
    sell_order_id integer,
    client_id integer,
    is_commit boolean DEFAULT true NOT NULL,
    commit_minutes integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    status integer DEFAULT 0 NOT NULL,
    expire_time timestamp with time zone,
    resource_id integer
);


ALTER TABLE sell_order_response OWNER TO postgres;

--
-- Name: COLUMN sell_order_response.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sell_order_response.client_id IS 'ä¹°è€…çš„client_id';


--
-- Name: sell_order_response_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sell_order_response_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sell_order_response_id_seq OWNER TO postgres;

--
-- Name: sell_order_response_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE sell_order_response_id_seq OWNED BY sell_order_response.id;


--
-- Name: send_mails; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE send_mails (
    id integer NOT NULL,
    client_id integer,
    mail_subject character varying(200),
    mail_content text,
    mail_to character varying(200),
    mail_cc character varying(200),
    files character varying(200)[],
    status integer DEFAULT 0,
    send_time time with time zone
);


ALTER TABLE send_mails OWNER TO postgres;

--
-- Name: COLUMN send_mails.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN send_mails.status IS '0 - waiting
1 - done
-1 - error

';


--
-- Name: send_mails_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE send_mails_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE send_mails_id_seq OWNER TO postgres;

--
-- Name: send_mails_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE send_mails_id_seq OWNED BY send_mails.id;


--
-- Name: send_rate_preserved_data; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE send_rate_preserved_data (
    id integer NOT NULL,
    rate_id integer NOT NULL,
    email_cc character varying(255) NOT NULL,
    subject character varying(255) NOT NULL,
    content character varying(255) NOT NULL,
    format integer,
    zipped boolean,
    start_effective_date text,
    email_template integer
);


ALTER TABLE send_rate_preserved_data OWNER TO postgres;

--
-- Name: send_rate_preserved_data_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE send_rate_preserved_data_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE send_rate_preserved_data_id_seq OWNER TO postgres;

--
-- Name: send_rate_preserved_data_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE send_rate_preserved_data_id_seq OWNED BY send_rate_preserved_data.id;


--
-- Name: send_rate_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE send_rate_template (
    id integer NOT NULL,
    name character varying(200),
    subject character varying(200),
    content text
);


ALTER TABLE send_rate_template OWNER TO postgres;

--
-- Name: send_rate_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE send_rate_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE send_rate_template_id_seq OWNER TO postgres;

--
-- Name: send_rate_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE send_rate_template_id_seq OWNED BY send_rate_template.id;


--
-- Name: server_platform_server_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE server_platform_server_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE server_platform_server_id_seq OWNER TO postgres;

--
-- Name: server_platform; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE server_platform (
    server_id integer DEFAULT nextval('server_platform_server_id_seq'::regclass) NOT NULL,
    server_type integer,
    ip ip4r NOT NULL,
    enable_register boolean DEFAULT false,
    port integer,
    project_type integer,
    info_ip ip4r,
    info_port integer,
    name character varying(200),
    sip_ip ip4r,
    sip_port integer,
    sip_path character varying(500)
);


ALTER TABLE server_platform OWNER TO postgres;

--
-- Name: TABLE server_platform; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE server_platform IS 'ç³»ç»Ÿå¹³å°åœ°å€';


--
-- Name: COLUMN server_platform.server_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN server_platform.server_id IS 'ä¸»é”®';


--
-- Name: COLUMN server_platform.server_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN server_platform.server_type IS '0ï¼ï¼class4
1ï¼ï¼sip proxy
2---sipcapture server
è´Ÿè´£æ³¨å†Œçš„';


--
-- Name: COLUMN server_platform.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN server_platform.ip IS 'ip';


--
-- Name: COLUMN server_platform.enable_register; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN server_platform.enable_register IS 'å‘é€æ³¨å†Œè¯·æ±‚çš„class4';


--
-- Name: COLUMN server_platform.project_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN server_platform.project_type IS 'é¡¹ç›®é…ç½®
1--exchange
2--wholesales
3--partition


';


--
-- Name: service_charge; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE service_charge (
    service_charge_id integer NOT NULL,
    name character varying(40) NOT NULL,
    buy_rate numeric(30,10) DEFAULT 0 NOT NULL,
    less_buy_rate_fee numeric(30,10),
    greater_buy_rate_fee numeric(30,10),
    sell_rate numeric(30,10),
    less_sell_rate_fee numeric(30,10),
    greater_sell_rate_fee numeric(30,10),
    buy_max_rate numeric(30,10),
    greater_buy_max_rate_fee numeric(30,10),
    sell_max_rate numeric(30,10),
    greater_sell_max_rate_fee numeric(30,10)
);


ALTER TABLE service_charge OWNER TO postgres;

--
-- Name: COLUMN service_charge.buy_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN service_charge.buy_rate IS 'æ‰“è¿›è´¹çŽ‡';


--
-- Name: COLUMN service_charge.less_buy_rate_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN service_charge.less_buy_rate_fee IS 'å°äºŽæ‰“è¿›rateçš„æ—¶å€™ï¼Œæ¯åˆ†é’Ÿå¤šå°‘è´¹ç”¨';


--
-- Name: COLUMN service_charge.greater_buy_rate_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN service_charge.greater_buy_rate_fee IS 'å¤§äºŽæˆ–ç­‰äºŽæ‰“è¿›rate
å¹¶ä¸”
å°äºŽæ‰“è¿›max rateçš„æ—¶å€™ï¼Œæ¯åˆ†é’Ÿå¤šå°‘è´¹ç”¨';


--
-- Name: COLUMN service_charge.sell_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN service_charge.sell_rate IS 'æ‰“å‡ºè´¹çŽ‡';


--
-- Name: COLUMN service_charge.buy_max_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN service_charge.buy_max_rate IS 'æ‰“è¿›æœ€å¤§è´¹çŽ‡';


--
-- Name: COLUMN service_charge.greater_buy_max_rate_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN service_charge.greater_buy_max_rate_fee IS 'å¤§äºŽæˆ–ç­‰äºŽæ‰“è¿›max rateçš„æ—¶å€™ï¼Œæ¯åˆ†é’Ÿå¤šå°‘è´¹ç”¨';


--
-- Name: service_charge_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE service_charge_items (
    id integer NOT NULL,
    min_rate numeric(30,10),
    max_rate numeric(30,10),
    charge_value real,
    service_charge_id integer
);


ALTER TABLE service_charge_items OWNER TO postgres;

--
-- Name: TABLE service_charge_items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE service_charge_items IS 'exchangeçš„æœåŠ¡è´¹è¡¨';


--
-- Name: service_charge_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE service_charge_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_charge_items_id_seq OWNER TO postgres;

--
-- Name: service_charge_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE service_charge_items_id_seq OWNED BY service_charge_items.id;


--
-- Name: service_charge_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE service_charge_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_charge_items_record_record_id_seq OWNER TO postgres;

--
-- Name: service_charge_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE service_charge_items_record (
    id integer,
    min_rate numeric(30,10),
    max_rate numeric(30,10),
    charge_value real,
    service_charge_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('service_charge_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE service_charge_items_record OWNER TO postgres;

--
-- Name: service_charge_items_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE service_charge_items_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_charge_items_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: service_charge_items_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE service_charge_items_record_tmp (
    id integer,
    min_rate numeric(30,10),
    max_rate numeric(30,10),
    charge_value real,
    service_charge_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('service_charge_items_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE service_charge_items_record_tmp OWNER TO postgres;

--
-- Name: service_charge_service_charge_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE service_charge_service_charge_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_charge_service_charge_id_seq OWNER TO postgres;

--
-- Name: service_charge_service_charge_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE service_charge_service_charge_id_seq OWNED BY service_charge.service_charge_id;


--
-- Name: shceduler_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE shceduler_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE shceduler_id_seq OWNER TO postgres;

--
-- Name: shceduler_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE shceduler_id_seq OWNED BY scheduler.id;


--
-- Name: signup; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE signup (
    id integer NOT NULL,
    company character varying(100),
    login character varying(40),
    password character varying(50),
    address character varying(500),
    email character varying(100),
    noc_email character varying(100),
    billing_email character varying(100),
    rate_email character varying(100),
    rate_delivery_email character varying(100),
    tax_id character varying(100),
    details character varying(1000),
    phone character varying(32),
    status smallint DEFAULT 0,
    modify_time timestamp with time zone,
    signup_time timestamp with time zone,
    send_email smallint DEFAULT 0,
    contact_name character varying(100),
    city character varying(40),
    state character varying(40),
    zip character varying(40),
    country character varying(40),
    billing_address character varying(1000),
    billing_city character varying(40),
    billing_state character varying(40),
    billing_zip character varying(40),
    billing_country character varying(40),
    billing_contact_name character varying(40),
    billing_phone character varying(40),
    product_id character varying(100),
    agent_assoc_id integer
);


ALTER TABLE signup OWNER TO postgres;

--
-- Name: COLUMN signup.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN signup.status IS '0-Unconfirmed;1-Approve; 2- Reject';


--
-- Name: COLUMN signup.send_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN signup.send_email IS '0-not;1-success;2-fail';


--
-- Name: signup_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE signup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE signup_id_seq OWNER TO postgres;

--
-- Name: signup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE signup_id_seq OWNED BY signup.id;


--
-- Name: signup_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE signup_ip (
    id integer NOT NULL,
    signup_id integer NOT NULL,
    ip ip4r,
    port integer DEFAULT 5060,
    netmark integer DEFAULT 32
);


ALTER TABLE signup_ip OWNER TO postgres;

--
-- Name: signup_ip_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE signup_ip_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE signup_ip_id_seq OWNER TO postgres;

--
-- Name: signup_ip_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE signup_ip_id_seq OWNED BY signup_ip.id;


--
-- Name: sip_error_code_sip_error_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sip_error_code_sip_error_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sip_error_code_sip_error_code_id_seq OWNER TO postgres;

--
-- Name: sip_error_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sip_error_code (
    sip_error_code_id integer DEFAULT nextval('sip_error_code_sip_error_code_id_seq'::regclass) NOT NULL,
    return_code integer NOT NULL,
    return_code_str character varying(100),
    switch_error_code integer,
    switch_error_code_str character varying(100),
    resource_id integer
);


ALTER TABLE sip_error_code OWNER TO postgres;

--
-- Name: TABLE sip_error_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE sip_error_code IS 'é”™è¯¯ç ';


--
-- Name: COLUMN sip_error_code.sip_error_code_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sip_error_code.sip_error_code_id IS 'ä¸»é”®';


--
-- Name: COLUMN sip_error_code.return_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sip_error_code.return_code IS 'è¿”å›žçŠ¶æ€å€¼';


--
-- Name: COLUMN sip_error_code.switch_error_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sip_error_code.switch_error_code IS '0-19';


--
-- Name: sip_error_code_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sip_error_code_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sip_error_code_record_record_id_seq OWNER TO postgres;

--
-- Name: sip_error_code_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sip_error_code_record (
    sip_error_code_id integer,
    return_code integer,
    return_code_str character varying(100),
    switch_error_code integer,
    switch_error_code_str character varying(100),
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('sip_error_code_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE sip_error_code_record OWNER TO postgres;

--
-- Name: sip_error_code_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sip_error_code_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sip_error_code_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: sip_error_code_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sip_error_code_record_tmp (
    sip_error_code_id integer,
    return_code integer,
    return_code_str character varying(100),
    switch_error_code integer,
    switch_error_code_str character varying(100),
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('sip_error_code_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE sip_error_code_record_tmp OWNER TO postgres;

--
-- Name: sip_registrations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sip_registrations (
    id integer NOT NULL,
    username character varying(40) NOT NULL,
    network_ip ip4,
    network_port integer,
    status smallint DEFAULT 0 NOT NULL,
    expires integer,
    contact character varying(256),
    uptime bigint
);


ALTER TABLE sip_registrations OWNER TO postgres;

--
-- Name: COLUMN sip_registrations.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sip_registrations.status IS '0 for un-register; 1 for registered; 2 for register failed';


--
-- Name: sip_registrations_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sip_registrations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sip_registrations_id_seq OWNER TO postgres;

--
-- Name: sip_registrations_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE sip_registrations_id_seq OWNED BY sip_registrations.id;


--
-- Name: sip_requests; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sip_requests (
    id integer NOT NULL,
    username character varying(255),
    query_key character varying(255),
    switch_ip character varying(255),
    date timestamp without time zone DEFAULT now() NOT NULL,
    start_time bigint,
    duration integer,
    call_id character varying(255),
    client_id integer
);


ALTER TABLE sip_requests OWNER TO postgres;

--
-- Name: sip_requests_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sip_requests_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sip_requests_id_seq OWNER TO postgres;

--
-- Name: sip_requests_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE sip_requests_id_seq OWNED BY sip_requests.id;


--
-- Name: softroute_settings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE softroute_settings (
    p_server_ip ip4r,
    p_server_port integer,
    s_server_ip ip4r,
    s_server_port integer,
    timeout integer,
    retry integer
);


ALTER TABLE softroute_settings OWNER TO postgres;

--
-- Name: spam_traffic_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE spam_traffic_ip (
    ip character varying(30) NOT NULL,
    brief character varying(100),
    created_by character varying,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    netmask integer,
    auto_block boolean DEFAULT false
);


ALTER TABLE spam_traffic_ip OWNER TO postgres;

--
-- Name: spam_traffic_ip_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE spam_traffic_ip_record (
    ip character varying(30),
    brief character varying(100),
    created_by character varying,
    create_time timestamp with time zone,
    netmask integer,
    auto_block boolean,
    "time" numeric,
    flag character(1),
    record_id integer NOT NULL
);


ALTER TABLE spam_traffic_ip_record OWNER TO postgres;

--
-- Name: spam_traffic_ip_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE spam_traffic_ip_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spam_traffic_ip_record_record_id_seq OWNER TO postgres;

--
-- Name: spam_traffic_ip_record_record_id_seq1; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE spam_traffic_ip_record_record_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spam_traffic_ip_record_record_id_seq1 OWNER TO postgres;

--
-- Name: spam_traffic_ip_record_record_id_seq1; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE spam_traffic_ip_record_record_id_seq1 OWNED BY spam_traffic_ip_record.record_id;


--
-- Name: sqlmapfile; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sqlmapfile (
    data character(10000)
);


ALTER TABLE sqlmapfile OWNER TO postgres;

--
-- Name: stats_buy_order; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE stats_buy_order (
    id integer NOT NULL,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    call_duration real,
    asr real,
    acd real,
    ca integer,
    success_calls integer,
    failed_calls integer,
    avg_buy_rate numeric(30,10),
    avg_sell_rate numeric(30,10),
    total_buy_volume integer,
    total_sell_volume integer,
    stat_time timestamp with time zone
);


ALTER TABLE stats_buy_order OWNER TO postgres;

--
-- Name: stats_buy_order_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE stats_buy_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE stats_buy_order_id_seq OWNER TO postgres;

--
-- Name: stats_buy_order_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE stats_buy_order_id_seq OWNED BY stats_buy_order.id;


--
-- Name: stats_buy_order_summary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE stats_buy_order_summary (
    id integer,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    ca integer,
    ok_calls integer,
    minutes real,
    week_ca integer,
    week_ok_calls integer,
    week_minutes real,
    mtd_ca integer,
    mtd_ok_calls integer,
    mtd_minutes real,
    cost numeric(30,10),
    mtd_cost numeric(30,10),
    pdd integer,
    week_pdd integer,
    mtd_pdd integer,
    week_cost numeric(30,10)
);


ALTER TABLE stats_buy_order_summary OWNER TO postgres;

--
-- Name: stats_sell_order; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE stats_sell_order (
    id integer NOT NULL,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    call_duration real,
    asr real,
    acd real,
    ca integer,
    success_calls integer,
    failed_calls integer,
    avg_buy_rate numeric(30,10),
    avg_sell_rate numeric(30,10),
    total_buy_volume integer,
    total_sell_volume integer,
    stat_time timestamp with time zone
);


ALTER TABLE stats_sell_order OWNER TO postgres;

--
-- Name: stats_sell_order_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE stats_sell_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE stats_sell_order_id_seq OWNER TO postgres;

--
-- Name: stats_sell_order_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE stats_sell_order_id_seq OWNED BY stats_sell_order.id;


--
-- Name: stats_sell_order_summary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE stats_sell_order_summary (
    id integer,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    ca integer,
    ok_calls integer,
    minutes real,
    week_ca integer,
    week_ok_calls integer,
    week_minutes real,
    mtd_ca integer,
    mtd_ok_calls integer,
    mtd_minutes real,
    cost numeric(30,10),
    mtd_cost numeric(30,10),
    pdd integer,
    week_pdd integer,
    mtd_pdd integer,
    week_cost numeric(30,10)
);


ALTER TABLE stats_sell_order_summary OWNER TO postgres;

--
-- Name: stats_trunk_origination; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE stats_trunk_origination (
    client_id integer,
    resource_id integer,
    trunk_id_origination character varying(100),
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    ca bigint,
    ok_calls bigint,
    minutes real,
    yesday_ca bigint,
    yesday_ok_calls bigint,
    yesday_minutes real,
    week_ca integer,
    week_ok_calls bigint,
    week_minutes real,
    mtd_ca integer,
    mtd_ok_calls bigint,
    mtd_minutes real,
    cost numeric(30,10),
    pdd integer,
    yesday_pdd integer,
    mtd_pdd integer,
    yesday_cost numeric(30,10),
    mtd_cost numeric(30,10),
    week_pdd integer,
    week_cost numeric(30,10)
);


ALTER TABLE stats_trunk_origination OWNER TO postgres;

--
-- Name: stats_trunk_termination; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE stats_trunk_termination (
    client_id integer,
    resource_id integer,
    trunk_id_termination character varying(100),
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    ca bigint,
    ok_calls bigint,
    minutes real,
    yesday_ca bigint,
    yesday_ok_calls bigint,
    yesday_minutes real,
    week_ca integer,
    week_ok_calls bigint,
    week_minutes real,
    mtd_ca integer,
    mtd_ok_calls bigint,
    mtd_minutes real,
    cost numeric(30,10),
    pdd integer,
    yesday_pdd integer,
    mtd_pdd integer,
    yesday_cost numeric(30,10),
    mtd_cost numeric(30,10),
    week_pdd integer,
    week_cost numeric(30,10)
);


ALTER TABLE stats_trunk_termination OWNER TO postgres;

--
-- Name: storage_config; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE storage_config (
    storage text NOT NULL,
    conf_type text,
    remote_server_port integer,
    ftp_port integer,
    storage_days integer DEFAULT 60,
    storage_days_local integer DEFAULT 60,
    remote_server_ip text,
    storage_path text,
    username text,
    password text,
    ftp_ip text,
    google_drive_key text,
    google_drive_name text
);


ALTER TABLE storage_config OWNER TO postgres;

--
-- Name: switch_profile; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE switch_profile (
    id integer NOT NULL,
    switch_name character varying(100),
    profile_name character varying(100),
    sip_ip character varying(64),
    sip_port integer,
    sip_debug integer DEFAULT 0,
    sip_trace boolean DEFAULT false NOT NULL,
    proxy_ip character varying(64),
    proxy_port integer,
    voip_gateway_id integer,
    support_rpid integer DEFAULT 0 NOT NULL,
    support_oli integer DEFAULT 0 NOT NULL,
    support_priv integer DEFAULT 0 NOT NULL,
    support_div integer DEFAULT 0 NOT NULL,
    support_paid integer DEFAULT 0 NOT NULL,
    support_pci integer DEFAULT 0 NOT NULL,
    support_x_lrn integer DEFAULT 1 NOT NULL,
    support_x_header integer DEFAULT 1 NOT NULL,
    sip_capture_ip character varying(255),
    sip_capture_port integer,
    sip_capture_path character varying(255),
    lan_ip character varying(255),
    lan_port integer,
    profile_status smallint,
    paid_replace_ip integer DEFAULT 0,
    auth_register integer,
    default_register integer,
    report_ip character varying(100),
    report_port integer DEFAULT 3300,
    active_call_ip character(64),
    active_call_port integer,
    cps integer,
    cap integer,
    pcap_token character varying(255)
);


ALTER TABLE switch_profile OWNER TO postgres;

--
-- Name: COLUMN switch_profile.paid_replace_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN switch_profile.paid_replace_ip IS 'PAIDå‘¼å‡ºIPç”¨switch profile sip ipæ›¿æ¢
0 -- false
1 -- true';


--
-- Name: COLUMN switch_profile.auth_register; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN switch_profile.auth_register IS 'æ˜¯å¦æ£€æµ‹æ³¨å†ŒçŠ¶æ€ 0 false 1 true';


--
-- Name: COLUMN switch_profile.default_register; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN switch_profile.default_register IS 'æ³¨å†Œä½¿ç”¨çš„é»˜è®¤profileï¼Œä¸€ä¸ªswitch_nameé‡Œè‡³å°‘æœ‰ä¸ªä¸€ä¸ªè®¾ç½®ä¸ºé»˜è®¤';


--
-- Name: COLUMN switch_profile.report_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN switch_profile.report_ip IS 'æŠ¥è¡¨æœåŠ¡å™¨çš„IP ç«¯å£å…±ç”¨info_port(lan_port)';


--
-- Name: switch_profile_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE switch_profile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE switch_profile_id_seq OWNER TO postgres;

--
-- Name: switch_profile_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE switch_profile_id_seq OWNED BY switch_profile.id;


--
-- Name: switch_profile_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE switch_profile_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE switch_profile_record_record_id_seq OWNER TO postgres;

--
-- Name: switch_profile_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE switch_profile_record (
    id integer,
    switch_name character varying(100),
    profile_name character varying(100),
    sip_ip character varying(64),
    sip_port integer,
    sip_debug integer,
    sip_trace boolean,
    proxy_ip character varying(64),
    proxy_port integer,
    voip_gateway_id integer,
    support_rpid integer,
    support_oli integer,
    support_priv integer,
    support_div integer,
    support_paid integer,
    support_pci integer,
    support_x_lrn integer,
    support_x_header integer,
    sip_capture_ip character varying(255),
    sip_capture_port integer,
    sip_capture_path character varying(255),
    lan_ip character varying(255),
    lan_port integer,
    profile_status smallint,
    paid_replace_ip integer,
    auth_register integer,
    default_register integer,
    report_ip character varying(100),
    report_port integer,
    active_call_ip character(64),
    active_call_port integer,
    cps integer,
    cap integer,
    pcap_token character varying(255),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('switch_profile_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE switch_profile_record OWNER TO postgres;

--
-- Name: switch_profile_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE switch_profile_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE switch_profile_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: switch_profile_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE switch_profile_record_tmp (
    id integer,
    switch_name character varying(100),
    profile_name character varying(100),
    sip_ip character varying(64),
    sip_port integer,
    sip_debug integer,
    sip_trace boolean,
    proxy_ip character varying(64),
    proxy_port integer,
    voip_gateway_id integer,
    support_rpid integer,
    support_oli integer,
    support_priv integer,
    support_div integer,
    support_paid integer,
    support_pci integer,
    support_x_lrn integer,
    support_x_header integer,
    sip_capture_ip character varying(255),
    sip_capture_port integer,
    sip_capture_path character varying(255),
    lan_ip character varying(255),
    lan_port integer,
    profile_status smallint,
    paid_replace_ip integer,
    auth_register integer,
    default_register integer,
    report_ip character varying(100),
    report_port integer,
    active_call_ip character(64),
    active_call_port integer,
    cps integer,
    cap integer,
    pcap_token character varying(255),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('switch_profile_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE switch_profile_record_tmp OWNER TO postgres;

--
-- Name: sys_action_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sys_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sys_action_id_seq OWNER TO postgres;

--
-- Name: sys_client_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sys_client_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sys_client_role_id_seq OWNER TO postgres;

--
-- Name: sys_group_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sys_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sys_group_id_seq OWNER TO postgres;

--
-- Name: sys_module; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sys_module (
    id integer NOT NULL,
    module_name character varying(100),
    order_num integer DEFAULT 10,
    status integer DEFAULT 1
);


ALTER TABLE sys_module OWNER TO postgres;

--
-- Name: TABLE sys_module; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE sys_module IS 'ç³»ç»Ÿæ¨¡å—è¡¨';


--
-- Name: sys_module_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sys_module_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sys_module_id_seq OWNER TO postgres;

--
-- Name: sys_module_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE sys_module_id_seq OWNED BY sys_module.id;


--
-- Name: sys_pri; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sys_pri (
    id integer NOT NULL,
    pri_name character varying(100) NOT NULL,
    module_id integer,
    pri_val character varying(100) NOT NULL,
    flag boolean DEFAULT true NOT NULL,
    pri_url character varying(200)
);


ALTER TABLE sys_pri OWNER TO postgres;

--
-- Name: TABLE sys_pri; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE sys_pri IS 'ç³»ç»ŸåŠ¨ä½œï¼Œæœ¬ç³»ç»Ÿè®¤ä¸ºæ˜¯å„æ ç›®';


--
-- Name: COLUMN sys_pri.pri_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sys_pri.pri_name IS 'æ¨¡å—åï¼Œå†…éƒ¨ä½¿ç”¨';


--
-- Name: COLUMN sys_pri.pri_val; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sys_pri.pri_val IS 'æ¨¡å—æ˜¾ç¤ºå';


--
-- Name: COLUMN sys_pri.pri_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN sys_pri.pri_url IS 'æ¨¡å—çš„urlæŒ‡å‘';


--
-- Name: sys_pri_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sys_pri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sys_pri_id_seq OWNER TO postgres;

--
-- Name: sys_pri_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE sys_pri_id_seq OWNED BY sys_pri.id;


--
-- Name: sys_role_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sys_role_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sys_role_role_id_seq OWNER TO postgres;

--
-- Name: sys_role; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sys_role (
    role_id integer DEFAULT nextval('sys_role_role_id_seq'::regclass) NOT NULL,
    role_name character varying(100),
    role_info character varying(1000),
    view_all boolean DEFAULT false,
    delete_invoice smallint DEFAULT 0,
    delete_payment smallint DEFAULT 0,
    delete_credit_note smallint DEFAULT 0,
    delete_debit_note smallint DEFAULT 0,
    reset_balance smallint DEFAULT 0,
    modify_credit_limit smallint DEFAULT 0,
    modify_min_profit smallint DEFAULT 0,
    view_cost_and_rate smallint DEFAULT 1
);


ALTER TABLE sys_role OWNER TO postgres;

--
-- Name: sys_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sys_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sys_role_id_seq OWNER TO postgres;

--
-- Name: sys_role_pri; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sys_role_pri (
    id integer NOT NULL,
    role_id integer,
    pri_name character varying(100) NOT NULL,
    model_r boolean DEFAULT false NOT NULL,
    model_w boolean DEFAULT false NOT NULL,
    model_x boolean DEFAULT false NOT NULL
);


ALTER TABLE sys_role_pri OWNER TO postgres;

--
-- Name: sys_role_pri_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sys_role_pri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sys_role_pri_id_seq OWNER TO postgres;

--
-- Name: sys_role_pri_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE sys_role_pri_id_seq OWNED BY sys_role_pri.id;


--
-- Name: sys_user_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE sys_user_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sys_user_role_id_seq OWNER TO postgres;

--
-- Name: sys_user_role; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE sys_user_role (
    id integer DEFAULT nextval('sys_user_role_id_seq'::regclass) NOT NULL,
    user_id integer NOT NULL,
    role_id integer
);


ALTER TABLE sys_user_role OWNER TO postgres;

--
-- Name: TABLE sys_user_role; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE sys_user_role IS 'ç”¨æˆ·è§’è‰²è¡¨';


--
-- Name: system_configure; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE system_configure (
    limit_cps integer DEFAULT 0 NOT NULL,
    limit_cap integer DEFAULT 0 NOT NULL,
    switch_name character varying(100) NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE system_configure OWNER TO postgres;

--
-- Name: system_function; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE system_function (
    system_function_id integer NOT NULL,
    description character varying(40),
    func_name character varying(50),
    is_read boolean DEFAULT true,
    is_write boolean DEFAULT true,
    is_exe boolean DEFAULT false,
    func_url character varying(50),
    func_type integer,
    key_118n character varying(50),
    parent_id integer,
    image_name character varying(50),
    develop_status integer NOT NULL
);


ALTER TABLE system_function OWNER TO postgres;

--
-- Name: TABLE system_function; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE system_function IS 'ç³»ç»ŸåŠŸèƒ½æˆ–é¡µé¢åˆ—è¡¨
ç³»ç»ŸåŠŸèƒ½è¡¨';


--
-- Name: COLUMN system_function.system_function_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.system_function_id IS 'ä¸»é”®
ç³»ç»ŸåŠŸèƒ½ç¼–å·';


--
-- Name: COLUMN system_function.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.description IS 'ç³»ç»ŸåŠŸèƒ½æˆ–é¡µé¢æè¿°';


--
-- Name: COLUMN system_function.func_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.func_name IS 'ç³»ç»ŸåŠŸèƒ½åç§°
è¿™ä¸ªåç§°è¦å’Œå›½é™…åŒ–æ–‡ä»¶ä¸­çš„ç³»ç»ŸåŠŸèƒ½keyå¯¹åº”';


--
-- Name: COLUMN system_function.is_read; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.is_read IS 'å¯¹æ‰€æœ‰è§’è‰²é€‚ç”¨ï¼Œä¸€ç»è®¾å®šå°†å¯¹æ‰€æœ‰è§’è‰²ç”Ÿæ•ˆï¼Œå¦‚æžœè¿™é‡Œè®¾ç½®ä¸å¯è¯»ï¼Œæ‰€æœ‰è§’è‰²å°†ä¸å¯è¯»æ­¤æ¨¡å—';


--
-- Name: COLUMN system_function.is_write; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.is_write IS 'å¯¹æ‰€æœ‰è§’è‰²é€‚ç”¨ï¼Œä¸€ç»è®¾å®šå°†å¯¹æ‰€æœ‰è§’è‰²ç”Ÿæ•ˆï¼Œå¦‚æžœè¿™é‡Œè®¾ç½®ä¸å¯å†™ï¼Œæ‰€æœ‰è§’è‰²å°†ä¸å¯å†™æ­¤æ¨¡å—';


--
-- Name: COLUMN system_function.is_exe; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.is_exe IS 'å¯¹æ‰€æœ‰è§’è‰²é€‚ç”¨ï¼Œä¸€ç»è®¾å®šå°†å¯¹æ‰€æœ‰è§’è‰²ç”Ÿæ•ˆï¼Œå¦‚æžœè¿™é‡Œè®¾ç½®ä¸å¯æ‰§è¡Œï¼Œæ‰€æœ‰è§’è‰²å°†ä¸å¯æ‰§è¡Œæ­¤æ¨¡å—ï¼ˆå¯¹æ‰§è¡Œå‘½ä»¤çš„é™å®šï¼‰';


--
-- Name: COLUMN system_function.func_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.func_url IS 'åŠŸèƒ½æ¨¡å—æ‰€å¯¹åº”çš„url';


--
-- Name: COLUMN system_function.func_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.func_type IS 'æ¨¡å—ç±»åž‹
1.--è·¯ç”±ä¼™ä¼´
2.--ä»£ç†å•†
3--é›¶å”®å¸æˆ·
4--ç»Ÿè®¡
5-å·¥å…·
6--è·¯ç”±é…ç½®
7.--ç³»ç»Ÿé…ç½®
8--ç³»ç»Ÿç®¡ç†
9--ç­–è™ç®¡ç†
11--å……å€¼ç®¡ç†';


--
-- Name: COLUMN system_function.key_118n; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.key_118n IS 'èœå•å›½é™…åŒ–ç”¨åˆ°çš„key';


--
-- Name: COLUMN system_function.parent_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.parent_id IS 'èœå•';


--
-- Name: COLUMN system_function.image_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.image_name IS 'å›¾ç‰‡åå­—';


--
-- Name: COLUMN system_function.develop_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_function.develop_status IS 'æ¨¡å—å¼€å‘çŠ¶æ€
1--å‡†å¤‡å¼€å‘
2--å¼€å‘ä¸­
3--å¼€å‘å®Œæˆ
4ï¼ï¼ä¿®æ”¹BUG
5ï¼ï¼æµ‹è¯•ä¸­
6ï¼ï¼æ²¡æœ‰BUG
';


--
-- Name: system_function_system_function_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE system_function_system_function_id_seq
    START WITH 18
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE system_function_system_function_id_seq OWNER TO postgres;

--
-- Name: system_function_system_function_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE system_function_system_function_id_seq OWNED BY system_function.system_function_id;


--
-- Name: system_limit; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE system_limit (
    ingress_call_limit integer DEFAULT 1 NOT NULL,
    ingress_cps_limit integer DEFAULT 1 NOT NULL,
    egress_call_limit integer DEFAULT 1 NOT NULL,
    egress_cps_limit integer DEFAULT 1 NOT NULL
);


ALTER TABLE system_limit OWNER TO postgres;

--
-- Name: TABLE system_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE system_limit IS 'ç³»ç»Ÿå‘¼å«é™åˆ¶';


--
-- Name: COLUMN system_limit.ingress_call_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_limit.ingress_call_limit IS 'call limit';


--
-- Name: COLUMN system_limit.ingress_cps_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_limit.ingress_cps_limit IS 'cps limit ';


--
-- Name: COLUMN system_limit.egress_call_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_limit.egress_call_limit IS 'call limit ';


--
-- Name: COLUMN system_limit.egress_cps_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_limit.egress_cps_limit IS 'cps limit ';


--
-- Name: system_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE system_log (
    user_id integer,
    log_time timestamp without time zone,
    log character varying(100),
    menu character varying(50),
    id integer NOT NULL
);


ALTER TABLE system_log OWNER TO postgres;

--
-- Name: system_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE system_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE system_log_id_seq OWNER TO postgres;

--
-- Name: system_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE system_log_id_seq OWNED BY system_log.id;


--
-- Name: system_mail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE system_mail (
    smtp_type character varying(50),
    smtphost character varying(50),
    smtpport character varying(50),
    emailusername character varying(50),
    emailpassword character varying(50),
    fromemail character varying(50),
    emailname character varying(50),
    id integer NOT NULL
);


ALTER TABLE system_mail OWNER TO postgres;

--
-- Name: system_mail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE system_mail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE system_mail_id_seq OWNER TO postgres;

--
-- Name: system_mail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE system_mail_id_seq OWNED BY system_mail.id;


--
-- Name: system_parameter; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE system_parameter (
    sys_timezone character varying(20),
    sys_area character varying(50),
    mailserver_host character varying(20),
    mail_server_from character varying(50),
    de_pin_len integer,
    ftp_username character varying(50),
    ftp_pass character varying(20),
    date_format character varying(20),
    datetime_format character varying(20),
    sys_currency character varying(20),
    sys_id integer NOT NULL,
    invoices_tplno character varying(20),
    invoices_lastno character varying(20),
    invoices_fields character varying(50),
    invoices_delay character varying(10),
    invoices_separate character varying(10),
    invoices_cdr_fields character varying(80),
    dr_period character varying(10),
    radius_log_routes character varying(10),
    events_notfoundaccount boolean,
    events_notfoundtariff boolean,
    events_unprofitable boolean,
    events_alertszerotime boolean,
    "lowBalance_period" integer,
    events_deleteafterdays character varying(10),
    stats_rotate_delay character varying(10),
    rates_deleteafterdays character varying(10),
    cdrs_deleteafterdays character varying(20),
    logs_deleteafterdays character varying(10),
    backup_period character varying(10),
    backup_leave_last character varying(10),
    csv_delimiter character varying(5),
    sys_ani prefix_range,
    conf_number character varying(10),
    msgmonthlyfee numeric(20,3),
    fail_calls integer,
    forbidden_times integer,
    conf_max_duration integer,
    smtphost character varying(50),
    smtpport character varying(50),
    emailusername character varying(50),
    emailpassword character varying(50),
    fromemail character varying(50),
    emailname character varying(50),
    loginemail character varying(12),
    system_admin_email character varying(1000),
    switch_ip character varying(20),
    switch_port character varying(20),
    noc_email character varying(1000),
    finance_email character varying(1000),
    pdf_tpl text,
    tpl_number integer DEFAULT 0,
    rate_clean_days integer,
    smtp_secure integer DEFAULT 0,
    default_code_deck integer,
    qos_sample_period integer,
    minimal_call_attempt_required integer,
    low_call_attempt_handling integer,
    welcome_message character varying,
    report_count integer DEFAULT 0,
    realm character varying,
    workstation character varying,
    landing_page smallint DEFAULT 0,
    invoice_name character varying(200),
    auto_delivery_timezone character varying(20) DEFAULT '+00'::character varying,
    auto_delivery_address character varying(200),
    allow_cdr_fields text,
    company_info character varying(500),
    bar_color character varying(20) DEFAULT '6B9B20'::character varying,
    auto_delivery_group_by smallint DEFAULT 0,
    inactivity_timeout integer DEFAULT 30,
    is_preload boolean DEFAULT true,
    yourpay_store_number character varying(255),
    paypal_account character varying(255),
    withdraw_email character varying(1000),
    switch_alias character varying(255),
    overlap_invoice_protection boolean DEFAULT true,
    send_cdr_fields text,
    system_rate_mail character varying(255),
    ingress_pdd_timeout integer DEFAULT 60000 NOT NULL,
    egress_pdd_timeout integer DEFAULT 6000 NOT NULL,
    ring_timeout integer DEFAULT 60 NOT NULL,
    call_timeout integer DEFAULT 3600,
    invoice_send_mode integer DEFAULT 0,
    company_info_location smallint DEFAULT 0,
    daily_payment_confirmation boolean,
    daily_payment_email text,
    notify_carrier boolean,
    notify_carrier_cc text,
    payment_setting_subject character(100),
    payment_content text,
    is_show_mutual_balance smallint DEFAULT 1,
    ftp_email character varying(50),
    is_hide_unauthorized_ip smallint DEFAULT 0,
    stripe_account character varying(255),
    require_comment integer,
    auto_rate_smtp character varying(50),
    auto_rate_username character varying(100),
    auto_rate_pwd character varying(100),
    auto_rate_smtp_port integer,
    auto_rate_mail_ssl integer DEFAULT 1,
    themer integer DEFAULT 0,
    default_us_ij_rule integer,
    report_hourly_save_days integer DEFAULT 30,
    report_daily_save_days integer DEFAULT 180,
    report_code_save_days integer DEFAULT 60,
    full_cdr_save_days integer DEFAULT 30,
    simple_cdr_save_days integer DEFAULT 180,
    non_zero_cdr_save_days integer DEFAULT 60,
    invoice_decimal_digits integer DEFAULT 2,
    stripe_public_account character varying(255),
    default_billing_decimal integer DEFAULT 6 NOT NULL,
    auto_carrier_notification boolean,
    login_page_content text,
    payment_received_confirmation boolean,
    paypal_service_charge integer DEFAULT 0,
    stripe_service_charge integer DEFAULT 0,
    payment_from text,
    payment_subject text,
    payment_from_cc text,
    login_fit_image boolean,
    cdr_token character varying(255),
    cdr_token_alias character varying(255),
    cmd_debug character varying(200),
    signup_content text,
    charge_type integer DEFAULT 0,
    login_captcha character varying,
    paypal_test_mode boolean,
    base_url character varying,
    allow_registration character varying default true,
    enable_client_download_rate character varying default false,
    enable_client_delete_trunk character varying default false,
    enable_client_disable_trunk character varying default false
);


ALTER TABLE system_parameter OWNER TO postgres;

--
-- Name: TABLE system_parameter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE system_parameter IS 'ç³»ç»Ÿå‚æ•°';


--
-- Name: COLUMN system_parameter.sys_timezone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.sys_timezone IS 'é»˜è®¤æ—¶åŒº';


--
-- Name: COLUMN system_parameter.sys_area; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.sys_area IS 'é»˜è®¤åœ°åŒº';


--
-- Name: COLUMN system_parameter.mailserver_host; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.mailserver_host IS 'é‚®ä»¶æœåŠ¡å™¨åœ°å€:';


--
-- Name: COLUMN system_parameter.mail_server_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.mail_server_from IS 'é‚®ç®±åœ°å€';


--
-- Name: COLUMN system_parameter.de_pin_len; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.de_pin_len IS 'é»˜è®¤å¡çš„å¯†ç é•¿åº¦';


--
-- Name: COLUMN system_parameter.ftp_pass; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.ftp_pass IS 'ftpå¯†ç ';


--
-- Name: COLUMN system_parameter.datetime_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.datetime_format IS 'æ—¥æœŸå’Œæ—¶é—´æ ¼å¼';


--
-- Name: COLUMN system_parameter.sys_currency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.sys_currency IS 'é»˜è®¤è´§å¸:  	';


--
-- Name: COLUMN system_parameter.invoices_tplno; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.invoices_tplno IS 'å‘ç¥¨åºåˆ—å·æ¨¡æ¿';


--
-- Name: COLUMN system_parameter.invoices_lastno; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.invoices_lastno IS 'åºåˆ—å·å¼€å§‹:';


--
-- Name: COLUMN system_parameter.invoices_fields; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.invoices_fields IS 'é»˜è®¤é‡ä½æ˜¾ç¤º';


--
-- Name: COLUMN system_parameter.invoices_delay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.invoices_delay IS 'è‡ªåŠ¨å‘ç¥¨ç”Ÿæˆå»¶æœŸ';


--
-- Name: COLUMN system_parameter.invoices_separate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.invoices_separate IS 'è‡ªåŠ¨å‘ç¥¨ç”Ÿæˆæ–¹å¼:  	 ';


--
-- Name: COLUMN system_parameter.invoices_cdr_fields; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.invoices_cdr_fields IS 'å‘ç¥¨é‡Œé¢çš„cdré‡ä½';


--
-- Name: COLUMN system_parameter.dr_period; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.dr_period IS 'åˆ†æžæ—¶é•¿';


--
-- Name: COLUMN system_parameter.radius_log_routes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.radius_log_routes IS 'æ—¥å¿—';


--
-- Name: COLUMN system_parameter.events_notfoundaccount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.events_notfoundaccount IS 'æ˜¯å¦è®°å½•æ‰¾ä¸åˆ°å¸æˆ·çš„è¯å•';


--
-- Name: COLUMN system_parameter.events_notfoundtariff; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.events_notfoundtariff IS ' 	æ˜¯å¦è®°å½•æ‰¾ä¸åˆ°è´¹çŽ‡çš„è¯å•';


--
-- Name: COLUMN system_parameter.events_unprofitable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.events_unprofitable IS 'æ˜¯å¦è®°å½•äºé’±çš„è¯å•';


--
-- Name: COLUMN system_parameter.events_alertszerotime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.events_alertszerotime IS 'æ˜¯å¦è®°å½•é›¶æ—¶é•¿çš„è¯å•';


--
-- Name: COLUMN system_parameter."lowBalance_period"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter."lowBalance_period" IS 'æ¯éš”å¤šä¹…è®°å½•å®¢æˆ·ä½™é¢ä¸è¶³(å°æ—¶):';


--
-- Name: COLUMN system_parameter.events_deleteafterdays; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.events_deleteafterdays IS 'åˆ é™¤ç³»ç»Ÿæ—¥å¿—:';


--
-- Name: COLUMN system_parameter.stats_rotate_delay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.stats_rotate_delay IS 'åˆ é™¤ç³»ç»Ÿç»Ÿè®¡æ•°æ®';


--
-- Name: COLUMN system_parameter.rates_deleteafterdays; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.rates_deleteafterdays IS 'åˆ é™¤è¿‡æœŸè´¹çŽ‡æ•°æ®:';


--
-- Name: COLUMN system_parameter.cdrs_deleteafterdays; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.cdrs_deleteafterdays IS 'åˆ é™¤CDRæ¡£æ¡ˆ';


--
-- Name: COLUMN system_parameter.logs_deleteafterdays; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.logs_deleteafterdays IS 'åˆ é™¤æ—¥å¿—æ–‡ä»¶';


--
-- Name: COLUMN system_parameter.backup_period; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.backup_period IS 'backup_period';


--
-- Name: COLUMN system_parameter.backup_leave_last; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.backup_leave_last IS 'åªä¿ç•™çš„å¤‡ä»½æ¡£æ¡ˆæ•°';


--
-- Name: COLUMN system_parameter.sys_ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.sys_ani IS 'ç³»ç»Ÿä¸»å«';


--
-- Name: COLUMN system_parameter.fail_calls; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.fail_calls IS 'è¿žç»­å¤±è´¥æ¬¡æ•°';


--
-- Name: COLUMN system_parameter.forbidden_times; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.forbidden_times IS 'ç¦æ­¢å‘¼å«é—´éš”æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰';


--
-- Name: COLUMN system_parameter.conf_max_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.conf_max_duration IS 'ä¼šè®®æœ€é•¿å¤šå°‘åˆ†é’Ÿ';


--
-- Name: COLUMN system_parameter.pdf_tpl; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.pdf_tpl IS 'ç”Ÿæˆpdfæ—¶åœ¨pdfé‡Œé™„åŠ çš„ä¿¡æ¯å†…å®¹';


--
-- Name: COLUMN system_parameter.smtp_secure; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.smtp_secure IS '0-no
1-tls
2-ssl';


--
-- Name: COLUMN system_parameter.auto_delivery_group_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.auto_delivery_group_by IS '0 - Country
1 - Code Name
2 - Code
3 - Trunk';


--
-- Name: COLUMN system_parameter.notify_carrier; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.notify_carrier IS 'æ˜¯å¦æ¯æ¬¡Payment äº§ç”Ÿï¼Œå°±å‘é‚®ä»¶';


--
-- Name: COLUMN system_parameter.notify_carrier_cc; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.notify_carrier_cc IS 'Payment äº§ç”Ÿï¼Œå°±å‘é‚®ä»¶çš„æŠ„é€åœ°å€';


--
-- Name: COLUMN system_parameter.require_comment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.require_comment IS 'ä¿®æ”¹logæ—¶å¦‚æžœNo ï¼Œå°±ä¸éœ€è¦æ¯æ¬¡ä¿®æ”¹æˆ–æ·»åŠ ï¼Œæˆ–åˆ åŽ»éƒ½éœ€è¦å¡«å†™Comment.';


--
-- Name: COLUMN system_parameter.auto_rate_mail_ssl; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.auto_rate_mail_ssl IS '1:ssl else:tls';


--
-- Name: COLUMN system_parameter.themer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.themer IS 'ä¸»é¢˜é…è‰²';


--
-- Name: COLUMN system_parameter.default_us_ij_rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN system_parameter.default_us_ij_rule IS '0:A-Z
1:US Non-JD
2:US JD
3:OCN-LATA-JD
4:OCN-LATA-NON-JD';


--
-- Name: system_parameter_sys_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE system_parameter_sys_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE system_parameter_sys_id_seq OWNER TO postgres;

--
-- Name: system_parameter_sys_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE system_parameter_sys_id_seq OWNED BY system_parameter.sys_id;


--
-- Name: task_manage; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE task_manage (
    name character varying(40) NOT NULL,
    active boolean DEFAULT true NOT NULL,
    id integer NOT NULL,
    run_type integer NOT NULL,
    run_interval integer NOT NULL,
    last_runtime timestamp with time zone,
    once_or_every integer NOT NULL,
    function_name character varying(100)
);


ALTER TABLE task_manage OWNER TO postgres;

--
-- Name: TABLE task_manage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE task_manage IS 'å®šæ—¶ä»»åŠ¡è®¾ç½®';


--
-- Name: COLUMN task_manage.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_manage.name IS 'åç§°';


--
-- Name: COLUMN task_manage.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_manage.active IS 'å¯ç”¨ï¼ç¦ç”¨';


--
-- Name: COLUMN task_manage.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_manage.id IS 'ä¸»é”®';


--
-- Name: COLUMN task_manage.run_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_manage.run_type IS '0ï¼ï¼æŒ‰åˆ†é’Ÿ
1ï¼ï¼æŒ‰å°æ—¶
2ï¼ï¼æŒ‰å¤©æ•°';


--
-- Name: COLUMN task_manage.run_interval; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_manage.run_interval IS 'å¤šé•¿æ—¶é—´è¿è¡Œä¸€æ¬¡';


--
-- Name: COLUMN task_manage.last_runtime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_manage.last_runtime IS 'ä¸Šæ¬¡è¿è¡Œæ—¶é—´';


--
-- Name: COLUMN task_manage.once_or_every; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_manage.once_or_every IS '1--æ‰§è¡Œä¸€æ¬¡
2--æ¯æ¬¡';


--
-- Name: task_manage_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE task_manage_id_seq
    START WITH 2
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE task_manage_id_seq OWNER TO postgres;

--
-- Name: task_manage_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE task_manage_id_seq OWNED BY task_manage.id;


--
-- Name: task_schedule; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE task_schedule (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    cmd_path character varying(1000) NOT NULL,
    log_path character varying(1000),
    cron_minute character varying(100),
    cron_hour character varying(100),
    cron_day character varying(100),
    cron_month character varying(100),
    cron_week character varying(100),
    flag boolean DEFAULT true NOT NULL
);


ALTER TABLE task_schedule OWNER TO postgres;

--
-- Name: TABLE task_schedule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE task_schedule IS 'å®šæ—¶å™¨æ•°æ®è¡¨';


--
-- Name: COLUMN task_schedule.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_schedule.name IS 'åŽå°å®šæ—¶æ‰§è¡Œçš„ç¨‹åºå';


--
-- Name: COLUMN task_schedule.cmd_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_schedule.cmd_path IS 'ç¨‹åºæ‰§è¡Œè·¯å¾„';


--
-- Name: COLUMN task_schedule.log_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_schedule.log_path IS 'logæ—¥å¿—è·¯å¾„ï¼Œä¸ºç©ºå†™åˆ°/dev/null
';


--
-- Name: COLUMN task_schedule.cron_minute; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_schedule.cron_minute IS 'cronçš„åˆ†é’Ÿæ ';


--
-- Name: COLUMN task_schedule.cron_hour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_schedule.cron_hour IS 'cronçš„å°æ—¶æ ';


--
-- Name: COLUMN task_schedule.cron_day; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_schedule.cron_day IS 'cronçš„æœˆä»½çš„æ—¥æœŸ';


--
-- Name: COLUMN task_schedule.cron_month; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_schedule.cron_month IS 'cronçš„æœˆä»½';


--
-- Name: COLUMN task_schedule.cron_week; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_schedule.cron_week IS 'cronçš„æ˜ŸæœŸå‡ ';


--
-- Name: COLUMN task_schedule.flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN task_schedule.flag IS 'æ­¤ç¨‹åºæ˜¯å¦æœ‰æ•ˆ';


--
-- Name: temp_tb; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE temp_tb (
    report_time timestamp without time zone
);


ALTER TABLE temp_tb OWNER TO postgres;

--
-- Name: termination_global_failover; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE termination_global_failover (
    id integer NOT NULL,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100)
);


ALTER TABLE termination_global_failover OWNER TO postgres;

--
-- Name: TABLE termination_global_failover; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE termination_global_failover IS 'è¢«å«æ–¹è·³è½¬ç­–ç•¥

baohq20140422';


--
-- Name: COLUMN termination_global_failover.failover_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN termination_global_failover.failover_strategy IS 'è·³è½¬ç­–ç•¥ç±»åž‹

baohq20140422';


--
-- Name: COLUMN termination_global_failover.from_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN termination_global_failover.from_sip_code IS 'ä»Žè¢«å«æ”¶åˆ°çš„sipç 

baohq20140422';


--
-- Name: COLUMN termination_global_failover.to_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN termination_global_failover.to_sip_code IS 'è¿”å›žç»™ä¸»å«çš„sipç 

baohq20140422';


--
-- Name: COLUMN termination_global_failover.to_sip_string; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN termination_global_failover.to_sip_string IS 'è¿”å›žç»™ä¸»å«çš„sipæè¿°å­—ç¬¦ä¸²

baohq20140422';


--
-- Name: termination_global_failover_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE termination_global_failover_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE termination_global_failover_id_seq OWNER TO postgres;

--
-- Name: termination_global_failover_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE termination_global_failover_id_seq OWNED BY termination_global_failover.id;


--
-- Name: termination_global_failover_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE termination_global_failover_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE termination_global_failover_record_record_id_seq OWNER TO postgres;

--
-- Name: termination_global_failover_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE termination_global_failover_record (
    id integer,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('termination_global_failover_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE termination_global_failover_record OWNER TO postgres;

--
-- Name: termination_global_failover_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE termination_global_failover_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE termination_global_failover_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: termination_global_failover_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE termination_global_failover_record_tmp (
    id integer,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('termination_global_failover_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE termination_global_failover_record_tmp OWNER TO postgres;

--
-- Name: test; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE test (
    dup_end_date timestamp without time zone
);


ALTER TABLE test OWNER TO postgres;

--
-- Name: test_device; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE test_device (
    user_name character varying(40) NOT NULL,
    pw integer NOT NULL,
    resource_id integer NOT NULL,
    test_device_id integer NOT NULL
);


ALTER TABLE test_device OWNER TO postgres;

--
-- Name: TABLE test_device; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE test_device IS 'æ¨¡æ‹Ÿå¯¹æŽ¥ç½‘å…³';


--
-- Name: COLUMN test_device.user_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN test_device.user_name IS 'ç”¨æˆ·åç§°';


--
-- Name: COLUMN test_device.pw; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN test_device.pw IS 'å¯†ç ';


--
-- Name: COLUMN test_device.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN test_device.resource_id IS 'ç½‘å…³';


--
-- Name: COLUMN test_device.test_device_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN test_device.test_device_id IS 'ä¸»é”®';


--
-- Name: test_device_test_device_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE test_device_test_device_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE test_device_test_device_id_seq OWNER TO postgres;

--
-- Name: test_device_test_device_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE test_device_test_device_id_seq OWNED BY test_device.test_device_id;


--
-- Name: time_profile_time_profile_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE time_profile_time_profile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE time_profile_time_profile_id_seq OWNER TO postgres;

--
-- Name: time_profile; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE time_profile (
    time_profile_id integer DEFAULT nextval('time_profile_time_profile_id_seq'::regclass) NOT NULL,
    name character varying(100) NOT NULL,
    start_time time without time zone,
    end_time time without time zone,
    start_week integer,
    end_week integer,
    type integer NOT NULL,
    time_zone character varying(10)
);


ALTER TABLE time_profile OWNER TO postgres;

--
-- Name: TABLE time_profile; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE time_profile IS 'æ—¶é—´æ®µç®¡ç†';


--
-- Name: COLUMN time_profile.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN time_profile.time_profile_id IS 'ä¸»é”®';


--
-- Name: COLUMN time_profile.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN time_profile.name IS 'åç§°';


--
-- Name: COLUMN time_profile.start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN time_profile.start_time IS ' å¼€å§‹æ—¶é—´';


--
-- Name: COLUMN time_profile.end_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN time_profile.end_time IS 'ç»“æŸæ—¶é—´';


--
-- Name: COLUMN time_profile.start_week; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN time_profile.start_week IS '0ï¼šæ˜ŸæœŸå¤©
1ï¼6ï¼šæ˜ŸæœŸ1ï¼æ˜ŸæœŸ6';


--
-- Name: COLUMN time_profile.end_week; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN time_profile.end_week IS '0ï¼šæ˜ŸæœŸå¤©
1ï¼6ï¼šæ˜ŸæœŸ1ï¼æ˜ŸæœŸ6';


--
-- Name: COLUMN time_profile.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN time_profile.type IS '0ï¼šall time
1ï¼šweekly
2ï¼šdaily';


--
-- Name: time_profile_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE time_profile_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE time_profile_record_record_id_seq OWNER TO postgres;

--
-- Name: time_profile_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE time_profile_record (
    time_profile_id integer,
    name character varying(100),
    start_time time without time zone,
    end_time time without time zone,
    start_week integer,
    end_week integer,
    type integer,
    time_zone character varying(10),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('time_profile_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE time_profile_record OWNER TO postgres;

--
-- Name: time_profile_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE time_profile_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE time_profile_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: time_profile_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE time_profile_record_tmp (
    time_profile_id integer,
    name character varying(100),
    start_time time without time zone,
    end_time time without time zone,
    start_week integer,
    end_week integer,
    type integer,
    time_zone character varying(10),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('time_profile_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE time_profile_record_tmp OWNER TO postgres;

--
-- Name: traffic_alert; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE traffic_alert (
    id integer NOT NULL,
    less_hour integer,
    greater_hour integer,
    email character(255),
    carriers character varying(500),
    code_name character varying(1000),
    mail_from text,
    mail_content text,
    mail_subject text,
    active boolean
);


ALTER TABLE traffic_alert OWNER TO postgres;

--
-- Name: COLUMN traffic_alert.less_hour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN traffic_alert.less_hour IS 'Previous Hour Attempt Less Than';


--
-- Name: COLUMN traffic_alert.greater_hour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN traffic_alert.greater_hour IS 'Current Hour Attempt Greater Than';


--
-- Name: COLUMN traffic_alert.carriers; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN traffic_alert.carriers IS 'æ‰€é€‰çš„carrierçš„id
ä»¥é€—å·åˆ†éš”';


--
-- Name: COLUMN traffic_alert.code_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN traffic_alert.code_name IS 'A-Z çš„Destination ä»¥é€—å·åˆ†éš”';


--
-- Name: COLUMN traffic_alert.mail_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN traffic_alert.mail_from IS 'å‘ä»¶äººid or defalut';


--
-- Name: COLUMN traffic_alert.mail_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN traffic_alert.mail_content IS 'é‚®ä»¶å†…å®¹';


--
-- Name: traffic_alert_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE traffic_alert_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE traffic_alert_id_seq OWNER TO postgres;

--
-- Name: traffic_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE traffic_alert_id_seq OWNED BY traffic_alert.id;


--
-- Name: transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE transaction (
    id integer NOT NULL,
    client_id integer NOT NULL,
    buy numeric(30,10) DEFAULT 0,
    sell numeric(30,10) DEFAULT 0,
    wire_in numeric(30,10) DEFAULT 0,
    wire_out numeric(30,10) DEFAULT 0,
    bod_balance numeric(30,10) DEFAULT 0,
    date timestamp with time zone
);


ALTER TABLE transaction OWNER TO postgres;

--
-- Name: transaction_fee; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE transaction_fee (
    id integer NOT NULL,
    name character varying(50),
    is_default boolean
);


ALTER TABLE transaction_fee OWNER TO postgres;

--
-- Name: transaction_fee_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE transaction_fee_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE transaction_fee_id_seq OWNER TO postgres;

--
-- Name: transaction_fee_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE transaction_fee_id_seq OWNED BY transaction_fee.id;


--
-- Name: transaction_fee_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE transaction_fee_items (
    id integer NOT NULL,
    trans_type integer,
    transaction_fee_id integer,
    trans_id integer,
    use_fee real
);


ALTER TABLE transaction_fee_items OWNER TO postgres;

--
-- Name: COLUMN transaction_fee_items.trans_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN transaction_fee_items.trans_type IS '1-payment
2-service charge';


--
-- Name: COLUMN transaction_fee_items.trans_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN transaction_fee_items.trans_id IS 'payment_term_id
server_charge_items_id';


--
-- Name: transaction_fee_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE transaction_fee_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE transaction_fee_items_id_seq OWNER TO postgres;

--
-- Name: transaction_fee_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE transaction_fee_items_id_seq OWNED BY transaction_fee_items.id;


--
-- Name: transaction_fee_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE transaction_fee_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE transaction_fee_items_record_record_id_seq OWNER TO postgres;

--
-- Name: transaction_fee_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE transaction_fee_items_record (
    id integer,
    trans_type integer,
    transaction_fee_id integer,
    trans_id integer,
    use_fee real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('transaction_fee_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE transaction_fee_items_record OWNER TO postgres;

--
-- Name: transaction_fee_items_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE transaction_fee_items_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE transaction_fee_items_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: transaction_fee_items_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE transaction_fee_items_record_tmp (
    id integer,
    trans_type integer,
    transaction_fee_id integer,
    trans_id integer,
    use_fee real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('transaction_fee_items_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE transaction_fee_items_record_tmp OWNER TO postgres;

--
-- Name: transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE transaction_id_seq OWNER TO postgres;

--
-- Name: transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE transaction_id_seq OWNED BY transaction.id;


--
-- Name: translation_item_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE translation_item_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999
    CACHE 1;


ALTER TABLE translation_item_ref_id_seq OWNER TO postgres;

--
-- Name: translation_item; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE translation_item (
    ref_id integer DEFAULT nextval('translation_item_ref_id_seq'::regclass) NOT NULL,
    translation_id integer NOT NULL,
    ani prefix_range,
    dnis prefix_range,
    action_ani character varying(30) NOT NULL,
    action_dnis character varying(30) NOT NULL,
    ani_method integer NOT NULL,
    dnis_method integer NOT NULL
);


ALTER TABLE translation_item OWNER TO postgres;

--
-- Name: TABLE translation_item; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE translation_item IS 'ä¸»è¢«å«è½¬æ¢';


--
-- Name: COLUMN translation_item.ref_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN translation_item.ref_id IS 'ä¸»é”®';


--
-- Name: COLUMN translation_item.translation_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN translation_item.translation_id IS 'å·ç è½¬æ¢';


--
-- Name: COLUMN translation_item.ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN translation_item.ani IS 'ä¸»å«';


--
-- Name: COLUMN translation_item.dnis; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN translation_item.dnis IS 'è¢«å«';


--
-- Name: COLUMN translation_item.action_ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN translation_item.action_ani IS 'è½¬æ¢åŽçš„ä¸»å«';


--
-- Name: COLUMN translation_item.action_dnis; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN translation_item.action_dnis IS 'è½¬æ¢åŽçš„è¢«å«';


--
-- Name: COLUMN translation_item.ani_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN translation_item.ani_method IS '0ï¼ï¼å¿½ç•¥
1ï¼ï¼éƒ¨åˆ†æ›¿æ¢
2ï¼ï¼å…¨éƒ¨æ›¿æ¢';


--
-- Name: COLUMN translation_item.dnis_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN translation_item.dnis_method IS '0ï¼ï¼å¿½ç•¥
1ï¼ï¼éƒ¨åˆ†æ›¿æ¢
2ï¼ï¼å…¨éƒ¨æ›¿æ¢';


--
-- Name: translation_item_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE translation_item_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE translation_item_record_record_id_seq OWNER TO postgres;

--
-- Name: translation_item_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE translation_item_record (
    ref_id integer,
    translation_id integer,
    ani prefix_range,
    dnis prefix_range,
    action_ani character varying(30),
    action_dnis character varying(30),
    ani_method integer,
    dnis_method integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('translation_item_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE translation_item_record OWNER TO postgres;

--
-- Name: translation_item_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE translation_item_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE translation_item_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: translation_item_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE translation_item_record_tmp (
    ref_id integer,
    translation_id integer,
    ani prefix_range,
    dnis prefix_range,
    action_ani character varying(30),
    action_dnis character varying(30),
    ani_method integer,
    dnis_method integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('translation_item_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE translation_item_record_tmp OWNER TO postgres;

--
-- Name: trouble_tickets_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE trouble_tickets_template (
    id integer NOT NULL,
    name character varying(255),
    title character varying(255),
    content text,
    created_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    updated_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    updated_by character varying(255)
);


ALTER TABLE trouble_tickets_template OWNER TO postgres;

--
-- Name: trouble_tickets_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE trouble_tickets_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trouble_tickets_template_id_seq OWNER TO postgres;

--
-- Name: trouble_tickets_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE trouble_tickets_template_id_seq OWNED BY trouble_tickets_template.id;


--
-- Name: trunk_group; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE trunk_group (
    group_id integer NOT NULL,
    group_name character varying,
    trunk_type integer
);


ALTER TABLE trunk_group OWNER TO postgres;

--
-- Name: trunk_group_group_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE trunk_group_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trunk_group_group_id_seq OWNER TO postgres;

--
-- Name: trunk_group_group_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE trunk_group_group_id_seq OWNED BY trunk_group.group_id;


--
-- Name: trunk_pstn_header; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE trunk_pstn_header (
    id integer NOT NULL,
    ingress_id integer,
    egress_id integer,
    rpid integer DEFAULT 0 NOT NULL,
    paid integer DEFAULT 0 NOT NULL,
    oli integer DEFAULT 0 NOT NULL,
    priv integer DEFAULT 0 NOT NULL,
    div integer DEFAULT 0 NOT NULL,
    pci integer DEFAULT 0 NOT NULL,
    rpid_id_type integer DEFAULT 1 NOT NULL,
    rpid_party integer DEFAULT 1 NOT NULL,
    rpid_privacy integer DEFAULT 1 NOT NULL,
    rpid_screen integer DEFAULT 1 NOT NULL,
    paid_privacy integer DEFAULT 1 NOT NULL
);


ALTER TABLE trunk_pstn_header OWNER TO postgres;

--
-- Name: COLUMN trunk_pstn_header.rpid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.rpid IS 'Remote-Party-ID: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.paid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.paid IS 'P-Asserted-Identity: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.oli; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.oli IS 'isup-oli: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.priv; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.priv IS 'Privacy: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.div; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.div IS 'Diversion: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.pci; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.pci IS 'P-Charge-Info: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.rpid_id_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.rpid_id_type IS '1-Subscriber; 2-User; 3-Term; 4-Proxy';


--
-- Name: COLUMN trunk_pstn_header.rpid_party; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.rpid_party IS '1-Caller; 2-Callee; 3-Proxy';


--
-- Name: COLUMN trunk_pstn_header.rpid_privacy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.rpid_privacy IS '1-Full; 2-Name; 3-Url; 4-Off; 5-Ipaddr; 6-Proxy';


--
-- Name: COLUMN trunk_pstn_header.rpid_screen; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.rpid_screen IS '1-No; 2-Yes; 3-Proxy';


--
-- Name: COLUMN trunk_pstn_header.paid_privacy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN trunk_pstn_header.paid_privacy IS '1-ID; 1-Proxy';


--
-- Name: trunk_pstn_header_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE trunk_pstn_header_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trunk_pstn_header_id_seq OWNER TO postgres;

--
-- Name: trunk_pstn_header_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE trunk_pstn_header_id_seq OWNED BY trunk_pstn_header.id;


--
-- Name: trunk_pstn_header_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE trunk_pstn_header_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trunk_pstn_header_record_record_id_seq OWNER TO postgres;

--
-- Name: trunk_pstn_header_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE trunk_pstn_header_record (
    id integer,
    ingress_id integer,
    egress_id integer,
    rpid integer,
    paid integer,
    oli integer,
    priv integer,
    div integer,
    pci integer,
    rpid_id_type integer,
    rpid_party integer,
    rpid_privacy integer,
    rpid_screen integer,
    paid_privacy integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('trunk_pstn_header_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE trunk_pstn_header_record OWNER TO postgres;

--
-- Name: trunk_relation_route; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE trunk_relation_route (
    id integer NOT NULL,
    type integer DEFAULT 2 NOT NULL,
    dynamic integer,
    static integer,
    prefix character varying,
    resource_id integer
);


ALTER TABLE trunk_relation_route OWNER TO postgres;

--
-- Name: trunk_relation_route_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE trunk_relation_route_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE trunk_relation_route_id_seq OWNER TO postgres;

--
-- Name: trunk_relation_route_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE trunk_relation_route_id_seq OWNED BY trunk_relation_route.id;


--
-- Name: trunk_stat; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE trunk_stat (
    resource_id integer,
    calls_3hr integer,
    call_24hr integer,
    duration_3hr integer,
    total_calls_3hr integer,
    term_code_name character varying(100),
    calls_1hr integer,
    duration_1hr integer,
    total_calls_1hr integer,
    total_calls_24hr integer,
    duration_24hr integer,
    total_calls_7hr integer
);


ALTER TABLE trunk_stat OWNER TO postgres;

--
-- Name: TABLE trunk_stat; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE trunk_stat IS 'search route çš„ calls asr acd å­˜å‚¨å€¼çš„ä½ç½® ';


--
-- Name: upload_ani_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE upload_ani_log (
    id integer NOT NULL,
    file_path character varying(255),
    upload_by character varying(200),
    upload_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE upload_ani_log OWNER TO postgres;

--
-- Name: upload_ani_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE upload_ani_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE upload_ani_log_id_seq OWNER TO postgres;

--
-- Name: upload_ani_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE upload_ani_log_id_seq OWNED BY upload_ani_log.id;


--
-- Name: upload_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE upload_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE upload_log_id_seq OWNER TO postgres;

--
-- Name: us_export_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE us_export_log (
    id integer NOT NULL,
    report_type integer,
    route_plan_id integer,
    rate_table_id integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    status integer,
    num_of_row integer,
    create_time timestamp with time zone,
    file_name character varying(200),
    pid integer,
    error_msg text,
    trunk_id integer,
    bill_method integer
);


ALTER TABLE us_export_log OWNER TO postgres;

--
-- Name: COLUMN us_export_log.report_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN us_export_log.report_type IS '1:retrun_code_report';


--
-- Name: COLUMN us_export_log.bill_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN us_export_log.bill_method IS '0:DNIS;1:LRN';


--
-- Name: us_export_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE us_export_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE us_export_log_id_seq OWNER TO postgres;

--
-- Name: us_export_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE us_export_log_id_seq OWNED BY us_export_log.id;


--
-- Name: us_frequent_number_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE us_frequent_number_report (
    report_time timestamp with time zone NOT NULL,
    route_plan integer,
    ingress_id integer,
    number_type integer,
    number_code character varying(100),
    total_calls integer,
    not_zero_calls integer,
    busy_calls integer,
    cancel_calls integer,
    duration integer
);


ALTER TABLE us_frequent_number_report OWNER TO postgres;

--
-- Name: us_lcr_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE us_lcr_report (
    report_time timestamp with time zone NOT NULL,
    rate_table_id integer,
    route_plan integer,
    orig_jur_type integer,
    ingress_dnis_type integer,
    npanxx character varying(100),
    ingress_client_rate double precision,
    lcr1_rate double precision,
    lcr1_total_calls integer,
    lcr1_not_zero_calls integer,
    lcr2_rate double precision,
    lcr2_total_calls integer,
    lcr2_not_zero_calls integer,
    lcr3_rate double precision,
    lcr3_not_zero_calls integer,
    lcr4_rate double precision,
    lcr4_total_calls integer,
    lcr4_not_zero_calls integer,
    inter_lcr1_rate double precision,
    inter_lcr1_total_calls integer,
    inter_lcr1_not_zero_calls integer,
    inter_lcr2_rate double precision,
    inter_lcr2_total_calls integer,
    inter_lcr2_not_zero_calls integer,
    inter_lcr3_rate double precision,
    inter_lcr3_total_calls integer,
    inter_lcr3_not_zero_calls integer,
    inter_lcr4_rate double precision,
    inter_lcr4_total_calls integer,
    inter_lcr4_not_zero_calls integer,
    intra_lcr1_rate double precision,
    intra_lcr1_total_calls integer,
    intra_lcr1_not_zero_calls integer,
    intra_lcr2_rate double precision,
    intra_lcr2_total_calls integer,
    intra_lcr2_not_zero_calls integer,
    intra_lcr3_rate double precision,
    intra_lcr3_total_calls integer,
    intra_lcr3_not_zero_calls integer,
    intra_lcr4_rate double precision,
    intra_lcr4_total_calls integer,
    intra_lcr4_not_zero_calls integer,
    ij_lcr1_rate double precision,
    ij_lcr1_total_calls integer,
    ij_lcr1_not_zero_calls integer,
    ij_lcr2_rate double precision,
    ij_lcr2_total_calls integer,
    ij_lcr2_not_zero_calls integer,
    ij_lcr3_rate double precision,
    ij_lcr3_total_calls integer,
    ij_lcr3_not_zero_calls integer,
    ij_lcr4_rate double precision,
    ij_lcr4_total_calls integer,
    ij_lcr4_not_zero_calls integer,
    lcr3_total_calls integer
);


ALTER TABLE us_lcr_report OWNER TO postgres;

--
-- Name: us_lcr_vendor_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE us_lcr_vendor_report (
    report_time timestamp with time zone NOT NULL,
    rate_table_id integer,
    route_plan integer,
    orig_jur_type integer,
    ingress_dnis_type integer,
    npanxx character varying(100),
    of_routes integer,
    of_working integer,
    of_blocked integer,
    inter_of_routes integer,
    inter_of_working integer,
    inter_of_blocked integer,
    intra_of_routes integer,
    intra_of_working integer,
    intra_of_blocked integer,
    local_of_routes integer,
    local_of_working integer,
    local_of_blocked integer,
    ij_of_routes integer,
    ij_of_working integer,
    ij_of_blocked integer
);


ALTER TABLE us_lcr_vendor_report OWNER TO postgres;

--
-- Name: us_ocn_lata; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE us_ocn_lata (
    id integer NOT NULL,
    ocn character varying(10),
    lata character varying(10),
    npa character varying(100),
    nxx character varying(100),
    a_block character(1),
    effective_time timestamp with time zone
);


ALTER TABLE us_ocn_lata OWNER TO postgres;

--
-- Name: us_ocn_lata_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE us_ocn_lata_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE us_ocn_lata_id_seq OWNER TO postgres;

--
-- Name: us_ocn_lata_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE us_ocn_lata_id_seq OWNED BY us_ocn_lata.id;


--
-- Name: us_return_code_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE us_return_code_report (
    report_time timestamp with time zone NOT NULL,
    rate_table_id integer,
    route_plan integer,
    orig_jur_type integer,
    ingress_dnis_type integer,
    ingress_rate_type integer,
    cause400 integer,
    cause200 integer,
    cause503 integer,
    cause487 integer,
    cause482 integer,
    cause_other integer,
    npanxx character varying(100)
);


ALTER TABLE us_return_code_report OWNER TO postgres;

--
-- Name: us_termination_vendor_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE us_termination_vendor_report (
    report_time timestamp with time zone NOT NULL,
    rate_table_id integer,
    route_plan integer,
    orig_jur_type integer,
    ingress_dnis_type integer,
    egress_id integer,
    lcr1_num integer,
    lcr2_num integer,
    lcr3_num integer,
    lcr1_200_num integer,
    lcr2_200_num integer,
    lcr3_200_num integer,
    inter_lcr1_num integer,
    inter_lcr2_num integer,
    inter_lcr3_num integer,
    inter_lcr1_200_num integer,
    inter_lcr2_200_num integer,
    inter_lcr3_200_num integer,
    intra_lcr1_num integer,
    intra_lcr2_num integer,
    intra_lcr3_num integer,
    intra_lcr1_200_num integer,
    intra_lcr2_200_num integer,
    intra_lcr3_200_num integer,
    ij_lcr1_num integer,
    ij_lcr2_num integer,
    ij_lcr3_num integer,
    ij_lcr1_200_num integer,
    ij_lcr2_200_num integer,
    ij_lcr3_200_num integer
);


ALTER TABLE us_termination_vendor_report OWNER TO postgres;

--
-- Name: usage_report_delivery; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE usage_report_delivery (
    type smallint,
    week character(2),
    month smallint,
    hour smallint,
    carrierid character varying(500),
    ingressid character varying(500),
    egressid character varying(500),
    is_all_carrier boolean,
    time_bucket smallint,
    code_bucket smallint,
    skip_empty boolean,
    email character(100),
    id integer NOT NULL,
    all_ingress boolean,
    all_egress boolean,
    action boolean
);


ALTER TABLE usage_report_delivery OWNER TO postgres;

--
-- Name: COLUMN usage_report_delivery.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.type IS '1.ä¸ºdaily
2.ä¸ºweekly
3.ä¸ºmonthly';


--
-- Name: COLUMN usage_report_delivery.week; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.week IS 'M, T, W, Th, F, Sa, Su';


--
-- Name: COLUMN usage_report_delivery.month; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.month IS '1åˆ°31';


--
-- Name: COLUMN usage_report_delivery.hour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.hour IS '0åˆ°23ç‚¹';


--
-- Name: COLUMN usage_report_delivery.carrierid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.carrierid IS 'ä¿å­˜carrierID ç”¨é€—å·éš”å¼€';


--
-- Name: COLUMN usage_report_delivery.ingressid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.ingressid IS 'ingress id';


--
-- Name: COLUMN usage_report_delivery.egressid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.egressid IS 'egressid é€—å·éš”å¼€';


--
-- Name: COLUMN usage_report_delivery.is_all_carrier; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.is_all_carrier IS 'tureä¸ºå…¨é€‰';


--
-- Name: COLUMN usage_report_delivery.time_bucket; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.time_bucket IS '1ä¸ºhourly
2ä¸ºdaily';


--
-- Name: COLUMN usage_report_delivery.code_bucket; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.code_bucket IS '1.ä¸ºby code
2 ä¸º by code name';


--
-- Name: COLUMN usage_report_delivery.skip_empty; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.skip_empty IS 'ture ä¸ºè·³è¿‡
';


--
-- Name: COLUMN usage_report_delivery.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.email IS 'æŽ¥æ”¶åœ°å€';


--
-- Name: COLUMN usage_report_delivery.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN usage_report_delivery.action IS 'æ˜¯å¦åœ¨ä½¿ç”¨';


--
-- Name: usage_report_delivery_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE usage_report_delivery_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usage_report_delivery_id_seq OWNER TO postgres;

--
-- Name: usage_report_delivery_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE usage_report_delivery_id_seq OWNED BY usage_report_delivery.id;


--
-- Name: user_auth_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE user_auth_ip (
    user_id integer,
    ip ip4r,
    id integer NOT NULL
);


ALTER TABLE user_auth_ip OWNER TO postgres;

--
-- Name: TABLE user_auth_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE user_auth_ip IS 'ç”¨æˆ·IPè®¤è¯è¡¨';


--
-- Name: user_auth_ip_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE user_auth_ip_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE user_auth_ip_id_seq OWNER TO postgres;

--
-- Name: user_auth_ip_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE user_auth_ip_id_seq OWNED BY user_auth_ip.id;


--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE users (
    user_id integer NOT NULL,
    name character varying(40) NOT NULL,
    password character varying(40) NOT NULL,
    role_id integer,
    reseller_id integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    active boolean DEFAULT true NOT NULL,
    client_id integer,
    email character varying(100),
    fullname character varying(100),
    user_type integer NOT NULL,
    create_user_id integer,
    last_login_time timestamp with time zone,
    card_id integer,
    is_online integer DEFAULT 2 NOT NULL,
    login_ip ip4r,
    default_mod integer DEFAULT 0,
    default_mod2 integer DEFAULT 0,
    last_seen timestamp with time zone,
    report_group boolean DEFAULT true NOT NULL,
    outbound_report boolean DEFAULT true NOT NULL,
    all_termination boolean DEFAULT true NOT NULL,
    show_carrier_trunk_drop_only boolean DEFAULT false NOT NULL,
    report_fields text
);


ALTER TABLE users OWNER TO postgres;

--
-- Name: TABLE users; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE users IS 'ç”¨æˆ·';


--
-- Name: COLUMN users.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.user_id IS 'ä¸»é”®';


--
-- Name: COLUMN users.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.name IS 'åå­—';


--
-- Name: COLUMN users.password; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.password IS 'å¯†ç ';


--
-- Name: COLUMN users.role_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.role_id IS 'è§’è‰²';


--
-- Name: COLUMN users.reseller_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.reseller_id IS 'ä»£ç†å•†';


--
-- Name: COLUMN users.create_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.create_time IS 'å»ºç«‹æ—¶é—´';


--
-- Name: COLUMN users.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.active IS 'ç¦ç”¨ï¼Œæ¿€æ´»';


--
-- Name: COLUMN users.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN users.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.email IS 'ç”µå­é‚®ä»¶';


--
-- Name: COLUMN users.fullname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.fullname IS 'å…¨å';


--
-- Name: COLUMN users.user_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.user_type IS 'ç”¨æˆ·ç±»åž‹(éžå¸¸é‡è¦è¿™ä¸ªå­—æ®µ
æ˜¯ç”¨æˆ·ç™»å½•ç³»ç»Ÿçš„æ ‡å¿—ä½œä¸ºä¸å¯ä»¥åˆ é™¤)
1--ç®¡ç†å‘˜
2--ä»£ç†å•†
3--å®¢æˆ·(è·¯ç”±ä¼™ä¼´)
4--å¸å·å¡(account)
5--æ™®é€šç”¨æˆ·
6--ä½“éªŒç”¨æˆ·';


--
-- Name: COLUMN users.create_user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.create_user_id IS 'åˆ›å»ºäºº';


--
-- Name: COLUMN users.last_login_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.last_login_time IS 'æœ€åŽç™»å½•çš„æ—¶é—´';


--
-- Name: COLUMN users.card_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.card_id IS 'è´¦å·å¡';


--
-- Name: COLUMN users.is_online; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN users.is_online IS 'æ˜¯å¦åœ¨çº¿
1ï¼ï¼åœ¨çº¿
2ï¼ï¼ç¦»çº¿
3ï¼ï¼ç¦»å¼€
ï¼ï¼ä¸å†ä½¿ç”¨ï¼Œå‡†å¤‡åˆ é™¤';


--
-- Name: users_limit; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE users_limit (
    id integer NOT NULL,
    user_id integer,
    client_id integer
);


ALTER TABLE users_limit OWNER TO postgres;

--
-- Name: users_limit_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE users_limit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE users_limit_id_seq OWNER TO postgres;

--
-- Name: users_limit_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE users_limit_id_seq OWNED BY users_limit.id;


--
-- Name: users_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE users_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE users_user_id_seq OWNER TO postgres;

--
-- Name: users_user_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE users_user_id_seq OWNED BY users.user_id;


--
-- Name: vendor_invoice; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vendor_invoice (
    vendor_invoice_id integer NOT NULL,
    client_id integer,
    invoice_time timestamp with time zone,
    billing_start timestamp with time zone,
    billing_end timestamp with time zone,
    system_mins numeric(6,2),
    billing_total numeric(7,2),
    status integer DEFAULT 0,
    system_total numeric(7,2),
    billing_mins numeric(6,2),
    file_path text,
    file_name text
);


ALTER TABLE vendor_invoice OWNER TO postgres;

--
-- Name: COLUMN vendor_invoice.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN vendor_invoice.status IS '0:Not Billed, 1:Disputed, 2:Accepted, 3:Dispute Resolved, 4:Billed';


--
-- Name: vendor_invoice_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vendor_invoice_detail (
    id integer NOT NULL,
    vendor_invoice_id integer,
    code_name character varying(100),
    mins numeric(6,2),
    non_zero_calls integer,
    rate numeric(30,10),
    report_date date,
    total_cost numeric(8,2)
);


ALTER TABLE vendor_invoice_detail OWNER TO postgres;

--
-- Name: vendor_invoice_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE vendor_invoice_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vendor_invoice_detail_id_seq OWNER TO postgres;

--
-- Name: vendor_invoice_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE vendor_invoice_detail_id_seq OWNED BY vendor_invoice_detail.id;


--
-- Name: vendor_invoice_dispute; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vendor_invoice_dispute (
    id integer NOT NULL,
    vendor_invoice_id integer,
    create_on timestamp with time zone,
    create_by character varying(100),
    dispute numeric(6,2),
    credit numeric(6,2),
    credit_note text
);


ALTER TABLE vendor_invoice_dispute OWNER TO postgres;

--
-- Name: vendor_invoice_dispute_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE vendor_invoice_dispute_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vendor_invoice_dispute_id_seq OWNER TO postgres;

--
-- Name: vendor_invoice_dispute_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE vendor_invoice_dispute_id_seq OWNED BY vendor_invoice_dispute.id;


--
-- Name: vendor_invoice_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE vendor_invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vendor_invoice_id_seq OWNER TO postgres;

--
-- Name: vendor_invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE vendor_invoice_id_seq OWNED BY vendor_invoice.vendor_invoice_id;


--
-- Name: vendor_test_number_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE vendor_test_number_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vendor_test_number_id_seq OWNER TO postgres;

--
-- Name: vendor_test_number_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE vendor_test_number_id_seq OWNED BY exchange_vendor_test_number.id;


--
-- Name: vendortest_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vendortest_code (
    id integer NOT NULL,
    vendortest_project_id integer NOT NULL,
    code_name character varying(50),
    active smallint DEFAULT 0 NOT NULL
);


ALTER TABLE vendortest_code OWNER TO postgres;

--
-- Name: vendortest_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE vendortest_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vendortest_code_id_seq OWNER TO postgres;

--
-- Name: vendortest_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE vendortest_code_id_seq OWNED BY vendortest_code.id;


--
-- Name: vendortest_number; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vendortest_number (
    id integer NOT NULL,
    vendortest_code_id integer NOT NULL,
    test_number character varying(100) NOT NULL,
    source_number character varying(100) NOT NULL,
    call_time integer DEFAULT 5 NOT NULL,
    sip_capture_path character varying
);


ALTER TABLE vendortest_number OWNER TO postgres;

--
-- Name: vendortest_number_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE vendortest_number_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vendortest_number_id_seq OWNER TO postgres;

--
-- Name: vendortest_number_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE vendortest_number_id_seq OWNED BY vendortest_number.id;


--
-- Name: vendortest_number_summary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vendortest_number_summary (
    id integer NOT NULL,
    pdd integer DEFAULT 0,
    start_epoch bigint DEFAULT 0,
    ring_epoch bigint DEFAULT 0,
    answer_epoch bigint DEFAULT 0,
    end_epoch bigint DEFAULT 0,
    duration integer DEFAULT 0,
    rbt_bytes integer DEFAULT 0,
    media_bytes integer DEFAULT 0,
    packet_loss integer DEFAULT 0,
    media_path character varying(64),
    pcap_path character varying(64),
    release_cause character varying(64),
    vendortest_code_id integer,
    ani character varying(64),
    dnis character varying(64),
    bill_status integer DEFAULT 0 NOT NULL,
    bill_type integer,
    currency_id integer,
    country_id integer,
    rate_id integer,
    rate_table_id integer,
    bill_time integer DEFAULT 0 NOT NULL,
    six_seconds integer DEFAULT 0 NOT NULL,
    cost numeric(12,6) DEFAULT 0 NOT NULL,
    rate numeric(12,6),
    bill_minutes numeric(12,6) DEFAULT 0 NOT NULL,
    early_sdp integer,
    early_nosdp integer,
    answer_nosdp integer,
    result_code integer
);


ALTER TABLE vendortest_number_summary OWNER TO postgres;

--
-- Name: COLUMN vendortest_number_summary.bill_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN vendortest_number_summary.bill_status IS '0 - æˆåŠŸ
1 - ç©ºè´¹çŽ‡
2 - è´¹çŽ‡æ‰¾ä¸åˆ°';


--
-- Name: COLUMN vendortest_number_summary.bill_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN vendortest_number_summary.bill_type IS '0 - dnis
1 - lrn';


--
-- Name: COLUMN vendortest_number_summary.country_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN vendortest_number_summary.country_id IS 'å¦‚æžœéžç©ºï¼Œåˆ™ä¼šåˆ¤æ–­æ˜¯å¦jurisdictionè®¡è´¹';


--
-- Name: COLUMN vendortest_number_summary.result_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN vendortest_number_summary.result_code IS '0 -- Normal Connected
1 -- FAS
2 -- Connected w/o Ring Tone
3 -- Dead Air
4 -- Normal Caller Hangup';


--
-- Name: vendortest_number_summary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE vendortest_number_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vendortest_number_summary_id_seq OWNER TO postgres;

--
-- Name: vendortest_number_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE vendortest_number_summary_id_seq OWNED BY vendortest_number_summary.id;


--
-- Name: vendortest_project; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vendortest_project (
    id integer NOT NULL,
    project_name character varying(50),
    status smallint DEFAULT 0 NOT NULL,
    trunk integer NOT NULL,
    order_type integer,
    order_id integer,
    public_link_key character varying(100),
    test_trunk_id integer,
    send_email integer DEFAULT 0 NOT NULL
);


ALTER TABLE vendortest_project OWNER TO postgres;

--
-- Name: COLUMN vendortest_project.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN vendortest_project.order_type IS '1:buy_order
2:sell_order';


--
-- Name: vendortest_project_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE vendortest_project_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vendortest_project_id_seq OWNER TO postgres;

--
-- Name: vendortest_project_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE vendortest_project_id_seq OWNED BY vendortest_project.id;


--
-- Name: vendortest_project_summary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vendortest_project_summary (
    id integer NOT NULL,
    start_epoch bigint DEFAULT 0,
    end_epoch bigint DEFAULT 0,
    pdd integer DEFAULT 0,
    pdd_count integer DEFAULT 0,
    asr real DEFAULT 0,
    asr_count integer DEFAULT 0,
    acd integer DEFAULT 0,
    acd_count integer DEFAULT 0,
    fas_count integer DEFAULT 0,
    vendortest_project_id integer
);


ALTER TABLE vendortest_project_summary OWNER TO postgres;

--
-- Name: vendortest_project_summary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE vendortest_project_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vendortest_project_summary_id_seq OWNER TO postgres;

--
-- Name: vendortest_project_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE vendortest_project_summary_id_seq OWNED BY vendortest_project_summary.id;


--
-- Name: version_information; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE version_information (
    id integer NOT NULL,
    program_name character varying(50),
    major_ver character varying(100),
    minor_ver character varying(100),
    build_date character varying(11),
    start_time timestamp with time zone,
    licensed_cps integer,
    licensed_channel integer,
    expires timestamp with time zone,
    switch_name character varying(100),
    serial_number character varying(100)
);


ALTER TABLE version_information OWNER TO postgres;

--
-- Name: version_information_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE version_information_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE version_information_id_seq OWNER TO postgres;

--
-- Name: version_information_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE version_information_id_seq OWNED BY version_information.id;


--
-- Name: voip_gateway; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE voip_gateway (
    id integer NOT NULL,
    name character varying(200),
    paid_replace_ip integer DEFAULT 0,
    lan_ip character varying(255),
    lan_port integer,
    active_call_ip character varying(64),
    active_call_port integer,
    sip_capture_ip character varying(255),
    sip_capture_port integer,
    sip_capture_path character varying(255)
);


ALTER TABLE voip_gateway OWNER TO postgres;

--
-- Name: voip_gateway_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE voip_gateway_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE voip_gateway_id_seq OWNER TO postgres;

--
-- Name: voip_gateway_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE voip_gateway_id_seq OWNED BY voip_gateway.id;


--
-- Name: web_session; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE web_session (
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    user_id integer,
    host character varying(1000),
    agent character varying(1000),
    id integer NOT NULL,
    msg character varying
);


ALTER TABLE web_session OWNER TO postgres;

--
-- Name: web_session_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE web_session_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE web_session_id_seq OWNER TO postgres;

--
-- Name: web_session_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE web_session_id_seq OWNED BY web_session.id;


SET search_path = pgagent, pg_catalog;

--
-- Name: pga_exception jexid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_exception ALTER COLUMN jexid SET DEFAULT nextval('pga_exception_jexid_seq'::regclass);


--
-- Name: pga_job jobid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_job ALTER COLUMN jobid SET DEFAULT nextval('pga_job_jobid_seq'::regclass);


--
-- Name: pga_jobclass jclid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_jobclass ALTER COLUMN jclid SET DEFAULT nextval('pga_jobclass_jclid_seq'::regclass);


--
-- Name: pga_joblog jlgid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_joblog ALTER COLUMN jlgid SET DEFAULT nextval('pga_joblog_jlgid_seq'::regclass);


--
-- Name: pga_jobstep jstid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_jobstep ALTER COLUMN jstid SET DEFAULT nextval('pga_jobstep_jstid_seq'::regclass);


--
-- Name: pga_jobsteplog jslid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_jobsteplog ALTER COLUMN jslid SET DEFAULT nextval('pga_jobsteplog_jslid_seq'::regclass);


--
-- Name: pga_schedule jscid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_schedule ALTER COLUMN jscid SET DEFAULT nextval('pga_schedule_jscid_seq'::regclass);


SET search_path = public, pg_catalog;

--
-- Name: actual_transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY actual_transaction ALTER COLUMN id SET DEFAULT nextval('actual_transaction_id_seq'::regclass);


--
-- Name: admin_alert id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY admin_alert ALTER COLUMN id SET DEFAULT nextval('admin_alert_id_seq'::regclass);


--
-- Name: agent agent_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent ALTER COLUMN agent_id SET DEFAULT nextval('agent_agent_id_seq'::regclass);


--
-- Name: agent_client id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_client ALTER COLUMN id SET DEFAULT nextval('agent_client_id_seq'::regclass);


--
-- Name: agent_clients id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_clients ALTER COLUMN id SET DEFAULT nextval('agent_clients_id_seq'::regclass);


--
-- Name: agent_commission_history history_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_commission_history ALTER COLUMN history_id SET DEFAULT nextval('agent_commission_history_history_id_seq'::regclass);


--
-- Name: agent_commission_history_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_commission_history_detail ALTER COLUMN id SET DEFAULT nextval('agent_commission_history_detail_id_seq'::regclass);


--
-- Name: agent_commission_payment id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_commission_payment ALTER COLUMN id SET DEFAULT nextval('agent_commission_payment_id_seq'::regclass);


--
-- Name: alert_action id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_action ALTER COLUMN id SET DEFAULT nextval('alert_action_id_seq'::regclass);


--
-- Name: alert_condition id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_condition ALTER COLUMN id SET DEFAULT nextval('alert_condition_id_seq'::regclass);


--
-- Name: alert_event id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_event ALTER COLUMN id SET DEFAULT nextval('alert_event_id_seq'::regclass);


--
-- Name: alert_mail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_mail ALTER COLUMN id SET DEFAULT nextval('alert_mail_id_seq'::regclass);


--
-- Name: alert_rule id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_rule ALTER COLUMN id SET DEFAULT nextval('alert_rule_id_seq'::regclass);


--
-- Name: alert_rules id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_rules ALTER COLUMN id SET DEFAULT nextval('alert_rules_id_seq'::regclass);


--
-- Name: alert_rules_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_rules_log ALTER COLUMN id SET DEFAULT nextval('alert_rules_log_id_seq'::regclass);


--
-- Name: alert_rules_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_rules_log_detail ALTER COLUMN id SET DEFAULT nextval('alert_rules_log_detail_id_seq'::regclass);


--
-- Name: allowed_sendto_ip id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY allowed_sendto_ip ALTER COLUMN id SET DEFAULT nextval('allowed_sendto_ip_id_seq'::regclass);


--
-- Name: ani_blocking_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ani_blocking_log ALTER COLUMN id SET DEFAULT nextval('ani_blocking_log_id_seq'::regclass);


--
-- Name: api_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY api_log ALTER COLUMN id SET DEFAULT nextval('api_log_id_seq'::regclass);


--
-- Name: automatic_rate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY automatic_rate ALTER COLUMN id SET DEFAULT nextval('automatic_rate_id_seq'::regclass);


--
-- Name: backup_clean id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY backup_clean ALTER COLUMN id SET DEFAULT nextval('backup_clean_id_seq'::regclass);


--
-- Name: balance_daily_reset_task id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY balance_daily_reset_task ALTER COLUMN id SET DEFAULT nextval('balance_daily_reset_task_id_seq'::regclass);


--
-- Name: balance_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY balance_history ALTER COLUMN id SET DEFAULT nextval('balance_history_id_seq'::regclass);


--
-- Name: balance_history_actual id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY balance_history_actual ALTER COLUMN id SET DEFAULT nextval('balance_history_actual_id_seq'::regclass);


--
-- Name: balance_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY balance_log ALTER COLUMN id SET DEFAULT nextval('balance_log_id_seq'::regclass);


--
-- Name: block_ani id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_ani ALTER COLUMN id SET DEFAULT nextval('block_ani_id_seq'::regclass);


--
-- Name: block_log log_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_log ALTER COLUMN log_id SET DEFAULT nextval('block_log_log_id_seq'::regclass);


--
-- Name: block_loop id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_loop ALTER COLUMN id SET DEFAULT nextval('block_loop_id_seq'::regclass);


--
-- Name: block_loop_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_loop_log ALTER COLUMN id SET DEFAULT nextval('block_loop_log_id_seq'::regclass);


--
-- Name: block_loop_log_calls id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_loop_log_calls ALTER COLUMN id SET DEFAULT nextval('block_loop_log_calls_id_seq'::regclass);


--
-- Name: block_ticket id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_ticket ALTER COLUMN id SET DEFAULT nextval('block_ticket_id_seq'::regclass);


--
-- Name: block_trouble_ticket id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_trouble_ticket ALTER COLUMN id SET DEFAULT nextval('block_trouble_ticket_id_seq'::regclass);


--
-- Name: buy_order id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY buy_order ALTER COLUMN id SET DEFAULT nextval('buy_order_id_seq'::regclass);


--
-- Name: buy_order_response id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY buy_order_response ALTER COLUMN id SET DEFAULT nextval('buy_order_response_id_seq'::regclass);


--
-- Name: c4_client_balance id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY c4_client_balance ALTER COLUMN id SET DEFAULT nextval('c4_client_balance_id_seq'::regclass);


--
-- Name: c4_livecall_user id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY c4_livecall_user ALTER COLUMN id SET DEFAULT nextval('c4_livecall_user_id_seq'::regclass);


--
-- Name: c4_lrn id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY c4_lrn ALTER COLUMN id SET DEFAULT nextval('c4_lrn_id_seq'::regclass);


--
-- Name: call_monitor id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY call_monitor ALTER COLUMN id SET DEFAULT nextval('call_monitor_id_seq'::regclass);


--
-- Name: captcha captcha_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY captcha ALTER COLUMN captcha_id SET DEFAULT nextval('captcha_captcha_id_seq'::regclass);


--
-- Name: carrier_group group_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY carrier_group ALTER COLUMN group_id SET DEFAULT nextval('carrier_group_group_id_seq'::regclass);


--
-- Name: carrier_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY carrier_template ALTER COLUMN id SET DEFAULT nextval('carrier_template_id_seq'::regclass);


--
-- Name: cdr_api_export_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_api_export_log ALTER COLUMN id SET DEFAULT nextval('cdr_api_export_log_id_seq'::regclass);


--
-- Name: cdr_compare id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_compare ALTER COLUMN id SET DEFAULT nextval('cdr_compare_id_seq'::regclass);


--
-- Name: cdr_compare_cloud id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_compare_cloud ALTER COLUMN id SET DEFAULT nextval('cdr_compare_cloud_id_seq'::regclass);


--
-- Name: cdr_export_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_export_log ALTER COLUMN id SET DEFAULT nextval('cdr_export_log_id_seq'::regclass);


--
-- Name: cdr_list_export_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_list_export_log ALTER COLUMN id SET DEFAULT nextval('cdr_list_export_log_id_seq'::regclass);


--
-- Name: cdr_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_log ALTER COLUMN id SET DEFAULT nextval('cdr_log_id_seq'::regclass);


--
-- Name: cdr_report_regenerate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_report_regenerate_log ALTER COLUMN id SET DEFAULT nextval('cdr_report_regenerate_log_id_seq'::regclass);


--
-- Name: cdr_rerate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_rerate ALTER COLUMN id SET DEFAULT nextval('cdr_rerate_id_seq'::regclass);


--
-- Name: cdr_transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_transaction ALTER COLUMN id SET DEFAULT nextval('cdr_transaction_id_seq'::regclass);


--
-- Name: class4_call_id_cloud_shark_id_map id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY class4_call_id_cloud_shark_id_map ALTER COLUMN id SET DEFAULT nextval('class4_call_id_cloud_shark_id_map_id_seq'::regclass);


--
-- Name: class4_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY class4_log ALTER COLUMN id SET DEFAULT nextval('class4_log_id_seq'::regclass);


--
-- Name: cleanup id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cleanup ALTER COLUMN id SET DEFAULT nextval('cleanup_id_seq'::regclass);


--
-- Name: client_balance_operation_action id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_balance_operation_action ALTER COLUMN id SET DEFAULT nextval('client_balance_operation_action_id_seq'::regclass);


--
-- Name: client_commit_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_commit_code ALTER COLUMN id SET DEFAULT nextval('client_commit_code_id_seq'::regclass);


--
-- Name: client_commit_minutes id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_commit_minutes ALTER COLUMN id SET DEFAULT nextval('client_commit_minutes_id_seq'::regclass);


--
-- Name: client_finance_transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_finance_transaction ALTER COLUMN id SET DEFAULT nextval('client_finance_transaction_id_seq'::regclass);


--
-- Name: client_payment client_payment_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_payment ALTER COLUMN client_payment_id SET DEFAULT nextval('client_payment_client_payment_id_seq'::regclass);


--
-- Name: client_route_request id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_route_request ALTER COLUMN id SET DEFAULT nextval('client_route_request_id_seq'::regclass);


--
-- Name: client_route_request_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_route_request_code ALTER COLUMN id SET DEFAULT nextval('client_route_request_code_id_seq'::regclass);


--
-- Name: client_route_strategy id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_route_strategy ALTER COLUMN id SET DEFAULT nextval('client_route_strategy_id_seq'::regclass);


--
-- Name: client_transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_transaction ALTER COLUMN id SET DEFAULT nextval('client_transaction_id_seq'::regclass);


--
-- Name: code_based_report_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code_based_report_log ALTER COLUMN id SET DEFAULT nextval('code_based_report_log_id_seq'::regclass);


--
-- Name: code_based_report_log_status id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code_based_report_log_status ALTER COLUMN id SET DEFAULT nextval('code_based_report_log_status_id_seq'::regclass);


--
-- Name: code_deck code_deck_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code_deck ALTER COLUMN code_deck_id SET DEFAULT nextval('code_deck_code_deck_id_seq'::regclass);


--
-- Name: code_stats id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code_stats ALTER COLUMN id SET DEFAULT nextval('code_stats_id_seq'::regclass);


--
-- Name: contract id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY contract ALTER COLUMN id SET DEFAULT nextval('contract_id_seq'::regclass);


--
-- Name: contract confirm_order_number; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY contract ALTER COLUMN confirm_order_number SET DEFAULT nextval('contract_confirm_order_number_seq'::regclass);


--
-- Name: contract_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY contract_code ALTER COLUMN id SET DEFAULT nextval('contract_code_id_seq'::regclass);


--
-- Name: credit_application id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY credit_application ALTER COLUMN id SET DEFAULT nextval('credit_application_id_seq'::regclass);


--
-- Name: credit_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY credit_log ALTER COLUMN id SET DEFAULT nextval('credit_log_id_seq'::regclass);


--
-- Name: current_dashboard_data id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY current_dashboard_data ALTER COLUMN id SET DEFAULT nextval('current_dashboard_data_id_seq'::regclass);


--
-- Name: daily_cdr_fields id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY daily_cdr_fields ALTER COLUMN id SET DEFAULT nextval('daily_cdr_fields_id_seq'::regclass);


--
-- Name: dashboard_time_option id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dashboard_time_option ALTER COLUMN id SET DEFAULT nextval('dashboard_time_option_id_seq'::regclass);


--
-- Name: dex id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dex ALTER COLUMN id SET DEFAULT nextval('dex_id_seq'::regclass);


--
-- Name: dex_resource id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dex_resource ALTER COLUMN id SET DEFAULT nextval('dex_resource_id_seq'::regclass);


--
-- Name: dialer_detection id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dialer_detection ALTER COLUMN id SET DEFAULT nextval('dialer_detection_id_seq'::regclass);


--
-- Name: did_billing_plan id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_billing_plan ALTER COLUMN id SET DEFAULT nextval('did_billing_plan_id_seq'::regclass);


--
-- Name: did_billing_rel id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_billing_rel ALTER COLUMN id SET DEFAULT nextval('did_billing_rel_id_seq'::regclass);


--
-- Name: did_request id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_request ALTER COLUMN id SET DEFAULT nextval('did_request_id_seq'::regclass);


--
-- Name: did_request_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_request_detail ALTER COLUMN id SET DEFAULT nextval('did_request_detail_id_seq'::regclass);


--
-- Name: did_special_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_special_code ALTER COLUMN id SET DEFAULT nextval('did_special_code_id_seq'::regclass);


--
-- Name: direct_seller_enrollment id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY direct_seller_enrollment ALTER COLUMN id SET DEFAULT nextval('direct_seller_enrollment_id_seq'::regclass);


--
-- Name: dynamic_route_items id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_items ALTER COLUMN id SET DEFAULT nextval('dynamic_route_items_id_seq'::regclass);


--
-- Name: dynamic_route_override id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_override ALTER COLUMN id SET DEFAULT nextval('dynamic_route_override_id_seq'::regclass);


--
-- Name: dynamic_route_pri id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_pri ALTER COLUMN id SET DEFAULT nextval('dynamic_route_pri_id_seq'::regclass);


--
-- Name: dynamic_route_qos id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_qos ALTER COLUMN id SET DEFAULT nextval('dynamic_route_qos_id_seq'::regclass);


--
-- Name: egress_profile id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY egress_profile ALTER COLUMN id SET DEFAULT nextval('egress_profile_id_seq'::regclass);


--
-- Name: egress_test id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY egress_test ALTER COLUMN id SET DEFAULT nextval('egress_test_id_seq'::regclass);


--
-- Name: egress_test_result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY egress_test_result ALTER COLUMN id SET DEFAULT nextval('egress_test_result_id_seq'::regclass);


--
-- Name: email_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY email_log ALTER COLUMN id SET DEFAULT nextval('daily_email_log_id_seq'::regclass);


--
-- Name: email_record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY email_record ALTER COLUMN id SET DEFAULT nextval('email_record_id_seq'::regclass);


--
-- Name: error_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY error_log ALTER COLUMN id SET DEFAULT nextval('error_log_id_seq'::regclass);


--
-- Name: event_log event_log_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY event_log ALTER COLUMN event_log_id SET DEFAULT nextval('event_log_event_log_id_seq'::regclass);


--
-- Name: exchange_agent_email_type id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_email_type ALTER COLUMN id SET DEFAULT nextval('exchange_agent_email_type_id_seq'::regclass);


--
-- Name: exchange_agent_exchange_push_list_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_exchange_push_list_log ALTER COLUMN id SET DEFAULT nextval('exchange_agent_exchange_push_list_log_id_seq'::regclass);


--
-- Name: exchange_agent_exchange_push_list_result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_exchange_push_list_result ALTER COLUMN id SET DEFAULT nextval('exchange_agent_exchange_push_list_result_id_seq'::regclass);


--
-- Name: exchange_agent_exchange_push_list_send_member id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_exchange_push_list_send_member ALTER COLUMN id SET DEFAULT nextval('exchange_agent_exchange_push_list_send_member_id_seq'::regclass);


--
-- Name: exchange_agent_generate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_generate ALTER COLUMN id SET DEFAULT nextval('exchange_agent_generate_id_seq'::regclass);


--
-- Name: exchange_agent_generate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_generate_log ALTER COLUMN id SET DEFAULT nextval('exchange_agent_generate_insert_send_log_id_seq'::regclass);


--
-- Name: exchange_agent_import_target_push id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_import_target_push ALTER COLUMN id SET DEFAULT nextval('exchange_agent_import_target_push_id_seq'::regclass);


--
-- Name: exchange_agent_import_target_push_job id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_import_target_push_job ALTER COLUMN id SET DEFAULT nextval('exchange_agent_import_target_push_job_id_seq'::regclass);


--
-- Name: exchange_agent_mail_tmplate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_mail_tmplate ALTER COLUMN id SET DEFAULT nextval('exchange_agent_mail_tmplate_id_seq'::regclass);


--
-- Name: exchange_agent_partition_login_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_partition_login_log ALTER COLUMN id SET DEFAULT nextval('exchange_agent_partition_login_log_id_seq'::regclass);


--
-- Name: exchange_agent_product_agent_mapping id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_product_agent_mapping ALTER COLUMN id SET DEFAULT nextval('exchange_agent_product_agent_mapping_id_seq'::regclass);


--
-- Name: exchange_agent_product_client_mapping id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_product_client_mapping ALTER COLUMN id SET DEFAULT nextval('exchange_agent_product_client_mapping_id_seq'::regclass);


--
-- Name: exchange_agent_product_no_route id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_product_no_route ALTER COLUMN id SET DEFAULT nextval('exchange_agent_product_no_route_id_seq'::regclass);


--
-- Name: exchange_agent_product_no_route_now id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_product_no_route_now ALTER COLUMN id SET DEFAULT nextval('exchange_agent_product_no_route_now_id_seq'::regclass);


--
-- Name: exchange_agent_product_push_list_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_product_push_list_log ALTER COLUMN id SET DEFAULT nextval('exchange_agent_product_push_list_log_id_seq'::regclass);


--
-- Name: exchange_agent_product_push_list_result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_product_push_list_result ALTER COLUMN id SET DEFAULT nextval('exchange_agent_product_push_list_result_id_seq'::regclass);


--
-- Name: exchange_agent_product_push_list_send_member id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_product_push_list_send_member ALTER COLUMN id SET DEFAULT nextval('exchange_agent_product_push_list_send_member_id_seq'::regclass);


--
-- Name: exchange_agent_send_mail_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_send_mail_log ALTER COLUMN id SET DEFAULT nextval('exchange_agent_send_mail_log_id_seq'::regclass);


--
-- Name: exchange_agent_send_mail_log_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_send_mail_log_list ALTER COLUMN id SET DEFAULT nextval('exchange_agent_send_mail_log_list_id_seq'::regclass);


--
-- Name: exchange_agent_send_rate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_send_rate_log ALTER COLUMN id SET DEFAULT nextval('exchange_agent_send_rate_log_id_seq'::regclass);


--
-- Name: exchange_agent_target_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_target_log ALTER COLUMN id SET DEFAULT nextval('exchange_agent_target_log_id_seq'::regclass);


--
-- Name: exchange_agent_target_result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_target_result ALTER COLUMN id SET DEFAULT nextval('exchange_agent_target_result_id_seq'::regclass);


--
-- Name: exchange_agent_target_send_member id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_target_send_member ALTER COLUMN id SET DEFAULT nextval('exchange_agent_target_send_member_id_seq'::regclass);


--
-- Name: exchange_agent_user id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_user ALTER COLUMN id SET DEFAULT nextval('exchange_agent_user_id_seq'::regclass);


--
-- Name: exchange_agent_vendor_test_result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_vendor_test_result ALTER COLUMN id SET DEFAULT nextval('exchange_agent_vendor_test_result_id_seq'::regclass);


--
-- Name: exchange_block_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_block_log ALTER COLUMN id SET DEFAULT nextval('exchange_block_log_id_seq'::regclass);


--
-- Name: exchange_client_user_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_client_user_list ALTER COLUMN id SET DEFAULT nextval('exchange_client_user_list_id_seq'::regclass);


--
-- Name: exchange_code_name_mapping id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_code_name_mapping ALTER COLUMN id SET DEFAULT nextval('exchange_code_name_mapping_id_seq'::regclass);


--
-- Name: exchange_egress_did id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_egress_did ALTER COLUMN id SET DEFAULT nextval('exchange_egress_did_id_seq'::regclass);


--
-- Name: exchange_false_del id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_false_del ALTER COLUMN id SET DEFAULT nextval('exchange_false_del_id_seq'::regclass);


--
-- Name: exchange_finance id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_finance ALTER COLUMN id SET DEFAULT nextval('exchange_finance_id_seq'::regclass);


--
-- Name: exchange_finance_agent id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_finance_agent ALTER COLUMN id SET DEFAULT nextval('exchange_finance_agent_id_seq'::regclass);


--
-- Name: exchange_finance_agent_clients id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_finance_agent_clients ALTER COLUMN id SET DEFAULT nextval('exchange_finance_agent_clients_id_seq'::regclass);


--
-- Name: exchange_interpeering_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_interpeering_log ALTER COLUMN id SET DEFAULT nextval('exchange_interpeering_log_id_seq'::regclass);


--
-- Name: exchange_job id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job ALTER COLUMN id SET DEFAULT nextval('exchange_job_id_seq'::regclass);


--
-- Name: exchange_job_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_list ALTER COLUMN id SET DEFAULT nextval('exchange_job_list_id_seq'::regclass);


--
-- Name: exchange_job_session id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session ALTER COLUMN id SET DEFAULT nextval('exchange_job_session_id_seq'::regclass);


--
-- Name: exchange_job_session_block_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session_block_log ALTER COLUMN id SET DEFAULT nextval('exchange_job_session_block_log_id_seq'::regclass);


--
-- Name: exchange_job_session_buy_route_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session_buy_route_log ALTER COLUMN id SET DEFAULT nextval('exchange_job_session_buy_route_log_id_seq'::regclass);


--
-- Name: exchange_job_session_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session_list ALTER COLUMN id SET DEFAULT nextval('exchange_job_session_list_id_seq'::regclass);


--
-- Name: exchange_job_session_remove_route_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session_remove_route_log ALTER COLUMN id SET DEFAULT nextval('exchange_job_session_remove_route_log_id_seq'::regclass);


--
-- Name: exchange_mass_edit_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_mass_edit_log ALTER COLUMN id SET DEFAULT nextval('exchange_mass_edit_log_id_seq'::regclass);


--
-- Name: exchange_member_egress_test id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_member_egress_test ALTER COLUMN id SET DEFAULT nextval('exchange_member_egress_test_id_seq'::regclass);


--
-- Name: exchange_my_route_download_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_my_route_download_log ALTER COLUMN id SET DEFAULT nextval('exchange_my_route_download_log_id_seq'::regclass);


--
-- Name: exchange_opp_email id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_opp_email ALTER COLUMN id SET DEFAULT nextval('exchange_opp_email_id_seq'::regclass);


--
-- Name: exchange_par_account id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_account ALTER COLUMN id SET DEFAULT nextval('exchange_par_account_id_seq'::regclass);


--
-- Name: exchange_par_active_ips id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_active_ips ALTER COLUMN id SET DEFAULT nextval('exchange_par_active_ips_id_seq'::regclass);


--
-- Name: exchange_par_plan id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_plan ALTER COLUMN id SET DEFAULT nextval('exchange_par_plan_id_seq'::regclass);


--
-- Name: exchange_par_plan_record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_plan_record ALTER COLUMN id SET DEFAULT nextval('exchange_par_plan_record_id_seq'::regclass);


--
-- Name: exchange_par_port id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_port ALTER COLUMN id SET DEFAULT nextval('exchange_par_port_id_seq'::regclass);


--
-- Name: exchange_par_script id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_script ALTER COLUMN id SET DEFAULT nextval('exchange_par_script_id_seq'::regclass);


--
-- Name: exchange_par_switch_profiles id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_switch_profiles ALTER COLUMN id SET DEFAULT nextval('exchange_par_switch_profiles_id_seq'::regclass);


--
-- Name: exchange_par_system_parm id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_system_parm ALTER COLUMN id SET DEFAULT nextval('exchange_par_system_parm_id_seq'::regclass);


--
-- Name: exchange_product_copy_rate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_product_copy_rate_log ALTER COLUMN id SET DEFAULT nextval('exchange_product_copy_rate_log_id_seq'::regclass);


--
-- Name: exchange_product_copy_route_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_product_copy_route_log ALTER COLUMN id SET DEFAULT nextval('exchange_product_copy_route_log_id_seq'::regclass);


--
-- Name: exchange_product_copy_route_rate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_product_copy_route_rate_log ALTER COLUMN id SET DEFAULT nextval('exchange_product_copy_route_rate_log_id_seq'::regclass);


--
-- Name: exchange_product_user_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_product_user_list ALTER COLUMN id SET DEFAULT nextval('exchange_public_user_list_id_seq'::regclass);


--
-- Name: exchange_reg_country id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_reg_country ALTER COLUMN id SET DEFAULT nextval('exchange_reg_country_id_seq'::regclass);


--
-- Name: exchange_resource_private id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_resource_private ALTER COLUMN id SET DEFAULT nextval('exchange_resource_private_id_seq'::regclass);


--
-- Name: exchange_simple_session id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_simple_session ALTER COLUMN id SET DEFAULT nextval('exchange_simple_session_id_seq'::regclass);


--
-- Name: exchange_simple_session_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_simple_session_list ALTER COLUMN id SET DEFAULT nextval('exchange_simple_session_list_id_seq'::regclass);


--
-- Name: exchange_sys_module id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_module ALTER COLUMN id SET DEFAULT nextval('exchange_sys_module_id_seq'::regclass);


--
-- Name: exchange_sys_pri id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_pri ALTER COLUMN id SET DEFAULT nextval('exchange_sys_pri_id_seq'::regclass);


--
-- Name: exchange_sys_role role_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_role ALTER COLUMN role_id SET DEFAULT nextval('exchange_sys_role_role_id_seq'::regclass);


--
-- Name: exchange_sys_role_pri id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_role_pri ALTER COLUMN id SET DEFAULT nextval('exchange_sys_role_pri_id_seq'::regclass);


--
-- Name: exchange_vendor_test_number id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_vendor_test_number ALTER COLUMN id SET DEFAULT nextval('vendor_test_number_id_seq'::regclass);


--
-- Name: execution_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY execution_log ALTER COLUMN id SET DEFAULT nextval('execution_log_id_seq'::regclass);


--
-- Name: export_task_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY export_task_log ALTER COLUMN id SET DEFAULT nextval('export_task_log_id_seq'::regclass);


--
-- Name: fraud_detection id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fraud_detection ALTER COLUMN id SET DEFAULT nextval('fraud_detection_id_seq'::regclass);


--
-- Name: fraud_detection_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fraud_detection_log ALTER COLUMN id SET DEFAULT nextval('fraud_detection_log_id_seq'::regclass);


--
-- Name: fraud_detection_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fraud_detection_log_detail ALTER COLUMN id SET DEFAULT nextval('fraud_detection_log_detail_id_seq'::regclass);


--
-- Name: ftp_cdr_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ftp_cdr_log ALTER COLUMN id SET DEFAULT nextval('ftp_cdr_log_id_seq'::regclass);


--
-- Name: ftp_cdr_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ftp_cdr_log_detail ALTER COLUMN id SET DEFAULT nextval('ftp_cdr_log_detail_id_seq'::regclass);


--
-- Name: ftp_conf id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ftp_conf ALTER COLUMN id SET DEFAULT nextval('ftp_conf_id_seq'::regclass);


--
-- Name: ftp_server_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ftp_server_log ALTER COLUMN id SET DEFAULT nextval('ftp_server_log_id_seq'::regclass);


--
-- Name: global_failover id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY global_failover ALTER COLUMN id SET DEFAULT nextval('global_failover_id_seq'::regclass);


--
-- Name: global_route_error id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY global_route_error ALTER COLUMN id SET DEFAULT nextval('global_route_error_id_seq'::regclass);


--
-- Name: hang_calls_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY hang_calls_history ALTER COLUMN id SET DEFAULT nextval('hang_calls_history_id_seq'::regclass);


--
-- Name: hung_calls_detection_configuration id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY hung_calls_detection_configuration ALTER COLUMN id SET DEFAULT nextval('hung_calls_detection_configuration_id_seq'::regclass);


--
-- Name: hung_calls_report_delete_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY hung_calls_report_delete_log ALTER COLUMN id SET DEFAULT nextval('hung_calls_report_delete_log_id_seq'::regclass);


--
-- Name: import_code_constraints_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY import_code_constraints_log ALTER COLUMN id SET DEFAULT nextval('import_code_constraints_log_id_seq'::regclass);


--
-- Name: import_rate_file_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY import_rate_file_log ALTER COLUMN id SET DEFAULT nextval('import_rate_file_log_id_seq'::regclass);


--
-- Name: import_rate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY import_rate_log ALTER COLUMN id SET DEFAULT nextval('import_rate_log_id_seq'::regclass);


--
-- Name: import_rate_status id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY import_rate_status ALTER COLUMN id SET DEFAULT nextval('import_rate_status_id_seq'::regclass);


--
-- Name: import_target_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY import_target_log ALTER COLUMN id SET DEFAULT nextval('import_target_log_id_seq'::regclass);


--
-- Name: ingress_test id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ingress_test ALTER COLUMN id SET DEFAULT nextval('ingress_test_id_seq'::regclass);


--
-- Name: invalid_detection_block_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_detection_block_log ALTER COLUMN id SET DEFAULT nextval('invalid_detection_block_log_id_seq'::regclass);


--
-- Name: invalid_number_detection id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_number_detection ALTER COLUMN id SET DEFAULT nextval('invalid_number_detection_id_seq'::regclass);


--
-- Name: invalid_number_detection_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_number_detection_log ALTER COLUMN id SET DEFAULT nextval('invalid_number_detection_log_id_seq'::regclass);


--
-- Name: invalid_number_detection_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_number_detection_log_detail ALTER COLUMN id SET DEFAULT nextval('invalid_number_detection_log_detail_id_seq'::regclass);


--
-- Name: invoice invoice_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice ALTER COLUMN invoice_id SET DEFAULT nextval('invoice_invoice_id_seq'::regclass);


--
-- Name: invoice_calls invoice_calls_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_calls ALTER COLUMN invoice_calls_id SET DEFAULT nextval('invoice_calls_invoice_calls_id_seq'::regclass);


--
-- Name: invoice_cdr_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_cdr_log ALTER COLUMN id SET DEFAULT nextval('invoice_cdr_log_id_seq'::regclass);


--
-- Name: invoice_credit_note id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_credit_note ALTER COLUMN id SET DEFAULT nextval('invoice_credit_note_id_seq'::regclass);


--
-- Name: invoice_daily_cost id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_daily_cost ALTER COLUMN id SET DEFAULT nextval('invoice_daily_cost_id_seq'::regclass);


--
-- Name: invoice_did id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_did ALTER COLUMN id SET DEFAULT nextval('invoice_did_id_seq'::regclass);


--
-- Name: invoice_email id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_email ALTER COLUMN id SET DEFAULT nextval('invoice_email_id_seq'::regclass);


--
-- Name: invoice_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_history ALTER COLUMN id SET DEFAULT nextval('invoice_history_id_seq'::regclass);


--
-- Name: invoice_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_log ALTER COLUMN id SET DEFAULT nextval('invoice_log_id_seq'::regclass);


--
-- Name: invoice_payment id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_payment ALTER COLUMN id SET DEFAULT nextval('invoice_payment_id_seq'::regclass);


--
-- Name: invoice_reconcile id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_reconcile ALTER COLUMN id SET DEFAULT nextval('invoice_reconcile_id_seq'::regclass);


--
-- Name: invoice_service_charge invoice_service_charge_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_service_charge ALTER COLUMN invoice_service_charge_id SET DEFAULT nextval('invoice_service_charge_invoice_service_charge_id_seq'::regclass);


--
-- Name: ip_modif_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ip_modif_log ALTER COLUMN id SET DEFAULT nextval('ip_modif_log_id_seq'::regclass);


--
-- Name: jurisdiction_country id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction_country ALTER COLUMN id SET DEFAULT nextval('jurisdiction_country_id_seq'::regclass);


--
-- Name: jurisdiction_update_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction_update_history ALTER COLUMN id SET DEFAULT nextval('jurisdiction_update_history_id_seq'::regclass);


--
-- Name: jurisdiction_update_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction_update_log ALTER COLUMN id SET DEFAULT nextval('jurisdiction_update_log_id_seq'::regclass);


--
-- Name: kill_pg_sql_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY kill_pg_sql_log ALTER COLUMN id SET DEFAULT nextval('kill_pg_sql_log_id_seq'::regclass);


--
-- Name: lcr_record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lcr_record ALTER COLUMN id SET DEFAULT nextval('lcr_record_id_seq'::regclass);


--
-- Name: lcr_reports id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lcr_reports ALTER COLUMN id SET DEFAULT nextval('lcr_reports_id_seq'::regclass);


--
-- Name: license_modification_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY license_modification_log ALTER COLUMN id SET DEFAULT nextval('license_modification_log_id_seq'::regclass);


--
-- Name: lnp_request id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lnp_request ALTER COLUMN id SET DEFAULT nextval('lnp_request_id_seq'::regclass);


--
-- Name: lnp_request_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lnp_request_detail ALTER COLUMN id SET DEFAULT nextval('lnp_request_detail_id_seq'::regclass);


--
-- Name: loop_detection id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY loop_detection ALTER COLUMN id SET DEFAULT nextval('loop_detection_id_seq'::regclass);


--
-- Name: loop_detection_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY loop_detection_detail ALTER COLUMN id SET DEFAULT nextval('loop_detection_detail_id_seq'::regclass);


--
-- Name: lrn lrn_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lrn ALTER COLUMN lrn_id SET DEFAULT nextval('lrn_lrn_id_seq'::regclass);


--
-- Name: lrn_groups id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lrn_groups ALTER COLUMN id SET DEFAULT nextval('lrn_groups_id_seq'::regclass);


--
-- Name: lrn_items id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lrn_items ALTER COLUMN id SET DEFAULT nextval('lrn_items_id_seq'::regclass);


--
-- Name: lrn_items_logs id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lrn_items_logs ALTER COLUMN id SET DEFAULT nextval('lrn_items_logs_id_seq'::regclass);


--
-- Name: lrn_servers id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lrn_servers ALTER COLUMN id SET DEFAULT nextval('lrn_servers_id_seq'::regclass);


--
-- Name: mail_cdr_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY mail_cdr_log ALTER COLUMN id SET DEFAULT nextval('mail_cdr_log_id_seq'::regclass);


--
-- Name: mail_cdr_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY mail_cdr_log_detail ALTER COLUMN id SET DEFAULT nextval('mail_cdr_log_detail_id_seq'::regclass);


--
-- Name: mail_sender id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY mail_sender ALTER COLUMN id SET DEFAULT nextval('emails_id_seq'::regclass);


--
-- Name: modif_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY modif_log ALTER COLUMN id SET DEFAULT nextval('modif_log_id_seq'::regclass);


--
-- Name: mutual_transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY mutual_transaction ALTER COLUMN id SET DEFAULT nextval('mutual_transaction_id_seq'::regclass);


--
-- Name: ocn_lata id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ocn_lata ALTER COLUMN id SET DEFAULT nextval('ocn_lata_id_seq'::regclass);


--
-- Name: opentact_balance id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY opentact_balance ALTER COLUMN id SET DEFAULT nextval('opentact_balance_id_seq'::regclass);


--
-- Name: options_of_record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY options_of_record ALTER COLUMN id SET DEFAULT nextval('options_of_record_id_seq'::regclass);


--
-- Name: order_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_code ALTER COLUMN id SET DEFAULT nextval('order_code_id_seq'::regclass);


--
-- Name: order_partern id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_partern ALTER COLUMN id SET DEFAULT nextval('order_partern_id_seq'::regclass);


--
-- Name: order_user id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_user ALTER COLUMN id SET DEFAULT nextval('order_user_id_seq'::regclass);


--
-- Name: order_user_alert id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_user_alert ALTER COLUMN id SET DEFAULT nextval('order_user_alert_id_seq'::regclass);


--
-- Name: order_user_finance id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_user_finance ALTER COLUMN id SET DEFAULT nextval('order_user_finance_id_seq'::regclass);


--
-- Name: order_user_qos id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_user_qos ALTER COLUMN id SET DEFAULT nextval('order_user_qos_id_seq'::regclass);


--
-- Name: order_user_rate_watch id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_user_rate_watch ALTER COLUMN id SET DEFAULT nextval('order_user_rate_watch_id_seq'::regclass);


--
-- Name: orig_invoice invoice_id; Type: DEFAULT; Schema: public; Owner: class4_user
--

ALTER TABLE ONLY orig_invoice ALTER COLUMN invoice_id SET DEFAULT nextval('orig_invoice_invoice_id_seq'::regclass);


--
-- Name: orig_log log_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY orig_log ALTER COLUMN log_id SET DEFAULT nextval('orig_log_log_id_seq'::regclass);


--
-- Name: origination_global_failover id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY origination_global_failover ALTER COLUMN id SET DEFAULT nextval('origination_global_failover_id_seq'::regclass);


--
-- Name: par_user id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY par_user ALTER COLUMN id SET DEFAULT nextval('par_user_id_seq'::regclass);


--
-- Name: partition_gateway_ref id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY partition_gateway_ref ALTER COLUMN id SET DEFAULT nextval('partition_gateway_ref_id_seq'::regclass);


--
-- Name: partition_invoice id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY partition_invoice ALTER COLUMN id SET DEFAULT nextval('partition_invoice_id_seq'::regclass);


--
-- Name: partner id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY partner ALTER COLUMN id SET DEFAULT nextval('partner_id_seq'::regclass);


--
-- Name: payline_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY payline_history ALTER COLUMN id SET DEFAULT nextval('payline_history_id_seq'::regclass);


--
-- Name: payment_invoice id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY payment_invoice ALTER COLUMN id SET DEFAULT nextval('payment_invoice_id_seq'::regclass);


--
-- Name: pex_offer_pending_rate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY pex_offer_pending_rate ALTER COLUMN id SET DEFAULT nextval('pex_offer_pending_rate_id_seq'::regclass);


--
-- Name: pex_offers id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY pex_offers ALTER COLUMN id SET DEFAULT nextval('pex_offers_id_seq'::regclass);


--
-- Name: private_invite id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY private_invite ALTER COLUMN id SET DEFAULT nextval('private_invite_id_seq'::regclass);


--
-- Name: product_agents_ref id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_agents_ref ALTER COLUMN id SET DEFAULT nextval('product_agents_ref_id_seq'::regclass);


--
-- Name: product_clients_ref id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_clients_ref ALTER COLUMN id SET DEFAULT nextval('product_clients_ref_id_seq'::regclass);


--
-- Name: product_items_resource id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_items_resource ALTER COLUMN id SET DEFAULT nextval('product_items_resource_id_seq'::regclass);


--
-- Name: product_rout_rate_table id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_rout_rate_table ALTER COLUMN id SET DEFAULT nextval('product_rout_rate_table_id_seq'::regclass);


--
-- Name: product_route_rate_table id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_route_rate_table ALTER COLUMN id SET DEFAULT nextval('product_route_rate_table_id_seq'::regclass);


--
-- Name: quick_cdr id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY quick_cdr ALTER COLUMN id SET DEFAULT nextval('quick_cdr_id_seq'::regclass);


--
-- Name: random_ani_generation id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY random_ani_generation ALTER COLUMN id SET DEFAULT nextval('random_ani_generation_id_seq'::regclass);


--
-- Name: random_ani_populated_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY random_ani_populated_log ALTER COLUMN id SET DEFAULT nextval('random_ani_populated_log_id_seq'::regclass);


--
-- Name: random_ani_table id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY random_ani_table ALTER COLUMN id SET DEFAULT nextval('random_ani_table_id_seq'::regclass);


--
-- Name: rate_auto_create id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_auto_create ALTER COLUMN id SET DEFAULT nextval('rate_auto_create_id_seq'::regclass);


--
-- Name: rate_auto_create_interval id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_auto_create_interval ALTER COLUMN id SET DEFAULT nextval('rate_auto_create_interval_id_seq'::regclass);


--
-- Name: rate_auto_create_profit id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_auto_create_profit ALTER COLUMN id SET DEFAULT nextval('rate_auto_create_profit_id_seq'::regclass);


--
-- Name: rate_auto_diff id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_auto_diff ALTER COLUMN id SET DEFAULT nextval('rate_auto_diff_id_seq'::regclass);


--
-- Name: rate_download_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_download_log ALTER COLUMN id SET DEFAULT nextval('rate_download_log_id_seq'::regclass);


--
-- Name: rate_email_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_email_template ALTER COLUMN id SET DEFAULT nextval('rate_email_template_id_seq'::regclass);


--
-- Name: rate_generate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generate ALTER COLUMN id SET DEFAULT nextval('rate_generate_id_seq'::regclass);


--
-- Name: rate_generation_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_history ALTER COLUMN id SET DEFAULT nextval('rate_generation_history_id_seq'::regclass);


--
-- Name: rate_generation_history_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_history_detail ALTER COLUMN id SET DEFAULT nextval('rate_generation_history_detail_id_seq'::regclass);


--
-- Name: rate_generation_rate generation_rate_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_rate ALTER COLUMN generation_rate_id SET DEFAULT nextval('rate_generation_rate_generation_rate_id_seq'::regclass);


--
-- Name: rate_generation_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_template ALTER COLUMN id SET DEFAULT nextval('rate_generation_template_id_seq'::regclass);


--
-- Name: rate_generation_template_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_template_detail ALTER COLUMN id SET DEFAULT nextval('rate_generation_template_detail_id_seq'::regclass);


--
-- Name: rate_generation_template_margin id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_template_margin ALTER COLUMN id SET DEFAULT nextval('rate_generation_template_margin_id_seq'::regclass);


--
-- Name: rate_handler id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_handler ALTER COLUMN id SET DEFAULT nextval('rate_handler_id_seq'::regclass);


--
-- Name: rate_import_error_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_import_error_log ALTER COLUMN id SET DEFAULT nextval('rate_import_error_log_id_seq'::regclass);


--
-- Name: rate_mail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_mail ALTER COLUMN id SET DEFAULT nextval('rate_mail_id_seq'::regclass);


--
-- Name: rate_mail_decks id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_mail_decks ALTER COLUMN id SET DEFAULT nextval('rate_mail_decks_id_seq'::regclass);


--
-- Name: rate_mail_decks_files id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_mail_decks_files ALTER COLUMN id SET DEFAULT nextval('rate_mail_decks_files_id_seq'::regclass);


--
-- Name: rate_management id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_management ALTER COLUMN id SET DEFAULT nextval('rate_management_id_seq'::regclass);


--
-- Name: rate_management_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_management_detail ALTER COLUMN id SET DEFAULT nextval('rate_management_detail_id_seq'::regclass);


--
-- Name: rate_management_option id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_management_option ALTER COLUMN id SET DEFAULT nextval('rate_management_option_id_seq'::regclass);


--
-- Name: rate_mass_edit_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_mass_edit_log ALTER COLUMN id SET DEFAULT nextval('rate_mass_edit_log_id_seq'::regclass);


--
-- Name: rate_send_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_send_log ALTER COLUMN id SET DEFAULT nextval('rate_send_log_id_seq'::regclass);


--
-- Name: rate_send_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_send_log_detail ALTER COLUMN id SET DEFAULT nextval('rate_send_log_detail_id_seq'::regclass);


--
-- Name: rate_send_logging id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_send_logging ALTER COLUMN id SET DEFAULT nextval('rate_send_logging_id_seq'::regclass);


--
-- Name: rate_send_rules id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_send_rules ALTER COLUMN id SET DEFAULT nextval('rate_send_rules_id_seq'::regclass);


--
-- Name: rate_upload_fail_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_upload_fail_log ALTER COLUMN id SET DEFAULT nextval('rate_upload_fail_log_id_seq'::regclass);


--
-- Name: rate_upload_queue id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_upload_queue ALTER COLUMN id SET DEFAULT nextval('rate_upload_queue_id_seq'::regclass);


--
-- Name: rate_upload_success_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_upload_success_log ALTER COLUMN id SET DEFAULT nextval('rate_upload_success_log_id_seq'::regclass);


--
-- Name: rate_upload_task id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_upload_task ALTER COLUMN id SET DEFAULT nextval('rate_upload_task_id_seq'::regclass);


--
-- Name: rate_upload_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_upload_template ALTER COLUMN id SET DEFAULT nextval('rate_upload_template_id_seq'::regclass);


--
-- Name: ratemail_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ratemail_history ALTER COLUMN id SET DEFAULT nextval('ratemail_history_id_seq'::regclass);


--
-- Name: real_cdr real_cdr_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY real_cdr ALTER COLUMN real_cdr_id SET DEFAULT nextval('real_cdr_real_cdr_id_seq'::regclass);


--
-- Name: redirect_carrier id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY redirect_carrier ALTER COLUMN id SET DEFAULT nextval('redirect_carrier_id_seq'::regclass);


--
-- Name: redirect_host id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY redirect_host ALTER COLUMN id SET DEFAULT nextval('redirect_host_id_seq'::regclass);


--
-- Name: register_of_record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY register_of_record ALTER COLUMN id SET DEFAULT nextval('register_of_record_id_seq'::regclass);


--
-- Name: rerate_cdr_download_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rerate_cdr_download_log ALTER COLUMN id SET DEFAULT nextval('rerate_cdr_download_log_id_seq'::regclass);


--
-- Name: rerate_cdr_task id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rerate_cdr_task ALTER COLUMN id SET DEFAULT nextval('rerate_cdr_task_id_seq'::regclass);


--
-- Name: rerate_log rerate_log_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rerate_log ALTER COLUMN rerate_log_id SET DEFAULT nextval('rerate_log_rerate_log_id_seq'::regclass);


--
-- Name: rerate_report_exec_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rerate_report_exec_log ALTER COLUMN id SET DEFAULT nextval('rerate_report_exec_log_id_seq'::regclass);


--
-- Name: reseller id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY reseller ALTER COLUMN id SET DEFAULT nextval('reseller_id_seq'::regclass);


--
-- Name: reseller_client id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY reseller_client ALTER COLUMN id SET DEFAULT nextval('reseller_client_id_seq'::regclass);


--
-- Name: resource_auth id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_auth ALTER COLUMN id SET DEFAULT nextval('resource_auth_id_seq'::regclass);


--
-- Name: resource_block_group id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_block_group ALTER COLUMN id SET DEFAULT nextval('resource_block_group_id_seq'::regclass);


--
-- Name: resource_block_items id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_block_items ALTER COLUMN id SET DEFAULT nextval('resource_block_items_id_seq'::regclass);


--
-- Name: resource_capacity id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_capacity ALTER COLUMN id SET DEFAULT nextval('resource_capacity_id_seq'::regclass);


--
-- Name: resource_codecs_ref id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_codecs_ref ALTER COLUMN id SET DEFAULT nextval('resource_codecs_ref_id_seq'::regclass);


--
-- Name: resource_direction direction_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_direction ALTER COLUMN direction_id SET DEFAULT nextval('resource_direction_direction_id_seq'::regclass);


--
-- Name: resource_direction_template direction_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_direction_template ALTER COLUMN direction_id SET DEFAULT nextval('resource_direction_template_direction_id_seq'::regclass);


--
-- Name: resource_ip_limit limit_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_ip_limit ALTER COLUMN limit_id SET DEFAULT nextval('resource_ip_limit_limit_id_seq'::regclass);


--
-- Name: resource_lrn_action id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_lrn_action ALTER COLUMN id SET DEFAULT nextval('resource_lrn_action_id_seq'::regclass);


--
-- Name: resource_next_route_rule id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_next_route_rule ALTER COLUMN id SET DEFAULT nextval('resource_next_route_rule_id_seq'::regclass);


--
-- Name: resource_next_route_rule_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_next_route_rule_template ALTER COLUMN id SET DEFAULT nextval('resource_next_route_rule_template_id_seq'::regclass);


--
-- Name: resource_prefix id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_prefix ALTER COLUMN id SET DEFAULT nextval('resource_prefix_id_seq'::regclass);


--
-- Name: resource_rate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_rate ALTER COLUMN id SET DEFAULT nextval('resource_rate_id_seq'::regclass);


--
-- Name: resource_replace_action id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_replace_action ALTER COLUMN id SET DEFAULT nextval('resource_replace_action_id_seq'::regclass);


--
-- Name: resource_replace_action_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_replace_action_template ALTER COLUMN id SET DEFAULT nextval('resource_replace_action_template_id_seq'::regclass);


--
-- Name: resource_template resource_template_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_template ALTER COLUMN resource_template_id SET DEFAULT nextval('resource_template_resource_template_id_seq'::regclass);


--
-- Name: resource_translation_ref ref_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_translation_ref ALTER COLUMN ref_id SET DEFAULT nextval('resource_translation_ref_ref_id_seq'::regclass);


--
-- Name: retrieve_password_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY retrieve_password_log ALTER COLUMN id SET DEFAULT nextval('retrieve_password_log_id_seq'::regclass);


--
-- Name: role role_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY role ALTER COLUMN role_id SET DEFAULT nextval('role_role_id_seq'::regclass);


--
-- Name: role_privilege role_privilege_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY role_privilege ALTER COLUMN role_privilege_id SET DEFAULT nextval('role_privilege_role_privilege_id_seq'::regclass);


--
-- Name: route route_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY route ALTER COLUMN route_id SET DEFAULT nextval('route_route_id_seq'::regclass);


--
-- Name: route_block id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY route_block ALTER COLUMN id SET DEFAULT nextval('route_block_id_seq'::regclass);


--
-- Name: route_strategy route_strategy_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY route_strategy ALTER COLUMN route_strategy_id SET DEFAULT nextval('route_strategy_route_strategy_id_seq'::regclass);


--
-- Name: routing_wizard_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY routing_wizard_list ALTER COLUMN id SET DEFAULT nextval('routing_wizard_list_id_seq'::regclass);


--
-- Name: scheduled_report id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY scheduled_report ALTER COLUMN id SET DEFAULT nextval('scheduled_report_id_seq'::regclass);


--
-- Name: scheduled_report_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY scheduled_report_log ALTER COLUMN id SET DEFAULT nextval('scheduled_report_log_id_seq'::regclass);


--
-- Name: scheduler id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY scheduler ALTER COLUMN id SET DEFAULT nextval('shceduler_id_seq'::regclass);


--
-- Name: scheduler_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY scheduler_log ALTER COLUMN id SET DEFAULT nextval('scheduler_log_id_seq'::regclass);


--
-- Name: search_logs id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY search_logs ALTER COLUMN id SET DEFAULT nextval('search_logs_id_seq'::regclass);


--
-- Name: sell_order id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sell_order ALTER COLUMN id SET DEFAULT nextval('sell_order_id_seq'::regclass);


--
-- Name: sell_order_response id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sell_order_response ALTER COLUMN id SET DEFAULT nextval('sell_order_response_id_seq'::regclass);


--
-- Name: send_mails id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY send_mails ALTER COLUMN id SET DEFAULT nextval('send_mails_id_seq'::regclass);


--
-- Name: send_rate_preserved_data id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY send_rate_preserved_data ALTER COLUMN id SET DEFAULT nextval('send_rate_preserved_data_id_seq'::regclass);


--
-- Name: send_rate_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY send_rate_template ALTER COLUMN id SET DEFAULT nextval('send_rate_template_id_seq'::regclass);


--
-- Name: service_charge service_charge_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY service_charge ALTER COLUMN service_charge_id SET DEFAULT nextval('service_charge_service_charge_id_seq'::regclass);


--
-- Name: service_charge_items id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY service_charge_items ALTER COLUMN id SET DEFAULT nextval('service_charge_items_id_seq'::regclass);


--
-- Name: signup id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY signup ALTER COLUMN id SET DEFAULT nextval('signup_id_seq'::regclass);


--
-- Name: signup_ip id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY signup_ip ALTER COLUMN id SET DEFAULT nextval('signup_ip_id_seq'::regclass);


--
-- Name: sip_registrations id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sip_registrations ALTER COLUMN id SET DEFAULT nextval('sip_registrations_id_seq'::regclass);


--
-- Name: sip_requests id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sip_requests ALTER COLUMN id SET DEFAULT nextval('sip_requests_id_seq'::regclass);


--
-- Name: spam_traffic_ip_record record_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY spam_traffic_ip_record ALTER COLUMN record_id SET DEFAULT nextval('spam_traffic_ip_record_record_id_seq1'::regclass);


--
-- Name: stats_buy_order id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY stats_buy_order ALTER COLUMN id SET DEFAULT nextval('stats_buy_order_id_seq'::regclass);


--
-- Name: stats_sell_order id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY stats_sell_order ALTER COLUMN id SET DEFAULT nextval('stats_sell_order_id_seq'::regclass);


--
-- Name: switch_profile id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY switch_profile ALTER COLUMN id SET DEFAULT nextval('switch_profile_id_seq'::regclass);


--
-- Name: sys_module id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sys_module ALTER COLUMN id SET DEFAULT nextval('sys_module_id_seq'::regclass);


--
-- Name: sys_pri id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sys_pri ALTER COLUMN id SET DEFAULT nextval('sys_pri_id_seq'::regclass);


--
-- Name: sys_role_pri id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sys_role_pri ALTER COLUMN id SET DEFAULT nextval('sys_role_pri_id_seq'::regclass);


--
-- Name: system_function system_function_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY system_function ALTER COLUMN system_function_id SET DEFAULT nextval('system_function_system_function_id_seq'::regclass);


--
-- Name: system_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY system_log ALTER COLUMN id SET DEFAULT nextval('system_log_id_seq'::regclass);


--
-- Name: system_mail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY system_mail ALTER COLUMN id SET DEFAULT nextval('system_mail_id_seq'::regclass);


--
-- Name: system_parameter sys_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY system_parameter ALTER COLUMN sys_id SET DEFAULT nextval('system_parameter_sys_id_seq'::regclass);


--
-- Name: task_manage id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY task_manage ALTER COLUMN id SET DEFAULT nextval('task_manage_id_seq'::regclass);


--
-- Name: termination_global_failover id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY termination_global_failover ALTER COLUMN id SET DEFAULT nextval('termination_global_failover_id_seq'::regclass);


--
-- Name: test_device test_device_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY test_device ALTER COLUMN test_device_id SET DEFAULT nextval('test_device_test_device_id_seq'::regclass);


--
-- Name: traffic_alert id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY traffic_alert ALTER COLUMN id SET DEFAULT nextval('traffic_alert_id_seq'::regclass);


--
-- Name: transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY transaction ALTER COLUMN id SET DEFAULT nextval('transaction_id_seq'::regclass);


--
-- Name: transaction_fee id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY transaction_fee ALTER COLUMN id SET DEFAULT nextval('transaction_fee_id_seq'::regclass);


--
-- Name: transaction_fee_items id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY transaction_fee_items ALTER COLUMN id SET DEFAULT nextval('transaction_fee_items_id_seq'::regclass);


--
-- Name: trouble_tickets_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY trouble_tickets_template ALTER COLUMN id SET DEFAULT nextval('trouble_tickets_template_id_seq'::regclass);


--
-- Name: trunk_group group_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY trunk_group ALTER COLUMN group_id SET DEFAULT nextval('trunk_group_group_id_seq'::regclass);


--
-- Name: trunk_pstn_header id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY trunk_pstn_header ALTER COLUMN id SET DEFAULT nextval('trunk_pstn_header_id_seq'::regclass);


--
-- Name: trunk_relation_route id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY trunk_relation_route ALTER COLUMN id SET DEFAULT nextval('trunk_relation_route_id_seq'::regclass);


--
-- Name: upload_ani_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY upload_ani_log ALTER COLUMN id SET DEFAULT nextval('upload_ani_log_id_seq'::regclass);


--
-- Name: us_export_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY us_export_log ALTER COLUMN id SET DEFAULT nextval('us_export_log_id_seq'::regclass);


--
-- Name: us_ocn_lata id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY us_ocn_lata ALTER COLUMN id SET DEFAULT nextval('us_ocn_lata_id_seq'::regclass);


--
-- Name: usage_report_delivery id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY usage_report_delivery ALTER COLUMN id SET DEFAULT nextval('usage_report_delivery_id_seq'::regclass);


--
-- Name: user_auth_ip id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY user_auth_ip ALTER COLUMN id SET DEFAULT nextval('user_auth_ip_id_seq'::regclass);


--
-- Name: users user_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY users ALTER COLUMN user_id SET DEFAULT nextval('users_user_id_seq'::regclass);


--
-- Name: users_limit id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY users_limit ALTER COLUMN id SET DEFAULT nextval('users_limit_id_seq'::regclass);


--
-- Name: vendor_invoice vendor_invoice_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendor_invoice ALTER COLUMN vendor_invoice_id SET DEFAULT nextval('vendor_invoice_id_seq'::regclass);


--
-- Name: vendor_invoice_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendor_invoice_detail ALTER COLUMN id SET DEFAULT nextval('vendor_invoice_detail_id_seq'::regclass);


--
-- Name: vendor_invoice_dispute id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendor_invoice_dispute ALTER COLUMN id SET DEFAULT nextval('vendor_invoice_dispute_id_seq'::regclass);


--
-- Name: vendortest_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendortest_code ALTER COLUMN id SET DEFAULT nextval('vendortest_code_id_seq'::regclass);


--
-- Name: vendortest_number id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendortest_number ALTER COLUMN id SET DEFAULT nextval('vendortest_number_id_seq'::regclass);


--
-- Name: vendortest_number_summary id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendortest_number_summary ALTER COLUMN id SET DEFAULT nextval('vendortest_number_summary_id_seq'::regclass);


--
-- Name: vendortest_project id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendortest_project ALTER COLUMN id SET DEFAULT nextval('vendortest_project_id_seq'::regclass);


--
-- Name: vendortest_project_summary id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendortest_project_summary ALTER COLUMN id SET DEFAULT nextval('vendortest_project_summary_id_seq'::regclass);


--
-- Name: version_information id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY version_information ALTER COLUMN id SET DEFAULT nextval('version_information_id_seq'::regclass);


--
-- Name: voip_gateway id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY voip_gateway ALTER COLUMN id SET DEFAULT nextval('voip_gateway_id_seq'::regclass);


--
-- Name: web_session id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY web_session ALTER COLUMN id SET DEFAULT nextval('web_session_id_seq'::regclass);


SET search_path = pgagent, pg_catalog;

--
-- Name: pga_exception pga_exception_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_exception
    ADD CONSTRAINT pga_exception_pkey PRIMARY KEY (jexid);


--
-- Name: pga_job pga_job_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_job
    ADD CONSTRAINT pga_job_pkey PRIMARY KEY (jobid);


--
-- Name: pga_jobagent pga_jobagent_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_jobagent
    ADD CONSTRAINT pga_jobagent_pkey PRIMARY KEY (jagpid);


--
-- Name: pga_jobclass pga_jobclass_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_jobclass
    ADD CONSTRAINT pga_jobclass_pkey PRIMARY KEY (jclid);


--
-- Name: pga_joblog pga_joblog_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_joblog
    ADD CONSTRAINT pga_joblog_pkey PRIMARY KEY (jlgid);


--
-- Name: pga_jobstep pga_jobstep_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_jobstep
    ADD CONSTRAINT pga_jobstep_pkey PRIMARY KEY (jstid);


--
-- Name: pga_jobsteplog pga_jobsteplog_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_jobsteplog
    ADD CONSTRAINT pga_jobsteplog_pkey PRIMARY KEY (jslid);


--
-- Name: pga_schedule pga_schedule_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_schedule
    ADD CONSTRAINT pga_schedule_pkey PRIMARY KEY (jscid);


SET search_path = public, pg_catalog;

--
-- Name: agent_client agent_client_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_client
    ADD CONSTRAINT agent_client_pkey PRIMARY KEY (id);


--
-- Name: agent_clients agent_clients_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_clients
    ADD CONSTRAINT agent_clients_pkey PRIMARY KEY (id);


--
-- Name: agent_commission_history_detail agent_commission_history_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_commission_history_detail
    ADD CONSTRAINT agent_commission_history_detail_pkey PRIMARY KEY (id);


--
-- Name: agent_commission_history agent_commission_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_commission_history
    ADD CONSTRAINT agent_commission_history_pkey PRIMARY KEY (history_id);


--
-- Name: agent_commission_payment agent_commission_payment_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_commission_payment
    ADD CONSTRAINT agent_commission_payment_pkey PRIMARY KEY (id);


--
-- Name: agent agent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent
    ADD CONSTRAINT agent_pkey PRIMARY KEY (agent_id);


--
-- Name: alert_rules_log_detail alert_rules_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_rules_log_detail
    ADD CONSTRAINT alert_rules_log_detail_pkey PRIMARY KEY (id);


--
-- Name: alert_rules_log alert_rules_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_rules_log
    ADD CONSTRAINT alert_rules_log_pkey PRIMARY KEY (id);


--
-- Name: alert_rules alert_rules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_rules
    ADD CONSTRAINT alert_rules_pkey PRIMARY KEY (id);


--
-- Name: alert_rules alert_rules_rule_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_rules
    ADD CONSTRAINT alert_rules_rule_name_key UNIQUE (rule_name);


--
-- Name: ani_blocking_log ani_blocking_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ani_blocking_log
    ADD CONSTRAINT ani_blocking_log_pkey PRIMARY KEY (id);


--
-- Name: api_log api_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY api_log
    ADD CONSTRAINT api_log_pkey PRIMARY KEY (id);


--
-- Name: automatic_rate automatic_rate_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY automatic_rate
    ADD CONSTRAINT automatic_rate_pkey PRIMARY KEY (id);


--
-- Name: balance_daily_reset_task balance_daily_reset_task_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY balance_daily_reset_task
    ADD CONSTRAINT balance_daily_reset_task_pkey PRIMARY KEY (id);


--
-- Name: balance_history_actual balance_history_actual_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY balance_history_actual
    ADD CONSTRAINT balance_history_actual_pkey PRIMARY KEY (id);


--
-- Name: balance_history balance_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY balance_history
    ADD CONSTRAINT balance_history_pkey PRIMARY KEY (id);


--
-- Name: balance_log balance_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY balance_log
    ADD CONSTRAINT balance_log_pkey PRIMARY KEY (id);


--
-- Name: block_ani block_ani_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_ani
    ADD CONSTRAINT block_ani_pkey PRIMARY KEY (id);


--
-- Name: block_log block_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_log
    ADD CONSTRAINT block_log_pkey PRIMARY KEY (log_id);


--
-- Name: block_ticket block_ticket_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_ticket
    ADD CONSTRAINT block_ticket_pkey PRIMARY KEY (id);


--
-- Name: block_trouble_ticket block_trouble_ticket_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_trouble_ticket
    ADD CONSTRAINT block_trouble_ticket_pkey PRIMARY KEY (id);


--
-- Name: c4_client_balance c4_client_balance_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY c4_client_balance
    ADD CONSTRAINT c4_client_balance_pkey PRIMARY KEY (id);


--
-- Name: c4_livecall_user c4_livecall_user_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY c4_livecall_user
    ADD CONSTRAINT c4_livecall_user_pkey PRIMARY KEY (id);


--
-- Name: c4_lrn c4_lrn_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY c4_lrn
    ADD CONSTRAINT c4_lrn_pkey PRIMARY KEY (id);


--
-- Name: call_monitor call_monitor_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY call_monitor
    ADD CONSTRAINT call_monitor_pkey PRIMARY KEY (id);


--
-- Name: captcha captcha_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY captcha
    ADD CONSTRAINT captcha_pkey PRIMARY KEY (captcha_id);


--
-- Name: carrier_group carrier_group_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY carrier_group
    ADD CONSTRAINT carrier_group_pkey PRIMARY KEY (group_id);


--
-- Name: carrier_template carrier_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY carrier_template
    ADD CONSTRAINT carrier_template_pkey PRIMARY KEY (id);


--
-- Name: cdr_export_log cdr_export_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_export_log
    ADD CONSTRAINT cdr_export_log_pkey PRIMARY KEY (id);


--
-- Name: cdr_list_export_log cdr_list_export_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_list_export_log
    ADD CONSTRAINT cdr_list_export_log_pkey PRIMARY KEY (id);


--
-- Name: cdr_report_regenerate_log cdr_report_regenerate_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_report_regenerate_log
    ADD CONSTRAINT cdr_report_regenerate_log_pkey PRIMARY KEY (id);


--
-- Name: exchange_ci_sessions ci_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_ci_sessions
    ADD CONSTRAINT ci_sessions_pkey PRIMARY KEY (session_id);


--
-- Name: digit_translation class4_digit_translation_translation_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY digit_translation
    ADD CONSTRAINT class4_digit_translation_translation_name UNIQUE (translation_name);


--
-- Name: invoice_log class4_fkey_invoice_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_log
    ADD CONSTRAINT class4_fkey_invoice_log_id PRIMARY KEY (id);


--
-- Name: ingress_test class4_pk_ingress_test_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ingress_test
    ADD CONSTRAINT class4_pk_ingress_test_id PRIMARY KEY (id);


--
-- Name: alert_action class4_pkey_alert_action_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_action
    ADD CONSTRAINT class4_pkey_alert_action_id PRIMARY KEY (id);


--
-- Name: alert_exec_log class4_pkey_alert_action_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_exec_log
    ADD CONSTRAINT class4_pkey_alert_action_log_id PRIMARY KEY (id);


--
-- Name: alert_condition class4_pkey_alert_condition_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_condition
    ADD CONSTRAINT class4_pkey_alert_condition_id PRIMARY KEY (id);


--
-- Name: alert_event class4_pkey_alert_event_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_event
    ADD CONSTRAINT class4_pkey_alert_event_id PRIMARY KEY (id);


--
-- Name: alert_mail class4_pkey_alert_mail_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_mail
    ADD CONSTRAINT class4_pkey_alert_mail_id PRIMARY KEY (id);


--
-- Name: alert_rule class4_pkey_alert_rule_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_rule
    ADD CONSTRAINT class4_pkey_alert_rule_id PRIMARY KEY (id);


--
-- Name: backup_clean class4_pkey_backup_clean_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY backup_clean
    ADD CONSTRAINT class4_pkey_backup_clean_id PRIMARY KEY (id);


--
-- Name: block_loop class4_pkey_block_loop_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_loop
    ADD CONSTRAINT class4_pkey_block_loop_id PRIMARY KEY (id);


--
-- Name: block_loop_log_calls class4_pkey_block_loop_log_calls_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_loop_log_calls
    ADD CONSTRAINT class4_pkey_block_loop_log_calls_id PRIMARY KEY (block_loop_log_id);


--
-- Name: block_loop_log class4_pkey_block_loop_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_loop_log
    ADD CONSTRAINT class4_pkey_block_loop_log_id PRIMARY KEY (id);


--
-- Name: buy_order class4_pkey_buy_order_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY buy_order
    ADD CONSTRAINT class4_pkey_buy_order_id PRIMARY KEY (id);


--
-- Name: buy_order_response class4_pkey_buy_order_response_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY buy_order_response
    ADD CONSTRAINT class4_pkey_buy_order_response_id PRIMARY KEY (id);


--
-- Name: capture class4_pkey_capture_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capture
    ADD CONSTRAINT class4_pkey_capture_id PRIMARY KEY (capture_id);


--
-- Name: cdr_compare_cloud class4_pkey_cdr_compare_cloud_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_compare_cloud
    ADD CONSTRAINT class4_pkey_cdr_compare_cloud_id PRIMARY KEY (id);


--
-- Name: cdr_compare class4_pkey_cdr_compare_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_compare
    ADD CONSTRAINT class4_pkey_cdr_compare_id PRIMARY KEY (id);


--
-- Name: cdr_log class4_pkey_cdr_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_log
    ADD CONSTRAINT class4_pkey_cdr_log_id PRIMARY KEY (id);


--
-- Name: cdr_rerate class4_pkey_cdr_rerate_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cdr_rerate
    ADD CONSTRAINT class4_pkey_cdr_rerate_id PRIMARY KEY (id);


--
-- Name: client_balance class4_pkey_client_balance_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_balance
    ADD CONSTRAINT class4_pkey_client_balance_client_id PRIMARY KEY (client_id);


--
-- Name: client_cdr_delete_bak class4_pkey_client_cdr_delete_bak_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_cdr_delete_bak
    ADD CONSTRAINT class4_pkey_client_cdr_delete_bak_id PRIMARY KEY (id);


--
-- Name: client_commit_code class4_pkey_client_commit_code_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_commit_code
    ADD CONSTRAINT class4_pkey_client_commit_code_id PRIMARY KEY (id);


--
-- Name: client_commit_minutes class4_pkey_client_commit_minutes_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_commit_minutes
    ADD CONSTRAINT class4_pkey_client_commit_minutes_id PRIMARY KEY (id);


--
-- Name: client_finance_transaction class4_pkey_client_finance_transaction_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_finance_transaction
    ADD CONSTRAINT class4_pkey_client_finance_transaction_id PRIMARY KEY (id);


--
-- Name: client class4_pkey_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client
    ADD CONSTRAINT class4_pkey_client_id PRIMARY KEY (client_id);


--
-- Name: client_payment class4_pkey_client_payment_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_payment
    ADD CONSTRAINT class4_pkey_client_payment_id PRIMARY KEY (client_payment_id);


--
-- Name: code_deck class4_pkey_code_deck_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code_deck
    ADD CONSTRAINT class4_pkey_code_deck_id PRIMARY KEY (code_deck_id);


--
-- Name: code class4_pkey_code_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code
    ADD CONSTRAINT class4_pkey_code_id PRIMARY KEY (code_id);


--
-- Name: code_stats class4_pkey_code_stats_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code_stats
    ADD CONSTRAINT class4_pkey_code_stats_id PRIMARY KEY (id);


--
-- Name: codecs class4_pkey_codecs_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY codecs
    ADD CONSTRAINT class4_pkey_codecs_id PRIMARY KEY (id);


--
-- Name: contract_code class4_pkey_contract_code_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY contract_code
    ADD CONSTRAINT class4_pkey_contract_code_id PRIMARY KEY (id);


--
-- Name: contract class4_pkey_contract_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY contract
    ADD CONSTRAINT class4_pkey_contract_id PRIMARY KEY (id);


--
-- Name: credit_application class4_pkey_credit_application_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY credit_application
    ADD CONSTRAINT class4_pkey_credit_application_id PRIMARY KEY (id);


--
-- Name: currency class4_pkey_currency_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY currency
    ADD CONSTRAINT class4_pkey_currency_id PRIMARY KEY (currency_id);


--
-- Name: currency_updates class4_pkey_currency_updates_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY currency_updates
    ADD CONSTRAINT class4_pkey_currency_updates_id PRIMARY KEY (currency_updates_id);


--
-- Name: digit_translation class4_pkey_digit_translation_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY digit_translation
    ADD CONSTRAINT class4_pkey_digit_translation_id PRIMARY KEY (translation_id);


--
-- Name: direct_seller_enrollment class4_pkey_direct_seller_enrollment_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY direct_seller_enrollment
    ADD CONSTRAINT class4_pkey_direct_seller_enrollment_id PRIMARY KEY (id);


--
-- Name: dynamic_route class4_pkey_dynamic_route_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route
    ADD CONSTRAINT class4_pkey_dynamic_route_id PRIMARY KEY (dynamic_route_id);


--
-- Name: dynamic_route_items class4_pkey_dynamic_route_items_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_items
    ADD CONSTRAINT class4_pkey_dynamic_route_items_id PRIMARY KEY (id);


--
-- Name: dynamic_route_override class4_pkey_dynamic_route_override_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_override
    ADD CONSTRAINT class4_pkey_dynamic_route_override_id PRIMARY KEY (id);


--
-- Name: dynamic_route_pri class4_pkey_dynamic_route_pri_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_pri
    ADD CONSTRAINT class4_pkey_dynamic_route_pri_id PRIMARY KEY (id);


--
-- Name: dynamic_route_qos class4_pkey_dynamic_route_qos_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_qos
    ADD CONSTRAINT class4_pkey_dynamic_route_qos_id PRIMARY KEY (id);


--
-- Name: egress_test class4_pkey_egress_test_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY egress_test
    ADD CONSTRAINT class4_pkey_egress_test_id PRIMARY KEY (id);


--
-- Name: egress_test_result class4_pkey_egress_test_result_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY egress_test_result
    ADD CONSTRAINT class4_pkey_egress_test_result_id PRIMARY KEY (id);


--
-- Name: email_record class4_pkey_email_record_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY email_record
    ADD CONSTRAINT class4_pkey_email_record_id PRIMARY KEY (id);


--
-- Name: error_info class4_pkey_error_info_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY error_info
    ADD CONSTRAINT class4_pkey_error_info_id PRIMARY KEY (id);


--
-- Name: event_log class4_pkey_event_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY event_log
    ADD CONSTRAINT class4_pkey_event_log_id PRIMARY KEY (event_log_id);


--
-- Name: exchange_finance class4_pkey_exchange_finance_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_finance
    ADD CONSTRAINT class4_pkey_exchange_finance_id PRIMARY KEY (id);


--
-- Name: global_failover class4_pkey_global_failover_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY global_failover
    ADD CONSTRAINT class4_pkey_global_failover_id PRIMARY KEY (id);


--
-- Name: invoice_calls class4_pkey_invoice_calls_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_calls
    ADD CONSTRAINT class4_pkey_invoice_calls_id PRIMARY KEY (invoice_calls_id);


--
-- Name: invoice_credit_note class4_pkey_invoice_credit_note_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_credit_note
    ADD CONSTRAINT class4_pkey_invoice_credit_note_id PRIMARY KEY (id);


--
-- Name: invoice_daily_cost class4_pkey_invoice_daily_cost_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_daily_cost
    ADD CONSTRAINT class4_pkey_invoice_daily_cost_id PRIMARY KEY (id);


--
-- Name: invoice_did class4_pkey_invoice_did_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_did
    ADD CONSTRAINT class4_pkey_invoice_did_id PRIMARY KEY (id);


--
-- Name: invoice_email class4_pkey_invoice_email_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_email
    ADD CONSTRAINT class4_pkey_invoice_email_id PRIMARY KEY (id);


--
-- Name: invoice class4_pkey_invoice_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT class4_pkey_invoice_id PRIMARY KEY (invoice_id);


--
-- Name: invoice_item class4_pkey_invoice_item_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT class4_pkey_invoice_item_id PRIMARY KEY (id);


--
-- Name: invoice_payment class4_pkey_invoice_payment_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_payment
    ADD CONSTRAINT class4_pkey_invoice_payment_id PRIMARY KEY (id);


--
-- Name: invoice_service_charge class4_pkey_invoice_service_charge_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_service_charge
    ADD CONSTRAINT class4_pkey_invoice_service_charge_id PRIMARY KEY (invoice_service_charge_id);


--
-- Name: jurisdiction_country class4_pkey_jurisdiction_country_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction_country
    ADD CONSTRAINT class4_pkey_jurisdiction_country_id PRIMARY KEY (id);


--
-- Name: jurisdiction class4_pkey_jurisdiction_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction
    ADD CONSTRAINT class4_pkey_jurisdiction_id PRIMARY KEY (id);


--
-- Name: jurisdiction_prefix class4_pkey_jurisdiction_prefix_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction_prefix
    ADD CONSTRAINT class4_pkey_jurisdiction_prefix_id PRIMARY KEY (id);


--
-- Name: lrn class4_pkey_lrn_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lrn
    ADD CONSTRAINT class4_pkey_lrn_id PRIMARY KEY (lrn_id);


--
-- Name: mail_tmplate class4_pkey_mail_tmplate_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY mail_tmplate
    ADD CONSTRAINT class4_pkey_mail_tmplate_id PRIMARY KEY (id);


--
-- Name: online_users class4_pkey_online_users_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY online_users
    ADD CONSTRAINT class4_pkey_online_users_id PRIMARY KEY (online_id);


--
-- Name: order_code class4_pkey_order_code_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_code
    ADD CONSTRAINT class4_pkey_order_code_id PRIMARY KEY (id);


--
-- Name: order_partern class4_pkey_order_partern_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_partern
    ADD CONSTRAINT class4_pkey_order_partern_id PRIMARY KEY (id);


--
-- Name: order_user_alert class4_pkey_order_user_alert_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_user_alert
    ADD CONSTRAINT class4_pkey_order_user_alert_id PRIMARY KEY (id);


--
-- Name: order_user class4_pkey_order_user_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_user
    ADD CONSTRAINT class4_pkey_order_user_id PRIMARY KEY (id);


--
-- Name: order_user_rate_watch class4_pkey_order_user_rate_watch_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_user_rate_watch
    ADD CONSTRAINT class4_pkey_order_user_rate_watch_id PRIMARY KEY (id);


--
-- Name: partition_invoice class4_pkey_partition_invoice_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY partition_invoice
    ADD CONSTRAINT class4_pkey_partition_invoice_id PRIMARY KEY (id);


--
-- Name: payment_term class4_pkey_payment_term_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY payment_term
    ADD CONSTRAINT class4_pkey_payment_term_id PRIMARY KEY (payment_term_id);


--
-- Name: private_invite class4_pkey_private_invite_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY private_invite
    ADD CONSTRAINT class4_pkey_private_invite_id PRIMARY KEY (id);


--
-- Name: product class4_pkey_product_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product
    ADD CONSTRAINT class4_pkey_product_id PRIMARY KEY (product_id);


--
-- Name: product_items class4_pkey_product_items_item_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_items
    ADD CONSTRAINT class4_pkey_product_items_item_id PRIMARY KEY (item_id);


--
-- Name: product_items_resource class4_pkey_product_items_resource_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_items_resource
    ADD CONSTRAINT class4_pkey_product_items_resource_id PRIMARY KEY (id);


--
-- Name: rate_auto_create class4_pkey_rate_auto_create_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_auto_create
    ADD CONSTRAINT class4_pkey_rate_auto_create_id PRIMARY KEY (id);


--
-- Name: rate_auto_create_interval class4_pkey_rate_auto_create_interval_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_auto_create_interval
    ADD CONSTRAINT class4_pkey_rate_auto_create_interval_id PRIMARY KEY (id);


--
-- Name: rate class4_pkey_rate_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate
    ADD CONSTRAINT class4_pkey_rate_id PRIMARY KEY (rate_id);


--
-- Name: rate_table class4_pkey_rate_table_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_table
    ADD CONSTRAINT class4_pkey_rate_table_id PRIMARY KEY (rate_table_id);


--
-- Name: real_cdr class4_pkey_real_cdr_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY real_cdr
    ADD CONSTRAINT class4_pkey_real_cdr_id PRIMARY KEY (real_cdr_id);


--
-- Name: resource_block class4_pkey_resource_block_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_block
    ADD CONSTRAINT class4_pkey_resource_block_id PRIMARY KEY (res_block_id);


--
-- Name: resource_codecs_ref class4_pkey_resource_codecs_ref_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_codecs_ref
    ADD CONSTRAINT class4_pkey_resource_codecs_ref_id PRIMARY KEY (id);


--
-- Name: resource_direction class4_pkey_resource_direction_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_direction
    ADD CONSTRAINT class4_pkey_resource_direction_id PRIMARY KEY (direction_id);


--
-- Name: resource class4_pkey_resource_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT class4_pkey_resource_id PRIMARY KEY (resource_id);


--
-- Name: resource_ip class4_pkey_resource_ip_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_ip
    ADD CONSTRAINT class4_pkey_resource_ip_id PRIMARY KEY (resource_ip_id);


--
-- Name: resource_ip_limit class4_pkey_resource_ip_limit_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_ip_limit
    ADD CONSTRAINT class4_pkey_resource_ip_limit_id PRIMARY KEY (limit_id);


--
-- Name: resource_lrn_action class4_pkey_resource_lrn_action_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_lrn_action
    ADD CONSTRAINT class4_pkey_resource_lrn_action_id PRIMARY KEY (id);


--
-- Name: resource_next_route_rule class4_pkey_resource_next_route_rule_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_next_route_rule
    ADD CONSTRAINT class4_pkey_resource_next_route_rule_id PRIMARY KEY (id);


--
-- Name: resource_prefix class4_pkey_resource_prefix_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_prefix
    ADD CONSTRAINT class4_pkey_resource_prefix_id PRIMARY KEY (id);


--
-- Name: resource_rate class4_pkey_resource_rate_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_rate
    ADD CONSTRAINT class4_pkey_resource_rate_id PRIMARY KEY (id);


--
-- Name: resource_replace_action class4_pkey_resource_replace_action_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_replace_action
    ADD CONSTRAINT class4_pkey_resource_replace_action_id PRIMARY KEY (id);


--
-- Name: resource_translation_ref class4_pkey_resource_translation_ref_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_translation_ref
    ADD CONSTRAINT class4_pkey_resource_translation_ref_id PRIMARY KEY (ref_id);


--
-- Name: role class4_pkey_role_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY role
    ADD CONSTRAINT class4_pkey_role_id PRIMARY KEY (role_id);


--
-- Name: role_privilege class4_pkey_role_privilege_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY role_privilege
    ADD CONSTRAINT class4_pkey_role_privilege_id PRIMARY KEY (role_privilege_id);


--
-- Name: route class4_pkey_route_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY route
    ADD CONSTRAINT class4_pkey_route_id PRIMARY KEY (route_id);


--
-- Name: route_strategy class4_pkey_route_strategy_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY route_strategy
    ADD CONSTRAINT class4_pkey_route_strategy_id PRIMARY KEY (route_strategy_id);


--
-- Name: sell_order class4_pkey_sell_order_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sell_order
    ADD CONSTRAINT class4_pkey_sell_order_id PRIMARY KEY (id);


--
-- Name: sell_order_response class4_pkey_sell_order_response_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sell_order_response
    ADD CONSTRAINT class4_pkey_sell_order_response_id PRIMARY KEY (id);


--
-- Name: server_platform class4_pkey_server_platform_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY server_platform
    ADD CONSTRAINT class4_pkey_server_platform_id PRIMARY KEY (server_id);


--
-- Name: service_charge class4_pkey_service_charge_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY service_charge
    ADD CONSTRAINT class4_pkey_service_charge_id PRIMARY KEY (service_charge_id);


--
-- Name: service_charge_items class4_pkey_service_charge_item_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY service_charge_items
    ADD CONSTRAINT class4_pkey_service_charge_item_id PRIMARY KEY (id);


--
-- Name: sip_error_code class4_pkey_sip_error_code_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sip_error_code
    ADD CONSTRAINT class4_pkey_sip_error_code_id PRIMARY KEY (sip_error_code_id);


--
-- Name: system_function class4_pkey_system_function_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY system_function
    ADD CONSTRAINT class4_pkey_system_function_id PRIMARY KEY (system_function_id);


--
-- Name: system_parameter class4_pkey_system_parameter; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY system_parameter
    ADD CONSTRAINT class4_pkey_system_parameter PRIMARY KEY (sys_id);


--
-- Name: task_manage class4_pkey_task_manage_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY task_manage
    ADD CONSTRAINT class4_pkey_task_manage_id PRIMARY KEY (id);


--
-- Name: test_device class4_pkey_test_device_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY test_device
    ADD CONSTRAINT class4_pkey_test_device_id PRIMARY KEY (test_device_id);


--
-- Name: time_profile class4_pkey_time_profile_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY time_profile
    ADD CONSTRAINT class4_pkey_time_profile_id PRIMARY KEY (time_profile_id);


--
-- Name: transaction_fee class4_pkey_transaction_fee_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY transaction_fee
    ADD CONSTRAINT class4_pkey_transaction_fee_id PRIMARY KEY (id);


--
-- Name: transaction_fee_items class4_pkey_transaction_fee_items_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY transaction_fee_items
    ADD CONSTRAINT class4_pkey_transaction_fee_items_id PRIMARY KEY (id);


--
-- Name: translation_item class4_pkey_translation_item_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY translation_item
    ADD CONSTRAINT class4_pkey_translation_item_id PRIMARY KEY (ref_id);


--
-- Name: users class4_pkey_users_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY users
    ADD CONSTRAINT class4_pkey_users_id PRIMARY KEY (user_id);


--
-- Name: web_session class4_pkey_web_session_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY web_session
    ADD CONSTRAINT class4_pkey_web_session_id PRIMARY KEY (id);


--
-- Name: agent_client_client class4_pr_agent_client_client_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_client_client
    ADD CONSTRAINT class4_pr_agent_client_client_client_id PRIMARY KEY (id);


--
-- Name: agent_client_client class4_pr_agent_client_client_uq_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_client_client
    ADD CONSTRAINT class4_pr_agent_client_client_uq_client_id UNIQUE (client_id);


--
-- Name: exchange_block_log class4_pr_exchange_block_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_block_log
    ADD CONSTRAINT class4_pr_exchange_block_log_id PRIMARY KEY (id);


--
-- Name: route_block class4_pr_route_block_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY route_block
    ADD CONSTRAINT class4_pr_route_block_id PRIMARY KEY (id);


--
-- Name: product_rout_rate_table class4_product_rout_rate_table_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_rout_rate_table
    ADD CONSTRAINT class4_product_rout_rate_table_id PRIMARY KEY (id);


--
-- Name: alert_action class4_uq_alert_action_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_action
    ADD CONSTRAINT class4_uq_alert_action_name UNIQUE (name);


--
-- Name: alert_condition class4_uq_alert_condition_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_condition
    ADD CONSTRAINT class4_uq_alert_condition_name UNIQUE (name);


--
-- Name: alert_rule class4_uq_alert_rule_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_rule
    ADD CONSTRAINT class4_uq_alert_rule_name UNIQUE (name);


--
-- Name: carrier_template class4_uq_carrier_template_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY carrier_template
    ADD CONSTRAINT class4_uq_carrier_template_name UNIQUE (template_name);


--
-- Name: client class4_uq_client_login; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client
    ADD CONSTRAINT class4_uq_client_login UNIQUE (login);


--
-- Name: client class4_uq_client_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client
    ADD CONSTRAINT class4_uq_client_name UNIQUE (name);


--
-- Name: code_country class4_uq_code_country_country; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code_country
    ADD CONSTRAINT class4_uq_code_country_country UNIQUE (country);


--
-- Name: code_deck class4_uq_code_deck_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code_deck
    ADD CONSTRAINT class4_uq_code_deck_client_id UNIQUE (client_id);


--
-- Name: code_deck class4_uq_code_deck_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code_deck
    ADD CONSTRAINT class4_uq_code_deck_name UNIQUE (name);


--
-- Name: codecs class4_uq_codecs_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY codecs
    ADD CONSTRAINT class4_uq_codecs_name UNIQUE (name);


--
-- Name: contract class4_uq_contract_order_number; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY contract
    ADD CONSTRAINT class4_uq_contract_order_number UNIQUE (confirm_order_number);


--
-- Name: currency class4_uq_currency_code; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY currency
    ADD CONSTRAINT class4_uq_currency_code UNIQUE (code);


--
-- Name: dynamic_route class4_uq_dynamic_route_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route
    ADD CONSTRAINT class4_uq_dynamic_route_name UNIQUE (name);


--
-- Name: exchange_finance class4_uq_exchange_finance_number; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_finance
    ADD CONSTRAINT class4_uq_exchange_finance_number UNIQUE (action_number);


--
-- Name: global_failover class4_uq_global_failover; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY global_failover
    ADD CONSTRAINT class4_uq_global_failover UNIQUE (from_sip_code);


--
-- Name: invoice class4_uq_invoice_number; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT class4_uq_invoice_number UNIQUE (invoice_number);


--
-- Name: jurisdiction class4_uq_jurisdiction_alias; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction
    ADD CONSTRAINT class4_uq_jurisdiction_alias UNIQUE (alias);


--
-- Name: jurisdiction class4_uq_jurisdiction_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction
    ADD CONSTRAINT class4_uq_jurisdiction_name UNIQUE (name);


--
-- Name: payment_term class4_uq_payment_term_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY payment_term
    ADD CONSTRAINT class4_uq_payment_term_name UNIQUE (name);


--
-- Name: product_items class4_uq_product_item_pro_pre; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_items
    ADD CONSTRAINT class4_uq_product_item_pro_pre UNIQUE (product_id, digits);


--
-- Name: rate_table class4_uq_rate_table_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_table
    ADD CONSTRAINT class4_uq_rate_table_name UNIQUE (name);


--
-- Name: resource class4_uq_resource_alias; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT class4_uq_resource_alias UNIQUE (alias);


--
-- Name: resource class4_uq_resource_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT class4_uq_resource_name UNIQUE (name);


--
-- Name: resource_rate class4_uq_resource_rate; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_rate
    ADD CONSTRAINT class4_uq_resource_rate UNIQUE (code, ingress_id, egress_id);


--
-- Name: resource_next_route_rule class4_uq_resource_route_rule; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_next_route_rule
    ADD CONSTRAINT class4_uq_resource_route_rule UNIQUE (reponse_code, resource_id);


--
-- Name: role class4_uq_role_role_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY role
    ADD CONSTRAINT class4_uq_role_role_name UNIQUE (role_name);


--
-- Name: route_strategy class4_uq_route_strategy_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY route_strategy
    ADD CONSTRAINT class4_uq_route_strategy_name UNIQUE (name);


--
-- Name: task_manage class4_uq_task_manage_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY task_manage
    ADD CONSTRAINT class4_uq_task_manage_name UNIQUE (name);


--
-- Name: time_profile class4_uq_time_profile_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY time_profile
    ADD CONSTRAINT class4_uq_time_profile_name UNIQUE (name);


--
-- Name: users class4_uq_users_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY users
    ADD CONSTRAINT class4_uq_users_name UNIQUE (name);


--
-- Name: cleanup cleanup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cleanup
    ADD CONSTRAINT cleanup_pkey PRIMARY KEY (id);


--
-- Name: client_balance_operation_action client_balance_operation_action_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_balance_operation_action
    ADD CONSTRAINT client_balance_operation_action_pkey PRIMARY KEY (id);


--
-- Name: client_low_balance_config client_low_balance_config_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_low_balance_config
    ADD CONSTRAINT client_low_balance_config_pkey PRIMARY KEY (client_id);


--
-- Name: client_transaction client_transaction_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_transaction
    ADD CONSTRAINT client_transaction_pkey PRIMARY KEY (id);


--
-- Name: credit_log credit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY credit_log
    ADD CONSTRAINT credit_log_pkey PRIMARY KEY (id);


--
-- Name: current_dashboard_data current_dashboard_data_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY current_dashboard_data
    ADD CONSTRAINT current_dashboard_data_pkey PRIMARY KEY (id);


--
-- Name: daily_cdr_fields daily_cdr_fields_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY daily_cdr_fields
    ADD CONSTRAINT daily_cdr_fields_id PRIMARY KEY (id);


--
-- Name: email_log daily_email_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY email_log
    ADD CONSTRAINT daily_email_log_id PRIMARY KEY (id);


--
-- Name: dashboard_time_option dashboard_time_option_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dashboard_time_option
    ADD CONSTRAINT dashboard_time_option_pkey PRIMARY KEY (id);


--
-- Name: default_fields default_fields_report_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY default_fields
    ADD CONSTRAINT default_fields_report_name_key UNIQUE (report_name);


--
-- Name: dialer_detection dialer_detection_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dialer_detection
    ADD CONSTRAINT dialer_detection_pkey PRIMARY KEY (id);


--
-- Name: did_assign did_assign_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_assign
    ADD CONSTRAINT did_assign_pkey PRIMARY KEY (number);


--
-- Name: did_billing_plan did_billing_plan_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_billing_plan
    ADD CONSTRAINT did_billing_plan_pkey PRIMARY KEY (id);


--
-- Name: did_billing_rel did_billing_rel_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_billing_rel
    ADD CONSTRAINT did_billing_rel_pkey PRIMARY KEY (id);


--
-- Name: did_request_detail did_request_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_request_detail
    ADD CONSTRAINT did_request_detail_pkey PRIMARY KEY (id);


--
-- Name: did_request did_request_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_request
    ADD CONSTRAINT did_request_pkey PRIMARY KEY (id);


--
-- Name: did_special_code did_special_code_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_special_code
    ADD CONSTRAINT did_special_code_pkey PRIMARY KEY (id);


--
-- Name: rate_generate dnl_cloud_pkey_rate_generate_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generate
    ADD CONSTRAINT dnl_cloud_pkey_rate_generate_id PRIMARY KEY (id);


--
-- Name: egress_profile egress_profile_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY egress_profile
    ADD CONSTRAINT egress_profile_pkey PRIMARY KEY (id);


--
-- Name: mail_sender emails_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY mail_sender
    ADD CONSTRAINT emails_pkey PRIMARY KEY (id);


--
-- Name: error_log error_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY error_log
    ADD CONSTRAINT error_log_pkey PRIMARY KEY (id);


--
-- Name: exchange_sys_module exchange sys module_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_module
    ADD CONSTRAINT "exchange sys module_id" PRIMARY KEY (id);


--
-- Name: exchange_agent_email_type exchange_agent_email_type_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_email_type
    ADD CONSTRAINT exchange_agent_email_type_id PRIMARY KEY (id);


--
-- Name: exchange_agent_exchange_push_list_result exchange_agent_exchange_push_list_result_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_exchange_push_list_result
    ADD CONSTRAINT exchange_agent_exchange_push_list_result_id PRIMARY KEY (id);


--
-- Name: exchange_agent_import_target_push exchange_agent_import_target_push_id_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_import_target_push
    ADD CONSTRAINT exchange_agent_import_target_push_id_pkey PRIMARY KEY (id);


--
-- Name: exchange_agent_mail_tmplate exchange_agent_mail_tmplate_id_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_mail_tmplate
    ADD CONSTRAINT exchange_agent_mail_tmplate_id_pkey PRIMARY KEY (id);


--
-- Name: exchange_agent_product_no_route exchange_agent_product_no_route_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_product_no_route
    ADD CONSTRAINT exchange_agent_product_no_route_id PRIMARY KEY (id);


--
-- Name: exchange_agent_send_mail_log exchange_agent_send_mail_log_id_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_send_mail_log
    ADD CONSTRAINT exchange_agent_send_mail_log_id_pkey PRIMARY KEY (id);


--
-- Name: exchange_client_user_list exchange_client_user_list_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_client_user_list
    ADD CONSTRAINT exchange_client_user_list_id PRIMARY KEY (id);


--
-- Name: exchange_finance_agent_clients exchange_finance_agent_clients_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_finance_agent_clients
    ADD CONSTRAINT exchange_finance_agent_clients_id PRIMARY KEY (id);


--
-- Name: exchange_finance_agent exchange_finance_agent_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_finance_agent
    ADD CONSTRAINT exchange_finance_agent_id PRIMARY KEY (id);


--
-- Name: exchange_job exchange_job_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job
    ADD CONSTRAINT exchange_job_id PRIMARY KEY (id);


--
-- Name: exchange_job_session_block_log exchange_job_session_block_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session_block_log
    ADD CONSTRAINT exchange_job_session_block_log_id PRIMARY KEY (id);


--
-- Name: exchange_job_session exchange_job_session_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session
    ADD CONSTRAINT exchange_job_session_id PRIMARY KEY (id);


--
-- Name: exchange_job_session_list exchange_job_session_list_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session_list
    ADD CONSTRAINT exchange_job_session_list_id PRIMARY KEY (id);


--
-- Name: exchange_my_route_download_log exchange_my_route_download_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_my_route_download_log
    ADD CONSTRAINT exchange_my_route_download_log_id PRIMARY KEY (id);


--
-- Name: exchange_opp_email exchange_opp_email_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_opp_email
    ADD CONSTRAINT exchange_opp_email_id PRIMARY KEY (id);


--
-- Name: exchange_par_account exchange_par_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_account
    ADD CONSTRAINT exchange_par_id PRIMARY KEY (id);


--
-- Name: exchange_par_plan_record exchange_par_plan_record_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_plan_record
    ADD CONSTRAINT exchange_par_plan_record_id PRIMARY KEY (id);


--
-- Name: exchange_par_system_parm exchange_par_system_parm_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_system_parm
    ADD CONSTRAINT exchange_par_system_parm_id PRIMARY KEY (id);


--
-- Name: exchange_product_copy_route_log exchange_product_copy_route_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_product_copy_route_log
    ADD CONSTRAINT exchange_product_copy_route_log_id PRIMARY KEY (id);


--
-- Name: exchange_product_user_list exchange_product_user_list_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_product_user_list
    ADD CONSTRAINT exchange_product_user_list_id PRIMARY KEY (id);


--
-- Name: exchange_reg_country exchange_reg_country_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_reg_country
    ADD CONSTRAINT exchange_reg_country_id PRIMARY KEY (id);


--
-- Name: exchange_resource_private exchange_resource_private_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_resource_private
    ADD CONSTRAINT exchange_resource_private_id PRIMARY KEY (id);


--
-- Name: exchange_simple_session exchange_simple_session_id_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_simple_session
    ADD CONSTRAINT exchange_simple_session_id_pkey PRIMARY KEY (id);


--
-- Name: exchange_simple_session_list exchange_simple_session_list_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_simple_session_list
    ADD CONSTRAINT exchange_simple_session_list_pkey PRIMARY KEY (id);


--
-- Name: exchange_sys_pri exchange_sys_pri_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_pri
    ADD CONSTRAINT exchange_sys_pri_id PRIMARY KEY (id);


--
-- Name: exchange_sys_pri exchange_sys_pri_pri_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_pri
    ADD CONSTRAINT exchange_sys_pri_pri_name_key UNIQUE (pri_name);


--
-- Name: exchange_sys_role exchange_sys_role_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_role
    ADD CONSTRAINT exchange_sys_role_pkey PRIMARY KEY (role_id);


--
-- Name: exchange_sys_role_pri exchange_sys_role_pri_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_role_pri
    ADD CONSTRAINT exchange_sys_role_pri_pkey PRIMARY KEY (id);


--
-- Name: execution_log execution_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY execution_log
    ADD CONSTRAINT execution_log_pkey PRIMARY KEY (id);


--
-- Name: export_task_log export_task_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY export_task_log
    ADD CONSTRAINT export_task_log_pkey PRIMARY KEY (id);


--
-- Name: fraud_detection_log_detail fraud_detection_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fraud_detection_log_detail
    ADD CONSTRAINT fraud_detection_log_detail_pkey PRIMARY KEY (id);


--
-- Name: fraud_detection_log fraud_detection_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fraud_detection_log
    ADD CONSTRAINT fraud_detection_log_pkey PRIMARY KEY (id);


--
-- Name: fraud_detection fraud_detection_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fraud_detection
    ADD CONSTRAINT fraud_detection_pkey PRIMARY KEY (id);


--
-- Name: fraud_detection fraud_detection_rule_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fraud_detection
    ADD CONSTRAINT fraud_detection_rule_name_key UNIQUE (rule_name);


--
-- Name: ftp_cdr_log_detail ftp_cdr_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ftp_cdr_log_detail
    ADD CONSTRAINT ftp_cdr_log_detail_pkey PRIMARY KEY (id);


--
-- Name: ftp_conf ftp_conf_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ftp_conf
    ADD CONSTRAINT ftp_conf_id PRIMARY KEY (id);


--
-- Name: ftp_server_log ftp_server_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ftp_server_log
    ADD CONSTRAINT ftp_server_log_pkey PRIMARY KEY (id);


--
-- Name: global_route_error global_route_error_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY global_route_error
    ADD CONSTRAINT global_route_error_pkey PRIMARY KEY (id);


--
-- Name: hang_calls_history hang_calls_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY hang_calls_history
    ADD CONSTRAINT hang_calls_history_pkey PRIMARY KEY (id);


--
-- Name: hung_calls_detection_configuration hung_calls_detection_configuration_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY hung_calls_detection_configuration
    ADD CONSTRAINT hung_calls_detection_configuration_pkey PRIMARY KEY (id);


--
-- Name: hung_calls_report_delete_log hung_calls_report_delete_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY hung_calls_report_delete_log
    ADD CONSTRAINT hung_calls_report_delete_log_pkey PRIMARY KEY (id);


--
-- Name: task_schedule id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY task_schedule
    ADD CONSTRAINT id PRIMARY KEY (id);


--
-- Name: import_rate_status import_rate_status_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY import_rate_status
    ADD CONSTRAINT import_rate_status_id PRIMARY KEY (id);


--
-- Name: import_target_log import_target_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY import_target_log
    ADD CONSTRAINT import_target_log_id PRIMARY KEY (id);


--
-- Name: ingress_did_repository ingress_did_repository_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ingress_did_repository
    ADD CONSTRAINT ingress_did_repository_pkey PRIMARY KEY (number);


--
-- Name: invalid_detection_block_log invalid_detection_block_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_detection_block_log
    ADD CONSTRAINT invalid_detection_block_log_pkey PRIMARY KEY (id);


--
-- Name: invalid_number_detection invalid_number_detection_id_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_number_detection
    ADD CONSTRAINT invalid_number_detection_id_pkey PRIMARY KEY (id);


--
-- Name: invalid_number_detection_log_detail invalid_number_detection_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_number_detection_log_detail
    ADD CONSTRAINT invalid_number_detection_log_detail_pkey PRIMARY KEY (id);


--
-- Name: invalid_number_detection_log invalid_number_detection_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_number_detection_log
    ADD CONSTRAINT invalid_number_detection_log_pkey PRIMARY KEY (id);


--
-- Name: invoice_cdr_log invoice_cdr_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_cdr_log
    ADD CONSTRAINT invoice_cdr_log_pkey PRIMARY KEY (id);


--
-- Name: invoice_history invoice_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_history
    ADD CONSTRAINT invoice_history_pkey PRIMARY KEY (id);


--
-- Name: ip_modif_log ip_modif_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ip_modif_log
    ADD CONSTRAINT ip_modif_log_pkey PRIMARY KEY (id);


--
-- Name: jurisdiction_update_history jurisdiction_update_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction_update_history
    ADD CONSTRAINT jurisdiction_update_history_pkey PRIMARY KEY (id);


--
-- Name: jurisdiction_update_log jurisdiction_update_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction_update_log
    ADD CONSTRAINT jurisdiction_update_log_pkey PRIMARY KEY (id);


--
-- Name: kill_pg_sql_log kill_pg_sql_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY kill_pg_sql_log
    ADD CONSTRAINT kill_pg_sql_log_pkey PRIMARY KEY (id);


--
-- Name: lcr_record lcr_record_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lcr_record
    ADD CONSTRAINT lcr_record_pkey PRIMARY KEY (id);


--
-- Name: lcr_reports lcr_reports_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lcr_reports
    ADD CONSTRAINT lcr_reports_pkey PRIMARY KEY (id);


--
-- Name: license_modification_log license_modification_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY license_modification_log
    ADD CONSTRAINT license_modification_log_pkey PRIMARY KEY (id);


--
-- Name: lnp_request_detail lnp_request_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lnp_request_detail
    ADD CONSTRAINT lnp_request_detail_pkey PRIMARY KEY (id);


--
-- Name: lnp_request lnp_request_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lnp_request
    ADD CONSTRAINT lnp_request_pkey PRIMARY KEY (id);


--
-- Name: loop_detection_detail loop_detection_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY loop_detection_detail
    ADD CONSTRAINT loop_detection_detail_pkey PRIMARY KEY (id);


--
-- Name: loop_detection loop_detection_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY loop_detection
    ADD CONSTRAINT loop_detection_pkey PRIMARY KEY (id);


--
-- Name: lrn_servers lrn_servers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lrn_servers
    ADD CONSTRAINT lrn_servers_pkey PRIMARY KEY (id);


--
-- Name: mail_cdr_log_detail mail_cdr_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY mail_cdr_log_detail
    ADD CONSTRAINT mail_cdr_log_detail_pkey PRIMARY KEY (id);


--
-- Name: mail_cdr_log mail_cdr_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY mail_cdr_log
    ADD CONSTRAINT mail_cdr_log_id PRIMARY KEY (id);


--
-- Name: modif_log modif_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY modif_log
    ADD CONSTRAINT modif_log_id PRIMARY KEY (id);


--
-- Name: ocn_lata ocn_lata_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ocn_lata
    ADD CONSTRAINT ocn_lata_pkey PRIMARY KEY (id);


--
-- Name: opentact_balance opentact_balance_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY opentact_balance
    ADD CONSTRAINT opentact_balance_pkey PRIMARY KEY (id);


--
-- Name: orig_invoice orig_invoice_pkey; Type: CONSTRAINT; Schema: public; Owner: class4_user
--

ALTER TABLE ONLY orig_invoice
    ADD CONSTRAINT orig_invoice_pkey PRIMARY KEY (invoice_id);


--
-- Name: orig_log orig_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY orig_log
    ADD CONSTRAINT orig_log_pkey PRIMARY KEY (log_id);


--
-- Name: par_user par_user_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY par_user
    ADD CONSTRAINT par_user_id PRIMARY KEY (id);


--
-- Name: payline_history payline_history_invoice_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY payline_history
    ADD CONSTRAINT payline_history_invoice_id_key UNIQUE (invoice_id);


--
-- Name: payline_history payline_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY payline_history
    ADD CONSTRAINT payline_history_pkey PRIMARY KEY (id);


--
-- Name: payment_invoice payment_invoice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY payment_invoice
    ADD CONSTRAINT payment_invoice_pkey PRIMARY KEY (id);


--
-- Name: partner pri_partner_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY partner
    ADD CONSTRAINT pri_partner_id PRIMARY KEY (id);


--
-- Name: pex_offers pri_pex_offers_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY pex_offers
    ADD CONSTRAINT pri_pex_offers_id PRIMARY KEY (id);


--
-- Name: product_agents_ref product_agents_ref_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_agents_ref
    ADD CONSTRAINT product_agents_ref_pkey PRIMARY KEY (id);


--
-- Name: product_clients_ref product_clients_ref_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_clients_ref
    ADD CONSTRAINT product_clients_ref_pkey PRIMARY KEY (id);


--
-- Name: product_route_rate_table product_route_rate_table_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_route_rate_table
    ADD CONSTRAINT product_route_rate_table_pkey PRIMARY KEY (id);


--
-- Name: quick_cdr quick_cdr_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY quick_cdr
    ADD CONSTRAINT quick_cdr_pkey PRIMARY KEY (id);


--
-- Name: random_ani_populated_log random_ani_populated_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY random_ani_populated_log
    ADD CONSTRAINT random_ani_populated_log_pkey PRIMARY KEY (id);


--
-- Name: rate_download_log rate_download_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_download_log
    ADD CONSTRAINT rate_download_log_pkey PRIMARY KEY (id);


--
-- Name: rate_email_template rate_email_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_email_template
    ADD CONSTRAINT rate_email_template_pkey PRIMARY KEY (id);


--
-- Name: rate_generation_history_detail rate_generation_history_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_history_detail
    ADD CONSTRAINT rate_generation_history_detail_pkey PRIMARY KEY (id);


--
-- Name: rate_generation_history rate_generation_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_history
    ADD CONSTRAINT rate_generation_history_pkey PRIMARY KEY (id);


--
-- Name: rate_generation_rate rate_generation_rate_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_rate
    ADD CONSTRAINT rate_generation_rate_pkey PRIMARY KEY (generation_rate_id);


--
-- Name: rate_generation_template_detail rate_generation_template_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_template_detail
    ADD CONSTRAINT rate_generation_template_detail_pkey PRIMARY KEY (id);


--
-- Name: rate_generation_template_margin rate_generation_template_margin_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_template_margin
    ADD CONSTRAINT rate_generation_template_margin_pkey PRIMARY KEY (id);


--
-- Name: rate_generation_template rate_generation_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_template
    ADD CONSTRAINT rate_generation_template_pkey PRIMARY KEY (id);


--
-- Name: rate_handler rate_handler_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_handler
    ADD CONSTRAINT rate_handler_pkey PRIMARY KEY (id);


--
-- Name: rate_import_error_log rate_import_error_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_import_error_log
    ADD CONSTRAINT rate_import_error_log_pkey PRIMARY KEY (id);


--
-- Name: rate_mail_decks_files rate_mail_decks_files_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_mail_decks_files
    ADD CONSTRAINT rate_mail_decks_files_pkey PRIMARY KEY (id);


--
-- Name: rate_mail_decks rate_mail_decks_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_mail_decks
    ADD CONSTRAINT rate_mail_decks_pkey PRIMARY KEY (id);


--
-- Name: rate_mail rate_mail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_mail
    ADD CONSTRAINT rate_mail_pkey PRIMARY KEY (id);


--
-- Name: rate_management_option rate_management_option_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_management_option
    ADD CONSTRAINT rate_management_option_pkey PRIMARY KEY (id);


--
-- Name: rate_mass_edit_log rate_mass_edit_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_mass_edit_log
    ADD CONSTRAINT rate_mass_edit_log_id PRIMARY KEY (id);


--
-- Name: rate_send_log_detail rate_send_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_send_log_detail
    ADD CONSTRAINT rate_send_log_detail_pkey PRIMARY KEY (id);


--
-- Name: rate_send_log rate_send_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_send_log
    ADD CONSTRAINT rate_send_log_pkey PRIMARY KEY (id);


--
-- Name: rate_send_logging rate_send_logging_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_send_logging
    ADD CONSTRAINT rate_send_logging_id PRIMARY KEY (id);


--
-- Name: rate_send_rules rate_send_rules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_send_rules
    ADD CONSTRAINT rate_send_rules_pkey PRIMARY KEY (id);


--
-- Name: rate_upload_fail_log rate_upload_fail_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_upload_fail_log
    ADD CONSTRAINT rate_upload_fail_log_pkey PRIMARY KEY (id);


--
-- Name: rate_upload_queue rate_upload_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_upload_queue
    ADD CONSTRAINT rate_upload_queue_pkey PRIMARY KEY (id);


--
-- Name: rate_upload_success_log rate_upload_success_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_upload_success_log
    ADD CONSTRAINT rate_upload_success_log_pkey PRIMARY KEY (id);


--
-- Name: rate_upload_task rate_upload_task_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_upload_task
    ADD CONSTRAINT rate_upload_task_pkey PRIMARY KEY (id);


--
-- Name: rate_upload_template rate_upload_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_upload_template
    ADD CONSTRAINT rate_upload_template_pkey PRIMARY KEY (id);


--
-- Name: ratemail_history ratemail_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ratemail_history
    ADD CONSTRAINT ratemail_history_pkey PRIMARY KEY (id);


--
-- Name: report_delivery_history report_delivery_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY report_delivery_history
    ADD CONSTRAINT report_delivery_history_pkey PRIMARY KEY (id);


--
-- Name: rerate_cdr_download_log rerate_cdr_download_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rerate_cdr_download_log
    ADD CONSTRAINT rerate_cdr_download_log_pkey PRIMARY KEY (id);


--
-- Name: rerate_cdr_task rerate_cdr_task_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rerate_cdr_task
    ADD CONSTRAINT rerate_cdr_task_pkey PRIMARY KEY (id);


--
-- Name: rerate_log rerate_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rerate_log
    ADD CONSTRAINT rerate_log_pkey PRIMARY KEY (rerate_log_id);


--
-- Name: rerate_report_exec_log rerate_report_exec_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rerate_report_exec_log
    ADD CONSTRAINT rerate_report_exec_log_pkey PRIMARY KEY (id);


--
-- Name: reseller_client reseller_client_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY reseller_client
    ADD CONSTRAINT reseller_client_pkey PRIMARY KEY (id);


--
-- Name: reseller reseller_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY reseller
    ADD CONSTRAINT reseller_pkey PRIMARY KEY (id);


--
-- Name: resource_block_group resource_block_group_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_block_group
    ADD CONSTRAINT resource_block_group_pkey PRIMARY KEY (id);


--
-- Name: resource_direction_template resource_direction_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_direction_template
    ADD CONSTRAINT resource_direction_template_pkey PRIMARY KEY (direction_id);


--
-- Name: resource_next_route_rule_template resource_next_route_rule_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_next_route_rule_template
    ADD CONSTRAINT resource_next_route_rule_template_pkey PRIMARY KEY (id);


--
-- Name: resource_replace_action_template resource_replace_action_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_replace_action_template
    ADD CONSTRAINT resource_replace_action_template_pkey PRIMARY KEY (id);


--
-- Name: resource_template resource_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_template
    ADD CONSTRAINT resource_template_pkey PRIMARY KEY (resource_template_id);


--
-- Name: retrieve_password_log retrieve_password_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY retrieve_password_log
    ADD CONSTRAINT retrieve_password_log_pkey PRIMARY KEY (id);


--
-- Name: routing_wizard_list routing_wizard_list_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY routing_wizard_list
    ADD CONSTRAINT routing_wizard_list_pkey PRIMARY KEY (id);


--
-- Name: scheduled_report_log scheduled_report_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY scheduled_report_log
    ADD CONSTRAINT scheduled_report_log_pkey PRIMARY KEY (id);


--
-- Name: scheduled_report scheduled_report_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY scheduled_report
    ADD CONSTRAINT scheduled_report_pkey PRIMARY KEY (id);


--
-- Name: scheduler_log scheduler_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY scheduler_log
    ADD CONSTRAINT scheduler_log_pkey PRIMARY KEY (id);


--
-- Name: send_mails send_mails_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY send_mails
    ADD CONSTRAINT send_mails_pkey PRIMARY KEY (id);


--
-- Name: send_rate_preserved_data send_rate_preserved_data_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY send_rate_preserved_data
    ADD CONSTRAINT send_rate_preserved_data_pkey PRIMARY KEY (id);


--
-- Name: send_rate_template send_rate_template_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY send_rate_template
    ADD CONSTRAINT send_rate_template_id PRIMARY KEY (id);


--
-- Name: scheduler shceduler_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY scheduler
    ADD CONSTRAINT shceduler_pkey PRIMARY KEY (id);


--
-- Name: signup_ip signup_ip_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY signup_ip
    ADD CONSTRAINT signup_ip_pkey PRIMARY KEY (id);


--
-- Name: signup signup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY signup
    ADD CONSTRAINT signup_pkey PRIMARY KEY (id);


--
-- Name: sip_registrations sip_registrations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sip_registrations
    ADD CONSTRAINT sip_registrations_pkey PRIMARY KEY (id);


--
-- Name: sip_requests sip_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sip_requests
    ADD CONSTRAINT sip_requests_pkey PRIMARY KEY (id);


--
-- Name: spam_traffic_ip_record spam_traffic_ip_record_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY spam_traffic_ip_record
    ADD CONSTRAINT spam_traffic_ip_record_pkey PRIMARY KEY (record_id);


--
-- Name: switch_profile switch_profile_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY switch_profile
    ADD CONSTRAINT switch_profile_pkey PRIMARY KEY (id);


--
-- Name: sys_module sys_module_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sys_module
    ADD CONSTRAINT sys_module_pkey PRIMARY KEY (id);


--
-- Name: sys_pri sys_pri_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sys_pri
    ADD CONSTRAINT sys_pri_id PRIMARY KEY (id);


--
-- Name: sys_pri sys_pri_pri_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sys_pri
    ADD CONSTRAINT sys_pri_pri_name_key UNIQUE (pri_name);


--
-- Name: sys_role sys_role_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sys_role
    ADD CONSTRAINT sys_role_pkey PRIMARY KEY (role_id);


--
-- Name: traffic_alert traffic_alert_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY traffic_alert
    ADD CONSTRAINT traffic_alert_pkey PRIMARY KEY (id);


--
-- Name: trouble_tickets_template trouble_tickets_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY trouble_tickets_template
    ADD CONSTRAINT trouble_tickets_template_pkey PRIMARY KEY (id);


--
-- Name: trunk_group trunk_group_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY trunk_group
    ADD CONSTRAINT trunk_group_pkey PRIMARY KEY (group_id);


--
-- Name: trunk_pstn_header trunk_pstn_header_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY trunk_pstn_header
    ADD CONSTRAINT trunk_pstn_header_pkey PRIMARY KEY (id);


--
-- Name: dex unique_dex_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dex
    ADD CONSTRAINT unique_dex_name UNIQUE (dex_name);


--
-- Name: dex_resource_unactive unique_dex_resource_dein_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dex_resource_unactive
    ADD CONSTRAINT unique_dex_resource_dein_id UNIQUE (dex_id, dex_resource, ingress_id);


--
-- Name: dex_resource unique_dex_resource_id_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dex_resource
    ADD CONSTRAINT unique_dex_resource_id_id UNIQUE (dex_id, resource_id);


--
-- Name: order_partern unique_order_partern_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_partern
    ADD CONSTRAINT unique_order_partern_id UNIQUE (order_id, order_type, partern_id);


--
-- Name: partner unique_partner_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY partner
    ADD CONSTRAINT unique_partner_client_id UNIQUE (client_id, partner_id);


--
-- Name: product_items_resource unique_product_items_id_resource_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_items_resource
    ADD CONSTRAINT unique_product_items_id_resource_id UNIQUE (item_id, resource_id);


--
-- Name: vendortest_project unique_project_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendortest_project
    ADD CONSTRAINT unique_project_name UNIQUE (project_name);


--
-- Name: transaction unique_transaction_client_id_date; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY transaction
    ADD CONSTRAINT unique_transaction_client_id_date UNIQUE (client_id, date);


--
-- Name: CONSTRAINT unique_transaction_client_id_date ON transaction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON CONSTRAINT unique_transaction_client_id_date ON transaction IS 'client_idå’Œdateè”åˆå”¯ä¸€';


--
-- Name: vendortest_code unique_vendortest_code_code_proid; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendortest_code
    ADD CONSTRAINT unique_vendortest_code_code_proid UNIQUE (vendortest_project_id, code_name);


--
-- Name: upload_ani_log upload_ani_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY upload_ani_log
    ADD CONSTRAINT upload_ani_log_pkey PRIMARY KEY (id);


--
-- Name: us_export_log us_export_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY us_export_log
    ADD CONSTRAINT us_export_log_pkey PRIMARY KEY (id);


--
-- Name: us_ocn_lata us_ocn_lata_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY us_ocn_lata
    ADD CONSTRAINT us_ocn_lata_pkey PRIMARY KEY (id);


--
-- Name: usage_report_delivery usage_report_delivery_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY usage_report_delivery
    ADD CONSTRAINT usage_report_delivery_pkey PRIMARY KEY (id);


--
-- Name: users_limit users_limit_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY users_limit
    ADD CONSTRAINT users_limit_pkey PRIMARY KEY (id);


--
-- Name: vendor_invoice_detail vendor_invoice_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendor_invoice_detail
    ADD CONSTRAINT vendor_invoice_detail_pkey PRIMARY KEY (id);


--
-- Name: vendor_invoice_dispute vendor_invoice_dispute_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendor_invoice_dispute
    ADD CONSTRAINT vendor_invoice_dispute_pkey PRIMARY KEY (id);


--
-- Name: vendor_invoice vendor_invoice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendor_invoice
    ADD CONSTRAINT vendor_invoice_pkey PRIMARY KEY (vendor_invoice_id);


--
-- Name: vendortest_code vendortest_code_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendortest_code
    ADD CONSTRAINT vendortest_code_pkey PRIMARY KEY (id);


--
-- Name: vendortest_number vendortest_number_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendortest_number
    ADD CONSTRAINT vendortest_number_pkey PRIMARY KEY (id);


--
-- Name: vendortest_project vendortest_project_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendortest_project
    ADD CONSTRAINT vendortest_project_pkey PRIMARY KEY (id);


--
-- Name: version_information version_information_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY version_information
    ADD CONSTRAINT version_information_pkey PRIMARY KEY (id);


--
-- Name: voip_gateway voip_gateway_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY voip_gateway
    ADD CONSTRAINT voip_gateway_pkey PRIMARY KEY (id);


SET search_path = pgagent, pg_catalog;

--
-- Name: pga_exception_datetime; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE UNIQUE INDEX pga_exception_datetime ON pga_exception USING btree (jexdate, jextime);


--
-- Name: pga_exception_jexscid; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE INDEX pga_exception_jexscid ON pga_exception USING btree (jexscid);


--
-- Name: pga_jobclass_name; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE UNIQUE INDEX pga_jobclass_name ON pga_jobclass USING btree (jclname);


--
-- Name: pga_joblog_jobid; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE INDEX pga_joblog_jobid ON pga_joblog USING btree (jlgjobid);


--
-- Name: pga_jobschedule_jobid; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE INDEX pga_jobschedule_jobid ON pga_schedule USING btree (jscjobid);


--
-- Name: pga_jobstep_jobid; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE INDEX pga_jobstep_jobid ON pga_jobstep USING btree (jstjobid);


--
-- Name: pga_jobsteplog_jslid; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE INDEX pga_jobsteplog_jslid ON pga_jobsteplog USING btree (jsljlgid);


SET search_path = public, pg_catalog;

--
-- Name: alert_rules_log_detail_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX alert_rules_log_detail_time_idx ON alert_rules_log_detail USING btree ("time");


--
-- Name: alert_rules_log_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX alert_rules_log_time_idx ON alert_rules_log USING btree ("time");


--
-- Name: bad_number_detection_rules_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX bad_number_detection_rules_index ON bad_number_detection_rules USING btree (id);


--
-- Name: balance_log_client_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX balance_log_client_id_idx ON balance_log USING btree (client_id);


--
-- Name: balance_log_date_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX balance_log_date_idx ON balance_log USING btree (date);


--
-- Name: c4_agent_client_client_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_agent_client_client_record_id_idx ON agent_client_client_record USING btree (record_id);


--
-- Name: c4_allowed_sendto_ip_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_allowed_sendto_ip_record_id_idx ON allowed_sendto_ip_record USING btree (record_id);


--
-- Name: c4_balance_daily_reset_status_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_balance_daily_reset_status_idx ON balance_daily_reset_task USING btree (status);


--
-- Name: c4_balance_history_actual_date_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_balance_history_actual_date_idx ON balance_history_actual USING btree (date);


--
-- Name: c4_balance_history_date_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_balance_history_date_idx ON balance_history USING btree (date);


--
-- Name: c4_c4_lrn_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_c4_lrn_record_id_idx ON c4_lrn_record USING btree (record_id);


--
-- Name: c4_client_balance_create_client_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_client_balance_create_client_id_idx ON c4_client_balance USING btree (client_id);


--
-- Name: c4_client_balance_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_client_balance_record_id_idx ON c4_client_balance_record USING btree (record_id);


--
-- Name: c4_client_payment_payment_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_client_payment_payment_time_idx ON client_payment USING btree (payment_time);


--
-- Name: c4_client_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_client_record_id_idx ON client_record USING btree (record_id);


--
-- Name: c4_code_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_code_record_id_idx ON code_record USING btree (record_id);


--
-- Name: c4_currency_updates_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_currency_updates_record_id_idx ON currency_updates_record USING btree (record_id);


--
-- Name: c4_dynamic_route_items_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_dynamic_route_items_record_id_idx ON dynamic_route_items_record USING btree (record_id);


--
-- Name: c4_dynamic_route_override_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_dynamic_route_override_record_id_idx ON dynamic_route_override_record USING btree (record_id);


--
-- Name: c4_dynamic_route_pri_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_dynamic_route_pri_record_id_idx ON dynamic_route_pri_record USING btree (record_id);


--
-- Name: c4_dynamic_route_qos_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_dynamic_route_qos_record_id_idx ON dynamic_route_qos_record USING btree (record_id);


--
-- Name: c4_dynamic_route_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_dynamic_route_record_id_idx ON dynamic_route_record USING btree (record_id);


--
-- Name: c4_egress_profile_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_egress_profile_record_id_idx ON egress_profile_record USING btree (record_id);


--
-- Name: c4_exchange_finance_complete_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_exchange_finance_complete_time_idx ON exchange_finance USING btree (complete_time);


--
-- Name: c4_exchange_par_account_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_exchange_par_account_record_id_idx ON exchange_par_account_record USING btree (record_id);


--
-- Name: c4_global_route_error_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_global_route_error_record_id_idx ON global_route_error_record USING btree (record_id);


--
-- Name: c4_jurisdiction_prefix_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_jurisdiction_prefix_record_id_idx ON jurisdiction_prefix_record USING btree (record_id);


--
-- Name: c4_livecall_user_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_livecall_user_name_idx ON c4_livecall_user USING btree (name);


--
-- Name: c4_origination_global_failover_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_origination_global_failover_record_id_idx ON origination_global_failover_record USING btree (record_id);


--
-- Name: c4_partition_gateway_ref_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_partition_gateway_ref_record_id_idx ON partition_gateway_ref_record USING btree (record_id);


--
-- Name: c4_payment_term_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_payment_term_record_id_idx ON payment_term_record USING btree (record_id);


--
-- Name: c4_product_items_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_product_items_record_id_idx ON product_items_record USING btree (record_id);


--
-- Name: c4_product_items_resource_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_product_items_resource_record_id_idx ON product_items_resource_record USING btree (record_id);


--
-- Name: c4_product_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_product_record_id_idx ON product_record USING btree (record_id);


--
-- Name: c4_product_rout_rate_table_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_product_rout_rate_table_record_id_idx ON product_rout_rate_table_record USING btree (record_id);


--
-- Name: c4_random_ani_generation_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_random_ani_generation_record_id_idx ON random_ani_generation_record USING btree (record_id);


--
-- Name: c4_rate_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_rate_record_id_idx ON rate_record USING btree (record_id);


--
-- Name: c4_rate_table_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_rate_table_record_id_idx ON rate_table_record USING btree (record_id);


--
-- Name: c4_resource_block_items_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_block_items_record_id_idx ON resource_block_items_record USING btree (record_id);


--
-- Name: c4_resource_block_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_block_record_id_idx ON resource_block_record USING btree (record_id);


--
-- Name: c4_resource_capacity_egress_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_capacity_egress_id_idx ON resource_capacity USING btree (egress_id);


--
-- Name: c4_resource_capacity_ingress_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_capacity_ingress_id_idx ON resource_capacity USING btree (ingress_id);


--
-- Name: c4_resource_capacity_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_capacity_record_id_idx ON resource_capacity_record USING btree (record_id);


--
-- Name: c4_resource_codecs_ref_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_codecs_ref_record_id_idx ON resource_codecs_ref_record USING btree (record_id);


--
-- Name: c4_resource_direction_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_direction_record_id_idx ON resource_direction_record USING btree (record_id);


--
-- Name: c4_resource_ip_limit_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_ip_limit_record_id_idx ON resource_ip_limit_record USING btree (record_id);


--
-- Name: c4_resource_ip_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_ip_record_id_idx ON resource_ip_record USING btree (record_id);


--
-- Name: c4_resource_lrn_action_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_lrn_action_record_id_idx ON resource_lrn_action_record USING btree (record_id);


--
-- Name: c4_resource_next_route_rule_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_next_route_rule_record_id_idx ON resource_next_route_rule_record USING btree (record_id);


--
-- Name: c4_resource_prefix_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_prefix_record_id_idx ON resource_prefix_record USING btree (record_id);


--
-- Name: c4_resource_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_record_id_idx ON resource_record USING btree (record_id);


--
-- Name: c4_resource_replace_action_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_replace_action_record_id_idx ON resource_replace_action_record USING btree (record_id);


--
-- Name: c4_resource_translation_ref_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_translation_ref_record_id_idx ON resource_translation_ref_record USING btree (record_id);


--
-- Name: c4_route_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_route_record_id_idx ON route_record USING btree (record_id);


--
-- Name: c4_service_charge_items_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_service_charge_items_record_id_idx ON service_charge_items_record USING btree (record_id);


--
-- Name: c4_sip_error_code_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_sip_error_code_record_id_idx ON sip_error_code_record USING btree (record_id);


--
-- Name: c4_sip_registrations_username_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_sip_registrations_username_idx ON sip_registrations USING btree (username);


--
-- Name: c4_spam_traffic_ip_idx_new; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_spam_traffic_ip_idx_new ON spam_traffic_ip USING btree (ip);


--
-- Name: c4_switch_profile_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_switch_profile_record_id_idx ON switch_profile_record USING btree (record_id);


--
-- Name: c4_system_configure_create_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_system_configure_create_time_idx ON system_configure USING btree (create_time);


--
-- Name: c4_system_configure_switch_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_system_configure_switch_name_idx ON system_configure USING btree (switch_name);


--
-- Name: c4_termination_global_failover_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_termination_global_failover_record_id_idx ON termination_global_failover_record USING btree (record_id);


--
-- Name: c4_time_profile_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_time_profile_record_id_idx ON time_profile_record USING btree (record_id);


--
-- Name: c4_transaction_fee_items_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_transaction_fee_items_record_id_idx ON transaction_fee_items_record USING btree (record_id);


--
-- Name: c4_translation_item_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_translation_item_record_id_idx ON translation_item_record USING btree (record_id);


--
-- Name: c4_trunk_pstn_header_egress_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_trunk_pstn_header_egress_id_idx ON trunk_pstn_header USING btree (egress_id);


--
-- Name: c4_trunk_pstn_header_ingress_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_trunk_pstn_header_ingress_id_idx ON trunk_pstn_header USING btree (ingress_id);


--
-- Name: cdr_list_export_log_client_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX cdr_list_export_log_client_id_idx ON cdr_list_export_log USING btree (client_id);


--
-- Name: class4_idx_client_rate_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_client_rate_id ON client_rate USING btree (client_id, rate_table_id);


--
-- Name: class4_idx_code_code_deck_prefix; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_code_code_deck_prefix ON code USING btree (code_deck_id, code);


--
-- Name: class4_idx_code_prefix; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_code_prefix ON code USING gist (code gist_prefix_range_ops);


--
-- Name: class4_idx_dashboard_time_option_admin_point_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_dashboard_time_option_admin_point_time ON dashboard_time_option USING btree (admin_point_time);


--
-- Name: class4_idx_dashboard_time_option_client_point_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_dashboard_time_option_client_point_time ON dashboard_time_option USING btree (client_point_time);


--
-- Name: class4_idx_dashboard_time_option_iden; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_dashboard_time_option_iden ON dashboard_time_option USING btree (iden);


--
-- Name: class4_idx_host_info_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_host_info_time ON host_info USING btree ("time");


--
-- Name: class4_idx_jurisdiction_prefix; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_jurisdiction_prefix ON jurisdiction_prefix USING gist (prefix gist_prefix_range_ops);


--
-- Name: class4_idx_lrn_report_ingress_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_lrn_report_ingress_id ON lrn_report USING btree (ingress_id);


--
-- Name: class4_idx_lrn_report_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_lrn_report_time ON lrn_report USING btree (report_time);


--
-- Name: class4_idx_order_code_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_order_code_code ON order_code USING gist (code gist_prefix_range_ops);


--
-- Name: class4_idx_order_code_order_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_order_code_order_id ON order_code USING btree (order_id, order_type);


--
-- Name: class4_idx_order_code_order_id_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_order_code_order_id_code ON order_code USING gist (code gist_prefix_range_ops, order_id, order_type);


--
-- Name: class4_idx_product_clients_ref_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_product_clients_ref_client_id ON product_clients_ref USING btree (client_id);


--
-- Name: class4_idx_product_clients_ref_product_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_product_clients_ref_product_id ON product_clients_ref USING btree (product_id);


--
-- Name: class4_idx_product_items_prefix; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_product_items_prefix ON product_items USING gist (digits gist_prefix_range_ops, product_id);


--
-- Name: class4_idx_qos_ip_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_ip_time ON qos_ip USING btree (report_time);


--
-- Name: class4_idx_qos_ip_time_ip; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_ip_time_ip ON qos_ip USING btree (report_time, ip_id);


--
-- Name: class4_idx_qos_resource_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_resource_time ON qos_resource USING btree (report_time);


--
-- Name: class4_idx_qos_resource_time_res; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_resource_time_res ON qos_resource USING btree (report_time, res_id);


--
-- Name: class4_idx_qos_route_report_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_route_report_resource_id ON qos_route_report USING btree (report_time, resource_id);


--
-- Name: class4_idx_qos_total_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_total_time ON qos_total USING btree (report_time);


--
-- Name: class4_idx_rate_info_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_rate_info_time ON rate_info USING btree ("time");


--
-- Name: class4_idx_rate_table_id_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_rate_table_id_code ON rate USING gist (code gist_prefix_range_ops, rate_table_id);


--
-- Name: class4_idx_real_cdr_uuid_b; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_real_cdr_uuid_b ON real_cdr USING btree (uuid_b);


--
-- Name: class4_pr_rate_table_code_ref_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_pr_rate_table_code_ref_index ON rate_table_code_ref USING btree (rate_table_id);


--
-- Name: class4_rate_end_date_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_rate_end_date_idx ON rate USING btree (end_date);


--
-- Name: client_balance_operation_action_client_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX client_balance_operation_action_client_id_idx ON client_balance_operation_action USING btree (client_id);


--
-- Name: client_balance_operation_action_update_flag_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX client_balance_operation_action_update_flag_idx ON client_balance_operation_action USING btree (update_result);


--
-- Name: client_cdr_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX client_cdr_time_idx ON client_cdr USING btree ("time");


--
-- Name: dynamic_route_override_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX dynamic_route_override_record_tmp_idx ON dynamic_route_override_record_tmp USING btree (record_id);


--
-- Name: dynamic_route_pri_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX dynamic_route_pri_record_tmp_idx ON dynamic_route_pri_record_tmp USING btree (record_id);


--
-- Name: dynamic_route_qos_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX dynamic_route_qos_record_tmp_idx ON dynamic_route_qos_record_tmp USING btree (record_id);


--
-- Name: egress_profile_egress_ingress_profile_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX egress_profile_egress_ingress_profile_idx ON egress_profile USING btree (server_name, egress_id, ingress_id);


--
-- Name: fki_; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_ ON sys_role_pri USING btree (role_id);


--
-- Name: fki_class4_fkey_alert_mail_order_user_alert_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_alert_mail_order_user_alert_id ON alert_mail USING btree (user_alert_id);


--
-- Name: fki_class4_fkey_block_loop_log_calls_log_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_block_loop_log_calls_log_id ON block_loop_log_calls USING btree (block_loop_log_id);


--
-- Name: fki_class4_fkey_buy_order_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_buy_order_client_id ON buy_order USING btree (client_id);


--
-- Name: fki_class4_fkey_buy_order_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_buy_order_resource_id ON buy_order USING btree (resource_id);


--
-- Name: fki_class4_fkey_client_commit_code_contract_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_code_contract_id ON client_commit_code USING btree (contract_id);


--
-- Name: fki_class4_fkey_client_commit_code_egress_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_code_egress_id ON client_commit_code USING btree (egress_id);


--
-- Name: fki_class4_fkey_client_commit_code_ingress_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_code_ingress_id ON client_commit_code USING btree (ingress_id);


--
-- Name: fki_class4_fkey_client_commit_minutes_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_minutes_client_id ON client_commit_minutes USING btree (client_id);


--
-- Name: fki_class4_fkey_client_commit_minutes_contract_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_minutes_contract_id ON client_commit_minutes USING btree (contract_id);


--
-- Name: fki_class4_fkey_client_commit_minutes_ingress_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_minutes_ingress_id ON client_commit_minutes USING btree (ingress_id);


--
-- Name: fki_class4_fkey_client_currency_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_currency_id ON client USING btree (currency_id);


--
-- Name: fki_class4_fkey_client_group_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_group_id ON client USING btree (group_id);


--
-- Name: fki_class4_fkey_client_orig_rate_table_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_orig_rate_table_id ON client USING btree (orig_rate_table_id);


--
-- Name: fki_class4_fkey_client_payment_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_payment_client_id ON client_payment USING btree (client_id);


--
-- Name: fki_class4_fkey_client_payment_invoice_number; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_payment_invoice_number ON client_payment USING btree (invoice_number);


--
-- Name: fki_class4_fkey_client_payment_term_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_payment_term_id ON client USING btree (payment_term_id);


--
-- Name: fki_class4_fkey_client_role_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_role_id ON client USING btree (role_id);


--
-- Name: fki_class4_fkey_code_code_deck_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_code_code_deck_id ON code USING btree (code_deck_id);


--
-- Name: fki_class4_fkey_contract_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_contract_client_id ON contract USING btree (client_id);


--
-- Name: fki_class4_fkey_contract_code_contract_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_contract_code_contract_id ON contract_code USING btree (contract_id);


--
-- Name: fki_class4_fkey_contract_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_contract_resource_id ON contract USING btree (resource_id);


--
-- Name: fki_class4_fkey_contract_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_contract_user_id ON contract USING btree (user_id);


--
-- Name: fki_class4_fkey_currency_updates_currency_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_currency_updates_currency_id ON currency_updates USING btree (currency_id);


--
-- Name: fki_class4_fkey_dynamic_route_items_dynamic_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_items_dynamic_route_id ON dynamic_route_items USING btree (dynamic_route_id);


--
-- Name: fki_class4_fkey_dynamic_route_items_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_items_resource_id ON dynamic_route_items USING btree (resource_id);


--
-- Name: fki_class4_fkey_dynamic_route_override_dynamic_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_override_dynamic_route_id ON dynamic_route_override USING btree (dynamic_route_id);


--
-- Name: fki_class4_fkey_dynamic_route_override_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_override_resource_id ON dynamic_route_override USING btree (resource_id);


--
-- Name: fki_class4_fkey_dynamic_route_pri_dynamic_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_pri_dynamic_route_id ON dynamic_route_pri USING btree (dynamic_route_id);


--
-- Name: fki_class4_fkey_dynamic_route_pri_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_pri_resource_id ON dynamic_route_pri USING btree (resource_id);


--
-- Name: fki_class4_fkey_dynamic_route_qos_dynamic_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_qos_dynamic_route_id ON dynamic_route_qos USING btree (dynamic_route_id);


--
-- Name: fki_class4_fkey_dynamic_route_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_time_profile_id ON dynamic_route USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_invoice_calls_invoice_no; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_invoice_calls_invoice_no ON invoice_calls USING btree (invoice_no);


--
-- Name: fki_class4_fkey_invoice_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_invoice_client_id ON invoice USING btree (client_id);


--
-- Name: fki_class4_fkey_invoice_item_invoice_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_invoice_item_invoice_id ON invoice_item USING btree (invoice_id);


--
-- Name: fki_class4_fkey_jurisdiction_country_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_jurisdiction_country_id ON jurisdiction USING btree (jurisdiction_country_id);


--
-- Name: fki_class4_fkey_jurisdiction_prefix_country_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_jurisdiction_prefix_country_id ON jurisdiction_prefix USING btree (jurisdiction_country_id);


--
-- Name: fki_class4_fkey_jurisdiction_prefix_jurisdiction_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_jurisdiction_prefix_jurisdiction_id ON jurisdiction_prefix USING btree (jurisdiction_id);


--
-- Name: fki_class4_fkey_order_user_alert_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_order_user_alert_user_id ON order_user_alert USING btree (user_id);


--
-- Name: fki_class4_fkey_order_user_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_order_user_client_id ON order_user USING btree (client_id);


--
-- Name: fki_class4_fkey_order_user_rate_watch_alert_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_order_user_rate_watch_alert_id ON order_user_rate_watch USING btree (order_user_alert_id);


--
-- Name: fki_class4_fkey_product_items_product_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_product_items_product_id ON product_items USING btree (product_id);


--
-- Name: fki_class4_fkey_product_items_resource_item_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_product_items_resource_item_id ON product_items_resource USING btree (item_id);


--
-- Name: fki_class4_fkey_product_items_resource_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_product_items_resource_resource_id ON product_items_resource USING btree (resource_id);


--
-- Name: fki_class4_fkey_product_items_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_product_items_time_profile_id ON product_items USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_rate_auto_create_interval_rate_create_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_auto_create_interval_rate_create_id ON rate_auto_create_interval USING btree (rate_auto_create_id);


--
-- Name: fki_class4_fkey_rate_did_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_did_type ON rate USING btree (did_type);


--
-- Name: fki_class4_fkey_rate_rate_table_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_rate_table_id ON rate USING btree (rate_table_id);


--
-- Name: fki_class4_fkey_rate_table_code_deck_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_table_code_deck_id ON rate_table USING btree (code_deck_id);


--
-- Name: fki_class4_fkey_rate_table_currency_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_table_currency_id ON rate_table USING btree (currency_id);


--
-- Name: fki_class4_fkey_rate_table_jurisdiction_country_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_table_jurisdiction_country_id ON rate_table USING btree (jurisdiction_country_id);


--
-- Name: fki_class4_fkey_rate_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_time_profile_id ON rate USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_reosurce_ip_limit_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_reosurce_ip_limit_time_profile_id ON resource_ip_limit USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_resource_block_engress_res_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_block_engress_res_id ON resource_block USING btree (engress_res_id);


--
-- Name: fki_class4_fkey_resource_block_ingress_res_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_block_ingress_res_id ON resource_block USING btree (ingress_res_id);


--
-- Name: fki_class4_fkey_resource_block_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_block_time_profile_id ON resource_block USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_resource_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_client_id ON resource USING btree (client_id);


--
-- Name: fki_class4_fkey_resource_codec_ref_codec_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_codec_ref_codec_id ON resource_codecs_ref USING btree (codec_id);


--
-- Name: fki_class4_fkey_resource_direction_template_resource_template_i; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_direction_template_resource_template_i ON resource_direction_template USING btree (resource_template_id);


--
-- Name: fki_class4_fkey_resource_direction_template_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_direction_template_time_profile_id ON resource_direction_template USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_resource_direction_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_direction_time_profile_id ON resource_direction USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_resource_ip_limit_ip_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_ip_limit_ip_id ON resource_ip_limit USING btree (ip_id);


--
-- Name: fki_class4_fkey_resource_ip_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_ip_resource_id ON resource_ip USING btree (resource_id);


--
-- Name: fki_class4_fkey_resource_prefix_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_prefix_resource_id ON resource_prefix USING btree (resource_id);


--
-- Name: fki_class4_fkey_resource_rate_table_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_rate_table_id ON resource USING btree (rate_table_id);


--
-- Name: fki_class4_fkey_resource_replace_action_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_replace_action_resource_id ON resource_replace_action USING btree (resource_id);


--
-- Name: fki_class4_fkey_resource_route_strategy_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_route_strategy_id ON resource USING btree (route_strategy_id);


--
-- Name: fki_class4_fkey_resource_translation_ref_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_translation_ref_resource_id ON resource_translation_ref USING btree (resource_id);


--
-- Name: fki_class4_fkey_resource_translation_ref_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_translation_ref_time_profile_id ON resource_translation_ref USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_resource_translation_ref_translation_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_translation_ref_translation_id ON resource_translation_ref USING btree (translation_id);


--
-- Name: fki_class4_fkey_role_privilege_role_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_role_privilege_role_id ON role_privilege USING btree (role_id);


--
-- Name: fki_class4_fkey_role_privilege_system_function_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_role_privilege_system_function_id ON role_privilege USING btree (system_function_id);


--
-- Name: fki_class4_fkey_route_dynamic_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_route_dynamic_route_id ON route USING btree (dynamic_route_id);


--
-- Name: fki_class4_fkey_route_route_strategy_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_route_route_strategy_id ON route USING btree (route_strategy_id);


--
-- Name: fki_class4_fkey_route_static_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_route_static_route_id ON route USING btree (static_route_id);


--
-- Name: fki_class4_fkey_sell_order_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_sell_order_resource_id ON sell_order USING btree (resource_id);


--
-- Name: fki_class4_fkey_sell_order_response_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_sell_order_response_client_id ON sell_order_response USING btree (client_id);


--
-- Name: fki_class4_fkey_sell_order_response_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_sell_order_response_resource_id ON sell_order_response USING btree (resource_id);


--
-- Name: fki_class4_fkey_sell_order_response_sell_order_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_sell_order_response_sell_order_id ON sell_order_response USING btree (sell_order_id);


--
-- Name: fki_class4_fkey_sell_order_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_sell_order_user_id ON sell_order USING btree (user_id);


--
-- Name: fki_class4_fkey_term_rate_table_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_term_rate_table_id ON client USING btree (term_rate_table_id);


--
-- Name: fki_class4_fkey_test_device_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_test_device_resource_id ON test_device USING btree (resource_id);


--
-- Name: fki_class4_fkey_translation_item; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_translation_item ON translation_item USING btree (translation_id);


--
-- Name: fki_class4_fkey_users_role_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_users_role_id ON users USING btree (role_id);


--
-- Name: fki_class4_key_sell_order_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_key_sell_order_client_id ON sell_order USING btree (client_id);


--
-- Name: fki_class4_pkey_buy_order_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_pkey_buy_order_user_id ON buy_order USING btree (user_id);


--
-- Name: fki_class4_resource_codecs_ref_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_resource_codecs_ref_resource_id ON resource_codecs_ref USING btree (resource_id);


--
-- Name: fki_class4_resource_direction_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_resource_direction_resource_id ON resource_direction USING btree (resource_id);


--
-- Name: fki_exchange_agent_import_target_push_job_import_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_import_target_push_job_import_id_pkey ON exchange_agent_import_target_push_job USING btree (import_id);


--
-- Name: fki_exchange_agent_send_email_log_list; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_send_email_log_list ON exchange_agent_send_mail_log_list USING btree (client_id);


--
-- Name: fki_exchange_agent_send_mail_log_email_template_fkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_send_mail_log_email_template_fkey ON exchange_agent_send_mail_log USING btree (email_template);


--
-- Name: fki_exchange_agent_send_mail_log_list_log_id_fkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_send_mail_log_list_log_id_fkey ON exchange_agent_send_mail_log_list USING btree (log_id);


--
-- Name: fki_exchange_agent_user_agent_client_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_user_agent_client_id_pkey ON exchange_agent_user USING btree (agent_client_id);


--
-- Name: fki_exchange_agent_user_role_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_user_role_id_pkey ON exchange_agent_user USING btree (role_id);


--
-- Name: fki_exchange_false_del_resource_id_key; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_false_del_resource_id_key ON exchange_false_del USING btree (resource_id);


--
-- Name: fki_exchange_job_list_job_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_list_job_id ON exchange_job_list USING btree (job_id);


--
-- Name: fki_exchange_job_list_trunk_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_list_trunk_id ON exchange_job_list USING btree (trunk_id);


--
-- Name: fki_exchange_job_product_id_fkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_product_id_fkey ON exchange_job USING btree (product_id);


--
-- Name: fki_exchange_job_session_block_log_session_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_session_block_log_session_id ON exchange_job_session_block_log USING btree (session_id);


--
-- Name: fki_exchange_job_session_block_log_trunk_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_session_block_log_trunk_id ON exchange_job_session_block_log USING btree (trunk_id);


--
-- Name: fki_exchange_job_session_job_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_session_job_id ON exchange_job_session USING btree (job_id);


--
-- Name: fki_exchange_job_session_list_session_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_session_list_session_id ON exchange_job_session_list USING btree (session_id);


--
-- Name: fki_exchange_job_session_list_trunk_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_session_list_trunk_id ON exchange_job_session_list USING btree (trunk_id);


--
-- Name: fki_exchange_par_account_role_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_par_account_role_id_pkey ON exchange_par_account USING btree (role_id);


--
-- Name: fki_exchange_simple_session_list_session_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_simple_session_list_session_id_pkey ON exchange_simple_session_list USING btree (session_id);


--
-- Name: fki_exchange_simple_session_list_trunk_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_simple_session_list_trunk_pkey ON exchange_simple_session_list USING btree (trunk_id);


--
-- Name: fki_exchange_sys_role_pri_id_fkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_sys_role_pri_id_fkey ON exchange_sys_role_pri USING btree (pri_id);


--
-- Name: fki_order_user_role_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_order_user_role_id_pkey ON order_user USING btree (role_id);


--
-- Name: fki_sys_pri_pri_module_id_key; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_sys_pri_pri_module_id_key ON sys_pri USING btree (module_id);


--
-- Name: fki_voip_server_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_voip_server_id ON switch_profile USING btree (voip_gateway_id);


--
-- Name: fraud_detection_log_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fraud_detection_log_time_idx ON fraud_detection_log USING btree ("time");


--
-- Name: hang_calls_history_start_time_end_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX hang_calls_history_start_time_end_time_idx ON hang_calls_history USING btree (start_time, end_time);


--
-- Name: hang_calls_list_hang_calls_history_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX hang_calls_list_hang_calls_history_id_idx ON hang_calls_list USING btree (hang_calls_history_id);


--
-- Name: hang_calls_list_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX hang_calls_list_time_idx ON hang_calls_list USING btree ("time");


--
-- Name: idx_logs_act_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_logs_act_type ON logs USING btree (act_type);


--
-- Name: idx_logs_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_logs_user_id ON logs USING btree (user_id);


--
-- Name: idx_prefix_info_search; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_prefix_info_search ON prefix_info USING btree ("time");


--
-- Name: idx_rate_log_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_rate_log_user_id ON rate_log USING btree (user_id);


--
-- Name: idx_search_logs_module; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_search_logs_module ON search_logs USING btree (module);


--
-- Name: idx_search_logs_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_search_logs_type ON search_logs USING btree (type);


--
-- Name: idx_transaction_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transaction_client_id ON transaction USING btree (client_id);


--
-- Name: idx_transaction_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transaction_date ON transaction USING btree (date);


--
-- Name: invoice_history_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX invoice_history_client_id ON invoice_history USING btree (client_id);


--
-- Name: invoice_history_last_invoice_for; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX invoice_history_last_invoice_for ON invoice_history USING btree (last_invoice_for);


--
-- Name: jurisdiction_prefix_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX jurisdiction_prefix_record_tmp_idx ON jurisdiction_prefix_record_tmp USING btree (record_id);


--
-- Name: jurisdiction_update_history_task_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX jurisdiction_update_history_task_id_idx ON jurisdiction_update_history USING btree (task_id);


--
-- Name: opentact_balance_ingress_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX opentact_balance_ingress_id_idx ON opentact_balance USING btree (ingress_id);


--
-- Name: payline_history_invoice_id_keys; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX payline_history_invoice_id_keys ON payline_history USING btree (invoice_id);


--
-- Name: product_items_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX product_items_record_tmp_idx ON product_items_record_tmp USING btree (record_id);


--
-- Name: product_items_resource_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX product_items_resource_record_tmp_idx ON product_items_resource_record_tmp USING btree (record_id);


--
-- Name: qos_ip_server_ip_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX qos_ip_server_ip_index ON qos_ip USING btree (server_ip);


--
-- Name: qos_ip_server_port_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX qos_ip_server_port_index ON qos_ip USING btree (server_port);


--
-- Name: qos_resource_server_ip_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX qos_resource_server_ip_index ON qos_resource USING btree (server_ip);


--
-- Name: qos_resource_server_port_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX qos_resource_server_port_index ON qos_resource USING btree (server_port);


--
-- Name: qos_route_report_report_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX qos_route_report_report_time_idx ON qos_route_report USING btree (report_time);


--
-- Name: quick_cdr_user_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX quick_cdr_user_id_idx ON quick_cdr USING btree (user_id);


--
-- Name: random_ani_generation_ani_number_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX random_ani_generation_ani_number_idx ON random_ani_generation USING btree (ani_number);


--
-- Name: random_ani_generation_random_table_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX random_ani_generation_random_table_id_idx ON random_ani_generation USING btree (random_table_id);


--
-- Name: rate_generation_code_deck_tmplate_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_code_deck_tmplate_id_idx ON rate_generation_code_deck USING btree (rate_generation_template_id);


--
-- Name: rate_generation_history_status_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_history_status_idx ON rate_generation_history USING btree (status);


--
-- Name: rate_generation_rate_rate_generation_history_id_code_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_rate_rate_generation_history_id_code_idx ON rate_generation_rate USING btree (rate_generation_history_id, code);


--
-- Name: rate_generation_rate_rate_generation_history_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_rate_rate_generation_history_id_idx ON rate_generation_rate USING btree (rate_generation_history_id);


--
-- Name: rate_generation_template_detail_tmplate_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_template_detail_tmplate_id_idx ON rate_generation_template_detail USING btree (rate_generation_template_id);


--
-- Name: rate_generation_template_margin_tmplate_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_template_margin_tmplate_id_idx ON rate_generation_template_margin USING btree (rate_generation_template_id);


--
-- Name: rate_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_record_tmp_idx ON rate_record_tmp USING btree (record_id);


--
-- Name: route_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX route_record_tmp_idx ON route_record_tmp USING btree (record_id);


--
-- Name: spam_traffic_ip_record_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX spam_traffic_ip_record_time_idx ON spam_traffic_ip_record USING btree ("time");


--
-- Name: translation_item_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX translation_item_record_tmp_idx ON translation_item_record_tmp USING btree (record_id);


--
-- Name: unique_strategy_prefix_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX unique_strategy_prefix_client_id ON client_route_strategy USING btree (prefix, client_id);


--
-- Name: vendor_invoice_detail_vendor_invoice_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX vendor_invoice_detail_vendor_invoice_id_idx ON vendor_invoice_detail USING btree (vendor_invoice_id);


--
-- Name: version_information_program_switch_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX version_information_program_switch_name_idx ON version_information USING btree (program_name, switch_name);


SET search_path = pgagent, pg_catalog;

--
-- Name: pga_exception pga_exception_trigger; Type: TRIGGER; Schema: pgagent; Owner: postgres
--

CREATE TRIGGER pga_exception_trigger AFTER INSERT OR DELETE OR UPDATE ON pga_exception FOR EACH ROW EXECUTE PROCEDURE pga_exception_trigger();


--
-- Name: TRIGGER pga_exception_trigger ON pga_exception; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TRIGGER pga_exception_trigger ON pga_exception IS 'Update the job''s next run time whenever an exception changes';


--
-- Name: pga_job pga_job_trigger; Type: TRIGGER; Schema: pgagent; Owner: postgres
--

CREATE TRIGGER pga_job_trigger BEFORE UPDATE ON pga_job FOR EACH ROW EXECUTE PROCEDURE pga_job_trigger();


--
-- Name: TRIGGER pga_job_trigger ON pga_job; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TRIGGER pga_job_trigger ON pga_job IS 'Update the job''s next run time.';


--
-- Name: pga_schedule pga_schedule_trigger; Type: TRIGGER; Schema: pgagent; Owner: postgres
--

CREATE TRIGGER pga_schedule_trigger AFTER INSERT OR DELETE OR UPDATE ON pga_schedule FOR EACH ROW EXECUTE PROCEDURE pga_schedule_trigger();


--
-- Name: TRIGGER pga_schedule_trigger ON pga_schedule; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TRIGGER pga_schedule_trigger ON pga_schedule IS 'Update the job''s next run time whenever a schedule changes';


SET search_path = public, pg_catalog;

--
-- Name: c4_livecall_user c4_livecall_user_trig_record; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER c4_livecall_user_trig_record AFTER INSERT OR DELETE OR UPDATE ON c4_livecall_user FOR EACH ROW EXECUTE PROCEDURE c4_livecall_user_trigfun_record();


--
-- Name: host_based_report class4_trig_chost_based_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_chost_based_report_insert BEFORE INSERT ON host_based_report FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_host_based_report_insert();


--
-- Name: client_cdr class4_trig_client_cdr_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_client_cdr_insert BEFORE INSERT ON client_cdr FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_cdr_insert();


--
-- Name: cdr_report_detail class4_trig_client_report_detail_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_client_report_detail_insert BEFORE INSERT ON cdr_report_detail FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_report_detail_insert();


--
-- Name: cdr_report class4_trig_client_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_client_report_insert BEFORE INSERT ON cdr_report FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_report_insert();


--
-- Name: agent_client_client class4_trig_record_agent_client_client; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_agent_client_client AFTER INSERT OR DELETE OR UPDATE ON agent_client_client FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_agent_client_client();


--
-- Name: allowed_sendto_ip class4_trig_record_allowed_sendto_ip; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_allowed_sendto_ip AFTER INSERT OR DELETE OR UPDATE ON allowed_sendto_ip FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_allowed_sendto_ip();


--
-- Name: buy_order class4_trig_record_buy_order; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_buy_order AFTER INSERT OR DELETE OR UPDATE ON buy_order FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_buy_order();


--
-- Name: c4_lrn class4_trig_record_c4_lrn; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_c4_lrn AFTER INSERT OR DELETE OR UPDATE ON c4_lrn FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_c4_lrn();


--
-- Name: client class4_trig_record_client; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_client AFTER INSERT OR DELETE OR UPDATE ON client FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_client();


--
-- Name: client_commit_code class4_trig_record_client_commit_code; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_client_commit_code AFTER INSERT OR DELETE OR UPDATE ON client_commit_code FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_client_commit_code();


--
-- Name: client_commit_minutes class4_trig_record_client_commit_minutes; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_client_commit_minutes AFTER INSERT OR DELETE OR UPDATE ON client_commit_minutes FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_client_commit_minutes();


--
-- Name: code class4_trig_record_code; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_code AFTER INSERT OR DELETE OR UPDATE ON code FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_code();


--
-- Name: contract class4_trig_record_contract; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_contract AFTER INSERT OR DELETE OR UPDATE ON contract FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_contract();


--
-- Name: currency class4_trig_record_currency; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_currency AFTER INSERT OR DELETE OR UPDATE ON currency FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_currency();


--
-- Name: currency_updates class4_trig_record_currency_updates; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_currency_updates AFTER INSERT OR DELETE OR UPDATE ON currency_updates FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_currency_updates();


--
-- Name: dynamic_route class4_trig_record_dynamic_route; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_dynamic_route AFTER INSERT OR DELETE OR UPDATE ON dynamic_route FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_dynamic_route();


--
-- Name: dynamic_route_items class4_trig_record_dynamic_route_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_dynamic_route_items AFTER INSERT OR DELETE OR UPDATE ON dynamic_route_items FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_dynamic_route_items();


--
-- Name: dynamic_route_override class4_trig_record_dynamic_route_override; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_dynamic_route_override AFTER INSERT OR DELETE OR UPDATE ON dynamic_route_override FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_dynamic_route_override();


--
-- Name: dynamic_route_pri class4_trig_record_dynamic_route_pri; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_dynamic_route_pri AFTER INSERT OR DELETE OR UPDATE ON dynamic_route_pri FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_dynamic_route_pri();


--
-- Name: dynamic_route_qos class4_trig_record_dynamic_route_qos; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_dynamic_route_qos AFTER INSERT OR DELETE OR UPDATE ON dynamic_route_qos FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_dynamic_route_qos();


--
-- Name: egress_profile class4_trig_record_egress_profile; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_egress_profile AFTER INSERT OR DELETE OR UPDATE ON egress_profile FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_egress_profile();


--
-- Name: exchange_par_account class4_trig_record_exchange_par_account; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_exchange_par_account AFTER INSERT OR DELETE OR UPDATE ON exchange_par_account FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_exchange_par_account();


--
-- Name: global_route_error class4_trig_record_global_route_error; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_global_route_error AFTER INSERT OR DELETE OR UPDATE ON global_route_error FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_global_route_error();


--
-- Name: jurisdiction_prefix class4_trig_record_jurisdiction_prefix; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_jurisdiction_prefix AFTER INSERT OR DELETE OR UPDATE ON jurisdiction_prefix FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_jurisdiction_prefix();


--
-- Name: lrn_groups class4_trig_record_lrn_groups; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_lrn_groups AFTER INSERT OR DELETE OR UPDATE ON lrn_groups FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_lrn_groups();


--
-- Name: lrn_items class4_trig_record_lrn_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_lrn_items AFTER INSERT OR DELETE OR UPDATE ON lrn_items FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_lrn_items();


--
-- Name: origination_global_failover class4_trig_record_origination_global_failover; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_origination_global_failover AFTER INSERT OR DELETE OR UPDATE ON origination_global_failover FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_origination_global_failover();


--
-- Name: partition_gateway_ref class4_trig_record_partition_gateway_ref; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_partition_gateway_ref AFTER INSERT OR DELETE OR UPDATE ON partition_gateway_ref FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_partition_gateway_ref();


--
-- Name: payment_term class4_trig_record_payment_term; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_payment_term AFTER INSERT OR DELETE OR UPDATE ON payment_term FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_payment_term();


--
-- Name: product class4_trig_record_product; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_product AFTER INSERT OR DELETE OR UPDATE ON product FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_product();


--
-- Name: product_items class4_trig_record_product_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_product_items AFTER INSERT OR DELETE OR UPDATE ON product_items FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_product_items();


--
-- Name: product_items_resource class4_trig_record_product_items_resource; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_product_items_resource AFTER INSERT OR DELETE OR UPDATE ON product_items_resource FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_product_items_resource();


--
-- Name: product_rout_rate_table class4_trig_record_product_rout_rate_table; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_product_rout_rate_table AFTER INSERT OR DELETE OR UPDATE ON product_rout_rate_table FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_product_rout_rate_table();


--
-- Name: random_ani_generation class4_trig_record_random_ani_generation; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_random_ani_generation AFTER INSERT OR DELETE OR UPDATE ON random_ani_generation FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_random_ani_generation();


--
-- Name: rate class4_trig_record_rate; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_rate AFTER INSERT OR DELETE OR UPDATE ON rate FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_rate();


--
-- Name: rate_table class4_trig_record_rate_table; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_rate_table AFTER INSERT OR DELETE OR UPDATE ON rate_table FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_rate_table();


--
-- Name: resource class4_trig_record_resource; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource AFTER INSERT OR DELETE OR UPDATE ON resource FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource();


--
-- Name: resource_block class4_trig_record_resource_block; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_block AFTER INSERT OR DELETE OR UPDATE ON resource_block FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_block();


--
-- Name: resource_block_items class4_trig_record_resource_block_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_block_items AFTER INSERT OR DELETE OR UPDATE ON resource_block_items FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_block_items();


--
-- Name: resource_capacity class4_trig_record_resource_capacity; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_capacity AFTER INSERT OR DELETE OR UPDATE ON resource_capacity FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_capacity();


--
-- Name: resource_codecs_ref class4_trig_record_resource_codecs_ref; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_codecs_ref AFTER INSERT OR DELETE OR UPDATE ON resource_codecs_ref FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_codecs_ref();


--
-- Name: resource_direction class4_trig_record_resource_direction; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_direction AFTER INSERT OR DELETE OR UPDATE ON resource_direction FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_direction();


--
-- Name: resource_ip class4_trig_record_resource_ip; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_ip AFTER INSERT OR DELETE OR UPDATE ON resource_ip FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_ip();


--
-- Name: resource_ip_limit class4_trig_record_resource_ip_limit; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_ip_limit AFTER INSERT OR DELETE OR UPDATE ON resource_ip_limit FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_ip_limit();


--
-- Name: resource_lrn_action class4_trig_record_resource_lrn_action; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_lrn_action AFTER INSERT OR DELETE OR UPDATE ON resource_lrn_action FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_lrn_action();


--
-- Name: resource_next_route_rule class4_trig_record_resource_next_route_rule; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_next_route_rule AFTER INSERT OR DELETE OR UPDATE ON resource_next_route_rule FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_next_route_rule();


--
-- Name: resource_prefix class4_trig_record_resource_prefix; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_prefix AFTER INSERT OR DELETE OR UPDATE ON resource_prefix FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_prefix();


--
-- Name: resource_rate class4_trig_record_resource_rate; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_rate AFTER INSERT OR DELETE OR UPDATE ON resource_rate FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_rate();


--
-- Name: resource_replace_action class4_trig_record_resource_replace_action; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_replace_action AFTER INSERT OR DELETE OR UPDATE ON resource_replace_action FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_replace_action();


--
-- Name: resource_translation_ref class4_trig_record_resource_translation_ref; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_translation_ref AFTER INSERT OR DELETE OR UPDATE ON resource_translation_ref FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_resource_translation_ref();


--
-- Name: route class4_trig_record_route; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_route AFTER INSERT OR DELETE OR UPDATE ON route FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_route();


--
-- Name: sell_order class4_trig_record_sell_order; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_sell_order AFTER INSERT OR DELETE OR UPDATE ON sell_order FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_sell_order();


--
-- Name: service_charge_items class4_trig_record_service_charge_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_service_charge_items AFTER INSERT OR DELETE OR UPDATE ON service_charge_items FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_service_charge_items();


--
-- Name: sip_error_code class4_trig_record_sip_error_code; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_sip_error_code AFTER INSERT OR DELETE OR UPDATE ON sip_error_code FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_sip_error_code();


--
-- Name: spam_traffic_ip class4_trig_record_spam_traffic_ip; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_spam_traffic_ip AFTER INSERT OR DELETE OR UPDATE ON spam_traffic_ip FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_spam_traffic_ip();


--
-- Name: switch_profile class4_trig_record_switch_profile; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_switch_profile AFTER INSERT OR DELETE OR UPDATE ON switch_profile FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_switch_profile();


--
-- Name: termination_global_failover class4_trig_record_termination_global_failover; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_termination_global_failover AFTER INSERT OR DELETE OR UPDATE ON termination_global_failover FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_termination_global_failover();


--
-- Name: time_profile class4_trig_record_time_profile; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_time_profile AFTER INSERT OR DELETE OR UPDATE ON time_profile FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_time_profile();


--
-- Name: transaction_fee_items class4_trig_record_transaction_fee_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_transaction_fee_items AFTER INSERT OR DELETE OR UPDATE ON transaction_fee_items FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_transaction_fee_items();


--
-- Name: translation_item class4_trig_record_translation_item; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_translation_item AFTER INSERT OR DELETE OR UPDATE ON translation_item FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_translation_item();


--
-- Name: trunk_pstn_header class4_trig_record_trunk_pstn_header; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_trunk_pstn_header AFTER INSERT OR DELETE OR UPDATE ON trunk_pstn_header FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_record_trunk_pstn_header();


--
-- Name: did_report class4_trigfun_did_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_did_report_insert BEFORE INSERT ON did_report FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_did_report_insert();


--
-- Name: us_frequent_number_report class4_trigfun_us_frequent_number_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_us_frequent_number_report_insert BEFORE INSERT ON us_frequent_number_report FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_us_frequent_number_report_insert();


--
-- Name: us_lcr_report class4_trigfun_us_lcr_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_us_lcr_report_insert BEFORE INSERT ON us_lcr_report FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_us_lcr_report_insert();


--
-- Name: us_lcr_vendor_report class4_trigfun_us_lcr_vendor_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_us_lcr_vendor_report_insert BEFORE INSERT ON us_lcr_vendor_report FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_us_lcr_vendor_report_insert();


--
-- Name: us_return_code_report class4_trigfun_us_return_code_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_us_return_code_report_insert BEFORE INSERT ON us_return_code_report FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_us_return_code_report_insert();


--
-- Name: us_termination_vendor_report class4_trigfun_us_termination_vendor_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_us_termination_vendor_report_insert BEFORE INSERT ON us_termination_vendor_report FOR EACH ROW EXECUTE PROCEDURE class4_trigfun_us_termination_vendor_report_insert();


--
-- Name: product_rout_rate_table product_rout_rate_table_trig_record; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER product_rout_rate_table_trig_record AFTER INSERT OR DELETE OR UPDATE ON product_rout_rate_table FOR EACH ROW EXECUTE PROCEDURE product_rout_rate_table_trigfun_record();


--
-- Name: client_cdr t_opentact_balance_func; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER t_opentact_balance_func AFTER INSERT ON client_cdr FOR EACH ROW EXECUTE PROCEDURE opentact_balance_func();


--
-- Name: register_of_record t_opentact_egress_registration; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER t_opentact_egress_registration AFTER INSERT OR UPDATE ON register_of_record FOR EACH ROW EXECUTE PROCEDURE opentact_egress_registration();


SET search_path = pgagent, pg_catalog;

--
-- Name: pga_exception pga_exception_jexscid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_exception
    ADD CONSTRAINT pga_exception_jexscid_fkey FOREIGN KEY (jexscid) REFERENCES pga_schedule(jscid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: pga_job pga_job_jobagentid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_job
    ADD CONSTRAINT pga_job_jobagentid_fkey FOREIGN KEY (jobagentid) REFERENCES pga_jobagent(jagpid) ON UPDATE RESTRICT ON DELETE SET NULL;


--
-- Name: pga_job pga_job_jobjclid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_job
    ADD CONSTRAINT pga_job_jobjclid_fkey FOREIGN KEY (jobjclid) REFERENCES pga_jobclass(jclid) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: pga_joblog pga_joblog_jlgjobid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_joblog
    ADD CONSTRAINT pga_joblog_jlgjobid_fkey FOREIGN KEY (jlgjobid) REFERENCES pga_job(jobid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: pga_jobstep pga_jobstep_jstjobid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_jobstep
    ADD CONSTRAINT pga_jobstep_jstjobid_fkey FOREIGN KEY (jstjobid) REFERENCES pga_job(jobid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: pga_jobsteplog pga_jobsteplog_jsljlgid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_jobsteplog
    ADD CONSTRAINT pga_jobsteplog_jsljlgid_fkey FOREIGN KEY (jsljlgid) REFERENCES pga_joblog(jlgid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: pga_jobsteplog pga_jobsteplog_jsljstid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_jobsteplog
    ADD CONSTRAINT pga_jobsteplog_jsljstid_fkey FOREIGN KEY (jsljstid) REFERENCES pga_jobstep(jstid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: pga_schedule pga_schedule_jscjobid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pga_schedule
    ADD CONSTRAINT pga_schedule_jscjobid_fkey FOREIGN KEY (jscjobid) REFERENCES pga_job(jobid) ON UPDATE RESTRICT ON DELETE CASCADE;


SET search_path = public, pg_catalog;

--
-- Name: agent_client agent_client_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_client
    ADD CONSTRAINT agent_client_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agent(agent_id) ON DELETE CASCADE;


--
-- Name: agent_client agent_client_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_client
    ADD CONSTRAINT agent_client_client_id_fkey FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE CASCADE;


--
-- Name: agent_clients agent_clients_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_clients
    ADD CONSTRAINT agent_clients_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agent(agent_id) ON DELETE CASCADE;


--
-- Name: agent_clients agent_clients_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_clients
    ADD CONSTRAINT agent_clients_client_id_fkey FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE CASCADE;


--
-- Name: agent_commission_history agent_commission_history_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_commission_history
    ADD CONSTRAINT agent_commission_history_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES agent(agent_id) ON DELETE CASCADE;


--
-- Name: agent_commission_history_detail agent_commission_history_detail_history_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_commission_history_detail
    ADD CONSTRAINT agent_commission_history_detail_history_id_fkey FOREIGN KEY (history_id) REFERENCES agent_commission_history(history_id) ON DELETE CASCADE;


--
-- Name: agent_commission_payment agent_commission_payment_history_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY agent_commission_payment
    ADD CONSTRAINT agent_commission_payment_history_id_fkey FOREIGN KEY (history_id) REFERENCES agent_commission_history(history_id) ON DELETE CASCADE;


--
-- Name: alert_action alert_action_trouble_tickets_template_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_action
    ADD CONSTRAINT alert_action_trouble_tickets_template_fkey FOREIGN KEY (trouble_tickets_template) REFERENCES trouble_tickets_template(id);


--
-- Name: balance_history_actual balance_history_actual_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY balance_history_actual
    ADD CONSTRAINT balance_history_actual_client_id_fkey FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE CASCADE;


--
-- Name: balance_history balance_history_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY balance_history
    ADD CONSTRAINT balance_history_client_id_fkey FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE CASCADE;


--
-- Name: block_ani block_ani_action_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_ani
    ADD CONSTRAINT block_ani_action_id_fkey FOREIGN KEY (action_id) REFERENCES alert_action(id);


--
-- Name: alert_mail class4_fkey_alert_mail_order_user_alert_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY alert_mail
    ADD CONSTRAINT class4_fkey_alert_mail_order_user_alert_id FOREIGN KEY (user_alert_id) REFERENCES order_user_alert(id);


--
-- Name: block_loop_log_calls class4_fkey_block_loop_log_calls_log_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY block_loop_log_calls
    ADD CONSTRAINT class4_fkey_block_loop_log_calls_log_id FOREIGN KEY (block_loop_log_id) REFERENCES block_loop_log(id);


--
-- Name: buy_order class4_fkey_buy_order_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY buy_order
    ADD CONSTRAINT class4_fkey_buy_order_client_id FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE CASCADE;


--
-- Name: buy_order class4_fkey_buy_order_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY buy_order
    ADD CONSTRAINT class4_fkey_buy_order_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: client_commit_code class4_fkey_client_commit_code_contract_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_commit_code
    ADD CONSTRAINT class4_fkey_client_commit_code_contract_id FOREIGN KEY (contract_id) REFERENCES contract(id) ON DELETE CASCADE;


--
-- Name: client_commit_code class4_fkey_client_commit_code_egress_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_commit_code
    ADD CONSTRAINT class4_fkey_client_commit_code_egress_id FOREIGN KEY (egress_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: client_commit_code class4_fkey_client_commit_code_ingress_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_commit_code
    ADD CONSTRAINT class4_fkey_client_commit_code_ingress_id FOREIGN KEY (ingress_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: client_commit_minutes class4_fkey_client_commit_minutes_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_commit_minutes
    ADD CONSTRAINT class4_fkey_client_commit_minutes_client_id FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE CASCADE;


--
-- Name: client_commit_minutes class4_fkey_client_commit_minutes_contract_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_commit_minutes
    ADD CONSTRAINT class4_fkey_client_commit_minutes_contract_id FOREIGN KEY (contract_id) REFERENCES contract(id) ON DELETE CASCADE;


--
-- Name: client_commit_minutes class4_fkey_client_commit_minutes_ingress_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_commit_minutes
    ADD CONSTRAINT class4_fkey_client_commit_minutes_ingress_id FOREIGN KEY (ingress_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: client class4_fkey_client_currency_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client
    ADD CONSTRAINT class4_fkey_client_currency_id FOREIGN KEY (currency_id) REFERENCES currency(currency_id) ON DELETE SET NULL;


--
-- Name: client class4_fkey_client_group_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client
    ADD CONSTRAINT class4_fkey_client_group_id FOREIGN KEY (group_id) REFERENCES carrier_group(group_id) ON DELETE SET NULL;


--
-- Name: client_payment class4_fkey_client_payment_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_payment
    ADD CONSTRAINT class4_fkey_client_payment_client_id FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE SET NULL;


--
-- Name: client class4_fkey_client_payment_term_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client
    ADD CONSTRAINT class4_fkey_client_payment_term_id FOREIGN KEY (payment_term_id) REFERENCES payment_term(payment_term_id) ON DELETE SET NULL;


--
-- Name: code class4_fkey_code_code_deck_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY code
    ADD CONSTRAINT class4_fkey_code_code_deck_id FOREIGN KEY (code_deck_id) REFERENCES code_deck(code_deck_id) ON DELETE CASCADE;


--
-- Name: contract_code class4_fkey_contract_code_contract_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY contract_code
    ADD CONSTRAINT class4_fkey_contract_code_contract_id FOREIGN KEY (contract_id) REFERENCES contract(id) ON DELETE CASCADE;


--
-- Name: currency_updates class4_fkey_currency_updates_currency_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY currency_updates
    ADD CONSTRAINT class4_fkey_currency_updates_currency_id FOREIGN KEY (currency_id) REFERENCES currency(currency_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_items class4_fkey_dynamic_route_items_dynamic_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_items
    ADD CONSTRAINT class4_fkey_dynamic_route_items_dynamic_route_id FOREIGN KEY (dynamic_route_id) REFERENCES dynamic_route(dynamic_route_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_items class4_fkey_dynamic_route_items_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_items
    ADD CONSTRAINT class4_fkey_dynamic_route_items_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_override class4_fkey_dynamic_route_override_dynamic_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_override
    ADD CONSTRAINT class4_fkey_dynamic_route_override_dynamic_route_id FOREIGN KEY (dynamic_route_id) REFERENCES dynamic_route(dynamic_route_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_override class4_fkey_dynamic_route_override_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_override
    ADD CONSTRAINT class4_fkey_dynamic_route_override_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_pri class4_fkey_dynamic_route_pri_dynamic_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_pri
    ADD CONSTRAINT class4_fkey_dynamic_route_pri_dynamic_route_id FOREIGN KEY (dynamic_route_id) REFERENCES dynamic_route(dynamic_route_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_pri class4_fkey_dynamic_route_pri_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_pri
    ADD CONSTRAINT class4_fkey_dynamic_route_pri_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_qos class4_fkey_dynamic_route_qos_dynamic_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route_qos
    ADD CONSTRAINT class4_fkey_dynamic_route_qos_dynamic_route_id FOREIGN KEY (dynamic_route_id) REFERENCES dynamic_route(dynamic_route_id) ON DELETE CASCADE;


--
-- Name: dynamic_route class4_fkey_dynamic_route_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dynamic_route
    ADD CONSTRAINT class4_fkey_dynamic_route_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: invoice class4_fkey_invoice_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice
    ADD CONSTRAINT class4_fkey_invoice_client_id FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE CASCADE;


--
-- Name: invoice_item class4_fkey_invoice_item_invoice_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_item
    ADD CONSTRAINT class4_fkey_invoice_item_invoice_id FOREIGN KEY (invoice_id) REFERENCES invoice(invoice_id) ON DELETE CASCADE;


--
-- Name: jurisdiction class4_fkey_jurisdiction_country_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY jurisdiction
    ADD CONSTRAINT class4_fkey_jurisdiction_country_id FOREIGN KEY (jurisdiction_country_id) REFERENCES jurisdiction_country(id) ON DELETE CASCADE;


--
-- Name: order_user_rate_watch class4_fkey_order_user_rate_watch_alert_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_user_rate_watch
    ADD CONSTRAINT class4_fkey_order_user_rate_watch_alert_id FOREIGN KEY (order_user_alert_id) REFERENCES order_user_alert(id);


--
-- Name: product_items class4_fkey_product_items_product_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_items
    ADD CONSTRAINT class4_fkey_product_items_product_id FOREIGN KEY (product_id) REFERENCES product(product_id) ON DELETE CASCADE;


--
-- Name: product_items_resource class4_fkey_product_items_resource_item_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_items_resource
    ADD CONSTRAINT class4_fkey_product_items_resource_item_id FOREIGN KEY (item_id) REFERENCES product_items(item_id) ON DELETE CASCADE;


--
-- Name: product_items_resource class4_fkey_product_items_resource_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_items_resource
    ADD CONSTRAINT class4_fkey_product_items_resource_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: product_items class4_fkey_product_items_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_items
    ADD CONSTRAINT class4_fkey_product_items_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: rate_auto_create_interval class4_fkey_rate_auto_create_interval_rate_create_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_auto_create_interval
    ADD CONSTRAINT class4_fkey_rate_auto_create_interval_rate_create_id FOREIGN KEY (rate_auto_create_id) REFERENCES rate_auto_create(id);


--
-- Name: rate class4_fkey_rate_rate_table_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate
    ADD CONSTRAINT class4_fkey_rate_rate_table_id FOREIGN KEY (rate_table_id) REFERENCES rate_table(rate_table_id) ON DELETE CASCADE;


--
-- Name: rate_table class4_fkey_rate_table_code_deck_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_table
    ADD CONSTRAINT class4_fkey_rate_table_code_deck_id FOREIGN KEY (code_deck_id) REFERENCES code_deck(code_deck_id) ON DELETE SET NULL;


--
-- Name: rate_table class4_fkey_rate_table_currency_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_table
    ADD CONSTRAINT class4_fkey_rate_table_currency_id FOREIGN KEY (currency_id) REFERENCES currency(currency_id) ON DELETE SET NULL;


--
-- Name: rate class4_fkey_rate_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate
    ADD CONSTRAINT class4_fkey_rate_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource_ip_limit class4_fkey_reosurce_ip_limit_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_ip_limit
    ADD CONSTRAINT class4_fkey_reosurce_ip_limit_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource_block class4_fkey_resource_block_ingress_res_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_block
    ADD CONSTRAINT class4_fkey_resource_block_ingress_res_id FOREIGN KEY (ingress_res_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource_block class4_fkey_resource_block_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_block
    ADD CONSTRAINT class4_fkey_resource_block_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource class4_fkey_resource_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT class4_fkey_resource_client_id FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE SET NULL;


--
-- Name: resource_codecs_ref class4_fkey_resource_codec_ref_codec_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_codecs_ref
    ADD CONSTRAINT class4_fkey_resource_codec_ref_codec_id FOREIGN KEY (codec_id) REFERENCES codecs(id) ON DELETE CASCADE;


--
-- Name: resource_codecs_ref class4_fkey_resource_codecs_ref_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_codecs_ref
    ADD CONSTRAINT class4_fkey_resource_codecs_ref_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource_direction class4_fkey_resource_direction_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_direction
    ADD CONSTRAINT class4_fkey_resource_direction_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource_direction_template class4_fkey_resource_direction_template_resource_template_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_direction_template
    ADD CONSTRAINT class4_fkey_resource_direction_template_resource_template_id FOREIGN KEY (resource_template_id) REFERENCES resource_template(resource_template_id) ON DELETE CASCADE;


--
-- Name: resource_direction_template class4_fkey_resource_direction_template_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_direction_template
    ADD CONSTRAINT class4_fkey_resource_direction_template_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource_direction class4_fkey_resource_direction_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_direction
    ADD CONSTRAINT class4_fkey_resource_direction_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource class4_fkey_resource_group_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT class4_fkey_resource_group_id FOREIGN KEY (group_id) REFERENCES trunk_group(group_id) ON DELETE SET NULL;


--
-- Name: resource_ip_limit class4_fkey_resource_ip_limit_ip_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_ip_limit
    ADD CONSTRAINT class4_fkey_resource_ip_limit_ip_id FOREIGN KEY (ip_id) REFERENCES resource_ip(resource_ip_id) ON DELETE CASCADE;


--
-- Name: resource_ip class4_fkey_resource_ip_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_ip
    ADD CONSTRAINT class4_fkey_resource_ip_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource_prefix class4_fkey_resource_prefix_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_prefix
    ADD CONSTRAINT class4_fkey_resource_prefix_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource class4_fkey_resource_rate_table_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT class4_fkey_resource_rate_table_id FOREIGN KEY (rate_table_id) REFERENCES rate_table(rate_table_id) ON DELETE SET NULL;


--
-- Name: resource_replace_action class4_fkey_resource_replace_action_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_replace_action
    ADD CONSTRAINT class4_fkey_resource_replace_action_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id);


--
-- Name: resource class4_fkey_resource_route_strategy_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource
    ADD CONSTRAINT class4_fkey_resource_route_strategy_id FOREIGN KEY (route_strategy_id) REFERENCES route_strategy(route_strategy_id) ON DELETE SET NULL;


--
-- Name: resource_translation_ref class4_fkey_resource_translation_ref_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_translation_ref
    ADD CONSTRAINT class4_fkey_resource_translation_ref_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource_translation_ref class4_fkey_resource_translation_ref_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_translation_ref
    ADD CONSTRAINT class4_fkey_resource_translation_ref_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource_translation_ref class4_fkey_resource_translation_ref_translation_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_translation_ref
    ADD CONSTRAINT class4_fkey_resource_translation_ref_translation_id FOREIGN KEY (translation_id) REFERENCES digit_translation(translation_id) ON DELETE CASCADE;


--
-- Name: role_privilege class4_fkey_role_privilege_role_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY role_privilege
    ADD CONSTRAINT class4_fkey_role_privilege_role_id FOREIGN KEY (role_id) REFERENCES role(role_id);


--
-- Name: role_privilege class4_fkey_role_privilege_system_function_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY role_privilege
    ADD CONSTRAINT class4_fkey_role_privilege_system_function_id FOREIGN KEY (system_function_id) REFERENCES system_function(system_function_id);


--
-- Name: route class4_fkey_route_dynamic_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY route
    ADD CONSTRAINT class4_fkey_route_dynamic_route_id FOREIGN KEY (dynamic_route_id) REFERENCES dynamic_route(dynamic_route_id) ON DELETE SET NULL;


--
-- Name: route class4_fkey_route_route_strategy_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY route
    ADD CONSTRAINT class4_fkey_route_route_strategy_id FOREIGN KEY (route_strategy_id) REFERENCES route_strategy(route_strategy_id) ON DELETE CASCADE;


--
-- Name: route class4_fkey_route_static_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY route
    ADD CONSTRAINT class4_fkey_route_static_route_id FOREIGN KEY (static_route_id) REFERENCES product(product_id) ON DELETE SET NULL;


--
-- Name: sell_order class4_fkey_sell_order_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sell_order
    ADD CONSTRAINT class4_fkey_sell_order_client_id FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE CASCADE;


--
-- Name: sell_order class4_fkey_sell_order_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sell_order
    ADD CONSTRAINT class4_fkey_sell_order_resource_id FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: sell_order class4_fkey_sell_order_user_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sell_order
    ADD CONSTRAINT class4_fkey_sell_order_user_id FOREIGN KEY (user_id) REFERENCES order_user(id) ON DELETE CASCADE;


--
-- Name: signup_ip class4_fkey_signup_ip_signup_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY signup_ip
    ADD CONSTRAINT class4_fkey_signup_ip_signup_id FOREIGN KEY (signup_id) REFERENCES signup(id) ON DELETE CASCADE;


--
-- Name: translation_item class4_fkey_translation_item_translation_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY translation_item
    ADD CONSTRAINT class4_fkey_translation_item_translation_id FOREIGN KEY (translation_id) REFERENCES digit_translation(translation_id) ON DELETE CASCADE;


--
-- Name: buy_order class4_pkey_buy_order_user_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY buy_order
    ADD CONSTRAINT class4_pkey_buy_order_user_id FOREIGN KEY (user_id) REFERENCES order_user(id) ON DELETE CASCADE;


--
-- Name: resource_block class4_pkey_egress; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_block
    ADD CONSTRAINT class4_pkey_egress FOREIGN KEY (engress_res_id) REFERENCES resource(resource_id) ON DELETE SET NULL;


--
-- Name: client_low_balance_config client_low_balance_config_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY client_low_balance_config
    ADD CONSTRAINT client_low_balance_config_client_id_fkey FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE CASCADE;


--
-- Name: did_assign did_assign_egress_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_assign
    ADD CONSTRAINT did_assign_egress_id_fkey FOREIGN KEY (egress_id) REFERENCES resource(resource_id);


--
-- Name: did_request_detail did_request_detail_did_request_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_request_detail
    ADD CONSTRAINT did_request_detail_did_request_id_fkey FOREIGN KEY (did_request_id) REFERENCES did_request(id);


--
-- Name: did_request_detail did_request_detail_egress_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_request_detail
    ADD CONSTRAINT did_request_detail_egress_id_fkey FOREIGN KEY (egress_id) REFERENCES resource(resource_id);


--
-- Name: did_request_detail did_request_detail_number_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY did_request_detail
    ADD CONSTRAINT did_request_detail_number_fkey FOREIGN KEY (number) REFERENCES ingress_did_repository(number) ON DELETE CASCADE;


--
-- Name: egress_profile egress_profile_egress_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY egress_profile
    ADD CONSTRAINT egress_profile_egress_id_fkey FOREIGN KEY (egress_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: egress_profile egress_profile_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY egress_profile
    ADD CONSTRAINT egress_profile_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES switch_profile(id) ON DELETE CASCADE;


--
-- Name: exchange_agent_import_target_push_job exchange_agent_import_target_push_job_import_id_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_import_target_push_job
    ADD CONSTRAINT exchange_agent_import_target_push_job_import_id_pkey FOREIGN KEY (import_id) REFERENCES exchange_agent_import_target_push(id) ON DELETE CASCADE;


--
-- Name: exchange_agent_send_mail_log_list exchange_agent_send_email_log_list; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_send_mail_log_list
    ADD CONSTRAINT exchange_agent_send_email_log_list FOREIGN KEY (client_id) REFERENCES client(client_id) ON DELETE CASCADE;


--
-- Name: exchange_agent_send_mail_log exchange_agent_send_mail_log_email_template_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_send_mail_log
    ADD CONSTRAINT exchange_agent_send_mail_log_email_template_fkey FOREIGN KEY (email_template) REFERENCES exchange_agent_mail_tmplate(id) ON DELETE CASCADE;


--
-- Name: exchange_agent_send_mail_log_list exchange_agent_send_mail_log_list_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_send_mail_log_list
    ADD CONSTRAINT exchange_agent_send_mail_log_list_log_id_fkey FOREIGN KEY (log_id) REFERENCES exchange_agent_send_mail_log(id) ON DELETE CASCADE;


--
-- Name: exchange_agent_user exchange_agent_user_role_id_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_agent_user
    ADD CONSTRAINT exchange_agent_user_role_id_pkey FOREIGN KEY (role_id) REFERENCES exchange_sys_role(role_id);


--
-- Name: exchange_false_del exchange_false_del_resource_id_key; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_false_del
    ADD CONSTRAINT exchange_false_del_resource_id_key FOREIGN KEY (resource_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: exchange_job_list exchange_job_list_job_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_list
    ADD CONSTRAINT exchange_job_list_job_id FOREIGN KEY (job_id) REFERENCES exchange_job(id) ON DELETE CASCADE;


--
-- Name: exchange_job_list exchange_job_list_trunk_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_list
    ADD CONSTRAINT exchange_job_list_trunk_id FOREIGN KEY (trunk_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: exchange_job exchange_job_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job
    ADD CONSTRAINT exchange_job_product_id_fkey FOREIGN KEY (product_id) REFERENCES product_rout_rate_table(id) ON DELETE CASCADE;


--
-- Name: exchange_job_session_block_log exchange_job_session_block_log; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session_block_log
    ADD CONSTRAINT exchange_job_session_block_log FOREIGN KEY (session_id) REFERENCES exchange_job_session(id) ON DELETE CASCADE;


--
-- Name: exchange_job_session_block_log exchange_job_session_block_log_trunk_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session_block_log
    ADD CONSTRAINT exchange_job_session_block_log_trunk_id FOREIGN KEY (trunk_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: exchange_job_session exchange_job_session_job_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session
    ADD CONSTRAINT exchange_job_session_job_id FOREIGN KEY (job_id) REFERENCES exchange_job(id) ON DELETE CASCADE;


--
-- Name: exchange_job_session_list exchange_job_session_list_session_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session_list
    ADD CONSTRAINT exchange_job_session_list_session_id FOREIGN KEY (session_id) REFERENCES exchange_job_session(id) ON DELETE CASCADE;


--
-- Name: exchange_job_session_list exchange_job_session_list_trunk_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_job_session_list
    ADD CONSTRAINT exchange_job_session_list_trunk_id FOREIGN KEY (trunk_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: exchange_par_account exchange_par_account_role_id_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_par_account
    ADD CONSTRAINT exchange_par_account_role_id_pkey FOREIGN KEY (role_id) REFERENCES exchange_sys_role(role_id);


--
-- Name: exchange_simple_session_list exchange_simple_session_list_session_id_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_simple_session_list
    ADD CONSTRAINT exchange_simple_session_list_session_id_pkey FOREIGN KEY (session_id) REFERENCES exchange_simple_session(id) ON DELETE CASCADE;


--
-- Name: exchange_simple_session_list exchange_simple_session_list_trunk_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_simple_session_list
    ADD CONSTRAINT exchange_simple_session_list_trunk_pkey FOREIGN KEY (trunk_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: exchange_sys_pri exchange_sys_pri_pri_module_id_key; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_pri
    ADD CONSTRAINT exchange_sys_pri_pri_module_id_key FOREIGN KEY (module_id) REFERENCES exchange_sys_module(id);


--
-- Name: exchange_sys_role_pri exchange_sys_role_pri_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_role_pri
    ADD CONSTRAINT exchange_sys_role_pri_id_fkey FOREIGN KEY (pri_id) REFERENCES exchange_sys_pri(id);


--
-- Name: exchange_sys_role_pri exchange_sys_role_pri_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY exchange_sys_role_pri
    ADD CONSTRAINT exchange_sys_role_pri_role_id_fkey FOREIGN KEY (role_id) REFERENCES exchange_sys_role(role_id);


--
-- Name: product_agents_ref fkey_product_agent_agent_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_agents_ref
    ADD CONSTRAINT fkey_product_agent_agent_id FOREIGN KEY (agent_id) REFERENCES agent(agent_id) ON DELETE CASCADE;


--
-- Name: product_agents_ref fkey_product_agent_product_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_agents_ref
    ADD CONSTRAINT fkey_product_agent_product_id FOREIGN KEY (product_id) REFERENCES product_route_rate_table(id) ON DELETE CASCADE;


--
-- Name: fraud_detection_log_detail fraud_detection_log_detail_fraud_detection_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fraud_detection_log_detail
    ADD CONSTRAINT fraud_detection_log_detail_fraud_detection_log_id_fkey FOREIGN KEY (fraud_detection_log_id) REFERENCES fraud_detection_log(id) ON DELETE CASCADE;


--
-- Name: fraud_detection_log fraud_detection_log_fraud_detection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fraud_detection_log
    ADD CONSTRAINT fraud_detection_log_fraud_detection_id_fkey FOREIGN KEY (fraud_detection_id) REFERENCES fraud_detection(id) ON DELETE CASCADE;


--
-- Name: hang_calls_list hang_calls_list_hang_calls_history_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY hang_calls_list
    ADD CONSTRAINT hang_calls_list_hang_calls_history_id_fkey FOREIGN KEY (hang_calls_history_id) REFERENCES hang_calls_history(id);


--
-- Name: ingress_did_repository ingress_did_repository_egress_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ingress_did_repository
    ADD CONSTRAINT ingress_did_repository_egress_id_fkey FOREIGN KEY (egress_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: ingress_did_repository ingress_did_repository_ingress_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ingress_did_repository
    ADD CONSTRAINT ingress_did_repository_ingress_id_fkey FOREIGN KEY (ingress_id) REFERENCES resource(resource_id) ON DELETE CASCADE;


--
-- Name: invalid_detection_block_log invalid_detection_block_log_rule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_detection_block_log
    ADD CONSTRAINT invalid_detection_block_log_rule_id_fkey FOREIGN KEY (rule_id) REFERENCES invalid_number_detection(id) ON DELETE CASCADE;


--
-- Name: invalid_number_detection_log_detail invalid_number_detection_log_detail_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_number_detection_log_detail
    ADD CONSTRAINT invalid_number_detection_log_detail_log_id_fkey FOREIGN KEY (log_id) REFERENCES invalid_number_detection_log(id) ON DELETE CASCADE;


--
-- Name: invalid_number_detection_log invalid_number_detection_log_detection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invalid_number_detection_log
    ADD CONSTRAINT invalid_number_detection_log_detection_id_fkey FOREIGN KEY (detection_id) REFERENCES invalid_number_detection(id) ON DELETE CASCADE;


--
-- Name: invoice_calls_detail_by_trunk invoice_calls_detail_by_trunk_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_calls_detail_by_trunk
    ADD CONSTRAINT invoice_calls_detail_by_trunk_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: invoice_calls_total_by_trunk invoice_calls_total_by_trunk_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_calls_total_by_trunk
    ADD CONSTRAINT invoice_calls_total_by_trunk_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: invoice_show_code_100 invoice_show_code_100_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_show_code_100
    ADD CONSTRAINT invoice_show_code_100_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: invoice_show_code_name invoice_show_code_name_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_show_code_name
    ADD CONSTRAINT invoice_show_code_name_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: invoice_show_country invoice_show_country_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_show_country
    ADD CONSTRAINT invoice_show_country_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: invoice_show_date invoice_show_date_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY invoice_show_date
    ADD CONSTRAINT invoice_show_date_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: lnp_request_detail lnp_request_detail_request_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY lnp_request_detail
    ADD CONSTRAINT lnp_request_detail_request_id_fkey FOREIGN KEY (request_id) REFERENCES lnp_request(id);


--
-- Name: mail_cdr_log_detail mail_cdr_log_detail_mail_cdr_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY mail_cdr_log_detail
    ADD CONSTRAINT mail_cdr_log_detail_mail_cdr_log_id_fkey FOREIGN KEY (mail_cdr_log_id) REFERENCES mail_cdr_log(id);


--
-- Name: ocn_lata ocn_lata_rate_table_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ocn_lata
    ADD CONSTRAINT ocn_lata_rate_table_id_fkey FOREIGN KEY (rate_table_id) REFERENCES rate_table(rate_table_id);


--
-- Name: order_user order_user_role_id_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY order_user
    ADD CONSTRAINT order_user_role_id_pkey FOREIGN KEY (role_id) REFERENCES exchange_sys_role(role_id);


--
-- Name: payment_invoice payment_invoice_invoice_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY payment_invoice
    ADD CONSTRAINT payment_invoice_invoice_id_fkey FOREIGN KEY (invoice_id) REFERENCES invoice(invoice_id);


--
-- Name: payment_invoice payment_invoice_payment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY payment_invoice
    ADD CONSTRAINT payment_invoice_payment_id_fkey FOREIGN KEY (payment_id) REFERENCES client_payment(client_payment_id);


--
-- Name: product_route_rate_table product_route_rate_table_rate_table_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_route_rate_table
    ADD CONSTRAINT product_route_rate_table_rate_table_id_fkey FOREIGN KEY (rate_table_id) REFERENCES rate_table(rate_table_id) ON DELETE CASCADE;


--
-- Name: product_route_rate_table product_route_rate_table_route_strategy_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY product_route_rate_table
    ADD CONSTRAINT product_route_rate_table_route_strategy_id_fkey FOREIGN KEY (route_strategy_id) REFERENCES route_strategy(route_strategy_id) ON DELETE CASCADE;


--
-- Name: rate_generation_code_deck rate_generation_code_deck_rate_generation_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_code_deck
    ADD CONSTRAINT rate_generation_code_deck_rate_generation_template_id_fkey FOREIGN KEY (rate_generation_template_id) REFERENCES rate_generation_template(id);


--
-- Name: rate_generation_history_detail rate_generation_history_detail_email_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_history_detail
    ADD CONSTRAINT rate_generation_history_detail_email_template_id_fkey FOREIGN KEY (email_template_id) REFERENCES rate_email_template(id) ON DELETE SET NULL;


--
-- Name: rate_generation_history_detail rate_generation_history_detail_rate_generation_history_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_history_detail
    ADD CONSTRAINT rate_generation_history_detail_rate_generation_history_id_fkey FOREIGN KEY (rate_generation_history_id) REFERENCES rate_generation_history(id) ON DELETE CASCADE;


--
-- Name: rate_generation_history rate_generation_history_rate_generation_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_history
    ADD CONSTRAINT rate_generation_history_rate_generation_template_id_fkey FOREIGN KEY (rate_generation_template_id) REFERENCES rate_generation_template(id) ON DELETE CASCADE;


--
-- Name: rate_generation_template_detail rate_generation_template_detai_rate_generation_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_template_detail
    ADD CONSTRAINT rate_generation_template_detai_rate_generation_template_id_fkey FOREIGN KEY (rate_generation_template_id) REFERENCES rate_generation_template(id) ON DELETE CASCADE;


--
-- Name: rate_generation_template_margin rate_generation_template_margi_rate_generation_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_generation_template_margin
    ADD CONSTRAINT rate_generation_template_margi_rate_generation_template_id_fkey FOREIGN KEY (rate_generation_template_id) REFERENCES rate_generation_template(id) ON DELETE CASCADE;


--
-- Name: rate_mail_decks_files rate_mail_decks_files_rate_mail_decks_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_mail_decks_files
    ADD CONSTRAINT rate_mail_decks_files_rate_mail_decks_id_fkey FOREIGN KEY (rate_mail_decks_id) REFERENCES rate_mail_decks(id);


--
-- Name: rate_management_option rate_management_option_rate_table_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_management_option
    ADD CONSTRAINT rate_management_option_rate_table_id_fkey FOREIGN KEY (rate_table_id) REFERENCES rate_table(rate_table_id) ON DELETE CASCADE;


--
-- Name: rate_send_log_detail rate_send_log_detail_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rate_send_log_detail
    ADD CONSTRAINT rate_send_log_detail_log_id_fkey FOREIGN KEY (log_id) REFERENCES rate_send_log(id) ON DELETE CASCADE;


--
-- Name: rerate_cdr_download_log rerate_cdr_download_log_task_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rerate_cdr_download_log
    ADD CONSTRAINT rerate_cdr_download_log_task_id_fkey FOREIGN KEY (task_id) REFERENCES rerate_cdr_task(id) ON DELETE SET NULL;


--
-- Name: rerate_report_exec_log rerate_report_exec_log_task_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rerate_report_exec_log
    ADD CONSTRAINT rerate_report_exec_log_task_id_fkey FOREIGN KEY (task_id) REFERENCES rerate_cdr_task(id) ON DELETE SET NULL;


--
-- Name: reseller_client reseller_client_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY reseller_client
    ADD CONSTRAINT reseller_client_client_id_fkey FOREIGN KEY (client_id) REFERENCES client(client_id);


--
-- Name: reseller_client reseller_client_reseller_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY reseller_client
    ADD CONSTRAINT reseller_client_reseller_id_fkey FOREIGN KEY (reseller_id) REFERENCES reseller(id);


--
-- Name: resource_next_route_rule_template resource_next_route_rule_template_resource_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_next_route_rule_template
    ADD CONSTRAINT resource_next_route_rule_template_resource_template_id_fkey FOREIGN KEY (resource_template_id) REFERENCES resource_template(resource_template_id) ON DELETE CASCADE;


--
-- Name: resource_replace_action_template resource_replace_action_template_resource_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY resource_replace_action_template
    ADD CONSTRAINT resource_replace_action_template_resource_template_id_fkey FOREIGN KEY (resource_template_id) REFERENCES resource_template(resource_template_id) ON DELETE CASCADE;


--
-- Name: sys_pri sys_pri_pri_module_id_key; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sys_pri
    ADD CONSTRAINT sys_pri_pri_module_id_key FOREIGN KEY (module_id) REFERENCES sys_module(id) ON DELETE CASCADE;


--
-- Name: sys_role_pri sys_role_pri_pri_name_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sys_role_pri
    ADD CONSTRAINT sys_role_pri_pri_name_fkey FOREIGN KEY (pri_name) REFERENCES sys_pri(pri_name) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: sys_role_pri sys_role_pri_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY sys_role_pri
    ADD CONSTRAINT sys_role_pri_role_id_fkey FOREIGN KEY (role_id) REFERENCES sys_role(role_id);


--
-- Name: users_limit users_limit_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY users_limit
    ADD CONSTRAINT users_limit_client_id_fkey FOREIGN KEY (client_id) REFERENCES client(client_id);


--
-- Name: users_limit users_limit_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY users_limit
    ADD CONSTRAINT users_limit_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(user_id);


--
-- Name: vendor_invoice_detail vendor_invoice_detail_vendor_invoice_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendor_invoice_detail
    ADD CONSTRAINT vendor_invoice_detail_vendor_invoice_id_fkey FOREIGN KEY (vendor_invoice_id) REFERENCES vendor_invoice(vendor_invoice_id) ON DELETE CASCADE;


--
-- Name: vendor_invoice_dispute vendor_invoice_dispute_vendor_invoice_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY vendor_invoice_dispute
    ADD CONSTRAINT vendor_invoice_dispute_vendor_invoice_id_fkey FOREIGN KEY (vendor_invoice_id) REFERENCES vendor_invoice(vendor_invoice_id) ON DELETE CASCADE;


--
-- Name: switch_profile voip_server_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY switch_profile
    ADD CONSTRAINT voip_server_id FOREIGN KEY (voip_gateway_id) REFERENCES voip_gateway(id);


--
-- PostgreSQL database dump complete
--

