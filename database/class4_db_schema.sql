--
-- PostgreSQL database dump
--

-- Dumped from database version 9.6.10
-- Dumped by pg_dump version 9.6.10

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: pgagent; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA pgagent;


ALTER SCHEMA pgagent OWNER TO postgres;

--
-- Name: SCHEMA pgagent; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA pgagent IS 'pgAgent system tables';


--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: gbtreekey16; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.gbtreekey16;


--
-- Name: gbtreekey16_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbtreekey16_in(cstring) RETURNS public.gbtreekey16
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_in';


ALTER FUNCTION public.gbtreekey16_in(cstring) OWNER TO postgres;

--
-- Name: gbtreekey16_out(public.gbtreekey16); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbtreekey16_out(public.gbtreekey16) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_out';


ALTER FUNCTION public.gbtreekey16_out(public.gbtreekey16) OWNER TO postgres;

--
-- Name: gbtreekey16; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.gbtreekey16 (
    INTERNALLENGTH = 16,
    INPUT = public.gbtreekey16_in,
    OUTPUT = public.gbtreekey16_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE public.gbtreekey16 OWNER TO postgres;

--
-- Name: gbtreekey32; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.gbtreekey32;


--
-- Name: gbtreekey32_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbtreekey32_in(cstring) RETURNS public.gbtreekey32
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_in';


ALTER FUNCTION public.gbtreekey32_in(cstring) OWNER TO postgres;

--
-- Name: gbtreekey32_out(public.gbtreekey32); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbtreekey32_out(public.gbtreekey32) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_out';


ALTER FUNCTION public.gbtreekey32_out(public.gbtreekey32) OWNER TO postgres;

--
-- Name: gbtreekey32; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.gbtreekey32 (
    INTERNALLENGTH = 32,
    INPUT = public.gbtreekey32_in,
    OUTPUT = public.gbtreekey32_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE public.gbtreekey32 OWNER TO postgres;

--
-- Name: gbtreekey4; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.gbtreekey4;


--
-- Name: gbtreekey4_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbtreekey4_in(cstring) RETURNS public.gbtreekey4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_in';


ALTER FUNCTION public.gbtreekey4_in(cstring) OWNER TO postgres;

--
-- Name: gbtreekey4_out(public.gbtreekey4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbtreekey4_out(public.gbtreekey4) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_out';


ALTER FUNCTION public.gbtreekey4_out(public.gbtreekey4) OWNER TO postgres;

--
-- Name: gbtreekey4; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.gbtreekey4 (
    INTERNALLENGTH = 4,
    INPUT = public.gbtreekey4_in,
    OUTPUT = public.gbtreekey4_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE public.gbtreekey4 OWNER TO postgres;

--
-- Name: gbtreekey8; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.gbtreekey8;


--
-- Name: gbtreekey8_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbtreekey8_in(cstring) RETURNS public.gbtreekey8
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_in';


ALTER FUNCTION public.gbtreekey8_in(cstring) OWNER TO postgres;

--
-- Name: gbtreekey8_out(public.gbtreekey8); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbtreekey8_out(public.gbtreekey8) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_out';


ALTER FUNCTION public.gbtreekey8_out(public.gbtreekey8) OWNER TO postgres;

--
-- Name: gbtreekey8; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.gbtreekey8 (
    INTERNALLENGTH = 8,
    INPUT = public.gbtreekey8_in,
    OUTPUT = public.gbtreekey8_out,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE public.gbtreekey8 OWNER TO postgres;

--
-- Name: gbtreekey_var; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.gbtreekey_var;


--
-- Name: gbtreekey_var_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbtreekey_var_in(cstring) RETURNS public.gbtreekey_var
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_in';


ALTER FUNCTION public.gbtreekey_var_in(cstring) OWNER TO postgres;

--
-- Name: gbtreekey_var_out(public.gbtreekey_var); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbtreekey_var_out(public.gbtreekey_var) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbtreekey_out';


ALTER FUNCTION public.gbtreekey_var_out(public.gbtreekey_var) OWNER TO postgres;

--
-- Name: gbtreekey_var; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.gbtreekey_var (
    INTERNALLENGTH = variable,
    INPUT = public.gbtreekey_var_in,
    OUTPUT = public.gbtreekey_var_out,
    ALIGNMENT = int4,
    STORAGE = extended
);


ALTER TYPE public.gbtreekey_var OWNER TO postgres;

--
-- Name: ip4; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.ip4;


--
-- Name: ip4_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_in(cstring) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_in';


ALTER FUNCTION public.ip4_in(cstring) OWNER TO postgres;

--
-- Name: ip4_out(public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_out(public.ip4) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_out';


ALTER FUNCTION public.ip4_out(public.ip4) OWNER TO postgres;

--
-- Name: ip4_recv(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_recv(internal) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_recv';


ALTER FUNCTION public.ip4_recv(internal) OWNER TO postgres;

--
-- Name: ip4_send(public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_send(public.ip4) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_send';


ALTER FUNCTION public.ip4_send(public.ip4) OWNER TO postgres;

--
-- Name: ip4; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.ip4 (
    INTERNALLENGTH = 4,
    INPUT = public.ip4_in,
    OUTPUT = public.ip4_out,
    RECEIVE = public.ip4_recv,
    SEND = public.ip4_send,
    ALIGNMENT = int4,
    STORAGE = plain,
    PASSEDBYVALUE
);


ALTER TYPE public.ip4 OWNER TO postgres;

--
-- Name: TYPE ip4; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE public.ip4 IS 'IPv4 address ''#.#.#.#''';


--
-- Name: ip4r; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.ip4r;


--
-- Name: ip4r_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_in(cstring) RETURNS public.ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_in';


ALTER FUNCTION public.ip4r_in(cstring) OWNER TO postgres;

--
-- Name: ip4r_out(public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_out(public.ip4r) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_out';


ALTER FUNCTION public.ip4r_out(public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_recv(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_recv(internal) RETURNS public.ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_recv';


ALTER FUNCTION public.ip4r_recv(internal) OWNER TO postgres;

--
-- Name: ip4r_send(public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_send(public.ip4r) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_send';


ALTER FUNCTION public.ip4r_send(public.ip4r) OWNER TO postgres;

--
-- Name: ip4r; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.ip4r (
    INTERNALLENGTH = 8,
    INPUT = public.ip4r_in,
    OUTPUT = public.ip4r_out,
    RECEIVE = public.ip4r_recv,
    SEND = public.ip4r_send,
    ELEMENT = public.ip4,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE public.ip4r OWNER TO postgres;

--
-- Name: TYPE ip4r; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE public.ip4r IS 'IPv4 range ''#.#.#.#-#.#.#.#'' or ''#.#.#.#/#'' or ''#.#.#.#''';


--
-- Name: numtype; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.numtype AS (
	num numeric,
	count integer
);


ALTER TYPE public.numtype OWNER TO postgres;

--
-- Name: prefix_range; Type: SHELL TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.prefix_range;


--
-- Name: prefix_range_in(cstring); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_in(cstring) RETURNS public.prefix_range
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_in';


ALTER FUNCTION public.prefix_range_in(cstring) OWNER TO postgres;

--
-- Name: prefix_range_out(public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_out(public.prefix_range) RETURNS cstring
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_out';


ALTER FUNCTION public.prefix_range_out(public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_recv(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_recv(internal) RETURNS public.prefix_range
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_recv';


ALTER FUNCTION public.prefix_range_recv(internal) OWNER TO postgres;

--
-- Name: prefix_range_send(public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_send(public.prefix_range) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_send';


ALTER FUNCTION public.prefix_range_send(public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.prefix_range (
    INTERNALLENGTH = variable,
    INPUT = public.prefix_range_in,
    OUTPUT = public.prefix_range_out,
    RECEIVE = public.prefix_range_recv,
    SEND = public.prefix_range_send,
    ALIGNMENT = int4,
    STORAGE = plain
);


ALTER TYPE public.prefix_range OWNER TO postgres;

--
-- Name: TYPE prefix_range; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE public.prefix_range IS 'prefix range: (prefix)?([a-b])?';


--
-- Name: summmaryreporttype; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.summmaryreporttype AS (
	acd_24h bigint,
	pdd_24h bigint,
	asr_24h numeric,
	ca_24h bigint,
	res_id text
);


ALTER TYPE public.summmaryreporttype OWNER TO postgres;

--
-- Name: TYPE summmaryreporttype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TYPE public.summmaryreporttype IS 'ç»Ÿè®¡æŠ¥è¡¨ç±»åž‹';


--
-- Name: sumtype; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.sumtype AS (
	year integer,
	month integer,
	day integer,
	hour integer,
	minute integer,
	callvalue numeric,
	cpsvalue numeric
);


ALTER TYPE public.sumtype OWNER TO postgres;

--
-- Name: tablefunc_crosstab_2; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.tablefunc_crosstab_2 AS (
	row_name text,
	category_1 text,
	category_2 text
);


ALTER TYPE public.tablefunc_crosstab_2 OWNER TO postgres;

--
-- Name: tablefunc_crosstab_3; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.tablefunc_crosstab_3 AS (
	row_name text,
	category_1 text,
	category_2 text,
	category_3 text
);


ALTER TYPE public.tablefunc_crosstab_3 OWNER TO postgres;

--
-- Name: tablefunc_crosstab_4; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.tablefunc_crosstab_4 AS (
	row_name text,
	category_1 text,
	category_2 text,
	category_3 text,
	category_4 text
);


ALTER TYPE public.tablefunc_crosstab_4 OWNER TO postgres;

--
-- Name: pga_exception_trigger(); Type: FUNCTION; Schema: pgagent; Owner: postgres
--

CREATE FUNCTION pgagent.pga_exception_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE

    jobid int4 := 0;

BEGIN

     IF TG_OP = 'DELETE' THEN

        SELECT INTO jobid jscjobid FROM pgagent.pga_schedule WHERE jscid = OLD.jexscid;

        -- update pga_job from remaining schedules
        -- the actual calculation of jobnextrun will be performed in the trigger
        UPDATE pgagent.pga_job
           SET jobnextrun = NULL
         WHERE jobenabled AND jobid=jobid;
        RETURN OLD;
    ELSE

        SELECT INTO jobid jscjobid FROM pgagent.pga_schedule WHERE jscid = NEW.jexscid;

        UPDATE pgagent.pga_job
           SET jobnextrun = NULL
         WHERE jobenabled AND jobid=jobid;
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION pgagent.pga_exception_trigger() OWNER TO postgres;

--
-- Name: FUNCTION pga_exception_trigger(); Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON FUNCTION pgagent.pga_exception_trigger() IS 'Update the job''s next run time whenever an exception changes';


--
-- Name: pga_is_leap_year(smallint); Type: FUNCTION; Schema: pgagent; Owner: postgres
--

CREATE FUNCTION pgagent.pga_is_leap_year(smallint) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
BEGIN
    IF $1 % 4 != 0 THEN
        RETURN FALSE;
    END IF;

    IF $1 % 100 != 0 THEN
        RETURN TRUE;
    END IF;

    RETURN $1 % 400 = 0;
END;
$_$;


ALTER FUNCTION pgagent.pga_is_leap_year(smallint) OWNER TO postgres;

--
-- Name: FUNCTION pga_is_leap_year(smallint); Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON FUNCTION pgagent.pga_is_leap_year(smallint) IS 'Returns TRUE is $1 is a leap year';


--
-- Name: pga_job_trigger(); Type: FUNCTION; Schema: pgagent; Owner: postgres
--

CREATE FUNCTION pgagent.pga_job_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.jobenabled THEN
        IF NEW.jobnextrun IS NULL THEN
             SELECT INTO NEW.jobnextrun
                    MIN(pgagent.pga_next_schedule(jscid, jscstart, jscend, jscminutes, jschours, jscweekdays, jscmonthdays, jscmonths))
               FROM pgagent.pga_schedule
              WHERE jscenabled AND jscjobid=OLD.jobid;
        END IF;
    ELSE
        NEW.jobnextrun := NULL;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION pgagent.pga_job_trigger() OWNER TO postgres;

--
-- Name: FUNCTION pga_job_trigger(); Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON FUNCTION pgagent.pga_job_trigger() IS 'Update the job''s next run time.';


--
-- Name: pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]); Type: FUNCTION; Schema: pgagent; Owner: postgres
--

CREATE FUNCTION pgagent.pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
DECLARE
    jscid           ALIAS FOR $1;
    jscstart        ALIAS FOR $2;
    jscend          ALIAS FOR $3;
    jscminutes      ALIAS FOR $4;
    jschours        ALIAS FOR $5;
    jscweekdays     ALIAS FOR $6;
    jscmonthdays    ALIAS FOR $7;
    jscmonths       ALIAS FOR $8;

    nextrun         timestamp := '1970-01-01 00:00:00-00';
    runafter        timestamp := '1970-01-01 00:00:00-00';

    bingo            bool := FALSE;
    gotit            bool := FALSE;
    foundval        bool := FALSE;
    daytweak        bool := FALSE;
    minutetweak        bool := FALSE;

    i                int2 := 0;
    d                int2 := 0;

    nextminute        int2 := 0;
    nexthour        int2 := 0;
    nextday            int2 := 0;
    nextmonth       int2 := 0;
    nextyear        int2 := 0;


BEGIN
    -- No valid start date has been specified
    IF jscstart IS NULL THEN RETURN NULL; END IF;

    -- The schedule is past its end date
    IF jscend IS NOT NULL AND jscend < now() THEN RETURN NULL; END IF;

    -- Get the time to find the next run after. It will just be the later of
    -- now() + 1m and the start date for the time being, however, we might want to
    -- do more complex things using this value in the future.
    IF date_trunc('MINUTE', jscstart) > date_trunc('MINUTE', (now() + '1 Minute'::interval)) THEN
        runafter := date_trunc('MINUTE', jscstart);
    ELSE
        runafter := date_trunc('MINUTE', (now() + '1 Minute'::interval));
    END IF;

    --
    -- Enter a loop, generating next run timestamps until we find one
    -- that falls on the required weekday, and is not matched by an exception
    --

    WHILE bingo = FALSE LOOP

        --
        -- Get the next run year
        --
        nextyear := date_part('YEAR', runafter);

        --
        -- Get the next run month
        --
        nextmonth := date_part('MONTH', runafter);
        gotit := FALSE;
        FOR i IN (nextmonth) .. 12 LOOP
            IF jscmonths[i] = TRUE THEN
                nextmonth := i;
                gotit := TRUE;
                foundval := TRUE;
                EXIT;
            END IF;
        END LOOP;
        IF gotit = FALSE THEN
            FOR i IN 1 .. (nextmonth - 1) LOOP
                IF jscmonths[i] = TRUE THEN
                    nextmonth := i;

                    -- Wrap into next year
                    nextyear := nextyear + 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
           END LOOP;
        END IF;

        --
        -- Get the next run day
        --
        -- If the year, or month have incremented, get the lowest day,
        -- otherwise look for the next day matching or after today.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter)) THEN
            nextday := 1;
            FOR i IN 1 .. 32 LOOP
                IF jscmonthdays[i] = TRUE THEN
                    nextday := i;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nextday := date_part('DAY', runafter);
            gotit := FALSE;
            FOR i IN nextday .. 32 LOOP
                IF jscmonthdays[i] = TRUE THEN
                    nextday := i;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. (nextday - 1) LOOP
                    IF jscmonthdays[i] = TRUE THEN
                        nextday := i;

                        -- Wrap into next month
                        IF nextmonth = 12 THEN
                            nextyear := nextyear + 1;
                            nextmonth := 1;
                        ELSE
                            nextmonth := nextmonth + 1;
                        END IF;
                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        -- Was the last day flag selected?
        IF nextday = 32 THEN
            IF nextmonth = 1 THEN
                nextday := 31;
            ELSIF nextmonth = 2 THEN
                IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                    nextday := 29;
                ELSE
                    nextday := 28;
                END IF;
            ELSIF nextmonth = 3 THEN
                nextday := 31;
            ELSIF nextmonth = 4 THEN
                nextday := 30;
            ELSIF nextmonth = 5 THEN
                nextday := 31;
            ELSIF nextmonth = 6 THEN
                nextday := 30;
            ELSIF nextmonth = 7 THEN
                nextday := 31;
            ELSIF nextmonth = 8 THEN
                nextday := 31;
            ELSIF nextmonth = 9 THEN
                nextday := 30;
            ELSIF nextmonth = 10 THEN
                nextday := 31;
            ELSIF nextmonth = 11 THEN
                nextday := 30;
            ELSIF nextmonth = 12 THEN
                nextday := 31;
            END IF;
        END IF;

        --
        -- Get the next run hour
        --
        -- If the year, month or day have incremented, get the lowest hour,
        -- otherwise look for the next hour matching or after the current one.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter) OR nextday > date_part('DAY', runafter) OR daytweak = TRUE) THEN
            nexthour := 0;
            FOR i IN 1 .. 24 LOOP
                IF jschours[i] = TRUE THEN
                    nexthour := i - 1;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nexthour := date_part('HOUR', runafter);
            gotit := FALSE;
            FOR i IN (nexthour + 1) .. 24 LOOP
                IF jschours[i] = TRUE THEN
                    nexthour := i - 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. nexthour LOOP
                    IF jschours[i] = TRUE THEN
                        nexthour := i - 1;

                        -- Wrap into next month
                        IF (nextmonth = 1 OR nextmonth = 3 OR nextmonth = 5 OR nextmonth = 7 OR nextmonth = 8 OR nextmonth = 10 OR nextmonth = 12) THEN
                            d = 31;
                        ELSIF (nextmonth = 4 OR nextmonth = 6 OR nextmonth = 9 OR nextmonth = 11) THEN
                            d = 30;
                        ELSE
                            IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                                d := 29;
                            ELSE
                                d := 28;
                            END IF;
                        END IF;

                        IF nextday = d THEN
                            nextday := 1;
                            IF nextmonth = 12 THEN
                                nextyear := nextyear + 1;
                                nextmonth := 1;
                            ELSE
                                nextmonth := nextmonth + 1;
                            END IF;
                        ELSE
                            nextday := nextday + 1;
                        END IF;

                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        --
        -- Get the next run minute
        --
        -- If the year, month day or hour have incremented, get the lowest minute,
        -- otherwise look for the next minute matching or after the current one.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter) OR nextday > date_part('DAY', runafter) OR nexthour > date_part('HOUR', runafter) OR daytweak = TRUE) THEN
            nextminute := 0;
            IF minutetweak = TRUE THEN
        d := 1;
            ELSE
        d := date_part('YEAR', runafter)::int2;
            END IF;
            FOR i IN d .. 60 LOOP
                IF jscminutes[i] = TRUE THEN
                    nextminute := i - 1;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nextminute := date_part('MINUTE', runafter);
            gotit := FALSE;
            FOR i IN (nextminute + 1) .. 60 LOOP
                IF jscminutes[i] = TRUE THEN
                    nextminute := i - 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. nextminute LOOP
                    IF jscminutes[i] = TRUE THEN
                        nextminute := i - 1;

                        -- Wrap into next hour
                        IF (nextmonth = 1 OR nextmonth = 3 OR nextmonth = 5 OR nextmonth = 7 OR nextmonth = 8 OR nextmonth = 10 OR nextmonth = 12) THEN
                            d = 31;
                        ELSIF (nextmonth = 4 OR nextmonth = 6 OR nextmonth = 9 OR nextmonth = 11) THEN
                            d = 30;
                        ELSE
                            IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                                d := 29;
                            ELSE
                                d := 28;
                            END IF;
                        END IF;

                        IF nexthour = 23 THEN
                            nexthour = 0;
                            IF nextday = d THEN
                                nextday := 1;
                                IF nextmonth = 12 THEN
                                    nextyear := nextyear + 1;
                                    nextmonth := 1;
                                ELSE
                                    nextmonth := nextmonth + 1;
                                END IF;
                            ELSE
                                nextday := nextday + 1;
                            END IF;
                        ELSE
                            nexthour := nexthour + 1;
                        END IF;

                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        -- Build the result, and check it is not the same as runafter - this may
        -- happen if all array entries are set to false. In this case, add a minute.

        nextrun := (nextyear::varchar || '-'::varchar || nextmonth::varchar || '-' || nextday::varchar || ' ' || nexthour::varchar || ':' || nextminute::varchar)::timestamptz;

        IF nextrun = runafter AND foundval = FALSE THEN
                nextrun := nextrun + INTERVAL '1 Minute';
        END IF;

        -- If the result is past the end date, exit.
        IF nextrun > jscend THEN
            RETURN NULL;
        END IF;

        -- Check to ensure that the nextrun time is actually still valid. Its
        -- possible that wrapped values may have carried the nextrun onto an
        -- invalid time or date.
        IF ((jscminutes = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jscminutes[date_part('MINUTE', nextrun) + 1] = TRUE) AND
            (jschours = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jschours[date_part('HOUR', nextrun) + 1] = TRUE) AND
            (jscmonthdays = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jscmonthdays[date_part('DAY', nextrun)] = TRUE OR
            (jscmonthdays = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,t}' AND
             ((date_part('MONTH', nextrun) IN (1,3,5,7,8,10,12) AND date_part('DAY', nextrun) = 31) OR
              (date_part('MONTH', nextrun) IN (4,6,9,11) AND date_part('DAY', nextrun) = 30) OR
              (date_part('MONTH', nextrun) = 2 AND ((pgagent.pga_is_leap_year(date_part('DAY', nextrun)::int2) AND date_part('DAY', nextrun) = 29) OR date_part('DAY', nextrun) = 28))))) AND
            (jscmonths = '{f,f,f,f,f,f,f,f,f,f,f,f}' OR jscmonths[date_part('MONTH', nextrun)] = TRUE)) THEN


            -- Now, check to see if the nextrun time found is a) on an acceptable
            -- weekday, and b) not matched by an exception. If not, set
            -- runafter = nextrun and try again.

            -- Check for a wildcard weekday
            gotit := FALSE;
            FOR i IN 1 .. 7 LOOP
                IF jscweekdays[i] = TRUE THEN
                    gotit := TRUE;
                    EXIT;
                END IF;
            END LOOP;

            -- OK, is the correct weekday selected, or a wildcard?
            IF (jscweekdays[date_part('DOW', nextrun) + 1] = TRUE OR gotit = FALSE) THEN

                -- Check for exceptions
                SELECT INTO d jexid FROM pgagent.pga_exception WHERE jexscid = jscid AND ((jexdate = nextrun::date AND jextime = nextrun::time) OR (jexdate = nextrun::date AND jextime IS NULL) OR (jexdate IS NULL AND jextime = nextrun::time));
                IF FOUND THEN
                    -- Nuts - found an exception. Increment the time and try again
                    runafter := nextrun + INTERVAL '1 Minute';
                    bingo := FALSE;
                    minutetweak := TRUE;
            daytweak := FALSE;
                ELSE
                    bingo := TRUE;
                END IF;
            ELSE
                -- We're on the wrong week day - increment a day and try again.
                runafter := nextrun + INTERVAL '1 Day';
                bingo := FALSE;
                minutetweak := FALSE;
                daytweak := TRUE;
            END IF;

        ELSE
            runafter := nextrun + INTERVAL '1 Minute';
            bingo := FALSE;
            minutetweak := TRUE;
        daytweak := FALSE;
        END IF;

    END LOOP;

    RETURN nextrun;
END;
$_$;


ALTER FUNCTION pgagent.pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]) OWNER TO postgres;

--
-- Name: FUNCTION pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]); Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON FUNCTION pgagent.pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]) IS 'Calculates the next runtime for a given schedule';


--
-- Name: pga_schedule_trigger(); Type: FUNCTION; Schema: pgagent; Owner: postgres
--

CREATE FUNCTION pgagent.pga_schedule_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        -- update pga_job from remaining schedules
        -- the actual calculation of jobnextrun will be performed in the trigger
        UPDATE pgagent.pga_job
           SET jobnextrun = NULL
         WHERE jobenabled AND jobid=OLD.jscjobid;
        RETURN OLD;
    ELSE
        UPDATE pgagent.pga_job
           SET jobnextrun = NULL
         WHERE jobenabled AND jobid=NEW.jscjobid;
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION pgagent.pga_schedule_trigger() OWNER TO postgres;

--
-- Name: FUNCTION pga_schedule_trigger(); Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON FUNCTION pgagent.pga_schedule_trigger() IS 'Update the job''s next run time whenever a schedule changes';


--
-- Name: actual_trans(timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.actual_trans(timestamp with time zone, timestamp with time zone, integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	start_time alias for $1;
	end_time alias for $2;
	id_client alias for $3;
	trans_type alias for $4;
	r record;
	invoice_start_time timestamp with time zone;
	invoice_end_time timestamp with time zone;
	cdr_start_time timestamp with time zone;
	cdr_end_time timestamp with time zone;

begin

	--if id_client > 0 then
		--invoice_start_time := 0;
		--invoice_end_time := 0;
		--cdr_start_time := 0;
		--cdr_end_time := 0;
	--end if;

	if trans_type = 0 then --all

	if id_client = 0 then
		for r in
		select
		payment_time::text,
		(case payment_type
		when 4 then 1
		when 5 then 1
		when 3 then 2
		when 6 then 2
		when 7 then 5
		when 8 then 6
		when 9 then 9
		when 11 then 7
		when 12 then 8
		when 15 then 12
		end)::text as t_type,
		client_id::text,
		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
		from client_payment
		where payment_type in (3,4,5,6,7,8,9,11,12,15) and
		payment_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--(case type
		--when 0 then 4
		--when 2 then 4
		--end)::text as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where state=9 and type in (0,2) and
		--invoice_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--'3' as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where type = 3 and
		--invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select
		payment_time::text,
		(case payment_type
		when 4 then 1
		when 5 then 1
		when 3 then 2
		when 6 then 2
		when 7 then 5
		when 8 then 6
		when 9 then 9
		when 11 then 7
		when 12 then 8
		when 15 then 12
		end)::text as t_type,
		client_id::text,
		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
		from client_payment
		where payment_type in (3,4,5,6,7,8,9,11,12,15) and client_id=id_client and
		payment_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--(case type
		--when 0 then 4
		--when 2 then 4
		--end)::text as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where state=9 and type in (0,2) and client_id=id_client and
		--invoice_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--'3' as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where type = 3 and client_id=id_client and
		--invoice_time between start_time and end_time
		--union
		--select time::date::text,10::text,id_client::text,sum(egress_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client::text group by time::date
		--union
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client::text group by time::date
		union
		--select time::date::text,10::text,id_client::text,sum(egress_cost)::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client group by time::date
		select to_char(report_time, 'YYYY-MM-DD 23:59:59')::text,10::text,id_client::text,sum(egress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and egress_client_id=id_client group by to_char(report_time, 'YYYY-MM-DD 23:59:59')
		union
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost)::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client group by time::date
		select to_char(report_time, 'YYYY-MM-DD 23:59:59')::text,11::text,id_client::text,sum(ingress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and ingress_client_id=id_client group by to_char(report_time, 'YYYY-MM-DD 23:59:59')
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 12 then --scc cost

	if id_client=0 then
		for r in
		select payment_time::text,12::text,client_id::text,amount::text from client_payment where (payment_type=15)
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,12::text,client_id::text,amount::text from client_payment where (payment_type=15)
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 1 then --payment received

	if id_client=0 then
		for r in
		select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 2 then --payment sent

	if id_client=0 then
		for r in
		select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	--elsif trans_type = 3 then --invoice received

	--if id_client=0 then
	--	for r in
	--	select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
	--	and invoice_time between start_time and end_time
	--	loop
	--		return next r;
	--	end loop;
	--else
	--	for r in
	--	select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
	--	and invoice_time between start_time and end_time and client_id=id_client
	--	loop
	--		return next r;
	--	end loop;
	--end if;
	--elsif trans_type = 4 then --invoice sent

	--if id_client=0 then
	--	for r in
	--	select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
	--	and invoice_time between start_time and end_time
	--	loop
	--		return next r;
	--	end loop;
	--else
	--	for r in
	--	select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
	--	and invoice_time between start_time and end_time and client_id=id_client
	--	loop
	--		return next r;
	--	end loop;
	--end if;
	elsif trans_type = 5 then --credit note received

	if id_client=0 then
		for r in
		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 6 then --credit note sent

	if id_client=0 then
		for r in
		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 7 then --debit note received

	if id_client=0 then
		for r in
		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 8 then --debit note sent

	if id_client=0 then
		for r in
		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 9 then --reset

	if id_client=0 then
		for r in
		select payment_time::text,9::text,client_id::text,(coalesce(amount,0)+coalesce(egress_amount,0))::text from client_payment where payment_type=9
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,9::text,client_id::text,(coalesce(amount,0)+coalesce(egress_amount,0))::text from client_payment where payment_type=9
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 10 then --egress cdr cost

	if id_client=0 then
		return;
	else
		for r in
		--select time::date::text,10::text,id_client::text,sum(egress_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client::text group by time::date
		--select time::date::text,10::text,id_client::text,sum(egress_cost)::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client group by time::date
		select to_char(report_time, 'YYYY-MM-DD 23:59:59')::text,10::text,id_client::text,sum(egress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and egress_client_id=id_client group by to_char(report_time, 'YYYY-MM-DD 23:59:59')
-- 		select to_char(transaction_time, 'YYYY-MM-DD 23:59:59')::text,10::text,id_client::text,sum(amount)::text
-- 		from client_finance_transaction
-- 		where transaction_time between start_time and end_time
-- 		and client_id=id_client
-- 		and transaction_type=2
-- 		group by to_char(transaction_time, 'YYYY-MM-DD 23:59:59')
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 11 then --ingress cdr cost

	if id_client=0 then
		return;
	else
		for r in
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client::text group by time::date
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost)::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client group by time::date
		select to_char(report_time, 'YYYY-MM-DD 23:59:59')::text,11::text,id_client::text,sum(ingress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and ingress_client_id=id_client group by to_char(report_time, 'YYYY-MM-DD 23:59:59')
-- 		select to_char(transaction_time, 'YYYY-MM-DD 23:59:59')::text,11::text,id_client::text,sum(amount)::text
-- 		from client_finance_transaction
-- 		where transaction_time between start_time and end_time
-- 		and client_id=id_client
-- 		and transaction_type=1
-- 		group by to_char(transaction_time, 'YYYY-MM-DD 23:59:59')
		loop
			return next r;
		end loop;
	end if;
	end if;

	return;

end;
$_$;


ALTER FUNCTION public.actual_trans(timestamp with time zone, timestamp with time zone, integer, integer) OWNER TO postgres;

--
-- Name: actual_trans_exchange(timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.actual_trans_exchange(timestamp with time zone, timestamp with time zone, integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	start_time alias for $1;
	end_time alias for $2;
	id_client alias for $3;
	trans_type alias for $4;
	r record;
	invoice_start_time timestamp with time zone;
	invoice_end_time timestamp with time zone;
	cdr_start_time timestamp with time zone;
	cdr_end_time timestamp with time zone;

begin

	--if id_client > 0 then
		--invoice_start_time := 0;
		--invoice_end_time := 0;
		--cdr_start_time := 0;
		--cdr_end_time := 0;
	--end if;

	if trans_type = 0 then --all

	if id_client = 0 then
		for r in
		select
		action_time::text,
		(case action_type
		when 2 then 1
		when 1 then 2
		end)::text as t_type,
		client_id::text,
		actual_amount::text
		from exchange_finance
		where ((action_type=1 and status=4) or (action_type=2 and status=2))
		and action_time between start_time and end_time and client_id=id_client

-- 		select
-- 		payment_time::text,
-- 		(case payment_type
-- 		when 4 then 1
-- 		when 5 then 1
-- 		when 3 then 2
-- 		when 6 then 2
-- 		when 7 then 5
-- 		when 8 then 6
-- 		when 9 then 9
-- 		when 11 then 7
-- 		when 12 then 8
-- 		end)::text as t_type,
-- 		client_id::text,
-- 		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
-- 		from client_payment
-- 		where payment_type in (3,4,5,6,7,8,9,11,12) and
-- 		payment_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--(case type
		--when 0 then 4
		--when 2 then 4
		--end)::text as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where state=9 and type in (0,2) and
		--invoice_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--'3' as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where type = 3 and
		--invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select
		action_time::text,
		(case action_type
		when 2 then 1
		when 1 then 2
		end)::text as t_type,
		client_id::text,
		actual_amount::text
		from exchange_finance
		where ((action_type=1 and status=4) or (action_type=2 and status=2))
		and action_time between start_time and end_time and client_id=id_client

-- 		select
-- 		payment_time::text,
-- 		(case payment_type
-- 		when 4 then 1
-- 		when 5 then 1
-- 		when 3 then 2
-- 		when 6 then 2
-- 		when 7 then 5
-- 		when 8 then 6
-- 		when 9 then 9
-- 		when 11 then 7
-- 		when 12 then 8
-- 		end)::text as t_type,
-- 		client_id::text,
-- 		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
-- 		from client_payment
-- 		where payment_type in (3,4,5,6,7,8,9,11,12) and client_id=id_client and
-- 		payment_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--(case type
		--when 0 then 4
		--when 2 then 4
		--end)::text as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where state=9 and type in (0,2) and client_id=id_client and
		--invoice_time between start_time and end_time
		--union
		--select
		--invoice_time::text,
		--'3' as t_type,
		--client_id::text,
		--total_amount::text
		--from invoice
		--where type = 3 and client_id=id_client and
		--invoice_time between start_time and end_time
		--union
		--select time::date::text,10::text,id_client::text,sum(egress_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client::text group by time::date
		--union
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client::text group by time::date
		union
		--select time::date::text,10::text,id_client::text,sum(egress_cost)::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client group by time::date
		select report_time::date::text,10::text,id_client::text,sum(egress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and egress_client_id=id_client group by report_time::date
		union
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost)::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client group by time::date
		select report_time::date::text,11::text,id_client::text,sum(ingress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and ingress_client_id=id_client group by report_time::date
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 1 then --payment received

	if id_client=0 then
		for r in
		--select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		--and payment_time between start_time and end_time
		select action_time::text,1::text,client_id::text,actual_amount::text from exchange_finance where action_type=2 and status=2
		and action_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		--select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		--and payment_time between start_time and end_time and client_id=id_client
		select action_time::text,1::text,client_id::text,actual_amount::text from exchange_finance where action_type=2 and status=2
		and action_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 2 then --payment sent

	if id_client=0 then
		for r in
		--select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		--and payment_time between start_time and end_time
		select action_time::text,1::text,client_id::text,actual_amount::text from exchange_finance where action_type=1 and status=4
		and action_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		--select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		--and payment_time between start_time and end_time and client_id=id_client
		select action_time::text,1::text,client_id::text,actual_amount::text from exchange_finance where action_type=1 and status=4
		and action_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	--elsif trans_type = 3 then --invoice received

	--if id_client=0 then
	--	for r in
	--	select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
	--	and invoice_time between start_time and end_time
	--	loop
	--		return next r;
	--	end loop;
	--else
	--	for r in
	--	select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
	--	and invoice_time between start_time and end_time and client_id=id_client
	--	loop
	--		return next r;
	--	end loop;
	--end if;
	--elsif trans_type = 4 then --invoice sent

	--if id_client=0 then
	--	for r in
	--	select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
	--	and invoice_time between start_time and end_time
	--	loop
	--		return next r;
	--	end loop;
	--else
	--	for r in
	--	select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
	--	and invoice_time between start_time and end_time and client_id=id_client
	--	loop
	--		return next r;
	--	end loop;
	--end if;
-- 	elsif trans_type = 5 then --credit note received
--
-- 	if id_client=0 then
-- 		for r in
-- 		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
-- 		and payment_time between start_time and end_time
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	else
-- 		for r in
-- 		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
-- 		and payment_time between start_time and end_time and client_id=id_client
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	end if;
-- 	elsif trans_type = 6 then --credit note sent
--
-- 	if id_client=0 then
-- 		for r in
-- 		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
-- 		and payment_time between start_time and end_time
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	else
-- 		for r in
-- 		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
-- 		and payment_time between start_time and end_time and client_id=id_client
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	end if;
-- 	elsif trans_type = 7 then --debit note received
--
-- 	if id_client=0 then
-- 		for r in
-- 		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
-- 		and payment_time between start_time and end_time
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	else
-- 		for r in
-- 		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
-- 		and payment_time between start_time and end_time and client_id=id_client
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	end if;
-- 	elsif trans_type = 8 then --debit note sent
--
-- 	if id_client=0 then
-- 		for r in
-- 		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
-- 		and payment_time between start_time and end_time
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	else
-- 		for r in
-- 		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
-- 		and payment_time between start_time and end_time and client_id=id_client
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	end if;
-- 	elsif trans_type = 9 then --reset
--
-- 	if id_client=0 then
-- 		for r in
-- 		select payment_time::text,9::text,client_id::text,(coalesce(amount,0)+coalesce(egress_amount,0))::text from client_payment where payment_type=9
-- 		and payment_time between start_time and end_time
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	else
-- 		for r in
-- 		select payment_time::text,9::text,client_id::text,(coalesce(amount,0)+coalesce(egress_amount,0))::text from client_payment where payment_type=9
-- 		and payment_time between start_time and end_time and client_id=id_client
-- 		loop
-- 			return next r;
-- 		end loop;
-- 	end if;
	elsif trans_type = 10 then --egress cdr cost

	if id_client=0 then
		return;
	else
		for r in
		--select time::date::text,10::text,id_client::text,sum(egress_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client::text group by time::date
		--select time::date::text,10::text,id_client::text,sum(egress_cost)::text from client_cdr where
		--time between start_time and end_time and egress_client_id=id_client group by time::date
		select report_time::date::text,10::text,id_client::text,sum(egress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and egress_client_id=id_client group by report_time::date
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 11 then --ingress cdr cost

	if id_client=0 then
		return;
	else
		for r in
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost::numeric(20,4))::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client::text group by time::date
		--select time::date::text,11::text,id_client::text,sum(ingress_client_cost)::text from client_cdr where
		--time between start_time and end_time and ingress_client_id=id_client group by time::date
		select report_time::date::text,11::text,id_client::text,sum(ingress_call_cost)::text from cdr_report where
		report_time between start_time and end_time and ingress_client_id=id_client group by report_time::date
		loop
			return next r;
		end loop;
	end if;
	end if;

	return;

end;
$_$;


ALTER FUNCTION public.actual_trans_exchange(timestamp with time zone, timestamp with time zone, integer, integer) OWNER TO postgres;

--
-- Name: approve_client_payment(integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.approve_client_payment(integer[]) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	a alias for $1;
	a_u integer;
	r record;
	now_balance numeric;

begin
	select into a_u array_upper(a,1);
	if a_u is null then
		for r in select client_payment_id,amount,client_id from client_payment order by client_payment_id asc
		loop
			select into now_balance balance from client_balance where client_id = r.client_id::text order by client_balance_id desc limit 1;
			if now_balance is null then
				now_balance := 0;
			end if;
			insert into client_balance(client_id,balance,client_payment_id,type)
			select r.client_id::text,(now_balance+r.amount)::text,r.client_payment_id::text,'5';
			update client_payment set approved = true where client_payment_id = r.client_payment_id;
		end loop;
	else
		for i in 1..a_u
		loop
		select into r amount,client_id from client_payment where client_payment_id = a[i];
		select into now_balance balance from client_balance where client_id = r.client_id::text order by client_balance_id desc limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;
		insert into client_balance(client_id,balance,client_payment_id,type)
		select r.client_id::text,(now_balance+r.amount)::text,a[i]::text,'5';
		update client_payment set approved = true where client_payment_id = a[i];
		end loop;
	end if;
	return 'true';
end;
$_$;


ALTER FUNCTION public.approve_client_payment(integer[]) OWNER TO postgres;

--
-- Name: balance_detail(integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.balance_detail(client integer, balance_date text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
today date := CURRENT_DATE;
start_date timestamp with time zone = balance_date::text || ' 00:00:00+00';
end_date timestamp with time zone = balance_date::text || ' 23:59:59+00';
my_array numeric(20, 5)[] := '{0,0,0,0,0,0,0,0,0,0,0,0,0}';
actual_ingress_balance numeric(20, 5) := 0;
actual_egress_balance numeric(20, 5) := 0;
actual_total_balance numeric(20, 5) := 0;
mutual_ingress_balance numeric(20, 5) := 0;
mutual_egress_balance numeric(20, 5) := 0;
mutual_total_balance numeric(20, 5) := 0;
r record;
result record;
BEGIN
for r in
SELECT COALESCE(sum(amount), 0) as amount, 0 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (4,5) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 1 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 8 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 2 as type FROM client_payment
WHERE payment_time between start_date and end_date
and  payment_type = 12 AND client_id = client
UNION

select COALESCE(amount, 0) as amount, 3 as type FROM
ingress_cost(client, start_date, end_date) as (amount numeric)

--SELECT COALESCE(sum(ingress_client_cost::numeric(10,4)), 0), 3 as type FROM client_cdr
--WHERE time BETWEEN start_date and end_date  AND ingress_client_id = client and is_final_call=1

UNION
SELECT COALESCE(sum(amount), 0) as amount, 4 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 15 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 5 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (3,6) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 6 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 7 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 7 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 11 AND client_id = client
UNION

select COALESCE(amount, 0) as amount, 8 as type FROM
egress_cost(client, start_date, end_date) as (amount numeric)

--SELECT COALESCE(sum(egress_cost), 0) as amount, 8 as type
--from client_cdr where time between start_date and end_date
--and egress_client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount, 9 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
state != -1 AND type = 0 AND client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount,10 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
type = 3 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 11 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 2 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 12 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 1 AND client_id = client

loop
my_array[r.type] = r.amount;
end loop;

my_array[0] = my_array[0] + my_array[11];
my_array[5] = my_array[5] + my_array[12];

actual_ingress_balance = my_array[0] + my_array[1] - my_array[2] - my_array[3] -my_array[4];
actual_egress_balance = -my_array[5] - my_array[6] + my_array[7] + my_array[8];
actual_total_balance = actual_ingress_balance + actual_egress_balance;

mutual_ingress_balance = -my_array[9] + my_array[0] + my_array[1] - my_array[2];
mutual_egress_balance = my_array[10] - my_array[5] - my_array[6] + my_array[7];
mutual_total_balance = mutual_ingress_balance+mutual_egress_balance;

select into r * from balance_history_actual where client_id = client and date < start_date order by date desc;

if FOUND THEN
actual_ingress_balance = actual_ingress_balance + r.actual_ingress_balance;
actual_egress_balance = actual_egress_balance + r.actual_egress_balance;
actual_total_balance = actual_total_balance + r.actual_balance;
end if;

select into r * from balance_history where client_id = client and date < start_date order by date desc;

if FOUND THEN
mutual_ingress_balance = mutual_ingress_balance + r.mutual_ingress_balance;
mutual_egress_balance = mutual_egress_balance + r.mutual_egress_balance;
mutual_total_balance = mutual_total_balance + r.mutual_balance;
end if;

select into result actual_ingress_balance,actual_egress_balance,actual_total_balance,mutual_ingress_balance,mutual_egress_balance,mutual_total_balance,
my_array[0], my_array[1], my_array[2], my_array[3], my_array[4], my_array[5], my_array[6], my_array[7],
my_array[8], my_array[9], my_array[10];
return next result;
return;

END;
$$;


ALTER FUNCTION public.balance_detail(client integer, balance_date text) OWNER TO postgres;

--
-- Name: c4_client_balance_trigfun_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.c4_client_balance_trigfun_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT' and NEW.client_id='87')then
                insert into c4_client_balance_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE' and NEW.client_id='87')then
                insert into c4_client_balance_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE' and NEW.client_id='87')then
                insert into c4_client_balance_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into c4_client_balance_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.c4_client_balance_trigfun_record() OWNER TO postgres;

--
-- Name: c4_livecall_user_trigfun_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.c4_livecall_user_trigfun_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into c4_livecall_user_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into c4_livecall_user_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into c4_livecall_user_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into c4_livecall_user_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.c4_livecall_user_trigfun_record() OWNER TO postgres;

--
-- Name: c4_spam_traffic_ip_trigfun_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.c4_spam_traffic_ip_trigfun_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into c4_spam_traffic_ip_trig_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into c4_spam_traffic_ip_trig_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into c4_spam_traffic_ip_trig_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into c4_spam_traffic_ip_trig_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.c4_spam_traffic_ip_trigfun_record() OWNER TO postgres;

--
-- Name: cidr(public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cidr(public.ip4) RETURNS cidr
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_to_cidr';


ALTER FUNCTION public.cidr(public.ip4) OWNER TO postgres;

--
-- Name: cidr(public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cidr(public.ip4r) RETURNS cidr
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cast_to_cidr';


ALTER FUNCTION public.cidr(public.ip4r) OWNER TO postgres;

--
-- Name: class4_func_mismatch_report(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_func_mismatch_report(character varying, character varying, OUT org2_call integer, OUT org2_notzero_call integer, OUT org2_call_duration integer, OUT term2_call integer, OUT term2_notzero_call integer, OUT term2_call_duration integer, OUT org3_call integer, OUT org3_notzero_call integer, OUT org3_call_duration integer, OUT term3_call integer, OUT term3_notzero_call integer, OUT term3_call_duration integer, OUT org4_call integer, OUT org4_notzero_call integer, OUT org4_call_duration integer, OUT term4_call integer, OUT term4_notzero_call integer, OUT term4_call_duration integer) RETURNS record
    LANGUAGE plpgsql
    AS $_$

   DECLARE
      r RECORD;
      reseller_package  numeric;
      starts character varying:=$1;
      ends character varying:=$2;
   BEGIN

--Calls with unknown clients   origination
       select    count(ingress_client_id) as  org_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60 as call_duration
       into  r     from  client_cdr   where   ingress_client_bill_result='2' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 org2_call_duration :=0;
else
org2_call_duration :=r.call_duration;
end if;


if r.org_call  is null then
 org2_call :=0;
else
org2_call :=r.org_call;
end if;

   select    count(ingress_client_id) as  org_not_zero_call
       into  r     from  client_cdr   where   ingress_client_bill_result='2'   and case when call_duration='' then '0' ELSE call_duration end::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.org_not_zero_call  is null then
 org2_notzero_call :=0;
else
org2_notzero_call :=r.org_not_zero_call;
end if;

--Calls with unknown clients    termination
       select    count(egress_client_id) as  term_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60 as call_duration
       into  r     from  client_cdr   where   egress_bill_result='2' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 term2_call_duration :=0;
else
term2_call_duration :=r.call_duration;
end if;


if r.term_call  is null then
 term2_call :=0;
else
term2_call :=r.term_call;
end if;


   select  count(egress_client_id) as term_not_zero_call
       into  r     from  client_cdr   where    egress_bill_result='2'   and case when call_duration='' then '0' ELSE call_duration end ::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.term_not_zero_call  is null then
term2_notzero_call :=0;
else
term2_notzero_call :=r.term_not_zero_call;
end if;




--è´¹çŽ‡æ¨¡æ¿æ‰¾ä¸åˆ°     origination
       select    count(ingress_client_id) as  org_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60 as call_duration
       into  r     from  client_cdr   where   ingress_client_bill_result='3' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 org3_call_duration :=0;
else
org3_call_duration :=r.call_duration;
end if;


if r.org_call  is null then
 org3_call :=0;
else
org3_call :=r.org_call;
end if;

   select    count(ingress_client_id) as  org_not_zero_call
       into  r     from  client_cdr   where   ingress_client_bill_result='3'   and case when call_duration='' then '0' ELSE call_duration end ::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.org_not_zero_call  is null then
 org3_notzero_call :=0;
else
org3_notzero_call :=r.org_not_zero_call;
end if;

--è´¹çŽ‡æ¨¡æ¿æ‰¾ä¸åˆ°    termination
       select    count(egress_client_id) as  term_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60 as call_duration
       into  r     from  client_cdr   where   egress_bill_result='3' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 term3_call_duration :=0;
else
term3_call_duration :=r.call_duration;
end if;


if r.term_call  is null then
 term3_call :=0;
else
term3_call :=r.term_call;
end if;


   select  count(egress_client_id) as term_not_zero_call
       into  r     from  client_cdr   where    egress_bill_result='3'   and case when call_duration='' then '0' ELSE call_duration end ::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.term_not_zero_call  is null then
term3_notzero_call :=0;
else
term3_notzero_call :=r.term_not_zero_call;
end if;








--è´¹çŽ‡æ‰¾ä¸åˆ°     origination
       select    count(ingress_client_id) as  org_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60  as call_duration
       into  r     from  client_cdr   where   ingress_client_bill_result='4' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 org4_call_duration :=0;
else
org4_call_duration :=r.call_duration;
end if;


if r.org_call  is null then
 org4_call :=0;
else
org4_call :=r.org_call;
end if;

   select    count(ingress_client_id) as  org_not_zero_call
       into  r     from  client_cdr   where   ingress_client_bill_result='4'   and case when call_duration='' then '0' ELSE call_duration end ::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.org_not_zero_call  is null then
 org4_notzero_call :=0;
else
org4_notzero_call :=r.org_not_zero_call;
end if;

--è´¹çŽ‡æ¨¡æ¿æ‰¾ä¸åˆ°    termination
       select    count(egress_client_id) as  term_call, (sum(case when call_duration='' then '0' ELSE call_duration end::integer))/60  as call_duration
       into  r     from  client_cdr   where   egress_bill_result='4' and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.call_duration  is null then
 term4_call_duration :=0;
else
term4_call_duration :=r.call_duration;
end if;


if r.term_call  is null then
 term4_call :=0;
else
term4_call :=r.term_call;
end if;


   select  count(egress_client_id) as term_not_zero_call
       into  r     from  client_cdr   where    egress_bill_result='4'   and case when call_duration='' then '0' ELSE call_duration end ::integer >0
 and time   between starts::timestamp with time zone  and  ends::timestamp with time zone;

if r.term_not_zero_call  is null then
term4_notzero_call :=0;
else
term4_notzero_call :=r.term_not_zero_call;
end if;
   END;
$_$;


ALTER FUNCTION public.class4_func_mismatch_report(character varying, character varying, OUT org2_call integer, OUT org2_notzero_call integer, OUT org2_call_duration integer, OUT term2_call integer, OUT term2_notzero_call integer, OUT term2_call_duration integer, OUT org3_call integer, OUT org3_notzero_call integer, OUT org3_call_duration integer, OUT term3_call integer, OUT term3_notzero_call integer, OUT term3_call_duration integer, OUT org4_call integer, OUT org4_notzero_call integer, OUT org4_call_duration integer, OUT term4_call integer, OUT term4_notzero_call integer, OUT term4_call_duration integer) OWNER TO postgres;

--
-- Name: class4_func_monitor_ip_report(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_func_monitor_ip_report(character varying, OUT acd_15min numeric, OUT pdd_15min numeric, OUT asr_15min numeric, OUT ca_15min numeric, OUT acd_1h numeric, OUT pdd_1h numeric, OUT asr_1h numeric, OUT ca_1h numeric, OUT acd_24h numeric, OUT pdd_24h numeric, OUT asr_24h numeric, OUT ca_24h numeric) RETURNS record
    LANGUAGE plpgsql
    AS $_$
   DECLARE
      r RECORD;
      host_ip character varying:=$1;
   BEGIN

--15 min
       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,
       (sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::real) / NULLIF(sum(call_count::integer),0)) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where ip=host_ip and   time::bigint between extract(epoch from now())::bigint-(60*15)      and  extract(epoch from now())::bigint;

if r.asr  is null then
 asr_15min :=0;
else
asr_15min :=r.asr::numeric(20,2);
end if;
if r.acd  is null then
 acd_15min :=0;
else
acd_15min :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_15min :=0;
else
pdd_15min :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_15min :=0;
else
ca_15min :=r.ca;
end if;



--1 h

       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,(sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::integer) / NULLIF(sum(call_count::integer),0)) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where ip=host_ip and  time::bigint between extract(epoch from now())::bigint-(3600)      and  extract(epoch from now())::bigint;

if r.asr  is null then
 asr_1h :=0;
else
asr_1h :=r.asr::numeric(20,2);
end if;


if r.acd  is null then
 acd_1h :=0;
else
acd_1h :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_1h :=0;
else
pdd_1h :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_1h :=0;
else
ca_1h :=r.ca;
end if;




--24 h

       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,(sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::integer) / NULLIF(sum(call_count::integer),0)) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where ip=host_ip and  time::bigint between extract(epoch from now())::bigint-(3600*24)      and  extract(epoch from now())::bigint;

if r.asr  is null then
 asr_24h :=0;
else
asr_24h :=r.asr::numeric(20,2);
end if;

if r.acd  is null then
 acd_24h :=0;
else
acd_24h :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_24h :=0;
else
pdd_24h :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_24h :=0;
else
ca_24h :=r.ca;
end if;






   END;
$_$;


ALTER FUNCTION public.class4_func_monitor_ip_report(character varying, OUT acd_15min numeric, OUT pdd_15min numeric, OUT asr_15min numeric, OUT ca_15min numeric, OUT acd_1h numeric, OUT pdd_1h numeric, OUT asr_1h numeric, OUT ca_1h numeric, OUT acd_24h numeric, OUT pdd_24h numeric, OUT asr_24h numeric, OUT ca_24h numeric) OWNER TO postgres;

--
-- Name: class4_func_monitor_report(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_func_monitor_report(OUT acd_15min numeric, OUT pdd_15min numeric, OUT asr_15min numeric, OUT ca_15min numeric, OUT acd_1h numeric, OUT pdd_1h numeric, OUT asr_1h numeric, OUT ca_1h numeric, OUT acd_24h numeric, OUT pdd_24h numeric, OUT asr_24h numeric, OUT ca_24h numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
   DECLARE
      r RECORD;
      r2 RECORD;
   BEGIN

--15 min
       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,
       (sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::real) / NULLIF(sum(call_count::integer),0)    ) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where   time::bigint between extract(epoch from now())::bigint-(60*15)      and  extract(epoch from now())::bigint
       and direction='0'
;


if r.asr  is null then
 asr_15min :=0;
else
asr_15min :=r.asr::numeric(20,2);
end if;
if r.acd  is null then
 acd_15min :=0;
else
acd_15min :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_15min :=0;
else
pdd_15min :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_15min :=0;
else
ca_15min :=r.ca;
end if;



--1 h

       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,(sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::integer) / NULLIF(sum(call_count::integer),0   )) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where   time::bigint between extract(epoch from now())::bigint-(3600)      and  extract(epoch from now())::bigint
	and direction='0'
;


if r.asr  is null then
 asr_1h :=0;
else
asr_1h :=r.asr::numeric(20,2);
end if;


if r.acd  is null then
 acd_1h :=0;
else
acd_1h :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_1h :=0;
else
pdd_1h :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_1h :=0;
else
ca_1h :=r.ca;
end if;




--24 h

       select
       sum(call_count_asr::integer*asr::real)/NULLIF(sum(call_count_asr::integer),0) as asr,
(sum(acd::real)/NULLIF(sum(call_count::integer),0))/60 as acd,
       (sum(pdd::integer) / NULLIF(sum(call_count::integer),0)) as pdd, sum(ca::integer) as ca
       into  r     from  host_info
       where   time::bigint between extract(epoch from now())::bigint-(3600*24)      and  extract(epoch from now())::bigint
	and direction='0'
;


if r.asr  is null then
 asr_24h :=0;
else
asr_24h :=r.asr::numeric(20,2);
end if;

if r.acd  is null then
 acd_24h :=0;
else
acd_24h :=r.acd::numeric(20,2);
end if;

if r.pdd  is null then
 pdd_24h :=0;
else
pdd_24h :=floor(r.pdd);
end if;

if r.ca  is null then
 ca_24h :=0;
else
ca_24h :=r.ca;
end if;






   END;
$$;


ALTER FUNCTION public.class4_func_monitor_report(OUT acd_15min numeric, OUT pdd_15min numeric, OUT asr_15min numeric, OUT ca_15min numeric, OUT acd_1h numeric, OUT pdd_1h numeric, OUT asr_1h numeric, OUT ca_1h numeric, OUT acd_24h numeric, OUT pdd_24h numeric, OUT asr_24h numeric, OUT ca_24h numeric) OWNER TO postgres;

--
-- Name: class4_trigfun_cdr_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_cdr_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ DECLARE t timestamp with time zone;
BEGIN
	select into t TIMESTAMP WITH TIME ZONE 'epoch' + (NEW.start_time_of_date::bigint/1000000) * INTERVAL '1 second';
	NEW.time := t;
	if t >= '2017-06-07 00:00:00+00' and t < '2017-06-08 00:00:00+00' then insert into client_cdr20170607 select NEW.*;
	elsif t >= '2017-06-06 00:00:00+00' and t< '2017-06-07 00:00:00+00' then insert into client_cdr20170606 select NEW.*;
	elsif t >= '2016-12-09 00:00:00+00' and t< '2016-12-10 00:00:00+00' then insert into client_cdr20161209 select NEW.*;
	elsif t >= '2016-12-10 00:00:00+00' and t< '2016-12-11 00:00:00+00' then insert into client_cdr20161210 select NEW.*;
	elsif t >= '2016-12-11 00:00:00+00' and t< '2016-12-12 00:00:00+00' then insert into client_cdr20161211 select NEW.*;
	elsif t >= '2016-12-12 00:00:00+00' and t< '2016-12-13 00:00:00+00' then insert into client_cdr20161212 select NEW.*;
	elsif t >= '2016-12-13 00:00:00+00' and t< '2016-12-14 00:00:00+00' then insert into client_cdr20161213 select NEW.*;
	elsif t >= '2016-12-14 00:00:00+00' and t< '2016-12-15 00:00:00+00' then insert into client_cdr20161214 select NEW.*;
	elsif t >= '2016-12-15 00:00:00+00' and t< '2016-12-16 00:00:00+00' then insert into client_cdr20161215 select NEW.*;
	elsif t >= '2016-12-16 00:00:00+00' and t< '2016-12-17 00:00:00+00' then insert into client_cdr20161216 select NEW.*;
	elsif t >= '2016-12-17 00:00:00+00' and t< '2016-12-18 00:00:00+00' then insert into client_cdr20161217 select NEW.*;
	elsif t >= '2016-12-18 00:00:00+00' and t< '2016-12-19 00:00:00+00' then insert into client_cdr20161218 select NEW.*;
	elsif t >= '2016-12-19 00:00:00+00' and t< '2016-12-20 00:00:00+00' then insert into client_cdr20161219 select NEW.*;
	elsif t >= '2016-12-20 00:00:00+00' and t< '2016-12-21 00:00:00+00' then insert into client_cdr20161220 select NEW.*;
	elsif t >= '2016-12-21 00:00:00+00' and t< '2016-12-22 00:00:00+00' then insert into client_cdr20161221 select NEW.*;
	elsif t >= '2016-12-22 00:00:00+00' and t< '2016-12-23 00:00:00+00' then insert into client_cdr20161222 select NEW.*;
	elsif t >= '2016-12-23 00:00:00+00' and t< '2016-12-24 00:00:00+00' then insert into client_cdr20161223 select NEW.*;
	elsif t >= '2016-12-24 00:00:00+00' and t< '2016-12-25 00:00:00+00' then insert into client_cdr20161224 select NEW.*;
	elsif t >= '2016-12-25 00:00:00+00' and t< '2016-12-26 00:00:00+00' then insert into client_cdr20161225 select NEW.*;
	elsif t >= '2016-12-26 00:00:00+00' and t< '2016-12-27 00:00:00+00' then insert into client_cdr20161226 select NEW.*;
	elsif t >= '2016-12-27 00:00:00+00' and t< '2016-12-28 00:00:00+00' then insert into client_cdr20161227 select NEW.*;
	elsif t >= '2016-12-28 00:00:00+00' and t< '2016-12-29 00:00:00+00' then insert into client_cdr20161228 select NEW.*;
	elsif t >= '2016-12-29 00:00:00+00' and t< '2016-12-30 00:00:00+00' then insert into client_cdr20161229 select NEW.*;
	elsif t >= '2016-12-30 00:00:00+00' and t< '2016-12-31 00:00:00+00' then insert into client_cdr20161230 select NEW.*;
	elsif t >= '2016-12-31 00:00:00+00' and t< '2017-01-01 00:00:00+00' then insert into client_cdr20161231 select NEW.*;
	else
		raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.start_time_of_date;
		return NEW;
	end if;
	return NULL;
END;
$$;


ALTER FUNCTION public.class4_trigfun_cdr_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_client_active(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_client_active() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
low_cost numeric;
res integer;
new_balance real;
client_offset_balance boolean;

begin
if exists(select 1 from client where unlimited_credit is true and client_id = NEW.client_id::integer) then
return null;
end if;

select into low_cost, client_offset_balance allowed_credit, offset_balance from client where client_id = NEW.client_id::integer;

if client_offset_balance then
	new_balance := NEW.balance::real;
else
	new_balance := NEW.ingress_balance::real;
end if;

if new_balance::real <= low_cost then
if not exists (select 1 from client where client_id = NEW.client_id::integer and enough_balance = false) then
--insert into event_log(type,message,action_date,sender) values(1,'set enough balance false for client '|| NEW.client_id|| ' client balance id %'|| NEW.client_balance_id,current_timestamp(0),2);
update client set enough_balance = false where client_id = NEW.client_id::integer;
update resource set enough_balance = false where client_id = NEW.client_id::integer and ingress = true;
end if;
elsif NEW.balance::real > low_cost then
if not exists (select 1 from client where client_id = NEW.client_id::integer and enough_balance = true) then
--insert into event_log(type,message,action_date,sender) values(1,'set enough balance true for client '|| NEW.client_id|| ' client balance id %'|| NEW.client_balance_id,current_timestamp(0),2);
update client set enough_balance = true where client_id = NEW.client_id::integer;
update resource set enough_balance = true where client_id = NEW.client_id::integer and ingress = true;
end if;
end if;

return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_client_active() OWNER TO postgres;

--
-- Name: class4_trigfun_did_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_did_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        DECLARE
                t timestamp with time zone;
        BEGIN
                t:= NEW.report_time;

                if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
                        insert into did_report20161201 select NEW.*;
                elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
                        insert into did_report20161202 select NEW.*;
                elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
                        insert into did_report20161130 select NEW.*;
                elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into did_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into did_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into did_report20161202 select NEW.*;

                else
                        raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
                        return NEW;
                end if;


                return NULL;
        END
        $$;


ALTER FUNCTION public.class4_trigfun_did_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_host_based_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_host_based_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ DECLARE t timestamp with time zone;
BEGIN
	t:= NEW.report_time;
	if t >= '2017-06-07 00:00:00+00' and t < '2017-06-08 00:00:00+00' then insert into host_based_report20170607 select NEW.*;
	elsif t >= '2017-06-06 00:00:00+00' and t< '2017-06-07 00:00:00+00' then insert into host_based_report20170606 select NEW.*;
	elsif t >= '2016-12-09 00:00:00+00' and t< '2016-12-10 00:00:00+00' then insert into host_based_report20161209 select NEW.*;
	elsif t >= '2016-12-10 00:00:00+00' and t< '2016-12-11 00:00:00+00' then insert into host_based_report20161210 select NEW.*;
	elsif t >= '2016-12-11 00:00:00+00' and t< '2016-12-12 00:00:00+00' then insert into host_based_report20161211 select NEW.*;
	elsif t >= '2016-12-12 00:00:00+00' and t< '2016-12-13 00:00:00+00' then insert into host_based_report20161212 select NEW.*;
	elsif t >= '2016-12-13 00:00:00+00' and t< '2016-12-14 00:00:00+00' then insert into host_based_report20161213 select NEW.*;
	elsif t >= '2016-12-14 00:00:00+00' and t< '2016-12-15 00:00:00+00' then insert into host_based_report20161214 select NEW.*;
	elsif t >= '2016-12-15 00:00:00+00' and t< '2016-12-16 00:00:00+00' then insert into host_based_report20161215 select NEW.*;
	elsif t >= '2016-12-16 00:00:00+00' and t< '2016-12-17 00:00:00+00' then insert into host_based_report20161216 select NEW.*;
	elsif t >= '2016-12-17 00:00:00+00' and t< '2016-12-18 00:00:00+00' then insert into host_based_report20161217 select NEW.*;
	elsif t >= '2016-12-18 00:00:00+00' and t< '2016-12-19 00:00:00+00' then insert into host_based_report20161218 select NEW.*;
	elsif t >= '2016-12-19 00:00:00+00' and t< '2016-12-20 00:00:00+00' then insert into host_based_report20161219 select NEW.*;
	elsif t >= '2016-12-20 00:00:00+00' and t< '2016-12-21 00:00:00+00' then insert into host_based_report20161220 select NEW.*;
	elsif t >= '2016-12-21 00:00:00+00' and t< '2016-12-22 00:00:00+00' then insert into host_based_report20161221 select NEW.*;
	elsif t >= '2016-12-22 00:00:00+00' and t< '2016-12-23 00:00:00+00' then insert into host_based_report20161222 select NEW.*;
	elsif t >= '2016-12-23 00:00:00+00' and t< '2016-12-24 00:00:00+00' then insert into host_based_report20161223 select NEW.*;
	elsif t >= '2016-12-24 00:00:00+00' and t< '2016-12-25 00:00:00+00' then insert into host_based_report20161224 select NEW.*;
	elsif t >= '2016-12-25 00:00:00+00' and t< '2016-12-26 00:00:00+00' then insert into host_based_report20161225 select NEW.*;
	elsif t >= '2016-12-26 00:00:00+00' and t< '2016-12-27 00:00:00+00' then insert into host_based_report20161226 select NEW.*;
	elsif t >= '2016-12-27 00:00:00+00' and t< '2016-12-28 00:00:00+00' then insert into host_based_report20161227 select NEW.*;
	elsif t >= '2016-12-28 00:00:00+00' and t< '2016-12-29 00:00:00+00' then insert into host_based_report20161228 select NEW.*;
	elsif t >= '2016-12-29 00:00:00+00' and t< '2016-12-30 00:00:00+00' then insert into host_based_report20161229 select NEW.*;
	elsif t >= '2016-12-30 00:00:00+00' and t< '2016-12-31 00:00:00+00' then insert into host_based_report20161230 select NEW.*;
	elsif t >= '2016-12-31 00:00:00+00' and t< '2017-01-01 00:00:00+00' then insert into host_based_report20161231 select NEW.*;
	else
		raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
		return NEW;
	end if;
	return NULL;
END;
$$;


ALTER FUNCTION public.class4_trigfun_host_based_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_info_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_info_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        DECLARE
        BEGIN
		return NULL;

        END
        $$;


ALTER FUNCTION public.class4_trigfun_info_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_record_agent_client_client(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_agent_client_client() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into agent_client_client_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into agent_client_client_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into agent_client_client_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into agent_client_client_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_agent_client_client() OWNER TO postgres;

--
-- Name: class4_trigfun_record_allowed_sendto_ip(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_allowed_sendto_ip() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into allowed_sendto_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into allowed_sendto_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into allowed_sendto_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into allowed_sendto_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_allowed_sendto_ip() OWNER TO postgres;

--
-- Name: class4_trigfun_record_buy_order(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_buy_order() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into buy_order_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into buy_order_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into buy_order_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into buy_order_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_buy_order() OWNER TO postgres;

--
-- Name: class4_trigfun_record_c4_lrn(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_c4_lrn() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into c4_lrn_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into c4_lrn_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into c4_lrn_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into c4_lrn_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_c4_lrn() OWNER TO postgres;

--
-- Name: class4_trigfun_record_client(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_client() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into client_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into client_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into client_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into client_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_client() OWNER TO postgres;

--
-- Name: class4_trigfun_record_client_balance(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_client_balance() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into client_balance_record_tmp select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into client_balance_record_tmp select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into client_balance_record_tmp select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'U';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_client_balance() OWNER TO postgres;

--
-- Name: class4_trigfun_record_client_commit_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_client_commit_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into client_commit_code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into client_commit_code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into client_commit_code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into client_commit_code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_client_commit_code() OWNER TO postgres;

--
-- Name: class4_trigfun_record_client_commit_minutes(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_client_commit_minutes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into client_commit_minutes_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into client_commit_minutes_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into client_commit_minutes_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into client_commit_minutes_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_client_commit_minutes() OWNER TO postgres;

--
-- Name: class4_trigfun_record_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_code() OWNER TO postgres;

--
-- Name: class4_trigfun_record_contract(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_contract() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into contract_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into contract_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into contract_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into contract_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_contract() OWNER TO postgres;

--
-- Name: class4_trigfun_record_currency(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_currency() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into currency_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into currency_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into currency_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into currency_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_currency() OWNER TO postgres;

--
-- Name: class4_trigfun_record_currency_updates(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_currency_updates() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into currency_updates_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into currency_updates_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into currency_updates_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into currency_updates_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_currency_updates() OWNER TO postgres;

--
-- Name: class4_trigfun_record_dynamic_route(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_dynamic_route() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into dynamic_route_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into dynamic_route_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into dynamic_route_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into dynamic_route_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_dynamic_route() OWNER TO postgres;

--
-- Name: class4_trigfun_record_dynamic_route_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_dynamic_route_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into dynamic_route_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into dynamic_route_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into dynamic_route_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into dynamic_route_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_dynamic_route_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_dynamic_route_override(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_dynamic_route_override() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into dynamic_route_override_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into dynamic_route_override_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into dynamic_route_override_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into dynamic_route_override_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_dynamic_route_override() OWNER TO postgres;

--
-- Name: class4_trigfun_record_dynamic_route_pri(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_dynamic_route_pri() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into dynamic_route_pri_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into dynamic_route_pri_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into dynamic_route_pri_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into dynamic_route_pri_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_dynamic_route_pri() OWNER TO postgres;

--
-- Name: class4_trigfun_record_dynamic_route_qos(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_dynamic_route_qos() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into dynamic_route_qos_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into dynamic_route_qos_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into dynamic_route_qos_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into dynamic_route_qos_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_dynamic_route_qos() OWNER TO postgres;

--
-- Name: class4_trigfun_record_egress_profile(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_egress_profile() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into egress_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into egress_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into egress_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into egress_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_egress_profile() OWNER TO postgres;

--
-- Name: class4_trigfun_record_exchange_par_account(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_exchange_par_account() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into exchange_par_account_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into exchange_par_account_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into exchange_par_account_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into exchange_par_account_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_exchange_par_account() OWNER TO postgres;

--
-- Name: class4_trigfun_record_global_route_error(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_global_route_error() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into global_route_error_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into global_route_error_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into global_route_error_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into global_route_error_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_global_route_error() OWNER TO postgres;

--
-- Name: class4_trigfun_record_jurisdiction_prefix(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_jurisdiction_prefix() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into jurisdiction_prefix_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into jurisdiction_prefix_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into jurisdiction_prefix_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into jurisdiction_prefix_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_jurisdiction_prefix() OWNER TO postgres;

--
-- Name: class4_trigfun_record_livecall_user(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_livecall_user() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into livecall_user_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into livecall_user_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into livecall_user_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into livecall_user_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_livecall_user() OWNER TO postgres;

--
-- Name: class4_trigfun_record_lrn_groups(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_lrn_groups() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into lrn_groups_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into lrn_groups_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into lrn_groups_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into lrn_groups_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_lrn_groups() OWNER TO postgres;

--
-- Name: class4_trigfun_record_lrn_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_lrn_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into lrn_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into lrn_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into lrn_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into lrn_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_lrn_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_origination_global_failover(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_origination_global_failover() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into origination_global_failover_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into origination_global_failover_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into origination_global_failover_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into origination_global_failover_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_origination_global_failover() OWNER TO postgres;

--
-- Name: class4_trigfun_record_partition_gateway_ref(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_partition_gateway_ref() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into partition_gateway_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into partition_gateway_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into partition_gateway_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into partition_gateway_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_partition_gateway_ref() OWNER TO postgres;

--
-- Name: class4_trigfun_record_payment_term(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_payment_term() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into payment_term_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into payment_term_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into payment_term_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into payment_term_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_payment_term() OWNER TO postgres;

--
-- Name: class4_trigfun_record_product(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_product() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into product_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into product_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into product_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into product_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_product() OWNER TO postgres;

--
-- Name: class4_trigfun_record_product_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_product_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into product_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into product_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into product_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into product_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_product_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_product_items_resource(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_product_items_resource() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into product_items_resource_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into product_items_resource_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into product_items_resource_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into product_items_resource_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_product_items_resource() OWNER TO postgres;

--
-- Name: class4_trigfun_record_product_rout_rate_table(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_product_rout_rate_table() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into product_rout_rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into product_rout_rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into product_rout_rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into product_rout_rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_product_rout_rate_table() OWNER TO postgres;

--
-- Name: class4_trigfun_record_random_ani_generation(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_random_ani_generation() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into random_ani_generation_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into random_ani_generation_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into random_ani_generation_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into random_ani_generation_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_random_ani_generation() OWNER TO postgres;

--
-- Name: class4_trigfun_record_rate(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_rate() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into rate_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into rate_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into rate_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into rate_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_rate() OWNER TO postgres;

--
-- Name: class4_trigfun_record_rate_table(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_rate_table() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_rate_table() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_block(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_block() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_block_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_block_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_block_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_block_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_block() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_block_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_block_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_block_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_block_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_block_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_block_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_block_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_capacity(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_capacity() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_capacity_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_capacity_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_capacity_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_capacity_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_capacity() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_codecs_ref(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_codecs_ref() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_codecs_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_codecs_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_codecs_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_codecs_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_codecs_ref() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_direction(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_direction() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_direction_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_direction_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_direction_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_direction_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_direction() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_ip(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_ip() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_ip() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_ip_limit(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_ip_limit() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_ip_limit_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_ip_limit_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_ip_limit_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_ip_limit_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_ip_limit() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_lrn_action(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_lrn_action() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_lrn_action_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_lrn_action_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_lrn_action_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_lrn_action_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_lrn_action() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_next_route_rule(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_next_route_rule() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_next_route_rule_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_next_route_rule_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_next_route_rule_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_next_route_rule_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_next_route_rule() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_prefix(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_prefix() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_prefix_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_prefix_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_prefix_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_prefix_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_prefix() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_rate(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_rate() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_rate_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_rate_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_rate_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_rate_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_rate() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_rate_table_ref(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_rate_table_ref() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_rate_table_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_rate_table_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_rate_table_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'U';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_rate_table_ref() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_replace_action(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_replace_action() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_replace_action_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_replace_action_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_replace_action_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_replace_action_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_replace_action() OWNER TO postgres;

--
-- Name: class4_trigfun_record_resource_translation_ref(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_resource_translation_ref() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into resource_translation_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into resource_translation_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into resource_translation_ref_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into resource_translation_ref_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_resource_translation_ref() OWNER TO postgres;

--
-- Name: class4_trigfun_record_route(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_route() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into route_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into route_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into route_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into route_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_route() OWNER TO postgres;

--
-- Name: class4_trigfun_record_sell_order(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_sell_order() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into sell_order_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into sell_order_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into sell_order_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into sell_order_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_sell_order() OWNER TO postgres;

--
-- Name: class4_trigfun_record_service_charge_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_service_charge_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into service_charge_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into service_charge_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into service_charge_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into service_charge_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_service_charge_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_sip_error_code(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_sip_error_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into sip_error_code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into sip_error_code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into sip_error_code_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into sip_error_code_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_sip_error_code() OWNER TO postgres;

--
-- Name: class4_trigfun_record_spam_traffic_ip(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_spam_traffic_ip() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
       if(TG_OP='INSERT')then
               insert into spam_traffic_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
       elseif(TG_OP='DELETE')then
               insert into spam_traffic_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
       elseif(TG_OP='UPDATE')then
               insert into spam_traffic_ip_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
               insert into spam_traffic_ip_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
       end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_spam_traffic_ip() OWNER TO postgres;

--
-- Name: class4_trigfun_record_switch_profile(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_switch_profile() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into switch_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into switch_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into switch_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into switch_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_switch_profile() OWNER TO postgres;

--
-- Name: class4_trigfun_record_termination_global_failover(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_termination_global_failover() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into termination_global_failover_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into termination_global_failover_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into termination_global_failover_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into termination_global_failover_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_termination_global_failover() OWNER TO postgres;

--
-- Name: class4_trigfun_record_time_profile(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_time_profile() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into time_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into time_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into time_profile_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into time_profile_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_time_profile() OWNER TO postgres;

--
-- Name: class4_trigfun_record_transaction_fee_items(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_transaction_fee_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into transaction_fee_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into transaction_fee_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into transaction_fee_items_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into transaction_fee_items_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_transaction_fee_items() OWNER TO postgres;

--
-- Name: class4_trigfun_record_translation_item(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_translation_item() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into translation_item_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into translation_item_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into translation_item_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into translation_item_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_translation_item() OWNER TO postgres;

--
-- Name: class4_trigfun_record_trunk_pstn_header(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_record_trunk_pstn_header() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin

        if(TG_OP='INSERT')then
                insert into trunk_pstn_header_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into trunk_pstn_header_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into trunk_pstn_header_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into trunk_pstn_header_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.class4_trigfun_record_trunk_pstn_header() OWNER TO postgres;

--
-- Name: class4_trigfun_report_detail_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_report_detail_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ DECLARE t timestamp with time zone;
BEGIN
	t:= NEW.report_time;
	if t >= '2017-06-07 00:00:00+00' and t < '2017-06-08 00:00:00+00' then insert into cdr_report_detail20170607 select NEW.*;
	elsif t >= '2017-06-06 00:00:00+00' and t< '2017-06-07 00:00:00+00' then insert into cdr_report_detail20170606 select NEW.*;
	elsif t >= '2016-12-09 00:00:00+00' and t< '2016-12-10 00:00:00+00' then insert into cdr_report_detail20161209 select NEW.*;
	elsif t >= '2016-12-14 00:00:00+00' and t< '2016-12-15 00:00:00+00' then insert into cdr_report_detail20161214 select NEW.*;
	elsif t >= '2016-12-15 00:00:00+00' and t< '2016-12-16 00:00:00+00' then insert into cdr_report_detail20161215 select NEW.*;
	elsif t >= '2016-12-18 00:00:00+00' and t< '2016-12-19 00:00:00+00' then insert into cdr_report_detail20161218 select NEW.*;
	elsif t >= '2016-12-27 00:00:00+00' and t< '2016-12-28 00:00:00+00' then insert into cdr_report_detail20161227 select NEW.*;
	elsif t >= '2016-12-31 00:00:00+00' and t< '2017-01-01 00:00:00+00' then insert into cdr_report_detail20161231 select NEW.*;
	elsif t >= '2016-12-10 00:00:00+00' and t< '2016-12-11 00:00:00+00' then insert into cdr_report_detail20161210 select NEW.*;
	elsif t >= '2016-12-11 00:00:00+00' and t< '2016-12-12 00:00:00+00' then insert into cdr_report_detail20161211 select NEW.*;
	elsif t >= '2016-12-12 00:00:00+00' and t< '2016-12-13 00:00:00+00' then insert into cdr_report_detail20161212 select NEW.*;
	elsif t >= '2016-12-13 00:00:00+00' and t< '2016-12-14 00:00:00+00' then insert into cdr_report_detail20161213 select NEW.*;
	elsif t >= '2016-12-16 00:00:00+00' and t< '2016-12-17 00:00:00+00' then insert into cdr_report_detail20161216 select NEW.*;
	elsif t >= '2016-12-17 00:00:00+00' and t< '2016-12-18 00:00:00+00' then insert into cdr_report_detail20161217 select NEW.*;
	elsif t >= '2016-12-19 00:00:00+00' and t< '2016-12-20 00:00:00+00' then insert into cdr_report_detail20161219 select NEW.*;
	elsif t >= '2016-12-20 00:00:00+00' and t< '2016-12-21 00:00:00+00' then insert into cdr_report_detail20161220 select NEW.*;
	elsif t >= '2016-12-21 00:00:00+00' and t< '2016-12-22 00:00:00+00' then insert into cdr_report_detail20161221 select NEW.*;
	elsif t >= '2016-12-22 00:00:00+00' and t< '2016-12-23 00:00:00+00' then insert into cdr_report_detail20161222 select NEW.*;
	elsif t >= '2016-12-23 00:00:00+00' and t< '2016-12-24 00:00:00+00' then insert into cdr_report_detail20161223 select NEW.*;
	elsif t >= '2016-12-24 00:00:00+00' and t< '2016-12-25 00:00:00+00' then insert into cdr_report_detail20161224 select NEW.*;
	elsif t >= '2016-12-25 00:00:00+00' and t< '2016-12-26 00:00:00+00' then insert into cdr_report_detail20161225 select NEW.*;
	elsif t >= '2016-12-26 00:00:00+00' and t< '2016-12-27 00:00:00+00' then insert into cdr_report_detail20161226 select NEW.*;
	elsif t >= '2016-12-28 00:00:00+00' and t< '2016-12-29 00:00:00+00' then insert into cdr_report_detail20161228 select NEW.*;
	elsif t >= '2016-12-29 00:00:00+00' and t< '2016-12-30 00:00:00+00' then insert into cdr_report_detail20161229 select NEW.*;
	elsif t >= '2016-12-30 00:00:00+00' and t< '2016-12-31 00:00:00+00' then insert into cdr_report_detail20161230 select NEW.*;
	else
		raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
		return NEW;
	end if;
	return NULL;
END;
$$;


ALTER FUNCTION public.class4_trigfun_report_detail_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
        DECLARE
		t timestamp with time zone;
        BEGIN
		t:= NEW.report_time;

                if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
                        insert into cdr_report20161201 select NEW.*;
                elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
                        insert into cdr_report20161202 select NEW.*;
                elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
                        insert into cdr_report20161130 select NEW.*;
				elsif t >= '2016-10-16 00:00:00' and t< '2016-10-17 00:00:00' then insert into cdr_report20161016 select NEW.*;
elsif t >= '2016-10-17 00:00:00' and t< '2016-10-18 00:00:00' then insert into cdr_report20161017 select NEW.*;
elsif t >= '2016-10-18 00:00:00' and t< '2016-10-19 00:00:00' then insert into cdr_report20161018 select NEW.*;
elsif t >= '2016-10-19 00:00:00' and t< '2016-10-20 00:00:00' then insert into cdr_report20161019 select NEW.*;
elsif t >= '2016-10-20 00:00:00' and t< '2016-10-21 00:00:00' then insert into cdr_report20161020 select NEW.*;
elsif t >= '2016-10-21 00:00:00' and t< '2016-10-22 00:00:00' then insert into cdr_report20161021 select NEW.*;
elsif t >= '2016-10-22 00:00:00' and t< '2016-10-23 00:00:00' then insert into cdr_report20161022 select NEW.*;
elsif t >= '2016-10-23 00:00:00' and t< '2016-10-24 00:00:00' then insert into cdr_report20161023 select NEW.*;
elsif t >= '2016-10-24 00:00:00' and t< '2016-10-25 00:00:00' then insert into cdr_report20161024 select NEW.*;
elsif t >= '2016-10-25 00:00:00' and t< '2016-10-26 00:00:00' then insert into cdr_report20161025 select NEW.*;
elsif t >= '2016-10-26 00:00:00' and t< '2016-10-27 00:00:00' then insert into cdr_report20161026 select NEW.*;
elsif t >= '2016-10-27 00:00:00' and t< '2016-10-28 00:00:00' then insert into cdr_report20161027 select NEW.*;
elsif t >= '2016-10-28 00:00:00' and t< '2016-10-29 00:00:00' then insert into cdr_report20161028 select NEW.*;
elsif t >= '2016-10-29 00:00:00' and t< '2016-10-30 00:00:00' then insert into cdr_report20161029 select NEW.*;
elsif t >= '2016-10-30 00:00:00' and t< '2016-10-31 00:00:00' then insert into cdr_report20161030 select NEW.*;
elsif t >= '2016-10-31 00:00:00' and t< '2016-11-01 00:00:00' then insert into cdr_report20161031 select NEW.*;
elsif t >= '2016-11-01 00:00:00' and t< '2016-11-02 00:00:00' then insert into cdr_report20161101 select NEW.*;
elsif t >= '2016-11-02 00:00:00' and t< '2016-11-03 00:00:00' then insert into cdr_report20161102 select NEW.*;
elsif t >= '2016-11-03 00:00:00' and t< '2016-11-04 00:00:00' then insert into cdr_report20161103 select NEW.*;
elsif t >= '2016-11-04 00:00:00' and t< '2016-11-05 00:00:00' then insert into cdr_report20161104 select NEW.*;
elsif t >= '2016-11-05 00:00:00' and t< '2016-11-06 00:00:00' then insert into cdr_report20161105 select NEW.*;
elsif t >= '2016-11-06 00:00:00' and t< '2016-11-07 00:00:00' then insert into cdr_report20161106 select NEW.*;
elsif t >= '2016-11-07 00:00:00' and t< '2016-11-08 00:00:00' then insert into cdr_report20161107 select NEW.*;
elsif t >= '2016-11-08 00:00:00' and t< '2016-11-09 00:00:00' then insert into cdr_report20161108 select NEW.*;
elsif t >= '2016-11-09 00:00:00' and t< '2016-11-10 00:00:00' then insert into cdr_report20161109 select NEW.*;
elsif t >= '2016-11-10 00:00:00' and t< '2016-11-11 00:00:00' then insert into cdr_report20161110 select NEW.*;
elsif t >= '2016-11-11 00:00:00' and t< '2016-11-12 00:00:00' then insert into cdr_report20161111 select NEW.*;
elsif t >= '2016-11-12 00:00:00' and t< '2016-11-13 00:00:00' then insert into cdr_report20161112 select NEW.*;
elsif t >= '2016-11-13 00:00:00' and t< '2016-11-14 00:00:00' then insert into cdr_report20161113 select NEW.*;
elsif t >= '2016-11-14 00:00:00' and t< '2016-11-15 00:00:00' then insert into cdr_report20161114 select NEW.*;
elsif t >= '2016-11-15 00:00:00' and t< '2016-11-16 00:00:00' then insert into cdr_report20161115 select NEW.*;
elsif t >= '2016-11-16 00:00:00' and t< '2016-11-17 00:00:00' then insert into cdr_report20161116 select NEW.*;
elsif t >= '2016-11-17 00:00:00' and t< '2016-11-18 00:00:00' then insert into cdr_report20161117 select NEW.*;
elsif t >= '2016-11-18 00:00:00' and t< '2016-11-19 00:00:00' then insert into cdr_report20161118 select NEW.*;
elsif t >= '2016-11-19 00:00:00' and t< '2016-11-20 00:00:00' then insert into cdr_report20161119 select NEW.*;
elsif t >= '2016-11-20 00:00:00' and t< '2016-11-21 00:00:00' then insert into cdr_report20161120 select NEW.*;
elsif t >= '2016-11-21 00:00:00' and t< '2016-11-22 00:00:00' then insert into cdr_report20161121 select NEW.*;
elsif t >= '2016-11-22 00:00:00' and t< '2016-11-23 00:00:00' then insert into cdr_report20161122 select NEW.*;
elsif t >= '2016-11-23 00:00:00' and t< '2016-11-24 00:00:00' then insert into cdr_report20161123 select NEW.*;
elsif t >= '2016-11-24 00:00:00' and t< '2016-11-25 00:00:00' then insert into cdr_report20161124 select NEW.*;
elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into cdr_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into cdr_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into cdr_report20161202 select NEW.*;

                else
                        raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
                        return NEW;
                end if;


                return NULL;
        END
        $$;


ALTER FUNCTION public.class4_trigfun_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_upload(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_upload() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
declare
	table_type integer;
	table_name text;
	create_cmd text;
begin
	table_type := NEW.upload_type;
	table_name := NEW.upload_table;

	if table_type=1 then
	--upload ingress
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial,
		alias text NOT NULL,
		active text DEFAULT $$true$$,
		t38 text DEFAULT $$false$$,
		cps_limit text,
		capacity text,
		lnp text DEFAULT $$false$$,
		lrn_block text DEFAULT $$false$$,
		carrier_name text NOT NULL,
		rate_table_name text,
		route_plan_name text,
		media_type text DEFAULT $$1$$,--0ï¼ï¼Proxy Media + Transcoding,1ï¼ï¼Proxy Media,2ï¼ï¼Bypass Media
		proto text DEFAULT $$1$$,--1--sip,2--h323,0--all
		dnis_only text DEFAULT $$true$$,
		ring_timeout text,
		ignore_ring text DEFAULT $$false$$,
		ignore_early_media text DEFAULT $$false$$,
		codec text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=2 then
	--upload egress
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		alias text NOT NULL,
		active text DEFAULT $$true$$,
		t38 text DEFAULT $$false$$,
		res_strategy text DEFAULT $$1$$,--1ï¼ï¼top-down,2ï¼ï¼round-robin
		cps_limit text,
		capacity text,
		lnp text DEFAULT $$false$$,
		lrn_block text DEFAULT $$false$$,
		carrier_name text NOT NULL,
		rate_table_name text,
		route_plan_name text,
		media_type text DEFAULT $$1$$,--0ï¼ï¼Proxy Media + Transcoding,1ï¼ï¼Proxy Media,2ï¼ï¼Bypass Media
		proto text DEFAULT $$1$$,--1--sip,2--h323
		dnis_only text DEFAULT $$true$$,
		ring_timeout text,
		ignore_ring text DEFAULT $$false$$,
		ignore_early_media text DEFAULT $$false$$,
		codec text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=3 then
	--upload host
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		resource_name text NOT NULL,
		ip text NOT NULL,
		port text NOT NULL,
		time_profile_name text,
		cps text,
		capacity text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=4 then
	--upload resource_action
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		resource_name text NOT NULL,
		direction text NOT NULL,--1ï¼ï¼ingress,2ï¼ï¼egress
		"action" text NOT NULL,
		digits text NOT NULL,
		dnis text,
		time_profile_name text,
		"type" text NOT NULL,
		number_length text,
		number_type text DEFAULT $$0$$,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=5 then
	--upload resource digit mapping
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		resource_name text NOT NULL,
		translation_name text NOT NULL,
		time_profile_name text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=6 then
	--upload digit translation
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		ani text,
		dnis text,
		action_ani text NOT NULL,
		action_dnis text NOT NULL,
		ani_method text NOT NULL,--0ï¼ï¼ignore,1ï¼ï¼compare,2ï¼ï¼replace
		dnis_method text NOT NULL,--0ï¼ï¼ignore,1ï¼ï¼compare,2ï¼ï¼replace
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=7 then
	--upload resource block
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		ingress_name text NOT NULL,
		engress_name text NOT NULL,
		digit text,
		time_profile_name text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=8 then
	--upload jurisdiction
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		--alias text ,
		prefix text NOT NULL,
		state text NOT NULL,
		jurisdiction_name text NOT NULL,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=9 then
	--upload code
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		code text NOT NULL,
		country text NOT NULL,
		"name" text NOT NULL,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=10 then
	--upload rate
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		code text NOT NULL,
		rate text NOT NULL DEFAULT $$0$$,
		setup_fee text DEFAULT $$0$$,
		effective_date text DEFAULT current_timestamp(0)::text,
		end_date text,
		min_time text DEFAULT $$0$$,
		grace_time text DEFAULT $$0$$,
		"interval" text DEFAULT $$1$$,
		time_profile_name text,
		seconds text DEFAULT $$60$$,
		code_name text,
		intra_rate text DEFAULT $$0$$,
		inter_rate text DEFAULT $$0$$,
		local_rate text DEFAULT $$0$$,
		country text,
		zone text DEFAULT $$0$$,
		error_info text,
		is_duplicate boolean
		)';
		return null;
	elsif table_type=11 then
	--upload static route
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		digits text NOT NULL,
		strategy text NOT NULL,
		resource_alias text NOT NULL,
		percentage text,
		time_profile_name text,
		error_info text,
		is_duplicate boolean
		)';
	elsif table_type=12 then
	--upload route plan
		create_cmd := 'CREATE TABLE ' ||
		table_name
		|| '(
		id serial ,
		digits text,
		route_type text NOT NULL,
		dynamic_route_name text,
		static_route_name text,
		error_info text,
		is_duplicate boolean
		)';
	else return null;
	end if;

	execute create_cmd;

	return null;

end;
$_$;


ALTER FUNCTION public.class4_trigfun_upload() OWNER TO postgres;

--
-- Name: class4_trigfun_us_frequent_number_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_us_frequent_number_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
		DECLARE
		t timestamp with time zone;
		BEGIN
		t:= NEW.report_time;

				if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
						insert into us_frequent_number_report20161201 select NEW.*;
				elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
						insert into us_frequent_number_report20161202 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
						insert into us_frequent_number_report20161130 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into us_frequent_number_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into us_frequent_number_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into us_frequent_number_report20161202 select NEW.*;

				else
						raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
						return NEW;
				end if;


				return NULL;
		END
		$$;


ALTER FUNCTION public.class4_trigfun_us_frequent_number_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_us_lcr_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_us_lcr_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
		DECLARE
		t timestamp with time zone;
		BEGIN
		t:= NEW.report_time;

				if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
						insert into us_lcr_report20161201 select NEW.*;
				elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
						insert into us_lcr_report20161202 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
						insert into us_lcr_report20161130 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into us_lcr_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into us_lcr_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into us_lcr_report20161202 select NEW.*;

				else
						raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
						return NEW;
				end if;


				return NULL;
		END
		$$;


ALTER FUNCTION public.class4_trigfun_us_lcr_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_us_lcr_vendor_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_us_lcr_vendor_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
		DECLARE
		t timestamp with time zone;
		BEGIN
		t:= NEW.report_time;

				if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
						insert into us_lcr_vendor_report20161201 select NEW.*;
				elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
						insert into us_lcr_vendor_report20161202 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
						insert into us_lcr_vendor_report20161130 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into us_lcr_vendor_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into us_lcr_vendor_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into us_lcr_vendor_report20161202 select NEW.*;

				else
						raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
						return NEW;
				end if;


				return NULL;
		END
		$$;


ALTER FUNCTION public.class4_trigfun_us_lcr_vendor_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_us_return_code_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_us_return_code_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
		DECLARE
		t timestamp with time zone;
		BEGIN
		t:= NEW.report_time;

				if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
						insert into us_return_code_report20161201 select NEW.*;
				elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
						insert into us_return_code_report20161202 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
						insert into us_return_code_report20161130 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into us_return_code_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into us_return_code_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into us_return_code_report20161202 select NEW.*;

				else
						raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
						return NEW;
				end if;


				return NULL;
		END
		$$;


ALTER FUNCTION public.class4_trigfun_us_return_code_report_insert() OWNER TO postgres;

--
-- Name: class4_trigfun_us_termination_vendor_report_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4_trigfun_us_termination_vendor_report_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
		DECLARE
		t timestamp with time zone;
		BEGIN
		t:= NEW.report_time;

				if t >= '2016-12-01 00:00:00' and t < '2016-12-02 00:00:00' then
						insert into us_termination_vendor_report20161201 select NEW.*;
				elsif t >= '2016-12-02 00:00:00' and t < '2016-12-03 00:00:00' then
						insert into us_termination_vendor_report20161202 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t < '2016-12-01 00:00:00' then
						insert into us_termination_vendor_report20161130 select NEW.*;
				elsif t >= '2016-11-30 00:00:00' and t< '2016-12-01 00:00:00' then insert into us_termination_vendor_report20161130 select NEW.*;
elsif t >= '2016-12-01 00:00:00' and t< '2016-12-02 00:00:00' then insert into us_termination_vendor_report20161201 select NEW.*;
elsif t >= '2016-12-02 00:00:00' and t< '2016-12-03 00:00:00' then insert into us_termination_vendor_report20161202 select NEW.*;

				else
						raise warning 'The time (%) of cdr is not accepted by subtable, storing in supertable',NEW.report_time;
						return NEW;
				end if;


				return NULL;
		END
		$$;


ALTER FUNCTION public.class4_trigfun_us_termination_vendor_report_insert() OWNER TO postgres;

--
-- Name: class4fun_rate_dynamic2static(integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4fun_rate_dynamic2static(integer, integer, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$

declare
	id_rate_table alias for $1;
	id_rate alias for $2;
	code_rate alias for $3;
	action alias for $4;
        rate_prefix prefix_range;
        id_static_product integer;
        id_dynamic_route integer;
        old_code text;
        new_code text;
        r record;
        route_rule integer;
        id_profile integer;
        res record;
        sql_text text;
        new_res_1 integer;
        new_res_2 integer;
        new_res_3 integer;
        new_res_4 integer;
        new_res_5 integer;
        new_res_6 integer;
        new_res_7 integer;
        new_res_8 integer;
	prefix_count integer;

begin
        if(action='INSERT') then
			select into new_code COALESCE(code_rate,'');
-- 			select into prefix_count count(1) from rate where rate_table_id=id_rate_table and code::text=new_code;
-- 			if prefix_count>1 then
-- 				--raise notice 'code % exists in rate table %',new_code,NEW.rate_table_id;
-- 				return null;
-- 			end if;
                        for id_dynamic_route in select dynamic_route_id from dynamic_route where
                        resource_id_1 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_2 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_3 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_4 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_5 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_6 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_7 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_8 in (select resource_id from resource where rate_table_id = id_rate_table)
                        loop
                                select into route_rule routing_rule from dynamic_route where dynamic_route_id = id_dynamic_route;
                                select into id_profile time_profile_id from dynamic_route where dynamic_route_id = id_dynamic_route;
                                select into id_static_product product_id from product where dynamic_route_id = id_dynamic_route;

                                select into res resource_id_1,resource_id_2,resource_id_3,resource_id_4,
                                resource_id_5,resource_id_6,resource_id_7,resource_id_8 from dynamic_route where dynamic_route_id=id_dynamic_route;

                                select into new_res_1 COALESCE(res.resource_id_1,-1);
                                select into new_res_2 COALESCE(res.resource_id_2,-1);
                                select into new_res_3 COALESCE(res.resource_id_3,-1);
                                select into new_res_4 COALESCE(res.resource_id_4,-1);
                                select into new_res_5 COALESCE(res.resource_id_5,-1);
                                select into new_res_6 COALESCE(res.resource_id_6,-1);
                                select into new_res_7 COALESCE(res.resource_id_7,-1);
                                select into new_res_8 COALESCE(res.resource_id_8,-1);

				PERFORM dynamic2static(id_dynamic_route,id_static_product,
				new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8,route_rule,id_profile,new_code);

                        end loop;
        end if;

        if(action='DELETE') then
                        select into old_code COALESCE(code_rate,'');
-- 			if exists(select 1 from rate where rate_table_id=OLD.rate_table_id and code::text=old_code) then
-- 				--raise notice 'code % exists in rate table %',old_code,OLD.rate_table_id;
-- 				return null;
-- 			end if;
                        for id_dynamic_route in select dynamic_route_id from dynamic_route where
                        resource_id_1 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_2 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_3 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_4 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_5 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_6 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_7 in (select resource_id from resource where rate_table_id = id_rate_table) or
                        resource_id_8 in (select resource_id from resource where rate_table_id = id_rate_table)
                        loop
                                select into route_rule routing_rule from dynamic_route where dynamic_route_id = id_dynamic_route;
                                select into id_profile time_profile_id from dynamic_route where dynamic_route_id = id_dynamic_route;
                                select into id_static_product product_id from product where dynamic_route_id = id_dynamic_route;

                                select into res resource_id_1,resource_id_2,resource_id_3,resource_id_4,
                                resource_id_5,resource_id_6,resource_id_7,resource_id_8 from dynamic_route where dynamic_route_id=id_dynamic_route;

                                select into new_res_1 COALESCE(res.resource_id_1,-1);
                                select into new_res_2 COALESCE(res.resource_id_2,-1);
                                select into new_res_3 COALESCE(res.resource_id_3,-1);
                                select into new_res_4 COALESCE(res.resource_id_4,-1);
                                select into new_res_5 COALESCE(res.resource_id_5,-1);
                                select into new_res_6 COALESCE(res.resource_id_6,-1);
                                select into new_res_7 COALESCE(res.resource_id_7,-1);
                                select into new_res_8 COALESCE(res.resource_id_8,-1);

				PERFORM dynamic2static(id_dynamic_route,id_static_product,
				new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8,route_rule,id_profile,old_code);

                        end loop;
        end if;

        return null;

end;

$_$;


ALTER FUNCTION public.class4fun_rate_dynamic2static(integer, integer, text, text) OWNER TO postgres;

--
-- Name: class4fun_rate_table_dynamic2static(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4fun_rate_table_dynamic2static(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$

declare
	id_rate_table alias for $1;
        rate_prefix prefix_range;
        id_static_product integer;
        id_dynamic_route integer;
        old_rt integer;
        new_rt integer;
        r record;
        route_rule integer;
        id_profile integer;
        res record;
        new_res_1 integer;
        new_res_2 integer;
        new_res_3 integer;
        new_res_4 integer;
        new_res_5 integer;
        new_res_6 integer;
        new_res_7 integer;
        new_res_8 integer;
        sql_text text;

begin
	for id_dynamic_route in select dynamic_route_id from dynamic_route where
	resource_id_1 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_2 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_3 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_4 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_5 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_6 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_7 in (select resource_id from resource where rate_table_id = id_rate_table) or
	resource_id_8 in (select resource_id from resource where rate_table_id = id_rate_table)
	loop
		select into route_rule routing_rule from dynamic_route where dynamic_route_id = id_dynamic_route;
		select into id_profile time_profile_id from dynamic_route where dynamic_route_id = id_dynamic_route;
		select into id_static_product product_id from product where dynamic_route_id = id_dynamic_route;

		select into res resource_id_1,resource_id_2,resource_id_3,resource_id_4,
		resource_id_5,resource_id_6,resource_id_7,resource_id_8 from dynamic_route where dynamic_route_id=id_dynamic_route;

		select into new_res_1 COALESCE(res.resource_id_1,-1);
		select into new_res_2 COALESCE(res.resource_id_2,-1);
		select into new_res_3 COALESCE(res.resource_id_3,-1);
		select into new_res_4 COALESCE(res.resource_id_4,-1);
		select into new_res_5 COALESCE(res.resource_id_5,-1);
		select into new_res_6 COALESCE(res.resource_id_6,-1);
		select into new_res_7 COALESCE(res.resource_id_7,-1);
		select into new_res_8 COALESCE(res.resource_id_8,-1);

		PERFORM dynamic2static(id_dynamic_route,id_static_product,
		new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8,route_rule,id_profile);

	end loop;

        return null;

end;

$_$;


ALTER FUNCTION public.class4fun_rate_table_dynamic2static(integer) OWNER TO postgres;

--
-- Name: class4fun_rate_update_dynamic2static(integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.class4fun_rate_update_dynamic2static(integer, integer, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$

declare
	id_rate_table alias for $1;
	id_rate alias for $2;
	code_rate alias for $3;
	old_code_rate alias for $4;
        rate_prefix prefix_range;
        id_static_product integer;
        id_dynamic_route integer;
        old_code text;
        new_code text;
        r record;
        route_rule integer;
        id_profile integer;
        res record;
        sql_text text;
        new_res_1 integer;
        new_res_2 integer;
        new_res_3 integer;
        new_res_4 integer;
        new_res_5 integer;
        new_res_6 integer;
        new_res_7 integer;
        new_res_8 integer;
	prefix_count integer;

begin
	--if(TG_OP='UPDATE') then
		select into old_code COALESCE(old_code_rate,'');
		select into new_code COALESCE(code_rate,'');
		if old_code != new_code then
			for id_dynamic_route in
			select dynamic_route_id from dynamic_route where
			resource_id_1 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_2 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_3 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_4 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_5 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_6 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_7 in (select resource_id from resource where rate_table_id = id_rate_table) or
			resource_id_8 in (select resource_id from resource where rate_table_id = id_rate_table)
			loop
				select into route_rule routing_rule from dynamic_route where dynamic_route_id = id_dynamic_route;
				select into id_profile time_profile_id from dynamic_route where dynamic_route_id = id_dynamic_route;
				select into id_static_product product_id from product where dynamic_route_id = id_dynamic_route;

				select into res resource_id_1,resource_id_2,resource_id_3,resource_id_4,
				resource_id_5,resource_id_6,resource_id_7,resource_id_8 from dynamic_route where dynamic_route_id=id_dynamic_route;

				select into new_res_1 COALESCE(res.resource_id_1,-1);
				select into new_res_2 COALESCE(res.resource_id_2,-1);
				select into new_res_3 COALESCE(res.resource_id_3,-1);
				select into new_res_4 COALESCE(res.resource_id_4,-1);
				select into new_res_5 COALESCE(res.resource_id_5,-1);
				select into new_res_6 COALESCE(res.resource_id_6,-1);
				select into new_res_7 COALESCE(res.resource_id_7,-1);
				select into new_res_8 COALESCE(res.resource_id_8,-1);

				--if not exists(select 1 from rate where rate_table_id=OLD.rate_table_id and code::text=old_code) then
					PERFORM dynamic2static(id_dynamic_route,id_static_product,
					new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8,route_rule,id_profile,old_code);
-- 				else
-- 					raise notice 'code % exists in rate table %',old_code,OLD.rate_table_id;
				--end if;
				--select into prefix_count count(1) from rate where rate_table_id=NEW.rate_table_id and code::text=new_code;
				--if prefix_count=1 then
					PERFORM dynamic2static(id_dynamic_route,id_static_product,
					new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8,route_rule,id_profile,new_code);
-- 				else
-- 					raise notice 'code % exists in rate table %',new_code,NEW.rate_table_id;
				--end if;
			end loop;
		end if;
	--end if;

        return null;

end;

$_$;


ALTER FUNCTION public.class4fun_rate_update_dynamic2static(integer, integer, text, text) OWNER TO postgres;

--
-- Name: clean_rate(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.clean_rate() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
	clean_days integer;
begin

	select into clean_days rate_clean_days from system_parameter;
	delete from rate where end_date-now()>clean_days::text::interval;
end;

$$;


ALTER FUNCTION public.clean_rate() OWNER TO postgres;

--
-- Name: client_enough_balance(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.client_enough_balance(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
	low_cost client.allowed_credit%type;
	now_balance numeric;
	id_client alias for $1;

begin
	select into low_cost allowed_credit from client where client_id = id_client;
	select into now_balance balance from client_balance where client_id = id_client::text
	order by client_balance_id desc limit 1;
	if not found then
		now_balance := 0;
	end if;
	if now_balance <= low_cost then
		return false;
	else
		return true;
	end if;

end;
$_$;


ALTER FUNCTION public.client_enough_balance(integer) OWNER TO postgres;

--
-- Name: code_stats(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.code_stats(timestamp with time zone, timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	time_start alias for $1;
	time_end alias for $2;
begin

	delete from code_stats;
	for r in
		select term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00') as s_time,
		count(*) as ca,
		count(case answer_time_of_date when '0' then null when '' then null else answer_time_of_date end) as success_calls,
		sum(call_duration::real)/60 as minutes
		from client_cdr
		where time between time_start and time_end
		group by term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00')
	loop
		insert into code_stats(country,code_name,code,call_duration,ca,success_calls,stat_time)
		select r.term_country,r.term_code_name,r.term_code,r.minutes,r.ca,r.success_calls,r.s_time::timestamp with time zone;
	end loop;
end;

$_$;


ALTER FUNCTION public.code_stats(timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.connectby(text, text, text, text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text';


ALTER FUNCTION public.connectby(text, text, text, text, integer) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.connectby(text, text, text, text, integer, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text';


ALTER FUNCTION public.connectby(text, text, text, text, integer, text) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.connectby(text, text, text, text, text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text_serial';


ALTER FUNCTION public.connectby(text, text, text, text, text, integer) OWNER TO postgres;

--
-- Name: connectby(text, text, text, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.connectby(text, text, text, text, text, integer, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'connectby_text_serial';


ALTER FUNCTION public.connectby(text, text, text, text, text, integer, text) OWNER TO postgres;

--
-- Name: create_client_invoice(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_client_invoice() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
	last_date date;
	r record;
	pay_term_row record;
	in_total numeric := 0;
	in_amount numeric := 0;
	out_total numeric := 0;
	out_amount numeric := 0;
	in_minutes integer := 0;
	out_minutes integer := 0;
	due date;
	now_balance numeric;
	no_invoice text;
	r1 record;
	l_rate_minutes integer;
	gt_rate_minutes integer;
	gt_max_rate_minutes integer;
	charge_rate record;
	l_sell_rate_minutes integer;
	gt_sell_rate_minutes integer;
	gt_sell_max_rate_minutes integer;
	past_amount numeric := 0;
	pay_more_days integer;
	invoice_start_time timestamp with time zone;
	invoice_end_time timestamp with time zone;
	lrn_count integer := 0;
	lrn_call_rate numeric;
	lrn_call_cost numeric;

begin
	for r in select * from client where auto_invoicing = true
	loop
		in_total := 0;
		in_amount := 0;
		out_total := 0;
		out_amount := 0;
		l_rate_minutes := 0;
		gt_rate_minutes := 0;
		gt_max_rate_minutes := 0;
		l_sell_rate_minutes := 0;
		gt_sell_rate_minutes := 0;
		gt_sell_max_rate_minutes := 0;
		in_minutes := 0;
		out_minutes := 0;
		past_amount := 0;
		select into pay_term_row * from payment_term where payment_term_id = r.payment_term_id;

		select into last_date last_invoiced from client where client_id = r.client_id;
		if last_date is null then
			raise notice 'last invoice date is not found';
			continue;
		end if;
		if(last_date=current_date) then
			continue;
		end if;

		if(pay_term_row.type=1) then
		/*every days*/
			if(last_date + pay_term_row.days != current_date) then
				continue;
			end if;
		end if;
		if(pay_term_row.type=2) then
		/*every month*/
			if pay_term_row.days!=EXTRACT(DAY from now()) then
				if (to_char(now(),'DD') != to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) or (pay_term_row.days::text < to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) then
					continue;
				end if;
			end if;
		end if;
		if(pay_term_row.type=3) then
		/*every week*/
			if(pay_term_row.days != EXTRACT(DOW FROM now())) then
				continue;
			end if;
		end if;
		if(pay_term_row.type=4) then
		/*every month,more days*/
			for pay_more_days in select regexp_split_to_table(pay_term_row.more_days,',')
			loop
				if pay_more_days=EXTRACT(DAY from now()) then
					exit;
				elsif pay_more_days::text > to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD') and to_char(now(),'DD') = to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD') then
					exit;
				else
					continue;
				end if;
			end loop;
			if pay_more_days!=EXTRACT(DAY from now()) then
				if (to_char(now(),'DD') != to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) or (pay_more_days::text < to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) then
					continue;
				end if;
			end if;
		end if;

		raise notice 'create invoice for client %',r.client_id;
		select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;

		if r.invoice_zone is null or r.invoice_zone = '' or r.invoice_zone =' ' then
		select into invoice_start_time to_char(last_date,'YYYY-MM-DD 00:00:00')::timestamp with time zone;
		select into invoice_end_time to_char(current_date-1,'YYYY-MM-DD 23:59:59')::timestamp with time zone;
		else
		select into invoice_start_time (to_char(last_date,'YYYY-MM-DD 00:00:00')||r.invoice_zone)::timestamp with time zone;
		select into invoice_end_time (to_char(current_date-1,'YYYY-MM-DD 23:59:59')||r.invoice_zone)::timestamp with time zone;
		end if;

		if exists(select 1 from invoice where client_id=r.client_id and invoice_start=invoice_start_time and invoice_end=invoice_end_time) then
		raise notice 'exist invoice,continue';
		continue;
		end if;

		if r.auto_invoice_type=0 then
		--buy invoice

		------------------Ingress Invoice--------------
		select into lrn_count
		count(*)
		from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time
		and (lrn_number_vendor='2' or lrn_number_vendor='3') and is_final_call='1';
		if lrn_count is null then
			lrn_count := 0;
		end if;

		select into lrn_call_cost
		sum(case when lnp_dipping_cost is null then 0 when lnp_dipping_cost='' then 0 else lnp_dipping_cost::real end)
		from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if lrn_call_cost is null then
			lrn_call_cost := 0;
		end if;

		if lrn_count = 0 then
			lrn_call_rate :=0;
		else
			lrn_call_rate := lrn_call_cost/lrn_count;
		end if;

		select into in_total sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_total is null then
			in_total :=0;
		end if;

		if in_total = 0 and (r.invoice_zero is true or r.invoice_zero is null) then
		raise notice 'cost is 0,continue';
		continue;
		end if;

		select into in_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_minutes is null then
			in_minutes := 0;
		end if;

		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'buy total %,buy minutes %',in_total,in_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT trim(both ' ' from orig_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case ingress_rate_effective_date when '' then null else ingress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) as total_cost,
		case ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60)
		when 0 then 0
		else sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end)
		/
		(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where ingress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and ingress_client_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by trim(both ' ' from orig_code_name),ingress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,0,r1.effective_date::text;
		end loop;

		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type,lrn_numbers,lrn_rate,lrn_cost,invoice_zone)
		select
		in_total,in_total,null,in_minutes,null,0,0,0,r.client_id,current_timestamp(0),invoice_start_time,invoice_end_time,due,now_balance,no_invoice,0,null,null,null,r.invoice_zone;

		select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;

		elsif r.auto_invoice_type=1 then
		--sell invoice

		------------------Egress Invoice--------------
		select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_total is null then
			out_total :=0;
		end if;
		if out_total = 0 and (r.invoice_zero is true or r.invoice_zero is null) then
		raise notice 'cost is 0,continue';
                continue;
		end if;

		select into out_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case egress_bill_time when '' then 0 else egress_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_minutes is null then
			out_minutes := 0;
		end if;
		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'sell total %,sell minutes %',out_total,out_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT trim(both ' ' from term_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case egress_rate_effective_date when '' then null else egress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case egress_cost when '' then 0 else egress_cost::numeric end) as total_cost,
		case ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60)
		when 0 then 0
		else
		sum(case egress_cost when '' then 0 else egress_cost::numeric end)
		/
		(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where egress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and egress_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by trim(both ' ' from term_code_name),egress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,1,r1.effective_date::text;
		end loop;

		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type,invoice_zone)
		select
		out_total,null,out_total,null,out_minutes,0,0,0,r.client_id,current_timestamp(0),invoice_start_time,invoice_end_time,due,now_balance,no_invoice,1,r.invoice_zone;


		elsif r.auto_invoice_type=2 then
		--buy and sell invoice

		------------------Ingress Invoice--------------
		select into lrn_count
		count(*)
		from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time
		and (lrn_number_vendor='2' or lrn_number_vendor='3') and is_final_call='1';
		if lrn_count is null then
			lrn_count := 0;
		end if;

		select into lrn_call_cost
		sum(case when lnp_dipping_cost is null then 0 when lnp_dipping_cost='' then 0 else lnp_dipping_cost::real end)
		from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if lrn_call_cost is null then
			lrn_call_cost := 0;
		end if;

		if lrn_count = 0 then
			lrn_call_rate :=0;
		else
			lrn_call_rate := lrn_call_cost/lrn_count;
		end if;

		select into in_total sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_total is null then
			in_total :=0;
		end if;
                select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
                where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
                if out_total is null then
                        out_total :=0;
                end if;
		if in_total = 0 and out_total = 0 and (r.invoice_zero is true or r.invoice_zero is null) then
			raise notice 'cost is 0,continue';
			continue;
		end if;

		select into in_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_minutes is null then
			in_minutes := 0;
		end if;

		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'buy total %,buy minutes %',in_total,in_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT trim(both ' ' from orig_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case ingress_rate_effective_date when '' then null else ingress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) as total_cost,
		case ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60)
		when 0 then 0
		else sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end)
		/
		(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where ingress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and ingress_client_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by trim(both ' ' from orig_code_name),ingress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,0,r1.effective_date::text;
		end loop;

		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type,lrn_numbers,lrn_rate,lrn_cost,invoice_zone)
		select
		in_total,in_total,null,in_minutes,null,0,0,0,r.client_id,current_timestamp(0),invoice_start_time,invoice_end_time,due,now_balance,no_invoice,0,null,null,null,r.invoice_zone;

		select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;

		------------------Egress Invoice--------------
		select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_total is null then
			out_total :=0;
		end if;
		select into out_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case egress_bill_time when '' then 0 else egress_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_minutes is null then
			out_minutes := 0;
		end if;
		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'sell total %,sell minutes %',out_total,out_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT trim(both ' ' from term_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case egress_rate_effective_date when '' then null else egress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case egress_cost when '' then 0 else egress_cost::numeric end) as total_cost,
		case ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60)
		when 0 then 0
		else
		sum(case egress_cost when '' then 0 else egress_cost::numeric end)
		/
		(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where egress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and egress_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by trim(both ' ' from term_code_name),egress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,1,r1.effective_date::text;
		end loop;

		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type,invoice_zone)
		select
		out_total,null,out_total,null,out_minutes,0,0,0,r.client_id,current_timestamp(0),invoice_start_time,invoice_end_time,due,now_balance,no_invoice,1,r.invoice_zone;

		end if;

		update client set last_invoiced = current_timestamp(0) where client_id = r.client_id;

		end loop;

	return null;

end;
$$;


ALTER FUNCTION public.create_client_invoice() OWNER TO postgres;

--
-- Name: create_client_invoice(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_client_invoice(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, integer, timestamp with time zone) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	last_date date;
	r record;
	pay_term_row record;
	in_total numeric := 0;
	in_amount numeric := 0;
	out_total numeric := 0;
	out_amount numeric := 0;
	in_minutes integer := 0;
	out_minutes integer := 0;
	due date;
	now_balance numeric;
	no_invoice text;
	r1 record;
	l_rate_minutes integer;
	gt_rate_minutes integer;
	gt_max_rate_minutes integer;
	charge_rate record;
	l_sell_rate_minutes integer;
	gt_sell_rate_minutes integer;
	gt_sell_max_rate_minutes integer;
	past_amount numeric := 0;

	id_client alias for $1;
	time_start alias for $2;
	time_end alias for $3;
	number_invoice alias for $4;
	date_due alias for $5;
	type_invoice alias for $6;
	date_invoice alias for $7;
	lrn_count integer :=0;
	lrn_call_rate numeric;
	lrn_call_cost numeric :=0;

begin
		in_total := 0;
		in_amount := 0;
		out_total := 0;
		out_amount := 0;
		l_rate_minutes := 0;
		gt_rate_minutes := 0;
		gt_max_rate_minutes := 0;
		l_sell_rate_minutes := 0;
		gt_sell_rate_minutes := 0;
		gt_sell_max_rate_minutes := 0;
		in_minutes := 0;
		out_minutes := 0;
		past_amount := 0;

		raise notice 'create invoice for client %',id_client;
		if number_invoice='' then
			select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;
		else
			no_invoice := number_invoice;
		end if;
		raise notice 'invoice number is %',no_invoice;

		if type_invoice =0 then
		------------------Ingress Invoice--------------
		select into lrn_count
		count(*)
		from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone
		and (lrn_number_vendor='2' or lrn_number_vendor='3') and is_final_call='1';
		if lrn_count is null then
			lrn_count := 0;
		end if;

		select into lrn_call_cost
		sum(case when lnp_dipping_cost is null then 0 when lnp_dipping_cost='' then 0 else lnp_dipping_cost::real end)
		from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if lrn_call_cost is null then
			lrn_call_cost := 0;
		end if;

		if lrn_count = 0 then
			lrn_call_rate :=0;
		else
			lrn_call_rate := lrn_call_cost/lrn_count;
		end if;

		select into in_total sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if in_total is null then
			in_total :=0;
		end if;

		select into in_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if in_minutes is null then
			in_minutes := 0;
		end if;

		due := date_due;

		select into now_balance balance from client_balance where client_id = id_client::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'buy total %,buy minutes %',in_total,in_minutes;

		for r1 in
		SELECT trim(both ' ' from orig_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case ingress_rate_effective_date when '' then null else ingress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) as total_cost,
		case ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60)
		when 0 then 0
		else sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end)
		/
		(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where ingress_client_id = id_client::text
		and answer_time_of_date != '0'
		and ingress_client_bill_result ='1'
		and time between time_start::timestamp with time zone and time_end::timestamp with time zone
		group by trim(both ' ' from orig_code_name),ingress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,0,r1.effective_date::text;
		end loop;
		end if;

		if type_invoice =0 then
		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type,lrn_numbers,lrn_rate,lrn_cost)
		select
		in_total,in_total,null,in_minutes,null,0,0,0,id_client,date_invoice,time_start,time_end,date_due,now_balance,no_invoice,0,null,null,null;
		end if;

		if type_invoice =1 then
		------------------Egress Invoice--------------
		select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
		where egress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if out_total is null then
			out_total :=0;
		end if;
		select into out_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case egress_bill_time when '' then 0 else egress_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where egress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if out_minutes is null then
			out_minutes := 0;
		end if;
		due := date_due;

		select into now_balance balance from client_balance where client_id = id_client::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'sell total %,sell minutes %',out_total,out_minutes;

		for r1 in
		SELECT trim(both ' ' from term_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case egress_rate_effective_date when '' then null else egress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case egress_cost when '' then 0 else egress_cost::numeric end) as total_cost,
		case ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60)
		when 0 then 0
		else
		sum(case egress_cost when '' then 0 else egress_cost::numeric end)
		/
		(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where egress_client_id = id_client::text
		and answer_time_of_date != '0'
		and egress_bill_result ='1'
		and time between time_start::timestamp with time zone and time_end::timestamp with time zone
		group by trim(both ' ' from term_code_name),egress_rate_effective_date
		loop
			if r1.total_minutes = 1 then
				r1.avg_rate := round(r1.avg_rate, 4);
			end if;
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,1,r1.effective_date::text;
		end loop;
		end if;

		if type_invoice =1 then
		insert into invoice(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,
		state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number,type)
		select
		out_total,null,out_total,null,out_minutes,0,0,0,id_client,date_invoice,time_start,time_end,date_due,now_balance,no_invoice,1;
		end if;

		update client set last_invoiced = date_invoice where client_id = id_client;
		update invoice set create_type=1 where invoice_number=no_invoice;

		select into no_invoice invoice_number from invoice where invoice_number=no_invoice;
		if not found then
			return '';
		else
			return no_invoice;
		end if;

end;
$_$;


ALTER FUNCTION public.create_client_invoice(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, integer, timestamp with time zone) OWNER TO postgres;

--
-- Name: create_client_invoice_exchange(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_client_invoice_exchange() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
	last_date date;
	r record;
	pay_term_row record;
	in_total numeric := 0;
	in_amount numeric := 0;
	out_total numeric := 0;
	out_amount numeric := 0;
	in_minutes integer := 0;
	out_minutes integer := 0;
	due date;
	now_balance numeric;
	no_invoice text;
	r1 record;
	l_rate_minutes integer;
	gt_rate_minutes integer;
	gt_max_rate_minutes integer;
	charge_rate record;
	l_sell_rate_minutes integer;
	gt_sell_rate_minutes integer;
	gt_sell_max_rate_minutes integer;
	past_amount numeric := 0;
	pay_more_days integer;
	invoice_start_time timestamp with time zone;
	invoice_end_time timestamp with time zone;
	lrn_count integer := 0;
	lrn_call_rate numeric;
	lrn_call_cost numeric;

begin
	for r in select * from client where auto_invoicing = true
	loop
		in_total := 0;
		in_amount := 0;
		out_total := 0;
		out_amount := 0;
		l_rate_minutes := 0;
		gt_rate_minutes := 0;
		gt_max_rate_minutes := 0;
		l_sell_rate_minutes := 0;
		gt_sell_rate_minutes := 0;
		gt_sell_max_rate_minutes := 0;
		in_minutes := 0;
		out_minutes := 0;
		past_amount := 0;
		select into pay_term_row * from payment_term where payment_term_id = r.payment_term_id;

		select into last_date last_invoiced from client where client_id = r.client_id;
		if last_date is null then
			raise notice 'last invoice date is not found';
			continue;
		end if;

		if(last_date=current_date) then
			continue;
		end if;

		if(pay_term_row.type=1) then
		/*every days*/
			if(last_date + pay_term_row.days != current_date) then
				continue;
			end if;
		end if;
		if(pay_term_row.type=2) then
		/*every month*/
			if pay_term_row.days!=EXTRACT(DAY from now()) then
				if (to_char(now(),'DD') != to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) or (pay_term_row.days::text < to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) then
					continue;
				end if;
			end if;
		end if;
		if(pay_term_row.type=3) then
		/*every week*/
			if(pay_term_row.days != EXTRACT(DOW FROM now())) then
				continue;
			end if;
		end if;
		if(pay_term_row.type=4) then
		/*every month,more days*/
			for pay_more_days in select regexp_split_to_table(pay_term_row.more_days,',')
			loop
				if pay_more_days=EXTRACT(DAY from now()) then
					exit;
				elsif pay_more_days::text > to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD') and to_char(now(),'DD') = to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD') then
					exit;
				else
					continue;
				end if;
			end loop;
			if pay_more_days!=EXTRACT(DAY from now()) then
				if (to_char(now(),'DD') != to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) or (pay_more_days::text < to_char(to_timestamp(to_char(now()+'1 month','YYYY-MM-01'),'YYYY-MM-DD')-interval '1 day','DD')) then
					continue;
				end if;
			end if;
		end if;

		raise notice 'create invoice for client %',r.client_id;
		select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;
		raise notice 'invoice_number %',no_invoice;


		if r.invoice_zone is null or r.invoice_zone = '' or r.invoice_zone =' ' then
		select into invoice_start_time to_char(last_date,'YYYY-MM-DD 00:00:00')::timestamp with time zone;
		select into invoice_end_time to_char(current_date-1,'YYYY-MM-DD 23:59:59')::timestamp with time zone;
		else
		select into invoice_start_time (to_char(last_date,'YYYY-MM-DD 00:00:00')||r.invoice_zone)::timestamp with time zone;
		select into invoice_end_time (to_char(current_date-1,'YYYY-MM-DD 23:59:59')||r.invoice_zone)::timestamp with time zone;
		end if;

		if exists(select 1 from invoice where client_id=r.client_id and invoice_start=invoice_start_time and invoice_end=invoice_end_time) then
		raise notice 'exist invoice,continue';
		continue;
		end if;

		------------------Ingress Invoice--------------
		select into in_total sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_total is null then
			in_total :=0;
		end if;

		select into in_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where ingress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if in_minutes is null then
			in_minutes := 0;
		end if;

		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'buy total %,buy minutes %',in_total,in_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT contract_id,trim(both ' ' from orig_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case ingress_rate_effective_date when '' then null else ingress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) as total_cost,
		case ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60)
		when 0 then 0
		else sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end)
		/
		(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where ingress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and ingress_client_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by contract_id,trim(both ' ' from orig_code_name),ingress_rate_effective_date
		loop
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date,contract_number)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,0,r1.effective_date::text,r1.contract_id;
		end loop;


		------------------Egress Invoice--------------
		select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_total is null then
			out_total :=0;
		end if;
		select into out_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case egress_bill_time when '' then 0 else egress_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where egress_client_id = r.client_id::text and time between invoice_start_time and invoice_end_time;
		if out_minutes is null then
			out_minutes := 0;
		end if;
		due := current_date + pay_term_row.grace_days;

		select into now_balance balance from client_balance where client_id = r.client_id::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'sell total %,sell minutes %',out_total,out_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT contract_id,trim(both ' ' from term_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case egress_rate_effective_date when '' then null else egress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case egress_cost when '' then 0 else egress_cost::numeric end) as total_cost,
		case ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60)
		when 0 then 0
		else
		sum(case egress_cost when '' then 0 else egress_cost::numeric end)
		/
		(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where egress_client_id = r.client_id::text
		and answer_time_of_date != '0'
		and egress_bill_result ='1'
		and time between invoice_start_time and invoice_end_time
		group by contract_id,trim(both ' ' from term_code_name),egress_rate_effective_date
		loop
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date,contract_number)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,1,r1.effective_date::text,r1.contract_id;
		end loop;
/*
		select into past_amount total_amount from invoice where paid=false and client_id=r.client_id order by invoice_id desc limit 1;
		if past_amount is null then
			past_amount := 0;
		end if;
		raise notice 'past due amount %',past_amount;
*/
		insert into invoice
(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number)
		select
in_total-out_total,in_total,out_total,in_minutes,out_minutes,0,0,0,r.client_id,current_timestamp(0),invoice_start_time,invoice_end_time,due,now_balance,no_invoice;


		update client set last_invoiced = current_timestamp(0) where client_id = r.client_id;

		end loop;

	return null;

end;
$$;


ALTER FUNCTION public.create_client_invoice_exchange() OWNER TO postgres;

--
-- Name: create_client_invoice_exchange(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_client_invoice_exchange(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, timestamp with time zone) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	last_date date;
	r record;
	pay_term_row record;
	in_total numeric := 0;
	in_amount numeric := 0;
	out_total numeric := 0;
	out_amount numeric := 0;
	in_minutes integer := 0;
	out_minutes integer := 0;
	due date;
	now_balance numeric;
	no_invoice text;
	r1 record;
	l_rate_minutes integer;
	gt_rate_minutes integer;
	gt_max_rate_minutes integer;
	charge_rate record;
	l_sell_rate_minutes integer;
	gt_sell_rate_minutes integer;
	gt_sell_max_rate_minutes integer;
	past_amount numeric := 0;

	id_client alias for $1;
	time_start alias for $2;
	time_end alias for $3;
	number_invoice alias for $4;
	date_due alias for $5;
	date_invoice alias for $6;
	lrn_count integer :=0;
	lrn_call_rate numeric;
	lrn_call_cost numeric :=0;

begin
		in_total := 0;
		in_amount := 0;
		out_total := 0;
		out_amount := 0;
		l_rate_minutes := 0;
		gt_rate_minutes := 0;
		gt_max_rate_minutes := 0;
		l_sell_rate_minutes := 0;
		gt_sell_rate_minutes := 0;
		gt_sell_max_rate_minutes := 0;
		in_minutes := 0;
		out_minutes := 0;
		past_amount := 0;

		raise notice 'create invoice for client %',id_client;
		if number_invoice='' then
			select into no_invoice nextval('class4_seq_invoice_no'::regclass)::text;
		else
			no_invoice := number_invoice;
		end if;
		raise notice 'invoice_number %',no_invoice;


		------------------Ingress Invoice--------------
		select into in_total sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if in_total is null then
			in_total :=0;
		end if;

		select into in_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where ingress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if in_minutes is null then
			in_minutes := 0;
		end if;

		due := date_due;

		select into now_balance balance from client_balance where client_id = id_client::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'buy total %,buy minutes %',in_total,in_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT contract_id,trim(both ' ' from orig_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case ingress_rate_effective_date when '' then null else ingress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end) as total_cost,
		case ceil(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60)
		when 0 then 0
		else sum(case ingress_client_cost when '' then 0 else ingress_client_cost::numeric end)
		/
		(sum(case ingress_client_bill_time when '' then 0 else ingress_client_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where ingress_client_id = id_client::text
		and answer_time_of_date != '0'
		and ingress_client_bill_result ='1'
		and time between time_start::timestamp with time zone and time_end::timestamp with time zone
		group by contract_id,trim(both ' ' from orig_code_name),ingress_rate_effective_date
		loop
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date,contract_number)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,0,r1.effective_date::text,r1.contract_id;
		end loop;



		------------------Egress Invoice--------------
		select into out_total sum(case egress_cost when '' then 0 else egress_cost::numeric end) from client_cdr
		where egress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if out_total is null then
			out_total :=0;
		end if;
		select into out_minutes
		ceil(
			sum(
				GREATEST(case call_duration when '' then 0 else call_duration::integer end,case egress_bill_time when '' then 0 else egress_bill_time::integer end)
			)::numeric/60
		) from client_cdr
		where egress_client_id = id_client::text and time between time_start::timestamp with time zone and time_end::timestamp with time zone;
		if out_minutes is null then
			out_minutes := 0;
		end if;
		due := date_due;

		select into now_balance balance from client_balance where client_id = id_client::text limit 1;
		if now_balance is null then
			now_balance := 0;
		end if;

		raise notice 'sell total %,sell minutes %',out_total,out_minutes;

		--insert into invoice calls--
		for r1 in
		SELECT contract_id,trim(both ' ' from term_code_name) as code_name,
		TIMESTAMP WITH TIME ZONE 'epoch' + case egress_rate_effective_date when '' then null else egress_rate_effective_date::bigint end * INTERVAL '1 second' as effective_date,
		count(*) as total_count,
		ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) as total_minutes,
		sum(case egress_cost when '' then 0 else egress_cost::numeric end) as total_cost,
		case ceil(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60)
		when 0 then 0
		else
		sum(case egress_cost when '' then 0 else egress_cost::numeric end)
		/
		(sum(case egress_bill_time when '' then 0 else egress_bill_time::integer end)::numeric/60) end
		as avg_rate
		from client_cdr
		where egress_client_id = id_client::text
		and answer_time_of_date != '0'
		and egress_bill_result ='1'
		and time between time_start::timestamp with time zone and time_end::timestamp with time zone
		group by contract_id,trim(both ' ' from term_code_name),egress_rate_effective_date
		loop
			insert into invoice_calls(calls_count,total_minutes,avg_rate,cost,code_name,invoice_no,invoice_type,effective_date,contract_number)
			select r1.total_count,r1.total_minutes,r1.avg_rate,r1.total_cost,r1.code_name,no_invoice,1,r1.effective_date::text,r1.contract_id;
		end loop;
/*
		select into past_amount total_amount from invoice where paid=false and client_id=id_client order by invoice_id desc limit 1;
		if past_amount is null then
			past_amount := 0;
		end if;
		raise notice 'past due amount %',past_amount;
*/
		insert into invoice
(total_amount,buy_total,sell_total,buy_minutes,sell_minutes,buy_service_charge,sell_service_charge,state,client_id,invoice_time,invoice_start,invoice_end,due_date,current_balance,invoice_number)
		select
in_total-out_total,in_total,out_total,in_minutes,out_minutes,0,0,0,id_client,date_invoice,time_start,time_end,due,now_balance,no_invoice;



		update client set last_invoiced = date_invoice where client_id = id_client;
		update invoice set create_type=1 where invoice_number=no_invoice;

		select into no_invoice invoice_number from invoice where invoice_number=no_invoice;
		if not found then
			return '';
		else
			return no_invoice;
		end if;

end;
$_$;


ALTER FUNCTION public.create_client_invoice_exchange(integer, timestamp with time zone, timestamp with time zone, text, timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: crosstab(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab(text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab(text) OWNER TO postgres;

--
-- Name: crosstab(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab(text, integer) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab(text, integer) OWNER TO postgres;

--
-- Name: crosstab(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab(text, text) RETURNS SETOF record
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab_hash';


ALTER FUNCTION public.crosstab(text, text) OWNER TO postgres;

--
-- Name: crosstab2(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab2(text) RETURNS SETOF public.tablefunc_crosstab_2
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab2(text) OWNER TO postgres;

--
-- Name: crosstab3(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab3(text) RETURNS SETOF public.tablefunc_crosstab_3
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab3(text) OWNER TO postgres;

--
-- Name: crosstab4(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.crosstab4(text) RETURNS SETOF public.tablefunc_crosstab_4
    LANGUAGE c STABLE STRICT
    AS '$libdir/tablefunc', 'crosstab';


ALTER FUNCTION public.crosstab4(text) OWNER TO postgres;

--
-- Name: current_balance(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.current_balance(client integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
today date := CURRENT_DATE;
start_date timestamp with time zone = today::text || ' 00:00:00+00';
end_date timestamp with time zone = today::text || ' 23:59:59+00';
my_array numeric(20, 5)[] := '{0,0,0,0,0,0,0,0,0,0,0,0,0}';
actual_ingress_balance numeric(20, 5) := 0;
actual_egress_balance numeric(20, 5) := 0;
actual_total_balance numeric(20, 5) := 0;
mutual_ingress_balance numeric(20, 5) := 0;
mutual_egress_balance numeric(20, 5) := 0;
mutual_total_balance numeric(20, 5) := 0;
r record;
result record;
BEGIN
	for r in
	SELECT COALESCE(sum(amount), 0) as amount, 0 as type FROM client_payment
	WHERE receiving_time between start_date and end_date
	and payment_type in (4,5) AND client_id = client
	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 1 as type FROM client_payment
	WHERE payment_time between start_date and end_date
	and payment_type = 8 AND client_id = client
	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 2 as type FROM client_payment
	WHERE payment_time between start_date and end_date
	and  payment_type = 12 AND client_id = client
	--UNION

	--SELECT COALESCE(sum(ingress_client_cost::numeric(10,4)), 0), 3 as type FROM client_cdr
	--WHERE time BETWEEN start_date and end_date  AND ingress_client_id = client and is_final_call=1

	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 4 as type FROM client_payment
	WHERE payment_time between start_date and end_date
	and payment_type = 15 AND client_id = client
	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 5 as type FROM client_payment
	WHERE receiving_time between start_date and end_date
	and payment_type in (3,6) AND client_id = client
	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 6 as type FROM client_payment
	WHERE payment_time between start_date and end_date
	and payment_type = 7 AND client_id = client
	UNION
	SELECT COALESCE(sum(amount), 0) as amount, 7 as type FROM client_payment
	WHERE payment_time between start_date and end_date
	and payment_type = 11 AND client_id = client
	--UNION
	--SELECT COALESCE(sum(egress_cost), 0) as amount, 8 as type
	--from client_cdr where time between start_date and end_date
	--and egress_client_id = client
	UNION
	SELECT COALESCE(sum(total_amount), 0) as amount, 9 as type FROM invoice
	WHERE invoice_time between start_date and end_date   and
	state != -1 AND type = 0 AND client_id = client
	UNION
	SELECT COALESCE(sum(total_amount), 0) as amount,10 as type FROM invoice
	WHERE invoice_time between start_date and end_date   and
	type = 3 AND client_id = client
	UNION
	SELECT COALESCE(actual_amount, 0) as amount, 11 as type FROM exchange_finance
	WHERE complete_time between start_date and end_date and
	status = 2 and action_type = 2 AND client_id = client
	UNION
	SELECT COALESCE(actual_amount, 0) as amount, 12 as type FROM exchange_finance
	WHERE complete_time between start_date and end_date and
	status = 2 and action_type = 1 AND client_id = client

	loop
		my_array[r.type] =  r.amount;
	end loop;

	my_array[0] = my_array[0] + my_array[11];
	my_array[5] = my_array[5] + my_array[12];

	actual_ingress_balance = my_array[0]  + my_array[1] - my_array[2] - my_array[3] -my_array[4];
	actual_egress_balance = -my_array[5]  - my_array[6] + my_array[7] + my_array[8];
	actual_total_balance = actual_ingress_balance + actual_egress_balance;

	mutual_ingress_balance = -my_array[9] + my_array[0]  + my_array[1] - my_array[2];
	mutual_egress_balance = my_array[10] - my_array[5]  - my_array[6] + my_array[7];
	mutual_total_balance = mutual_ingress_balance+mutual_egress_balance;

	select into r * from balance_history_actual where client_id = client order by date desc;

	actual_ingress_balance = actual_ingress_balance + r.actual_ingress_balance;
	actual_egress_balance = actual_egress_balance + r.actual_egress_balance;
	actual_total_balance = actual_total_balance + r.actual_balance;

	select into r * from balance_history where client_id = client order by date desc;



	mutual_ingress_balance = mutual_ingress_balance + r.mutual_ingress_balance;
	mutual_egress_balance = mutual_egress_balance + r.mutual_egress_balance;
	mutual_total_balance = mutual_total_balance + r.mutual_balance;

	select into result actual_ingress_balance,actual_egress_balance,actual_total_balance,mutual_ingress_balance,mutual_egress_balance,mutual_total_balance;
	return next result;
	return;

END;
$$;


ALTER FUNCTION public.current_balance(client integer) OWNER TO postgres;

--
-- Name: current_balance_detail(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.current_balance_detail(client integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
today date := CURRENT_DATE;
start_date timestamp with time zone = today::text || ' 00:00:00+00';
end_date timestamp with time zone = today::text || ' 23:59:59+00';
my_array numeric(20, 5)[] := '{0,0,0,0,0,0,0,0,0,0,0,0,0}';
actual_ingress_balance numeric(20, 5) := 0;
actual_egress_balance numeric(20, 5) := 0;
actual_total_balance numeric(20, 5) := 0;
mutual_ingress_balance numeric(20, 5) := 0;
mutual_egress_balance numeric(20, 5) := 0;
mutual_total_balance numeric(20, 5) := 0;
r record;
result record;
BEGIN
for r in
SELECT COALESCE(sum(amount), 0) as amount, 0 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (4,5) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 1 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 8 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 2 as type FROM client_payment
WHERE payment_time between start_date and end_date
and  payment_type = 12 AND client_id = client
UNION

select COALESCE(amount, 0) as amount, 3 as type FROM
ingress_cost(client, start_date, end_date) as (amount numeric)

--SELECT COALESCE(sum(ingress_client_cost::numeric(10,4)), 0), 3 as type FROM client_cdr
--WHERE time BETWEEN start_date and end_date  AND ingress_client_id = client and is_final_call=1

UNION
SELECT COALESCE(sum(amount), 0) as amount, 4 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 15 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 5 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (3,6) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 6 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 7 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 7 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 11 AND client_id = client
UNION

select COALESCE(amount, 0) as amount, 8 as type FROM
egress_cost(client, start_date, end_date) as (amount numeric)

--SELECT COALESCE(sum(egress_cost), 0) as amount, 8 as type
--from client_cdr where time between start_date and end_date
--and egress_client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount, 9 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
state != -1 AND type = 0 AND client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount,10 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
type = 3 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 11 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 2 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 12 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 1 AND client_id = client

loop
my_array[r.type] = r.amount;
end loop;

my_array[0] = my_array[0] + my_array[11];
my_array[5] = my_array[5] + my_array[12];

actual_ingress_balance = my_array[0] + my_array[1] - my_array[2] - my_array[3] -my_array[4];
actual_egress_balance = -my_array[5] - my_array[6] + my_array[7] + my_array[8];
actual_total_balance = actual_ingress_balance + actual_egress_balance;

mutual_ingress_balance = -my_array[9] + my_array[0] + my_array[1] - my_array[2];
mutual_egress_balance = my_array[10] - my_array[5] - my_array[6] + my_array[7];
mutual_total_balance = mutual_ingress_balance+mutual_egress_balance;

select into r * from balance_history_actual where client_id = client order by date desc;

if FOUND THEN
actual_ingress_balance = actual_ingress_balance + r.actual_ingress_balance;
actual_egress_balance = actual_egress_balance + r.actual_egress_balance;
actual_total_balance = actual_total_balance + r.actual_balance;
end if;

select into r * from balance_history where client_id = client order by date desc;

if FOUND THEN
mutual_ingress_balance = mutual_ingress_balance + r.mutual_ingress_balance;
mutual_egress_balance = mutual_egress_balance + r.mutual_egress_balance;
mutual_total_balance = mutual_total_balance + r.mutual_balance;
end if;

select into result actual_ingress_balance,actual_egress_balance,actual_total_balance,mutual_ingress_balance,mutual_egress_balance,mutual_total_balance,
my_array[0], my_array[1], my_array[2], my_array[3], my_array[4], my_array[5], my_array[6], my_array[7],
my_array[8], my_array[9], my_array[10];
return next result;
return;

END;
$$;


ALTER FUNCTION public.current_balance_detail(client integer) OWNER TO postgres;

--
-- Name: current_balance_detail_not_last_data(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.current_balance_detail_not_last_data(client integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
today date := CURRENT_DATE;
start_date timestamp with time zone = today::text || ' 00:00:00+00';
end_date timestamp with time zone = today::text || ' 23:59:59+00';
my_array numeric(20, 5)[] := '{0,0,0,0,0,0,0,0,0,0,0,0,0}';
actual_ingress_balance numeric(20, 5) := 0;
actual_egress_balance numeric(20, 5) := 0;
actual_total_balance numeric(20, 5) := 0;
mutual_ingress_balance numeric(20, 5) := 0;
mutual_egress_balance numeric(20, 5) := 0;
mutual_total_balance numeric(20, 5) := 0;
r record;
result record;
BEGIN
for r in
SELECT COALESCE(sum(amount), 0) as amount, 0 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (4,5) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 1 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 8 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 2 as type FROM client_payment
WHERE payment_time between start_date and end_date
and  payment_type = 12 AND client_id = client
UNION

--select COALESCE(amount, 0) as amount, 3 as type FROM
--ingress_cost(client, start_date, end_date) as (amount numeric)

SELECT COALESCE(sum(ingress_call_cost::numeric(10,4)), 0), 3 as type FROM cdr_report
WHERE report_time BETWEEN start_date and end_date  AND ingress_client_id = client

UNION
SELECT COALESCE(sum(amount), 0) as amount, 4 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 15 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 5 as type FROM client_payment
WHERE receiving_time between start_date and end_date
and payment_type in (3,6) AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 6 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 7 AND client_id = client
UNION
SELECT COALESCE(sum(amount), 0) as amount, 7 as type FROM client_payment
WHERE payment_time between start_date and end_date
and payment_type = 11 AND client_id = client
UNION

--select COALESCE(amount, 0) as amount, 8 as type FROM
--egress_cost(client, start_date, end_date) as (amount numeric)

SELECT COALESCE(sum(egress_call_cost), 0) as amount, 8 as type
from cdr_report where report_time between start_date and end_date
and egress_client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount, 9 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
state != -1 AND type = 0 AND client_id = client
UNION
SELECT COALESCE(sum(total_amount), 0) as amount,10 as type FROM invoice
WHERE invoice_time between start_date and end_date   and
type = 3 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 11 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 2 AND client_id = client
UNION
SELECT COALESCE(sum(actual_amount), 0) as amount, 12 as type FROM exchange_finance
WHERE complete_time between start_date and end_date and
status = 2 and action_type = 1 AND client_id = client

loop
my_array[r.type] = r.amount;
end loop;

my_array[0] = my_array[0] + my_array[11];
my_array[5] = my_array[5] + my_array[12];

actual_ingress_balance = my_array[0] + my_array[1] - my_array[2] - my_array[3] -my_array[4];
actual_egress_balance = -my_array[5] - my_array[6] + my_array[7] + my_array[8];
actual_total_balance = actual_ingress_balance + actual_egress_balance;

mutual_ingress_balance = -my_array[9] + my_array[0] + my_array[1] - my_array[2];
mutual_egress_balance = my_array[10] - my_array[5] - my_array[6] + my_array[7];
mutual_total_balance = mutual_ingress_balance+mutual_egress_balance;

select into r * from balance_history_actual where client_id = client order by date desc;

if FOUND THEN
actual_ingress_balance = actual_ingress_balance + r.actual_ingress_balance;
actual_egress_balance = actual_egress_balance + r.actual_egress_balance;
actual_total_balance = actual_total_balance + r.actual_balance;
end if;

select into r * from balance_history where client_id = client order by date desc;

if FOUND THEN
mutual_ingress_balance = mutual_ingress_balance + r.mutual_ingress_balance;
mutual_egress_balance = mutual_egress_balance + r.mutual_egress_balance;
mutual_total_balance = mutual_total_balance + r.mutual_balance;
end if;

select into result actual_ingress_balance,actual_egress_balance,actual_total_balance,mutual_ingress_balance,mutual_egress_balance,mutual_total_balance,
my_array[0], my_array[1], my_array[2], my_array[3], my_array[4], my_array[5], my_array[6], my_array[7],
my_array[8], my_array[9], my_array[10];
return next result;
return;

END;
$$;


ALTER FUNCTION public.current_balance_detail_not_last_data(client integer) OWNER TO postgres;

--
-- Name: daily_origination_summary(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.daily_origination_summary(timestamp with time zone, timestamp with time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	time_start alias for $1;
	time_end alias for $2;
	exe_sql text;
	cdr_days integer;

begin
	SELECT into cdr_days time_end::date-time_start::date+1;
	exe_sql :=
	$c1$SELECT * FROM crosstab$c1$
	||cdr_days||
	$sql1$
	(
	'select client.name::text,cdr.cdr_date::text,cdr.mins::text from
	(
	SELECT ingress_client_id,time::date as cdr_date,sum(call_duration::integer)::real/60 as mins
	from client_cdr
	where time between ''
	$sql1$
	||time_start||'\'\''||
	$sql2$ and ''$sql2$
	||time_end||
	$sql3$''
	and ingress_client_id != ''''
	group by ingress_client_id,time::date order by 1,2
	) as cdr
	left join client on client.client_id::text=cdr.ingress_client_id
	')
	$sql3$;
	raise notice '%',exe_sql;
	for r in execute exe_sql
	loop
		return next r;
	end loop;

	return;
end;

$_$;


ALTER FUNCTION public.daily_origination_summary(timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: daily_termination_summary(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.daily_termination_summary(timestamp with time zone, timestamp with time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	time_start alias for $1;
	time_end alias for $2;
	exe_sql text;
	cdr_days integer;

begin
	SELECT into cdr_days time_end::date-time_start::date+1;
	exe_sql :=
	$c1$SELECT * FROM crosstab$c1$
	||cdr_days||
	$sql1$
	(
	'select client.name::text,cdr.cdr_date::text,cdr.mins::text from
	(
	SELECT egress_client_id,time::date as cdr_date,sum(call_duration::integer)::real/60 as mins
	from client_cdr
	where time between ''
	$sql1$
	||time_start||'\'\''||
	$sql2$ and ''$sql2$
	||time_end||
	$sql3$''
	and egress_client_id != ''''
	group by egress_client_id,time::date order by 1,2
	) as cdr
	left join client on client.client_id::text=cdr.egress_client_id
	')
	$sql3$;
	raise notice '%',exe_sql;
	for r in execute exe_sql
	loop
		return next r;
	end loop;

	return;
end;

$_$;


ALTER FUNCTION public.daily_termination_summary(timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: data_clean(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.data_clean() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

begin
	delete from time_profile_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from client_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from dynamic_route_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from dynamic_route_items_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from rate_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from route_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_ip_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_direction_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_codecs_ref_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_block_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from product_items_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from translation_item_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from product_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from product_items_resource_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from currency_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from rate_table_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_ip_limit_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_translation_ref_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from jurisdiction_prefix_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from sip_error_code_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_next_route_rule_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_prefix_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from resource_lrn_action_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from dynamic_route_pri_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from dynamic_route_qos_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);
	delete from dynamic_route_override_record where time < EXTRACT(EPOCH from CURRENT_DATE-1);

	delete from host_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);
	delete from ip_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);
	delete from prefix_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);
	delete from product_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);
	delete from rate_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);
	delete from resource_info where time::bigint < EXTRACT(EPOCH from CURRENT_DATE-7);

	--delete from real_cdr where ans_time_b::bigint/1000000 < EXTRACT(EPOCH from CURRENT_DATE-7);
end;

$$;


ALTER FUNCTION public.data_clean() OWNER TO postgres;

--
-- Name: dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$

declare
        id_static_product alias for $2;
        id_dynamic_route alias for $1;
        new_res_1 alias for $3;
        new_res_2 alias for $4;
        new_res_3 alias for $5;
        new_res_4 alias for $6;
        new_res_5 alias for $7;
        new_res_6 alias for $8;
        new_res_7 alias for $9;
        new_res_8 alias for $10;
        id_routing_rule alias for $11;
        id_time_profile alias for $12;
        r record;
        r1 record;
        r2 record;
        r3 record;
        r4 record;
        sql_text text;
	res text;

begin

	delete from product_items where product_id = id_static_product;

	sql_text := 'select code,max(rate_id),resource_id from resource join rate on rate.rate_table_id=resource.rate_table_id where resource_id in ('||
        new_res_1||','||
        new_res_2||','||
        new_res_3||','||
        new_res_4||','||
        new_res_5||','||
        new_res_6||','||
        new_res_7||','||
        new_res_8||') group by code,resource_id order by 1,2';

	select into res destroy_order_by_tree();
	for r1 in execute sql_text
	loop
		PERFORM create_order_by_tree(r1.code::text,r1.max::text,r1.resource_id::text);
		--insert into dynamic_route_tmp(code,maxid,resource_id)
		--select r1.code,r1.max,r1.resource_id;
	end loop;

	--copy (select code,max(rate_id),resource_id from resource join rate on rate.rate_table_id=resource.rate_table_id where resource_id in (106,105) group by code,resource_id order by 1,2) to '/tmp/aaa.csv';

	select into res execute_order_by_tree();
/*
	for r2 in select * from dynamic_route_tmp
	loop
		raise notice 'check prefix is %',r2.code;
		for r3 in select * from dynamic_route_tmp where code <@ r2.code and code != r2.code
		loop
			insert into dynamic_route_tmp(code,maxid,resource_id)
			select r3.code,r2.maxid,r2.resource_id;
		end loop;
	end loop;

        for r4 in select * from crosstab
	('select code,max(maxid),resource_id from dynamic_route_tmp group by code,resource_id order by 1,2')
        AS
        ct(code prefix_range, res_id_1 integer, res_id_2 integer, res_id_3 integer, res_id_4 integer, res_id_5 integer, res_id_6 integer, res_id_7 integer, res_id_8 integer)
        loop
		raise notice 'insert prefix is %',r4.code;
        	insert into product_items
(time_profile_id,product_id,strategy,digits,resource_id_1,resource_id_2,resource_id_3,resource_id_4,resource_id_5,resource_id_6,resource_id_7,resource_id_8)
                select id_time_profile,id_static_product,id_routing_rule,r4.code,r4.res_id_1,r4.res_id_2,r4.res_id_3,r4.res_id_4,r4.res_id_5,r4.res_id_6,r4.res_id_7,r4.res_id_8;
        end loop;
*/

        for r4 in select f1 as code,f2 as res_id_1,f3 as res_id_2,f4 as res_id_3,f5 as res_id_4,f6 as res_id_5,f7 as res_id_6,f8 as res_id_7,f9 as res_id_8 from record_order_by_tree(0)
        loop
		raise notice 'insert prefix is %',r4.code;
        	insert into product_items
(time_profile_id,product_id,strategy,digits,resource_id_1,resource_id_2,resource_id_3,resource_id_4,resource_id_5,resource_id_6,resource_id_7,resource_id_8)
                select id_time_profile,id_static_product,id_routing_rule,r4.code,
			case r4.res_id_1 when '' then null else r4.res_id_1::integer end,
			case r4.res_id_2 when '' then null else r4.res_id_2::integer end,
			case r4.res_id_3 when '' then null else r4.res_id_3::integer end,
			case r4.res_id_4 when '' then null else r4.res_id_4::integer end,
			case r4.res_id_5 when '' then null else r4.res_id_5::integer end,
			case r4.res_id_6 when '' then null else r4.res_id_6::integer end,
			case r4.res_id_7 when '' then null else r4.res_id_7::integer end,
			case r4.res_id_8 when '' then null else r4.res_id_8::integer end;
        end loop;

	select into res destroy_order_by_tree();


end;

$_$;


ALTER FUNCTION public.dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer) OWNER TO postgres;

--
-- Name: dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, text) RETURNS void
    LANGUAGE plpgsql
    AS $_$

declare
        id_static_product alias for $2;
        id_dynamic_route alias for $1;
        new_res_1 alias for $3;
        new_res_2 alias for $4;
        new_res_3 alias for $5;
        new_res_4 alias for $6;
        new_res_5 alias for $7;
        new_res_6 alias for $8;
        new_res_7 alias for $9;
        new_res_8 alias for $10;
        id_routing_rule alias for $11;
        id_time_profile alias for $12;
        rate_prefix alias for $13;
        r record;
        r1 record;
        r2 record;
        r3 record;
        r4 record;
        sql_text text;
	res text;

begin

	delete from product_items where product_id = id_static_product and digits <@ rate_prefix;

	if not exists(select 1 from rate where code <@ rate_prefix and rate_table_id in (select rate_table_id from resource where resource_id in (new_res_1,new_res_2,new_res_3,new_res_4,new_res_5,new_res_6,new_res_7,new_res_8))) then
		return;
	end if;

	if rate_prefix = '' then
	sql_text := '(select code::text,max(rate_id),resource_id from resource join rate on rate.rate_table_id=resource.rate_table_id where resource_id in ('||
        new_res_1||','||
        new_res_2||','||
        new_res_3||','||
        new_res_4||','||
        new_res_5||','||
        new_res_6||','||
        new_res_7||','||
        new_res_8||') group by code,resource_id order by 1,2)';
	else
	sql_text := '(select code::text,max(rate_id),resource_id from resource join rate on rate.rate_table_id=resource.rate_table_id where code <@ \''||rate_prefix||'\'::prefix_range and resource_id in ('||
        new_res_1||','||
        new_res_2||','||
        new_res_3||','||
        new_res_4||','||
        new_res_5||','||
        new_res_6||','||
        new_res_7||','||
        new_res_8||') group by code,resource_id order by 1,2)
	union
	(select \''||rate_prefix||'\',max(rate_id),resource_id from resource join rate on rate.rate_table_id=resource.rate_table_id where code @> \''||rate_prefix||'\'::prefix_range and resource_id in ('||
        new_res_1||','||
        new_res_2||','||
        new_res_3||','||
        new_res_4||','||
        new_res_5||','||
        new_res_6||','||
        new_res_7||','||
        new_res_8||') group by code,resource_id order by 1,2)';
        end if;
--raise notice 'SQL:-----------> %',sql_text;
	select into res destroy_order_by_tree();
	for r1 in execute sql_text
	loop
		PERFORM create_order_by_tree(r1.code::text,r1.max::text,r1.resource_id::text);
		--insert into dynamic_route_tmp(code,maxid,resource_id)
		--select r1.code,r1.max,r1.resource_id;
	end loop;
	select into res execute_order_by_tree();
/*
	for r2 in select * from dynamic_route_tmp
	loop
		raise notice 'check prefix is %',r2.code;
		for r3 in select * from dynamic_route_tmp where code <@ r2.code and code != r2.code
		loop
			insert into dynamic_route_tmp(code,maxid,resource_id)
			select r3.code,r2.maxid,r2.resource_id;
		end loop;
	end loop;

        for r4 in select * from crosstab
	('select code,max(maxid),resource_id from dynamic_route_tmp group by code,resource_id order by 1,2')
        AS
        ct(code prefix_range, res_id_1 integer, res_id_2 integer, res_id_3 integer, res_id_4 integer, res_id_5 integer, res_id_6 integer, res_id_7 integer, res_id_8 integer)
        loop
		raise notice 'insert prefix is %',r4.code;
        	insert into product_items
(time_profile_id,product_id,strategy,digits,resource_id_1,resource_id_2,resource_id_3,resource_id_4,resource_id_5,resource_id_6,resource_id_7,resource_id_8)
                select id_time_profile,id_static_product,id_routing_rule,r4.code,r4.res_id_1,r4.res_id_2,r4.res_id_3,r4.res_id_4,r4.res_id_5,r4.res_id_6,r4.res_id_7,r4.res_id_8;
        end loop;
*/
        for r4 in select f1 as code,f2 as res_id_1,f3 as res_id_2,f4 as res_id_3,f5 as res_id_4,f6 as res_id_5,f7 as res_id_6,f8 as res_id_7,f9 as res_id_8 from record_order_by_tree(0)
        loop
		raise notice 'insert prefix is %',r4.code;
        	insert into product_items
(time_profile_id,product_id,strategy,digits,resource_id_1,resource_id_2,resource_id_3,resource_id_4,resource_id_5,resource_id_6,resource_id_7,resource_id_8)
                select id_time_profile,id_static_product,id_routing_rule,r4.code,
			case r4.res_id_1 when '' then null else r4.res_id_1::integer end,
			case r4.res_id_2 when '' then null else r4.res_id_2::integer end,
			case r4.res_id_3 when '' then null else r4.res_id_3::integer end,
			case r4.res_id_4 when '' then null else r4.res_id_4::integer end,
			case r4.res_id_5 when '' then null else r4.res_id_5::integer end,
			case r4.res_id_6 when '' then null else r4.res_id_6::integer end,
			case r4.res_id_7 when '' then null else r4.res_id_7::integer end,
			case r4.res_id_8 when '' then null else r4.res_id_8::integer end;
        end loop;
	select into res destroy_order_by_tree();

end;

$_$;


ALTER FUNCTION public.dynamic2static(integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, text) OWNER TO postgres;

--
-- Name: egress_cost(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.egress_cost(client integer, start_datetime timestamp with time zone, end_datetime timestamp with time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
total_datetime timestamp with time zone = CURRENT_TIMESTAMP(0);
r record;
BEGIN
	SELECT max(report_time) + interval '1 hour' as max_time into r FROM cdr_report WHERE report_time between start_datetime
	and end_datetime;

	total_datetime = r.max_time;


	if total_datetime is null then
		SELECT
sum(egress_cost) as call_cost  into r
from client_cdr where time between start_datetime and end_datetime and egress_client_id = client;


	elsif total_datetime > end_datetime then
		SELECT sum(egress_call_cost) as call_cost into r
		from cdr_report where report_time between start_datetime and end_datetime
		and egress_client_id = client;


	else

		SELECT
sum(call_cost) as call_cost into r FROM ( ( SELECT sum(egress_call_cost) as call_cost
from cdr_report
where report_time between start_datetime and total_datetime and egress_client_id = client ) union
(SELECT
sum(egress_cost) as call_cost
from client_cdr where time between total_datetime and end_datetime and  egress_client_id  = client ) ) as t;

	end if;

	return next r;
	return;

END;
$$;


ALTER FUNCTION public.egress_cost(client integer, start_datetime timestamp with time zone, end_datetime timestamp with time zone) OWNER TO postgres;

--
-- Name: egress_profit_fun(integer[], integer, integer, numeric, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.egress_profit_fun(integer[], integer, integer, numeric, text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
	a alias for $1;--exist rate table
	t alias for $2;--type 1-min;2-max;3-avg;4-max add x%;5-max add x
	id_rate_table alias for $3;
	add_num alias for $4;
	dup_action alias for $5;
	r record;

begin
	if not exists(select 1 from rate_table where rate_table_id=id_rate_table) then
		raise exception 'rate table id % not exist',id_rate_table;
	end if;

	if t=1 then
		for r in SELECT r1.* from
		(select * from rate where rate_table_id=any(a)) as r1
		right join (select code,min(rate) as rate from rate where rate_table_id=any(a) group by code) as r2
		on r1.code=r2.code and r1.rate=r2.rate
		loop

			if exists(select 1 from rate where rate_table_id=id_rate_table and code=r.code) then
				if dup_action='ignore' then
					continue;
				elsif dup_action='overwrite' then
					delete from rate where rate_table_id=id_rate_table and code=r.code;
				end if;
			end if;

			insert into rate(rate_table_id,code,rate,setup_fee,effective_date,end_date,min_time,grace_time,interval,time_profile_id,seconds,code_name,intra_rate,inter_rate)
			select id_rate_table,r.code,r.rate,r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.intra_rate,r.inter_rate;
		end loop;

	elsif t=2 then
		for r in SELECT r1.* from
		(select * from rate where rate_table_id=any(a)) as r1
		right join (select code,max(rate) as rate from rate where rate_table_id=any(a) group by code) as r2
		on r1.code=r2.code and r1.rate=r2.rate
		loop

			if exists(select 1 from rate where rate_table_id=id_rate_table and code=r.code) then
				if dup_action='ignore' then
					continue;
				elsif dup_action='overwrite' then
					delete from rate where rate_table_id=id_rate_table and code=r.code;
				end if;
			end if;

			insert into rate(rate_table_id,code,rate,setup_fee,effective_date,end_date,min_time,grace_time,interval,time_profile_id,seconds,code_name,intra_rate,inter_rate)
			select id_rate_table,r.code,r.rate,r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.intra_rate,r.inter_rate;
		end loop;

	elsif t=3 then
		raise exception 'i cant do that';
		for r in select
		code,avg(rate) as rate,max(setup_fee) as setup_fee,max(effective_date) as effective_date,max(end_date) as end_date,max(min_time) as min_time,max(grace_time) as grace_time,max(interval) as interval,max(time_profile_id) as time_profile_id,max(seconds) as seconds,max(code_name) as code_name,avg(intra_rate) as intra_rate,avg(inter_rate) as inter_rate
		from rate where rate_table_id=any(a)
		group by code
		loop

			if exists(select 1 from rate where rate_table_id=id_rate_table and code=r.code) then
				if dup_action='ignore' then
					continue;
				elsif dup_action='overwrite' then
					delete from rate where rate_table_id=id_rate_table and code=r.code;
				end if;
			end if;

			insert into rate(rate_table_id,code,rate,setup_fee,effective_date,end_date,min_time,grace_time,interval,time_profile_id,seconds,code_name,intra_rate,inter_rate)
			select id_rate_table,r.code,r.rate,r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.intra_rate,r.inter_rate;
		end loop;

	elsif t=4 then
		for r in SELECT r1.* from
		(select * from rate where rate_table_id=any(a)) as r1
		right join (select code,max(rate) as rate from rate where rate_table_id=any(a) group by code) as r2
		on r1.code=r2.code and r1.rate=r2.rate
		loop

			if exists(select 1 from rate where rate_table_id=id_rate_table and code=r.code) then
				if dup_action='ignore' then
					continue;
				elsif dup_action='overwrite' then
					delete from rate where rate_table_id=id_rate_table and code=r.code;
				end if;
			end if;

			insert into rate(rate_table_id,code,rate,setup_fee,effective_date,end_date,min_time,grace_time,interval,time_profile_id,seconds,code_name,intra_rate,inter_rate)
			select id_rate_table,r.code,r.rate*(1+add_num),r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.intra_rate,r.inter_rate;
		end loop;

	elsif t=5 then
		for r in SELECT r1.* from
		(select * from rate where rate_table_id=any(a)) as r1
		right join (select code,max(rate) as rate from rate where rate_table_id=any(a) group by code) as r2
		on r1.code=r2.code and r1.rate=r2.rate
		loop

			if exists(select 1 from rate where rate_table_id=id_rate_table and code=r.code) then
				if dup_action='ignore' then
					continue;
				elsif dup_action='overwrite' then
					delete from rate where rate_table_id=id_rate_table and code=r.code;
				end if;
			end if;

			insert into rate(rate_table_id,code,rate,setup_fee,effective_date,end_date,min_time,grace_time,interval,time_profile_id,seconds,code_name,intra_rate,inter_rate)
			select id_rate_table,r.code,r.rate+add_num,r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.intra_rate,r.inter_rate;
		end loop;
	end if;

end;
$_$;


ALTER FUNCTION public.egress_profit_fun(integer[], integer, integer, numeric, text) OWNER TO postgres;

--
-- Name: enable_block(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.enable_block() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
	r record;

begin

	for r in
		SELECT   block_ticket.id, block_ticket.egress, (select client_id from resource where resource_id = block_ticket.egress),block_ticket.dnis FROM block_ticket join (
			select alert_action.disable_duration,alert_rule.name from alert_rule
			join alert_action on alert_rule.alert_action_id = alert_action.id where alert_action.disable_duration != 0 and alert_rule.monitor_type = 1
			) as t on block_ticket.rule_name = t.name where CURRENT_TIMESTAMP - block_ticket.blocked_time > t.disable_duration*60::varchar::interval and block_ticket.block = true
	loop
		delete from resource_block where ingress_res_id = r.egress and ingress_client_id = r.client_id and digit::varchar = r.dnis;
		update block_ticket set block = false, unblock_time = CURRENT_TIMESTAMP(0) where id = r.id;
	end loop;
end;

$$;


ALTER FUNCTION public.enable_block() OWNER TO postgres;

--
-- Name: exchange_alert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.exchange_alert() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
	r record;
	r1 record;
	id_client integer;
	now_time text;
	enable_alert boolean := false;
	enable_email boolean := false;
	traffic_email boolean := false;

begin
	for r in select * from order_user_alert order by id
	loop
		if r.email is null or r.email = '' or r.email like ' %' then
			continue;
		end if;
		select into id_client client_id from order_user where id=r.user_id;
		raise notice 'alert id %',r.id;
		enable_alert := false;
		enable_email := false;
		traffic_email := false;
		if r.freq_type=0 then
			--raise notice 'Real time';
			enable_alert := true;
		elsif r.freq_type=1 then
			--raise notice 'Hourly,%',r.freq_value;
			select into now_time to_char(now(),'MI');
			--raise notice 'now time is %',now_time;
			continue when now_time != all(regexp_split_to_array(r.freq_value,','));
			enable_alert := true;
		elsif r.freq_type=2 then
			--raise notice 'Daily,%',r.freq_value;
			select into now_time to_char(now(),'HH24:MI');
			--raise notice 'now time is %',now_time;
			continue when now_time != all(regexp_split_to_array(r.freq_value,','));
			enable_alert := true;
		elsif r.freq_type=3 then
			--raise notice 'Weekly,%',r.freq_value;
			select into now_time to_char(now(),'D');
			--raise notice 'now time is %',now_time;
			continue when now_time != all(regexp_split_to_array(r.freq_value,','));
			enable_alert := true;
		elsif r.freq_type=4 then
			--raise notice 'Monthly,%',r.freq_value;
			select into now_time trim(leading '0' from to_char(now(),'DD'));
			--raise notice 'now time is %',now_time;
			continue when now_time != all(regexp_split_to_array(r.freq_value,','));
			enable_alert := true;
		end if;

if enable_alert = true then
		--raise notice '<CHECK START>';
		if r.order_type=1 then
			if r.alert_type=0 then
				raise notice 'Buy order confirmation';
				for r1 in
				SELECT id,create_time
				from buy_order
				where client_id=id_client
				loop
					--send_body is buy_order.id
					if not exists (select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text) then
					enable_email := true;
					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;
					end if;
				end loop;
			elsif r.alert_type=1 then
				raise notice 'Buy Order With No Matching Sell Order';
				for r1 in
				SELECT id,auto_match_time
				from buy_order
				where client_id=id_client and auto_match=true and auto_match_result=0
				loop
					--send_body is buy_order.id and auto_match_time
					if r1.auto_match_time is not null and
					not exists(select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text||','||r1.auto_match_time::text)
					then
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id::text||','||r1.auto_match_time::text;
					end if;

				end loop;
			elsif r.alert_type=2 then
				raise notice 'Buy Order Purged for inactivity';
				for r1 in
				SELECT buy_order.id,buy_order.create_time
				from buy_order
				right join contract on contract.order_id=buy_order.id
				left join stats_buy_order_summary
				on buy_order.id=stats_buy_order_summary.id
				where stats_buy_order_summary.week_ca=0
				and contract.contract_type=1 and purged = false
				and now()-buy_order.create_time>interval '7 days'
				and buy_order.client_id=id_client
				loop
					--send_body is buy_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update buy_order set purged=true where id=r1.id;
				end loop;
			elsif r.alert_type=3 then
				raise notice 'Buy Order Matched with Sell Order';
				for r1 in
				SELECT contract.id,contract.create_time
				from contract
				left join buy_order
				on contract.order_id=buy_order.id
				where contract.contract_type=1 and buy_order.client_id=id_client and contract.status=1
				union
				SELECT contract.id,contract.create_time
				from contract
				where contract_type=2 and client_id=id_client and contract.status=1
				loop
					--send_body is contract.id
					if not exists (select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text) then
					--if r.last_email_time is null or r1.create_time > r.last_email_time then
					enable_email := true;
					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;
					end if;
				end loop;

			elsif r.alert_type=4 then
				raise notice 'Buy Traffic Terminating';
				for r1 in
				SELECT buy_order.id
--,buy_order.id::text||coalesce(ca,0)::text||','||coalesce(ok_calls,0)::text||','||coalesce(minutes,0)::text||','||coalesce(week_ca,0)::text||','||coalesce(week_ok_calls,0)::text||','||coalesce(week_minutes,0)::text as c
				from buy_order
				--left join stats_buy_order_summary
				--on buy_order.id=stats_buy_order_summary.id
				where buy_order.client_id=id_client
				loop
					--send_body is buy_order.id and asr/acd
					if not exists (select id from alert_mail where user_alert_id=r.id) then

					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					else

					SELECT into traffic_email now()-max(create_time)>interval '1 minutes' from alert_mail where user_alert_id=r.id;
					if traffic_email then
                                        enable_email := true;

                                        insert into alert_mail(user_alert_id,send_body)
                                        select
                                        r.id,r1.c;
					end if;

					end if;

				end loop;

			elsif r.alert_type=5 then
				raise notice 'Buy order matched to sell orders below min ASR';
				for r1 in
				SELECT buy_order.id
				from buy_order
				right join contract on contract.order_id=buy_order.id
				left join stats_buy_order_summary
				on buy_order.id=stats_buy_order_summary.id
				where contract.contract_type=1
				and asr>case when stats_buy_order_summary.ca = 0 then 0 else stats_buy_order_summary.ok_calls/stats_buy_order_summary.ca end
				and buy_order.client_id=id_client
				loop
					--send_body is buy_order.id
					if not exists (select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text) then
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					end if;
				end loop;
			end if;
		elsif r.order_type=2 then
			if r.alert_type=0 then
				raise notice 'Ask order confirmation';
				for r1 in
				select id,create_time
				from sell_order
				where client_id = id_client
				loop
					--send_body is sell_order.id
					--if r.last_email_time is null or r1.create_time > r.last_email_time then
					if not exists (select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text) then
					enable_email := true;
					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;
					end if;
				end loop;
			elsif r.alert_type=1 then
				raise notice 'Sell order no long has matching orders';
				for r1 in
				SELECT id,auto_match_time
				from sell_order
				where client_id=id_client and auto_match=true and auto_match_result=0
				loop
					--send_body is sell_order.id
					if r1.auto_match_time is not null and
					not exists(select id from alert_mail where user_alert_id=r.id and send_body=r1.id::text) then
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					end if;
				end loop;
			elsif r.alert_type=2 then
				raise notice 'Sell Order Congestion Notification';
				for r1 in
				SELECT order_id,count(*) as c
				from client_cdr
				where time between now()-interval '1 hours' and now()
				and egress_client_id=id_client::text
				and (release_cause='6' or release_cause='7')
				and order_type='2'
				group by order_id
				loop
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id::text||','||r1.c::text;

				end loop;
			elsif r.alert_type=3 then
				raise notice 'Sell Order Certified as â€œselectâ€ Route';
				for r1 in
				SELECT id from sell_order where is_select=2 and client_id=id_client
				loop
					--send_body is sell_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update sell_order set is_select=3 where id=r1.id;
				end loop;
			elsif r.alert_type=4 then
				raise notice 'Sell Order Placed First in LCR';
				for r1 in
				SELECT id from sell_order where is_first=1 and client_id=id_client
				loop
					--send_body is sell_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update sell_order set is_first=3 where id=r1.id;
				end loop;
			elsif r.alert_type=5 then
				raise notice 'Sell Order Lost First Position';
				for r1 in
				SELECT id from sell_order where is_first=2 and client_id=id_client
				loop
					--send_body is sell_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update sell_order set is_first=4 where id=r1.id;
				end loop;
			elsif r.alert_type=6 then
				raise notice 'Sell Order Deactivated due to quality drop';
			elsif r.alert_type=7 then
				raise notice 'Sell Order purged due to inactivity';
				for r1 in
				SELECT sell_order.id
				from sell_order
				left join stats_sell_order_summary
				on sell_order.id=stats_sell_order_summary.id
				where stats_sell_order_summary.week_ca=0 and purged = false
				loop
					--send_body is sell_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update sell_order set purged=true where id=r1.id;
				end loop;
			elsif r.alert_type=8 then
				raise notice 'Sell Order decertified as â€œselectâ€ route';
				for r1 in
				SELECT id from sell_order where is_select=1 and client_id=id_client
				loop
					--send_body is buy_order.id
					enable_email := true;

					insert into alert_mail(user_alert_id,send_body)
					select
					r.id,r1.id;

					update sell_order set is_select=0 where id=r1.id;
				end loop;
			end if;
		end if;
		--raise notice '<CHECK END>';
		raise notice 'enable email %',enable_email;
		if enable_email then
			update order_user_alert set last_email_time = current_timestamp(0) where id=r.id;
		end if;
end if;

	end loop;

end;

$$;


ALTER FUNCTION public.exchange_alert() OWNER TO postgres;

--
-- Name: exchange_trans(timestamp with time zone, timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.exchange_trans(timestamp with time zone, timestamp with time zone, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	start_time alias for $1;
	end_time alias for $2;
	id_client alias for $3;
	r record;

begin

	for r in

	select
	report_time::date,
	'1' as type,
	sum(case when ingress_client_id=id_client then ingress_call_cost else 0 end) as buy
	from cdr_report
	where report_time between start_time and end_time
	group by report_time::date
	union
	select
	report_time::date,
	'2' as type,
	sum(case when egress_client_id=id_client then egress_call_cost else 0 end) as sell
	from cdr_report
	where report_time between start_time and end_time
	group by report_time::date
	union
	select
	complete_time::date,
	'3' as type,
	sum(case when client_id=id_client and action_type=2 and status=2 then actual_amount else 0 end) as deposit
	from exchange_finance
	where complete_time between start_time and end_time
	group by complete_time::date
	union
	select
	action_time::date,
	'4' as type,
	sum(case when client_id=id_client and action_type=1 then actual_amount else 0 end) as withdraw
	from exchange_finance
	where action_time between start_time and end_time
	group by action_time::date

	loop
		return next r;
	end loop;


	return;

end;
$_$;


ALTER FUNCTION public.exchange_trans(timestamp with time zone, timestamp with time zone, integer) OWNER TO postgres;

--
-- Name: fifth_select(text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.fifth_select(text, text, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
   declare
       fifth_rec record;
   begin
       for fifth_rec in select resource_direction.action,resource_direction.digits
from resource_direction where direction=2 and callee_digit_match@>$1 and caller_digit_match@>$2 and dire_group_id=$3
order by length(callee_digit_match::text) DESC limit 1
 loop
           return next fifth_rec;
       end loop;
	return;
   end;
   $_$;


ALTER FUNCTION public.fifth_select(text, text, integer) OWNER TO postgres;

--
-- Name: filter_rate(integer[], timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.filter_rate(integer[], timestamp with time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	a alias for $1;
	r record;
	r1 record;
	r2 record;
	rate_other text[];
	rate_time alias for $2;

begin
	PERFORM destroy_sorted_syntex();

	for r in select * from rate where rate_table_id=any(a) and effective_date >= rate_time
	loop
		--raise notice 'rate_id %,rate_table_id %,code %,effective_date %,other %',r.rate_id,r.rate_table_id,r.code,r.effective_date,
		--case when r.code_name is null then '' else r.code_name::text end||'@split@'||
		--case when r.country is null then '' else r.country::text end||'@split@'||
		--case when r.rate is null then '' else r.rate::text end||'@split@'||
		--case when r.intra_rate is null then '' else r.intra_rate::text end||'@split@'||
		--case when r.inter_rate is null then '' else r.inter_rate::text end||'@split@'||
		--case when r.local_rate is null then '' else r.local_rate::text end||'@split@'||
		--case when r.end_date is null then '' else r.end_date::text end||'@split@'||
		--case when r.time_profile_id is null then '' else r.time_profile_id::text end||'@split@'||
		--case when r.zone is null then '' else r.zone::text end||'@split@'||
		--r.min_time::text||'@split@'||
		--r.grace_time::text||'@split@'||
		--r.interval::text||'@split@'||
		--r.seconds::text;

		PERFORM create_sort_syntex(r.code::text,r.rate_table_id::text,EXTRACT(EPOCH from r.effective_date)::text,
		case when r.code_name is null then '' else r.code_name::text end||'@split@'||
		case when r.country is null then '' else r.country::text end||'@split@'||
		case when r.rate is null then '' else r.rate::text end||'@split@'||
		case when r.intra_rate is null then '' else r.intra_rate::text end||'@split@'||
		case when r.inter_rate is null then '' else r.inter_rate::text end||'@split@'||
		case when r.local_rate is null then '' else r.local_rate::text end||'@split@'||
		case when r.end_date is null then '' else r.end_date::text end||'@split@'||
		case when r.time_profile_id is null then '' else r.time_profile_id::text end||'@split@'||
		case when r.zone is null then '' else r.zone::text end||'@split@'||
		r.min_time::text||'@split@'||
		r.grace_time::text||'@split@'||
		r.interval::text||'@split@'||
		r.seconds::text);

	end loop;

	PERFORM execute_sorted_syntex();

	for r1 in select c1 as code,c2 as rate_table_id,(TIMESTAMP WITH TIME ZONE 'epoch' + c3::bigint * INTERVAL '1 second')::text as effective_date,c4 as other from record_sorted_result(0) as t(c1,c2,c3,c4)
	loop
		--raise notice 'code %,rate_table_id %,effective_date %',r1.code,r1.rate_table_id,r1.effective_date;
		--raise notice '---> %',r1.other;
		rate_other := regexp_split_to_array(r1.other,'@split@');
		--raise notice '---> %',rate_other[1];
		--raise notice '---> %',rate_other[2];
		--raise notice '---> %',rate_other[3];
		--raise notice '---> %',rate_other[4];
		--raise notice '---> %',rate_other[5];
		--raise notice '---> %',rate_other[6];
		--raise notice '---> %',rate_other[7];
		--raise notice '---> %',rate_other[8];
		--raise notice '---> %',rate_other[9];
		--raise notice '---> %',rate_other[10];
		--raise notice '---> %',rate_other[11];
		--raise notice '---> %',rate_other[12];
		--raise notice '---> %',rate_other[13];
		select into r2 r1.code,r1.rate_table_id,r1.effective_date,rate_other[1],rate_other[2],rate_other[3],rate_other[4],rate_other[5],rate_other[6],rate_other[7],rate_other[8],rate_other[9],rate_other[10],rate_other[11],rate_other[12],rate_other[13];
		return next r2;
	end loop;

	PERFORM destroy_sorted_syntex();

	return;

end;
$_$;


ALTER FUNCTION public.filter_rate(integer[], timestamp with time zone) OWNER TO postgres;

--
-- Name: first_select(public.ip4, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.first_select(public.ip4, text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
   declare
       first_rec record;
   begin
       for first_rec in select resource_ip.resource_id,resource_ip.capacity,resource_ip.cps_limit,
resource.rtp_tos_difserv,resource.payload,resource.ingress,resource.egress,
resource.active,resource.rfc_2833,resource.direct_media,resource.t38,resource.nat,resource.translation_id,resource.alias,
resource_product_ref.digit,resource_product_ref.product_id from resource_ip,resource,resource_product_ref
 where resource_ip.ip>>= $1 and resource_ip.resource_id=resource.resource_id
 and resource_ip.resource_id=resource_product_ref.resource_id and resource_product_ref.digit@> $2 order by ip4r_size(resource_ip.ip),length(resource_product_ref.digit::text) desc
 loop
           return next first_rec;
       end loop;
       return;
   end;
$_$;


ALTER FUNCTION public.first_select(public.ip4, text) OWNER TO postgres;

--
-- Name: fourth_select(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.fourth_select(text, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
   declare
       fourth_rec record;
   begin
       for fourth_rec in select resource_direction.action,resource_direction.digits
from resource_direction where direction=2 and callee_digit_match@>$1 and resource_id=$2
order by length(callee_digit_match::text) DESC limit 1
 loop
           return next fourth_rec;
       end loop;
	return;
   end;
   $_$;


ALTER FUNCTION public.fourth_select(text, integer) OWNER TO postgres;

--
-- Name: gbt_bit_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bit_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bit_compress';


ALTER FUNCTION public.gbt_bit_compress(internal) OWNER TO postgres;

--
-- Name: gbt_bit_consistent(internal, bit, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bit_consistent(internal, bit, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bit_consistent';


ALTER FUNCTION public.gbt_bit_consistent(internal, bit, smallint) OWNER TO postgres;

--
-- Name: gbt_bit_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bit_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_bit_penalty';


ALTER FUNCTION public.gbt_bit_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_bit_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bit_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bit_picksplit';


ALTER FUNCTION public.gbt_bit_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_bit_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bit_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bit_same';


ALTER FUNCTION public.gbt_bit_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_bit_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bit_union(bytea, internal) RETURNS public.gbtreekey_var
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bit_union';


ALTER FUNCTION public.gbt_bit_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_bpchar_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bpchar_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bpchar_compress';


ALTER FUNCTION public.gbt_bpchar_compress(internal) OWNER TO postgres;

--
-- Name: gbt_bpchar_consistent(internal, character, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bpchar_consistent(internal, character, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bpchar_consistent';


ALTER FUNCTION public.gbt_bpchar_consistent(internal, character, smallint) OWNER TO postgres;

--
-- Name: gbt_bytea_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bytea_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bytea_compress';


ALTER FUNCTION public.gbt_bytea_compress(internal) OWNER TO postgres;

--
-- Name: gbt_bytea_consistent(internal, bytea, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bytea_consistent(internal, bytea, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bytea_consistent';


ALTER FUNCTION public.gbt_bytea_consistent(internal, bytea, smallint) OWNER TO postgres;

--
-- Name: gbt_bytea_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bytea_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_bytea_penalty';


ALTER FUNCTION public.gbt_bytea_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_bytea_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bytea_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bytea_picksplit';


ALTER FUNCTION public.gbt_bytea_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_bytea_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bytea_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bytea_same';


ALTER FUNCTION public.gbt_bytea_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_bytea_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_bytea_union(bytea, internal) RETURNS public.gbtreekey_var
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_bytea_union';


ALTER FUNCTION public.gbt_bytea_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_cash_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_cash_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_cash_compress';


ALTER FUNCTION public.gbt_cash_compress(internal) OWNER TO postgres;

--
-- Name: gbt_cash_consistent(internal, money, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_cash_consistent(internal, money, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_cash_consistent';


ALTER FUNCTION public.gbt_cash_consistent(internal, money, smallint) OWNER TO postgres;

--
-- Name: gbt_cash_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_cash_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_cash_penalty';


ALTER FUNCTION public.gbt_cash_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_cash_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_cash_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_cash_picksplit';


ALTER FUNCTION public.gbt_cash_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_cash_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_cash_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_cash_same';


ALTER FUNCTION public.gbt_cash_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_cash_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_cash_union(bytea, internal) RETURNS public.gbtreekey8
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_cash_union';


ALTER FUNCTION public.gbt_cash_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_date_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_date_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_date_compress';


ALTER FUNCTION public.gbt_date_compress(internal) OWNER TO postgres;

--
-- Name: gbt_date_consistent(internal, date, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_date_consistent(internal, date, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_date_consistent';


ALTER FUNCTION public.gbt_date_consistent(internal, date, smallint) OWNER TO postgres;

--
-- Name: gbt_date_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_date_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_date_penalty';


ALTER FUNCTION public.gbt_date_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_date_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_date_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_date_picksplit';


ALTER FUNCTION public.gbt_date_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_date_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_date_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_date_same';


ALTER FUNCTION public.gbt_date_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_date_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_date_union(bytea, internal) RETURNS public.gbtreekey8
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_date_union';


ALTER FUNCTION public.gbt_date_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_decompress';


ALTER FUNCTION public.gbt_decompress(internal) OWNER TO postgres;

--
-- Name: gbt_float4_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float4_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float4_compress';


ALTER FUNCTION public.gbt_float4_compress(internal) OWNER TO postgres;

--
-- Name: gbt_float4_consistent(internal, real, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float4_consistent(internal, real, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float4_consistent';


ALTER FUNCTION public.gbt_float4_consistent(internal, real, smallint) OWNER TO postgres;

--
-- Name: gbt_float4_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float4_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_float4_penalty';


ALTER FUNCTION public.gbt_float4_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_float4_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float4_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float4_picksplit';


ALTER FUNCTION public.gbt_float4_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_float4_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float4_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float4_same';


ALTER FUNCTION public.gbt_float4_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_float4_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float4_union(bytea, internal) RETURNS public.gbtreekey8
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float4_union';


ALTER FUNCTION public.gbt_float4_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_float8_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float8_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float8_compress';


ALTER FUNCTION public.gbt_float8_compress(internal) OWNER TO postgres;

--
-- Name: gbt_float8_consistent(internal, double precision, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float8_consistent(internal, double precision, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float8_consistent';


ALTER FUNCTION public.gbt_float8_consistent(internal, double precision, smallint) OWNER TO postgres;

--
-- Name: gbt_float8_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float8_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_float8_penalty';


ALTER FUNCTION public.gbt_float8_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_float8_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float8_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float8_picksplit';


ALTER FUNCTION public.gbt_float8_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_float8_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float8_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float8_same';


ALTER FUNCTION public.gbt_float8_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_float8_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_float8_union(bytea, internal) RETURNS public.gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_float8_union';


ALTER FUNCTION public.gbt_float8_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_inet_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_inet_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_inet_compress';


ALTER FUNCTION public.gbt_inet_compress(internal) OWNER TO postgres;

--
-- Name: gbt_inet_consistent(internal, inet, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_inet_consistent(internal, inet, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_inet_consistent';


ALTER FUNCTION public.gbt_inet_consistent(internal, inet, smallint) OWNER TO postgres;

--
-- Name: gbt_inet_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_inet_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_inet_penalty';


ALTER FUNCTION public.gbt_inet_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_inet_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_inet_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_inet_picksplit';


ALTER FUNCTION public.gbt_inet_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_inet_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_inet_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_inet_same';


ALTER FUNCTION public.gbt_inet_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_inet_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_inet_union(bytea, internal) RETURNS public.gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_inet_union';


ALTER FUNCTION public.gbt_inet_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_int2_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int2_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int2_compress';


ALTER FUNCTION public.gbt_int2_compress(internal) OWNER TO postgres;

--
-- Name: gbt_int2_consistent(internal, smallint, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int2_consistent(internal, smallint, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int2_consistent';


ALTER FUNCTION public.gbt_int2_consistent(internal, smallint, smallint) OWNER TO postgres;

--
-- Name: gbt_int2_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int2_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_int2_penalty';


ALTER FUNCTION public.gbt_int2_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int2_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int2_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int2_picksplit';


ALTER FUNCTION public.gbt_int2_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_int2_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int2_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int2_same';


ALTER FUNCTION public.gbt_int2_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int2_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int2_union(bytea, internal) RETURNS public.gbtreekey4
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int2_union';


ALTER FUNCTION public.gbt_int2_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_int4_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int4_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int4_compress';


ALTER FUNCTION public.gbt_int4_compress(internal) OWNER TO postgres;

--
-- Name: gbt_int4_consistent(internal, integer, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int4_consistent(internal, integer, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int4_consistent';


ALTER FUNCTION public.gbt_int4_consistent(internal, integer, smallint) OWNER TO postgres;

--
-- Name: gbt_int4_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int4_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_int4_penalty';


ALTER FUNCTION public.gbt_int4_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int4_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int4_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int4_picksplit';


ALTER FUNCTION public.gbt_int4_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_int4_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int4_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int4_same';


ALTER FUNCTION public.gbt_int4_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int4_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int4_union(bytea, internal) RETURNS public.gbtreekey8
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int4_union';


ALTER FUNCTION public.gbt_int4_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_int8_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int8_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int8_compress';


ALTER FUNCTION public.gbt_int8_compress(internal) OWNER TO postgres;

--
-- Name: gbt_int8_consistent(internal, bigint, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int8_consistent(internal, bigint, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int8_consistent';


ALTER FUNCTION public.gbt_int8_consistent(internal, bigint, smallint) OWNER TO postgres;

--
-- Name: gbt_int8_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int8_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_int8_penalty';


ALTER FUNCTION public.gbt_int8_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int8_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int8_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int8_picksplit';


ALTER FUNCTION public.gbt_int8_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_int8_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int8_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int8_same';


ALTER FUNCTION public.gbt_int8_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_int8_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_int8_union(bytea, internal) RETURNS public.gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_int8_union';


ALTER FUNCTION public.gbt_int8_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_intv_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_intv_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_compress';


ALTER FUNCTION public.gbt_intv_compress(internal) OWNER TO postgres;

--
-- Name: gbt_intv_consistent(internal, interval, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_intv_consistent(internal, interval, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_consistent';


ALTER FUNCTION public.gbt_intv_consistent(internal, interval, smallint) OWNER TO postgres;

--
-- Name: gbt_intv_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_intv_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_decompress';


ALTER FUNCTION public.gbt_intv_decompress(internal) OWNER TO postgres;

--
-- Name: gbt_intv_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_intv_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_intv_penalty';


ALTER FUNCTION public.gbt_intv_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_intv_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_intv_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_picksplit';


ALTER FUNCTION public.gbt_intv_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_intv_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_intv_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_same';


ALTER FUNCTION public.gbt_intv_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_intv_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_intv_union(bytea, internal) RETURNS public.gbtreekey32
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_intv_union';


ALTER FUNCTION public.gbt_intv_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_macad_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_macad_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_macad_compress';


ALTER FUNCTION public.gbt_macad_compress(internal) OWNER TO postgres;

--
-- Name: gbt_macad_consistent(internal, macaddr, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_macad_consistent(internal, macaddr, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_macad_consistent';


ALTER FUNCTION public.gbt_macad_consistent(internal, macaddr, smallint) OWNER TO postgres;

--
-- Name: gbt_macad_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_macad_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_macad_penalty';


ALTER FUNCTION public.gbt_macad_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_macad_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_macad_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_macad_picksplit';


ALTER FUNCTION public.gbt_macad_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_macad_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_macad_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_macad_same';


ALTER FUNCTION public.gbt_macad_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_macad_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_macad_union(bytea, internal) RETURNS public.gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_macad_union';


ALTER FUNCTION public.gbt_macad_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_numeric_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_numeric_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_numeric_compress';


ALTER FUNCTION public.gbt_numeric_compress(internal) OWNER TO postgres;

--
-- Name: gbt_numeric_consistent(internal, numeric, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_numeric_consistent(internal, numeric, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_numeric_consistent';


ALTER FUNCTION public.gbt_numeric_consistent(internal, numeric, smallint) OWNER TO postgres;

--
-- Name: gbt_numeric_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_numeric_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_numeric_penalty';


ALTER FUNCTION public.gbt_numeric_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_numeric_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_numeric_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_numeric_picksplit';


ALTER FUNCTION public.gbt_numeric_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_numeric_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_numeric_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_numeric_same';


ALTER FUNCTION public.gbt_numeric_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_numeric_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_numeric_union(bytea, internal) RETURNS public.gbtreekey_var
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_numeric_union';


ALTER FUNCTION public.gbt_numeric_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_oid_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_oid_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_oid_compress';


ALTER FUNCTION public.gbt_oid_compress(internal) OWNER TO postgres;

--
-- Name: gbt_oid_consistent(internal, oid, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_oid_consistent(internal, oid, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_oid_consistent';


ALTER FUNCTION public.gbt_oid_consistent(internal, oid, smallint) OWNER TO postgres;

--
-- Name: gbt_oid_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_oid_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_oid_penalty';


ALTER FUNCTION public.gbt_oid_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_oid_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_oid_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_oid_picksplit';


ALTER FUNCTION public.gbt_oid_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_oid_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_oid_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_oid_same';


ALTER FUNCTION public.gbt_oid_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_oid_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_oid_union(bytea, internal) RETURNS public.gbtreekey8
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_oid_union';


ALTER FUNCTION public.gbt_oid_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_text_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_text_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_text_compress';


ALTER FUNCTION public.gbt_text_compress(internal) OWNER TO postgres;

--
-- Name: gbt_text_consistent(internal, text, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_text_consistent(internal, text, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_text_consistent';


ALTER FUNCTION public.gbt_text_consistent(internal, text, smallint) OWNER TO postgres;

--
-- Name: gbt_text_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_text_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_text_penalty';


ALTER FUNCTION public.gbt_text_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_text_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_text_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_text_picksplit';


ALTER FUNCTION public.gbt_text_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_text_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_text_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_text_same';


ALTER FUNCTION public.gbt_text_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_text_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_text_union(bytea, internal) RETURNS public.gbtreekey_var
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_text_union';


ALTER FUNCTION public.gbt_text_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_time_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_time_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_time_compress';


ALTER FUNCTION public.gbt_time_compress(internal) OWNER TO postgres;

--
-- Name: gbt_time_consistent(internal, time without time zone, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_time_consistent(internal, time without time zone, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_time_consistent';


ALTER FUNCTION public.gbt_time_consistent(internal, time without time zone, smallint) OWNER TO postgres;

--
-- Name: gbt_time_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_time_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_time_penalty';


ALTER FUNCTION public.gbt_time_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_time_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_time_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_time_picksplit';


ALTER FUNCTION public.gbt_time_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_time_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_time_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_time_same';


ALTER FUNCTION public.gbt_time_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_time_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_time_union(bytea, internal) RETURNS public.gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_time_union';


ALTER FUNCTION public.gbt_time_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_timetz_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_timetz_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_timetz_compress';


ALTER FUNCTION public.gbt_timetz_compress(internal) OWNER TO postgres;

--
-- Name: gbt_timetz_consistent(internal, time with time zone, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_timetz_consistent(internal, time with time zone, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_timetz_consistent';


ALTER FUNCTION public.gbt_timetz_consistent(internal, time with time zone, smallint) OWNER TO postgres;

--
-- Name: gbt_ts_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_ts_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_ts_compress';


ALTER FUNCTION public.gbt_ts_compress(internal) OWNER TO postgres;

--
-- Name: gbt_ts_consistent(internal, timestamp without time zone, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_ts_consistent(internal, timestamp without time zone, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_ts_consistent';


ALTER FUNCTION public.gbt_ts_consistent(internal, timestamp without time zone, smallint) OWNER TO postgres;

--
-- Name: gbt_ts_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_ts_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/btree_gist', 'gbt_ts_penalty';


ALTER FUNCTION public.gbt_ts_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_ts_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_ts_picksplit(internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_ts_picksplit';


ALTER FUNCTION public.gbt_ts_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gbt_ts_same(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_ts_same(internal, internal, internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_ts_same';


ALTER FUNCTION public.gbt_ts_same(internal, internal, internal) OWNER TO postgres;

--
-- Name: gbt_ts_union(bytea, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_ts_union(bytea, internal) RETURNS public.gbtreekey16
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_ts_union';


ALTER FUNCTION public.gbt_ts_union(bytea, internal) OWNER TO postgres;

--
-- Name: gbt_tstz_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_tstz_compress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_tstz_compress';


ALTER FUNCTION public.gbt_tstz_compress(internal) OWNER TO postgres;

--
-- Name: gbt_tstz_consistent(internal, timestamp with time zone, smallint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_tstz_consistent(internal, timestamp with time zone, smallint) RETURNS boolean
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_tstz_consistent';


ALTER FUNCTION public.gbt_tstz_consistent(internal, timestamp with time zone, smallint) OWNER TO postgres;

--
-- Name: gbt_var_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gbt_var_decompress(internal) RETURNS internal
    LANGUAGE c IMMUTABLE
    AS '$libdir/btree_gist', 'gbt_var_decompress';


ALTER FUNCTION public.gbt_var_decompress(internal) OWNER TO postgres;

--
-- Name: gip4r_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gip4r_compress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_compress';


ALTER FUNCTION public.gip4r_compress(internal) OWNER TO postgres;

--
-- Name: gip4r_consistent(internal, public.ip4r, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gip4r_consistent(internal, public.ip4r, integer) RETURNS boolean
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_consistent';


ALTER FUNCTION public.gip4r_consistent(internal, public.ip4r, integer) OWNER TO postgres;

--
-- Name: gip4r_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gip4r_decompress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_decompress';


ALTER FUNCTION public.gip4r_decompress(internal) OWNER TO postgres;

--
-- Name: gip4r_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gip4r_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c STRICT
    AS '$libdir/ip4r', 'gip4r_penalty';


ALTER FUNCTION public.gip4r_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gip4r_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gip4r_picksplit(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_picksplit';


ALTER FUNCTION public.gip4r_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gip4r_same(public.ip4r, public.ip4r, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gip4r_same(public.ip4r, public.ip4r, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_same';


ALTER FUNCTION public.gip4r_same(public.ip4r, public.ip4r, internal) OWNER TO postgres;

--
-- Name: gip4r_union(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gip4r_union(internal, internal) RETURNS public.ip4r
    LANGUAGE c
    AS '$libdir/ip4r', 'gip4r_union';


ALTER FUNCTION public.gip4r_union(internal, internal) OWNER TO postgres;

--
-- Name: gpr_compress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gpr_compress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_compress';


ALTER FUNCTION public.gpr_compress(internal) OWNER TO postgres;

--
-- Name: gpr_consistent(internal, public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gpr_consistent(internal, public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_consistent';


ALTER FUNCTION public.gpr_consistent(internal, public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: gpr_decompress(internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gpr_decompress(internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_decompress';


ALTER FUNCTION public.gpr_decompress(internal) OWNER TO postgres;

--
-- Name: gpr_penalty(internal, internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gpr_penalty(internal, internal, internal) RETURNS internal
    LANGUAGE c STRICT
    AS '$libdir/prefix', 'gpr_penalty';


ALTER FUNCTION public.gpr_penalty(internal, internal, internal) OWNER TO postgres;

--
-- Name: gpr_picksplit(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gpr_picksplit(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_picksplit';


ALTER FUNCTION public.gpr_picksplit(internal, internal) OWNER TO postgres;

--
-- Name: gpr_picksplit_jordan(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gpr_picksplit_jordan(internal, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_picksplit_jordan';


ALTER FUNCTION public.gpr_picksplit_jordan(internal, internal) OWNER TO postgres;

--
-- Name: gpr_same(public.prefix_range, public.prefix_range, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gpr_same(public.prefix_range, public.prefix_range, internal) RETURNS internal
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_same';


ALTER FUNCTION public.gpr_same(public.prefix_range, public.prefix_range, internal) OWNER TO postgres;

--
-- Name: gpr_union(internal, internal); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.gpr_union(internal, internal) RETURNS text
    LANGUAGE c
    AS '$libdir/prefix', 'gpr_union';


ALTER FUNCTION public.gpr_union(internal, internal) OWNER TO postgres;

--
-- Name: ingress_cost(integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ingress_cost(client integer, start_datetime timestamp with time zone, end_datetime timestamp with time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
total_datetime timestamp with time zone = CURRENT_TIMESTAMP(0);
r record;
BEGIN
	SELECT max(report_time) + interval '1 hour' as max_time into r FROM cdr_report WHERE report_time between start_datetime
	and end_datetime;

	total_datetime = r.max_time;



	if total_datetime is null then
		SELECT
sum(ingress_client_cost) as call_cost  into r
from client_cdr where time between start_datetime and end_datetime and ingress_client_id = client and is_final_call=1;




	elsif total_datetime > end_datetime then
		SELECT sum(ingress_call_cost) as call_cost into r
		from cdr_report where report_time between start_datetime and end_datetime
		and ingress_client_id = client;


	else

		SELECT
sum(call_cost) as call_cost into r FROM ( ( SELECT sum(ingress_call_cost) as call_cost
from cdr_report
where report_time between start_datetime and total_datetime and ingress_client_id = client ) union
(SELECT
sum(ingress_client_cost) as call_cost
from client_cdr where time between total_datetime and end_datetime and ingress_client_id = client and is_final_call=1 ) ) as t;



	end if;

	return next r;
	return;

END;
$$;


ALTER FUNCTION public.ingress_cost(client integer, start_datetime timestamp with time zone, end_datetime timestamp with time zone) OWNER TO postgres;

--
-- Name: ip4(double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4(double precision) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_from_double';


ALTER FUNCTION public.ip4(double precision) OWNER TO postgres;

--
-- Name: ip4(inet); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4(inet) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_from_inet';


ALTER FUNCTION public.ip4(inet) OWNER TO postgres;

--
-- Name: ip4(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4(bigint) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_from_bigint';


ALTER FUNCTION public.ip4(bigint) OWNER TO postgres;

--
-- Name: ip4(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4(text) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_from_text';


ALTER FUNCTION public.ip4(text) OWNER TO postgres;

--
-- Name: ip4_and(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_and(public.ip4, public.ip4) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_and';


ALTER FUNCTION public.ip4_and(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4_cmp(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_cmp(public.ip4, public.ip4) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cmp';


ALTER FUNCTION public.ip4_cmp(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4_contained_by(public.ip4, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_contained_by(public.ip4, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_contained_by';


ALTER FUNCTION public.ip4_contained_by(public.ip4, public.ip4r) OWNER TO postgres;

--
-- Name: ip4_contains(public.ip4r, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_contains(public.ip4r, public.ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_contains';


ALTER FUNCTION public.ip4_contains(public.ip4r, public.ip4) OWNER TO postgres;

--
-- Name: ip4_eq(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_eq(public.ip4, public.ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_eq';


ALTER FUNCTION public.ip4_eq(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4_ge(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_ge(public.ip4, public.ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_ge';


ALTER FUNCTION public.ip4_ge(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4_gt(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_gt(public.ip4, public.ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_gt';


ALTER FUNCTION public.ip4_gt(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4_le(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_le(public.ip4, public.ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_le';


ALTER FUNCTION public.ip4_le(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4_lt(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_lt(public.ip4, public.ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_lt';


ALTER FUNCTION public.ip4_lt(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4_minus_bigint(public.ip4, bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_minus_bigint(public.ip4, bigint) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_minus_bigint';


ALTER FUNCTION public.ip4_minus_bigint(public.ip4, bigint) OWNER TO postgres;

--
-- Name: ip4_minus_int(public.ip4, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_minus_int(public.ip4, integer) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_minus_int';


ALTER FUNCTION public.ip4_minus_int(public.ip4, integer) OWNER TO postgres;

--
-- Name: ip4_minus_ip4(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_minus_ip4(public.ip4, public.ip4) RETURNS bigint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_minus_ip4';


ALTER FUNCTION public.ip4_minus_ip4(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4_neq(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_neq(public.ip4, public.ip4) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_neq';


ALTER FUNCTION public.ip4_neq(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4_net_lower(public.ip4, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_net_lower(public.ip4, integer) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_net_lower';


ALTER FUNCTION public.ip4_net_lower(public.ip4, integer) OWNER TO postgres;

--
-- Name: ip4_net_upper(public.ip4, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_net_upper(public.ip4, integer) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_net_upper';


ALTER FUNCTION public.ip4_net_upper(public.ip4, integer) OWNER TO postgres;

--
-- Name: ip4_netmask(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_netmask(integer) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_netmask';


ALTER FUNCTION public.ip4_netmask(integer) OWNER TO postgres;

--
-- Name: ip4_not(public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_not(public.ip4) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_not';


ALTER FUNCTION public.ip4_not(public.ip4) OWNER TO postgres;

--
-- Name: ip4_or(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_or(public.ip4, public.ip4) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_or';


ALTER FUNCTION public.ip4_or(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4_plus_bigint(public.ip4, bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_plus_bigint(public.ip4, bigint) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_plus_bigint';


ALTER FUNCTION public.ip4_plus_bigint(public.ip4, bigint) OWNER TO postgres;

--
-- Name: ip4_plus_int(public.ip4, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_plus_int(public.ip4, integer) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_plus_int';


ALTER FUNCTION public.ip4_plus_int(public.ip4, integer) OWNER TO postgres;

--
-- Name: ip4_xor(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4_xor(public.ip4, public.ip4) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_xor';


ALTER FUNCTION public.ip4_xor(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4hash(public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4hash(public.ip4) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4hash';


ALTER FUNCTION public.ip4hash(public.ip4) OWNER TO postgres;

--
-- Name: ip4r(cidr); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r(cidr) RETURNS public.ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cast_from_cidr';


ALTER FUNCTION public.ip4r(cidr) OWNER TO postgres;

--
-- Name: ip4r(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r(text) RETURNS public.ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cast_from_text';


ALTER FUNCTION public.ip4r(text) OWNER TO postgres;

--
-- Name: ip4r(public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r(public.ip4) RETURNS public.ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cast_from_ip4';


ALTER FUNCTION public.ip4r(public.ip4) OWNER TO postgres;

--
-- Name: ip4r(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r(public.ip4, public.ip4) RETURNS public.ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_from_ip4s';


ALTER FUNCTION public.ip4r(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4r_cmp(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_cmp(public.ip4r, public.ip4r) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cmp';


ALTER FUNCTION public.ip4r_cmp(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_contained_by(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_contained_by(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_contained_by';


ALTER FUNCTION public.ip4r_contained_by(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_contained_by_strict(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_contained_by_strict(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_contained_by_strict';


ALTER FUNCTION public.ip4r_contained_by_strict(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_contains(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_contains(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_contains';


ALTER FUNCTION public.ip4r_contains(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_contains_strict(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_contains_strict(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_contains_strict';


ALTER FUNCTION public.ip4r_contains_strict(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_eq(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_eq(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_eq';


ALTER FUNCTION public.ip4r_eq(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_ge(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_ge(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_ge';


ALTER FUNCTION public.ip4r_ge(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_gt(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_gt(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_gt';


ALTER FUNCTION public.ip4r_gt(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_inter(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_inter(public.ip4r, public.ip4r) RETURNS public.ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_inter';


ALTER FUNCTION public.ip4r_inter(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_le(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_le(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_le';


ALTER FUNCTION public.ip4r_le(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_left_of(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_left_of(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_left_of';


ALTER FUNCTION public.ip4r_left_of(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_lt(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_lt(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_lt';


ALTER FUNCTION public.ip4r_lt(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_neq(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_neq(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_neq';


ALTER FUNCTION public.ip4r_neq(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_net_mask(public.ip4, public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_net_mask(public.ip4, public.ip4) RETURNS public.ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_net_mask';


ALTER FUNCTION public.ip4r_net_mask(public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: ip4r_net_prefix(public.ip4, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_net_prefix(public.ip4, integer) RETURNS public.ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_net_prefix';


ALTER FUNCTION public.ip4r_net_prefix(public.ip4, integer) OWNER TO postgres;

--
-- Name: ip4r_overlaps(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_overlaps(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_overlaps';


ALTER FUNCTION public.ip4r_overlaps(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_right_of(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_right_of(public.ip4r, public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_right_of';


ALTER FUNCTION public.ip4r_right_of(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_size(public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_size(public.ip4r) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_size';


ALTER FUNCTION public.ip4r_size(public.ip4r) OWNER TO postgres;

--
-- Name: ip4r_union(public.ip4r, public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4r_union(public.ip4r, public.ip4r) RETURNS public.ip4r
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_union';


ALTER FUNCTION public.ip4r_union(public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: ip4rhash(public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ip4rhash(public.ip4r) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4rhash';


ALTER FUNCTION public.ip4rhash(public.ip4r) OWNER TO postgres;

--
-- Name: is_cidr(public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_cidr(public.ip4r) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_is_cidr';


ALTER FUNCTION public.is_cidr(public.ip4r) OWNER TO postgres;

--
-- Name: lower(public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.lower(public.ip4r) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_lower';


ALTER FUNCTION public.lower(public.ip4r) OWNER TO postgres;

--
-- Name: margin_max(bigint, real, real, real, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.margin_max(bigint, real, real, real, integer, text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	r1 record;
	in_ca alias for $1;
	in_rate alias for $2;
	in_asr alias for $3;
	in_acd alias for $4;
	t alias for $5;
	--1,find buy order;2--find sell order
	total_minutes real;
	name_code alias for $6;
begin
if t=1 then
	raise notice 'find buy order for code_name < % >',name_code;
	for r in
	SELECT
	s.id,
	case sum(s.minutes) when 0 then 0 else sum(s.cost)/sum(s.minutes) end as avg_rate,
	case sum(s.ca) when 0 then 0 else sum(s.ok_calls::real)/sum(s.ca) end as asr,
	case sum(s.minutes) when 0 then 0 else sum(s.minutes)/sum(s.ok_calls) end as acd
	from stats_buy_order_summary as s where code_name=name_code group by s.id having(sum(s.ca)>0 and sum(s.minutes)>0)
	loop
		raise notice 'order id %, avg_rate %, asr %, acd %',r.id,r.avg_rate,r.asr,r.acd;
		select into total_minutes in_ca*least(in_asr,r.asr)*least(in_acd,r.acd);
		select into r1 r.id::text,r.avg_rate::text,r.asr::text,r.acd::text,total_minutes::text,(total_minutes*r.avg_rate)::text,(total_minutes*in_rate)::text;
		return next r1;
	end loop;
elsif t=2 then
	raise notice 'find sell order for code_name < % >',name_code;
	for r in
	SELECT
	s.id,
	case sum(s.minutes) when 0 then 0 else sum(s.cost)/sum(s.minutes) end as avg_rate,
	case sum(s.ca) when 0 then 0 else sum(s.ok_calls::real)/sum(s.ca) end as asr,
	case sum(s.minutes) when 0 then 0 else sum(s.minutes)/sum(s.ok_calls) end as acd
	from stats_sell_order_summary as s where code_name=name_code group by s.id having(sum(s.ca)>0 and sum(s.minutes)>0)
	loop
		raise notice 'order id %, avg_rate %, asr %, acd %',r.id,r.avg_rate,r.asr,r.acd;
		select into total_minutes in_ca*least(in_asr,r.asr)*least(in_acd,r.acd);
		select into r1 r.id::text,r.avg_rate::text,r.asr::text,r.acd::text,total_minutes::text,(total_minutes*r.avg_rate)::text,(total_minutes*in_rate)::text;
		return next r1;
	end loop;
end if;

	return;
end;

$_$;


ALTER FUNCTION public.margin_max(bigint, real, real, real, integer, text) OWNER TO postgres;

--
-- Name: mutual_trans(timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.mutual_trans(timestamp with time zone, timestamp with time zone, integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	start_time alias for $1;
	end_time alias for $2;
	id_client alias for $3;
	trans_type alias for $4;
	r record;

begin

	if trans_type = 0 then --all

	if id_client = 0 then
		for r in
		select
		payment_time::text,
		(case payment_type
		when 4 then 1
		when 5 then 1
		when 3 then 2
		when 6 then 2
		when 7 then 5
		when 8 then 6
		when 9 then 9
		when 11 then 7
		when 12 then 8
		end)::text as t_type,
		client_id::text,
		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
		from client_payment
		where payment_type in (3,4,5,6,7,8,9,11,12) and
		payment_time between start_time and end_time
		union
		select
		invoice_time::text,
		(case type
		when 0 then 4
		when 2 then 4
		end)::text as t_type,
		client_id::text,
		total_amount::text
		from invoice
		where state=9 and type in (0,2) and
		invoice_time between start_time and end_time
		union
		select
		invoice_time::text,
		'3' as t_type,
		client_id::text,
		total_amount::text
		from invoice
		where type = 3 and
		invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select
		payment_time::text,
		(case payment_type
		when 4 then 1
		when 5 then 1
		when 3 then 2
		when 6 then 2
		when 7 then 5
		when 8 then 6
		when 9 then 9
		when 11 then 7
		when 12 then 8
		end)::text as t_type,
		client_id::text,
		case payment_type when 9 then (coalesce(amount,0)+coalesce(egress_amount,0))::text else amount::text end
		from client_payment
		where payment_type in (3,4,5,6,7,8,9,11,12) and client_id=id_client and
		payment_time between start_time and end_time
		union
		select
		invoice_time::text,
		(case type
		when 0 then 4
		when 2 then 4
		end)::text as t_type,
		client_id::text,
		total_amount::text
		from invoice
		where state=9 and type in (0,2) and client_id=id_client and
		invoice_time between start_time and end_time
		union
		select
		invoice_time::text,
		'3' as t_type,
		client_id::text,
		total_amount::text
		from invoice
		where type = 3 and client_id=id_client and
		invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 1 then --payment received

	if id_client=0 then
		for r in
		select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,1::text,client_id::text,amount::text from client_payment where (payment_type=4 or payment_type=5)
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 2 then --payment sent

	if id_client=0 then
		for r in
		select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,2::text,client_id::text,amount::text from client_payment where (payment_type=3 or payment_type=6)
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 3 then --invoice received

	if id_client=0 then
		for r in
		select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
		and invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select invoice_time::text,3::text,client_id::text,total_amount::text from invoice where type=3
		and invoice_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 4 then --invoice sent

	if id_client=0 then
		for r in
		select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
		and invoice_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select invoice_time::text,4::text,client_id::text,total_amount::text from invoice where (type=0 or type=2) and state=9
		and invoice_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 5 then --credit note received

	if id_client=0 then
		for r in
		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,5::text,client_id::text,amount::text from client_payment where payment_type=7
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 6 then --credit note sent

	if id_client=0 then
		for r in
		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,6::text,client_id::text,amount::text from client_payment where payment_type=8
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 7 then --debit note received

	if id_client=0 then
		for r in
		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,7::text,client_id::text,amount::text from client_payment where payment_type=11
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 8 then --debit note sent

	if id_client=0 then
		for r in
		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,8::text,client_id::text,amount::text from client_payment where payment_type=12
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	elsif trans_type = 9 then --reset

	if id_client=0 then
		for r in
		select payment_time::text,9::text,client_id::text,amount::text from client_payment where payment_type=9
		and payment_time between start_time and end_time
		loop
			return next r;
		end loop;
	else
		for r in
		select payment_time::text,9::text,client_id::text,amount::text from client_payment where payment_type=9
		and payment_time between start_time and end_time and client_id=id_client
		loop
			return next r;
		end loop;
	end if;
	end if;

	return;

end;
$_$;


ALTER FUNCTION public.mutual_trans(timestamp with time zone, timestamp with time zone, integer, integer) OWNER TO postgres;

--
-- Name: normal_rand(integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.normal_rand(integer, double precision, double precision) RETURNS SETOF double precision
    LANGUAGE c STRICT
    AS '$libdir/tablefunc', 'normal_rand';


ALTER FUNCTION public.normal_rand(integer, double precision, double precision) OWNER TO postgres;

--
-- Name: opentact_balance_func(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.opentact_balance_func() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        current_ingress_id integer;
            current_egress_rate double precision;
    BEGIN
        current_ingress_id := NEW.ingress_id;
        current_egress_rate := NEW.egress_rate;

        UPDATE  opentact_balance SET balance = balance - current_egress_rate WHERE ingress_id = current_ingress_id;

            return null;
    END;
    $$;


ALTER FUNCTION public.opentact_balance_func() OWNER TO postgres;

--
-- Name: opentact_egress_registration(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.opentact_egress_registration() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        ingress_id integer;
            egress_alias varchar;
            egress_id integer;
            resource_ip varchar;
            resource_port integer;
            current_state integer;
    BEGIN
            if  (TG_OP = 'INSERT') THEN
                    current_state := NEW.state;

                    SELECT into ingress_id resource_id FROM resource_ip WHERE  username = NEW.username  limit 1;

                    if ingress_id is not null then

                    SELECT into egress_alias replace(alias, '_ingress', '_egress') FROM resource WHERE  resource_id = ingress_id  limit 1;

                if egress_alias is not null then

                    SELECT into egress_id resource_id FROM resource WHERE alias = egress_alias and egress = true limit 1;
                    if egress_id is not null then
                        if current_state = 1 then
                            update resource_ip set ip = NEW.ip, port = NEW.port WHERE resource_id = egress_id;
                        else
                            update resource_ip set ip = NULL WHERE resource_id = egress_id;
                        end if;
                    end if;

                END IF;

            END IF;

            END IF;
            return null;
    END;
    $$;


ALTER FUNCTION public.opentact_egress_registration() OWNER TO postgres;

--
-- Name: order_stats(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.order_stats(timestamp with time zone, timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	time_start alias for $1;
	time_end alias for $2;
begin

	raise notice 'stats_trunk_origination';
	delete from stats_trunk_origination;
	for r in
	select ingress_client_id::integer as client_id,ingress_id::integer as resource_id,trunk_id_origination as alias,
	term_country as country,term_code_name as code_name,term_code as code,

	count(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as ca,
	count(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then ingress_client_cost::real else 0 end) as cost,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as total_pdd,

	count(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then time else null end) as yesday_ca,
	count(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone and answer_time_of_date > '0' then answer_time_of_date else null end) as yesday_ok_calls,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then call_duration::real else 0 end)/60 as yesday_minutes,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then ingress_client_cost::real else 0 end) as yesday_cost,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone and answer_time_of_date > '0' then pdd::integer else 0 end) as yesday_pdd,

	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as week_ca,
	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as week_ok_calls,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as week_minutes,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then ingress_client_cost::real else 0 end) as week_cost,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as week_pdd,

	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then time else null end) as mtd_ca,
	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as mtd_ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as mtd_minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then ingress_client_cost::real else 0 end) as mtd_cost,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as mtd_pdd

	from client_cdr
	where time between time_start and time_end
	and ingress_client_id != '' and ingress_id != ''
	group by ingress_client_id,ingress_id,trunk_id_origination,term_country,term_code_name,term_code
	loop
		raise notice 'ingress trunk % stats,country %,code_name %,code %',r.resource_id,r.country,r.code_name,r.code;
		insert into stats_trunk_origination
		(client_id,resource_id,trunk_id_origination,country,code_name,code,cost,pdd,ca,ok_calls,minutes,yesday_ca,yesday_ok_calls,yesday_minutes,week_ok_calls,week_minutes,mtd_ok_calls,mtd_minutes,week_ca,mtd_ca,yesday_pdd,yesday_cost,week_pdd,week_cost,mtd_pdd,mtd_cost)
		select r.client_id,r.resource_id,r.alias,r.country,r.code_name,r.code,r.cost,r.total_pdd,r.ca,r.ok_calls,r.minutes,r.yesday_ca,r.yesday_ok_calls,r.yesday_minutes,r.week_ok_calls,r.week_minutes,r.mtd_ok_calls,r.mtd_minutes,r.week_ca,r.mtd_ca,r.yesday_pdd,r.yesday_cost,r.week_pdd,r.week_cost,r.mtd_pdd,r.mtd_cost;
		--select r.client_id,r.resource_id,r.alias,r.country,r.code_name,r.code,r.cost,r.total_pdd,r.ca,r.ok_calls,r.minutes,0,0,0,0,0,0,0,0,0;
	end loop;

	raise notice 'stats_trunk_termination';
	delete from stats_trunk_termination;
	for r in
	select egress_client_id::integer as client_id,egress_id::integer as resource_id,trunk_id_termination as alias,
	term_country as country,term_code_name as code_name,term_code as code,

	count(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as ca,
	count(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then egress_cost::real else 0 end) as cost,
	sum(case when time between to_char(time_end,'YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as total_pdd,

	count(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then time else null end) as yesday_ca,
	count(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone and answer_time_of_date > '0' then answer_time_of_date else null end) as yesday_ok_calls,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then call_duration::real else 0 end)/60 as yesday_minutes,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone then egress_cost::real else 0 end) as yesday_cost,
	sum(case when time between to_char(time_end-interval '1 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and to_char(time_end-interval '1 days','YYYY-MM-DD 23:59:59')::timestamp with time zone and answer_time_of_date > '0' then pdd::integer else 0 end) as yesday_pdd,

	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as week_ca,
	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as week_ok_calls,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as week_minutes,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then egress_cost::real else 0 end) as week_cost,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as week_pdd,

	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then time else null end) as mtd_ca,
	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as mtd_ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as mtd_minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then egress_cost::real else 0 end) as mtd_cost,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as mtd_pdd

	from client_cdr
	where time between time_start and time_end
	and egress_client_id != '' and egress_id != ''
	group by egress_client_id,egress_id,trunk_id_termination,term_country,term_code_name,term_code
	loop
		raise notice 'egress trunk % stats,country %,code_name %,code %',r.resource_id,r.country,r.code_name,r.code;
		insert into stats_trunk_termination
		(client_id,resource_id,trunk_id_termination,country,code_name,code,cost,pdd,ca,ok_calls,minutes,yesday_ca,yesday_ok_calls,yesday_minutes,week_ok_calls,week_minutes,mtd_ok_calls,mtd_minutes,week_ca,mtd_ca,yesday_pdd,yesday_cost,week_pdd,week_cost,mtd_pdd,mtd_cost)
		select r.client_id,r.resource_id,r.alias,r.country,r.code_name,r.code,r.cost,r.total_pdd,r.ca,r.ok_calls,r.minutes,r.yesday_ca,r.yesday_ok_calls,r.yesday_minutes,r.week_ok_calls,r.week_minutes,r.mtd_ok_calls,r.mtd_minutes,r.week_ca,r.mtd_ca,r.yesday_pdd,r.yesday_cost,r.week_pdd,r.week_cost,r.mtd_pdd,r.mtd_cost;
		--select r.client_id,r.resource_id,r.alias,r.country,r.code_name,r.code,r.cost,r.total_pdd,r.ca,r.ok_calls,r.minutes,0,0,0,0,0,0,0,0,0;
	end loop;

	raise notice 'stats_buy_order_summary';
	delete from stats_buy_order_summary;
	for r in
	select order_id,term_country as country,term_code_name as code_name,term_code as code,

	count(case when time between time_end-interval '24 hours' and time_end then time else null end) as ca,
	count(case when time between time_end-interval '24 hours' and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as ok_calls,
	sum(case when time between time_end-interval '24 hours' and time_end then call_duration::real else 0 end)/60 as minutes,
	sum(case when time between time_end-interval '24 hours' and time_end then ingress_client_cost::real else 0 end) as cost,
	sum(case when time between time_end-interval '24 hours' and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as total_pdd,

	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as week_ca,
	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as week_ok_calls,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as week_minutes,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then ingress_client_cost::real else 0 end) as week_cost,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as week_pdd,

	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then time else null end) as mtd_ca,
	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as mtd_ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as mtd_minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then ingress_client_cost::real else 0 end) as mtd_cost,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as mtd_pdd

	from client_cdr
	where time between time_start and time_end and order_type='1'
	group by order_id,term_country,term_code_name,term_code
	loop
		raise notice 'buy order id %,country %,code_name %,code %',r.order_id,r.country,r.code_name,r.code;
		insert into stats_buy_order_summary
		(id,country,code_name,code,ca,ok_calls,minutes,week_ca,week_ok_calls,week_minutes,mtd_ca,mtd_ok_calls,mtd_minutes,cost,mtd_cost,week_pdd,week_cost,mtd_pdd,pdd)
		select r.order_id::integer,r.country,r.code_name,r.code,r.ca,r.ok_calls,r.minutes,r.week_ca,r.week_ok_calls,r.week_minutes,r.mtd_ca,r.mtd_ok_calls,r.mtd_minutes,r.cost,r.mtd_cost,r.week_pdd,r.week_cost,r.mtd_pdd,r.total_pdd;
		--select r.id,r.country,r.code_name,r.code,r.ca,r.ok_calls,r.minutes,0,0,0,0,0,0,r.cost,0;
	end loop;

	raise notice 'stats_sell_order_summary';
	delete from stats_sell_order_summary;
	for r in
	select order_id,term_country as country,term_code_name as code_name,term_code as code,

	count(case when time between time_end-interval '24 hours' and time_end then time else null end) as ca,
	count(case when time between time_end-interval '24 hours' and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as ok_calls,
	sum(case when time between time_end-interval '24 hours' and time_end then call_duration::real else 0 end)/60 as minutes,
	sum(case when time between time_end-interval '24 hours' and time_end then egress_cost::real else 0 end) as cost,
	sum(case when time between time_end-interval '24 hours' and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as total_pdd,

	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then time else null end) as week_ca,
	count(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as week_ok_calls,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as week_minutes,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end then egress_cost::real else 0 end) as week_cost,
	sum(case when time between to_char(time_end-interval '7 days','YYYY-MM-DD 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as week_pdd,

	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then time else null end) as mtd_ca,
	count(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then answer_time_of_date else null end) as mtd_ok_calls,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then call_duration::real else 0 end)/60 as mtd_minutes,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end then egress_cost::real else 0 end) as mtd_cost,
	sum(case when time between to_char(time_end,'YYYY-MM-01 00:00:00')::timestamp with time zone and time_end and answer_time_of_date > '0' then pdd::integer else 0 end) as mtd_pdd

	from client_cdr
	where time between time_start and time_end and order_type='2'
	group by order_id,term_country,term_code_name,term_code
	loop
		raise notice 'sell order id %,country %,code_name %,code %',r.order_id,r.country,r.code_name,r.code;
		insert into stats_sell_order_summary
		(id,country,code_name,code,ca,ok_calls,minutes,week_ca,week_ok_calls,week_minutes,mtd_ca,mtd_ok_calls,mtd_minutes,cost,mtd_cost,week_pdd,week_cost,mtd_pdd,pdd)
		select r.order_id::integer,r.country,r.code_name,r.code,r.ca,r.ok_calls,r.minutes,r.week_ca,r.week_ok_calls,r.week_minutes,r.mtd_ca,r.mtd_ok_calls,r.mtd_minutes,r.cost,r.mtd_cost,r.week_pdd,r.week_cost,r.mtd_pdd,r.total_pdd;
		--select r.id,r.country,r.code_name,r.code,r.ca,r.ok_calls,r.minutes,0,0,0,0,0,0,r.cost,0;
	end loop;

end;

$_$;


ALTER FUNCTION public.order_stats(timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: order_stats_report(timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.order_stats_report(timestamp with time zone, timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	time_start alias for $1;
	time_end alias for $2;
begin

	delete from stats_buy_order;
	for r in
		select order_id,term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00') as s_time,
		count(*) as ca,
		count(case answer_time_of_date when '0' then null when '' then null else answer_time_of_date end) as success_calls,
		sum(call_duration::real)/60 as minutes
		from client_cdr
		where time between time_start and time_end and order_type='1'
		group by order_id,term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00')
	loop
		raise notice 'buy order id %,country %,code_name %,code %',r.order_id,r.term_country,r.term_code_name,r.term_code;
		insert into stats_buy_order(id,country,code_name,code,call_duration,ca,success_calls,stat_time)
		select r.order_id::integer,r.term_country,r.term_code_name,r.term_code,r.minutes,r.ca,r.success_calls,r.s_time::timestamp with time zone;
	end loop;

	delete from stats_sell_order;
	for r in
		select order_id,term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00') as s_time,
		count(*) as ca,
		count(case answer_time_of_date when '0' then null when '' then null else answer_time_of_date end) as success_calls,
		sum(call_duration::real)/60 as minutes
		from client_cdr
		where time between time_start and time_end and order_type='2'
		group by order_id,term_country,term_code_name,term_code,to_char(time,'YYYY-MM-DD HH24:00:00')
	loop
		raise notice 'sell order id %,country %,code_name %,code %',r.order_id,r.term_country,r.term_code_name,r.term_code;
		insert into stats_sell_order(id,country,code_name,code,call_duration,ca,success_calls,stat_time)
		select r.order_id::integer,r.term_country,r.term_code_name,r.term_code,r.minutes,r.ca,r.success_calls,r.s_time::timestamp with time zone;
	end loop;
end;

$_$;


ALTER FUNCTION public.order_stats_report(timestamp with time zone, timestamp with time zone) OWNER TO postgres;

--
-- Name: pay_update_invoice(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.pay_update_invoice() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
   r RECORD;
   is_approved client_payment.approved%type ;--æ˜¯å¦å®¡æ ¸

	id_client integer;
	id_invoice  integer;

	amount_pay client_payment.amount%type; --å……å€¼é‡‘é¢
   amount_total    client_payment.amount%type;--æ€»å…±è¦ä»˜çš„é’±
   paid_flag   invoice.paid%type;--æ˜¯å¦ä»˜æ¸…


begin

	id_client := NEW.client_id;


    --æ‰¾ ä¸åˆ°client
	if id_client is null then
		return null;
	end if;

	--æœªå®¡æ ¸
	is_approved := NEW.approved;
	if is_approved !=true then
		return null;
	end if;

--ä»˜æ¬¾ä¸º0
	amount_pay := NEW.amount;
	if amount_pay is null then
		return null;
	end if;


	select   invoice_id,total_amount into r from invoice where client_id = id_client  order by   invoice_id   desc   limit 1;

--æ‰¾ä¸åˆ°invoice
	if r.invoice_id is null then
		return null;
   else
     id_invoice:=r.invoice_id;
     amount_total :=r.total_amount;
   end if;



if amount_total>amount_pay then
  paid_flag:=false;
else
  paid_flag:=true;
end if;

update  invoice  set pay_amount=amount_pay ,paid = paid_flag, client_id=id_client  where  invoice_id=id_invoice;

	return null;

end;
$$;


ALTER FUNCTION public.pay_update_invoice() OWNER TO postgres;

--
-- Name: pr_penalty(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.pr_penalty(public.prefix_range, public.prefix_range) RETURNS real
    LANGUAGE c STRICT
    AS '$libdir/prefix', 'pr_penalty';


ALTER FUNCTION public.pr_penalty(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range(text) RETURNS public.prefix_range
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_cast_from_text';


ALTER FUNCTION public.prefix_range(text) OWNER TO postgres;

--
-- Name: prefix_range_cmp(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_cmp(public.prefix_range, public.prefix_range) RETURNS integer
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_cmp';


ALTER FUNCTION public.prefix_range_cmp(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_contained_by(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_contained_by(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_contained_by';


ALTER FUNCTION public.prefix_range_contained_by(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_contained_by_strict(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_contained_by_strict(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_contained_by_strict';


ALTER FUNCTION public.prefix_range_contained_by_strict(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_contains(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_contains(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_contains';


ALTER FUNCTION public.prefix_range_contains(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_contains_strict(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_contains_strict(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_contains_strict';


ALTER FUNCTION public.prefix_range_contains_strict(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_eq(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_eq(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_eq';


ALTER FUNCTION public.prefix_range_eq(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_ge(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_ge(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_ge';


ALTER FUNCTION public.prefix_range_ge(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_gt(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_gt(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_gt';


ALTER FUNCTION public.prefix_range_gt(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_inter(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_inter(public.prefix_range, public.prefix_range) RETURNS public.prefix_range
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_inter';


ALTER FUNCTION public.prefix_range_inter(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_le(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_le(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_le';


ALTER FUNCTION public.prefix_range_le(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_lt(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_lt(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_lt';


ALTER FUNCTION public.prefix_range_lt(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_neq(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_neq(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_neq';


ALTER FUNCTION public.prefix_range_neq(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_overlaps(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_overlaps(public.prefix_range, public.prefix_range) RETURNS boolean
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_overlaps';


ALTER FUNCTION public.prefix_range_overlaps(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: prefix_range_union(public.prefix_range, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prefix_range_union(public.prefix_range, public.prefix_range) RETURNS public.prefix_range
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_union';


ALTER FUNCTION public.prefix_range_union(public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: product_rout_rate_table_trigfun_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.product_rout_rate_table_trigfun_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into product_rout_rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into product_rout_rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into product_rout_rate_table_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into product_rout_rate_table_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.product_rout_rate_table_trigfun_record() OWNER TO postgres;

--
-- Name: qos_chart(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.qos_chart(integer, integer, integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	qos_type alias for $1;
	search_id alias for $2;
	qos_name alias for $3;
	qos_duration alias for $4;
	r record;
	r1 record;
	success_asr_calls3 real := 0;
	total_asr_calls3 integer := 0;
	total_acd3 real := 0;
	total_pdd3 integer := 0;
	total_acd_calls3 integer := 0;
	total_ca3 integer := 0;
	asr3 real := 0;
	acd3 real := 0;
	pdd3 integer := 0;


begin

if qos_duration!=1 and qos_duration!=2 and qos_duration!=3 then
	raise notice 'qos duration error';
	return;
end if;

--Gobal Stats
if qos_type =1 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;


--Route Stats
elsif qos_type=2 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(value::integer) as ca
	from product_info
	where time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	and product_id=search_id::text
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from prefix_info
	where direction='1'
	and pro_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from prefix_info
	where direction='1'
	and pro_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from prefix_info
	where direction='1'
	and pro_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from prefix_info
	where direction='1'
	and pro_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

--Ingress Stats
elsif qos_type=3 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where res_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where res_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where res_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where res_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where res_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

--Egress Stats
elsif qos_type=4 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where res_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where res_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where res_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where res_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where res_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

--Ingress ip Stats
elsif qos_type=5 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where ip_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where ip_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

--Egress ip Stats
elsif qos_type=6 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where ip_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where ip_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where ip_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

--Route prefix Stats
elsif qos_type=7 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(call_count::integer) as ca
	from prefix_info
	where prefix_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from prefix_info
	where prefix_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from prefix_info
	where prefix_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from prefix_info
	where prefix_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from prefix_info
	where prefix_id=search_id::text
	and direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

elsif qos_type =8 then

	--call
	if qos_name=1 then
	for r in
	SELECT
	time,
	sum(ceil(asr::real*call_count_asr::integer/100)) as ca
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,r.ca::text;
		return next r1;
	end loop;
	--cps
	elsif qos_name=2 then
	for r in
	SELECT
	time,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		select into r1 r.time::text,(r.total_ca_3/180)::text;
		return next r1;
	end loop;
	--asr
	elsif qos_name=3 then
	for r in
	SELECT
	time,
	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
		select into r1 r.time::text,asr3::text;
		return next r1;
	end loop;
	--acd
	elsif qos_name=4 then
	for r in
	SELECT
	time,
	sum(case when acd::integer<0 then 0 else acd::integer end) as total_acd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
		select into r1 r.time::text,acd3::text;
		return next r1;
	end loop;
	--pdd
	elsif qos_name=5 then
	for r in
	SELECT
	time,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-(case qos_duration when 1 then 1*3600 when 2 then 24*3600 when 3 then 7*24*3600 else 0 end)
	group by time
	loop
		raise notice '%,%',r.total_pdd_3,r.total_acd_calls_3;
		if r.total_acd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_acd_calls_3; else pdd3:=0; end if;
		select into r1 r.time::text,pdd3::text;
		return next r1;
	end loop;
	else
	end if;

end if;

	return;

end;
$_$;


ALTER FUNCTION public.qos_chart(integer, integer, integer, integer) OWNER TO postgres;

--
-- Name: qos_report(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.qos_report(integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
	qos_type alias for $1;
	search_id alias for $2;
	r record;
	r1 record;
	success_asr_calls1 real := 0;
	total_asr_calls1 bigint := 0;
	total_acd1 real := 0;
	total_pdd1 bigint := 0;
	total_acd_calls1 bigint := 0;
	total_pdd_calls1 bigint := 0;
	total_ca1 bigint := 0;
	success_asr_calls2 real := 0;
	total_asr_calls2 bigint := 0;
	total_acd2 real := 0;
	total_pdd2 bigint := 0;
	total_acd_calls2 bigint := 0;
	total_pdd_calls2 bigint := 0;
	total_ca2 bigint := 0;
	success_asr_calls3 real := 0;
	total_asr_calls3 bigint := 0;
	total_acd3 real := 0;
	total_pdd3 bigint := 0;
	total_acd_calls3 bigint := 0;
	total_pdd_calls3 bigint := 0;
	total_ca3 bigint := 0;
	asr1 real := 0;
	acd1 real := 0;
	pdd1 bigint := 0;

	asr2 real := 0;
	acd2 real := 0;
	pdd2 bigint := 0;

	asr3 real := 0;
	acd3 real := 0;
	pdd3 bigint := 0;


begin

--Gobal Stats
if qos_type =1 then
	for r in
	SELECT
	*
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	loop
		if r.time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then
		success_asr_calls1 = success_asr_calls1 + r.asr::real*r.call_count_asr::integer;
		total_asr_calls1 = total_asr_calls1 + r.call_count_asr::integer;
		total_acd1 = total_acd1 + case when r.acd::real<0 then 0 else r.acd::real end;
		total_pdd1 = total_pdd1 + r.pdd::integer;
		total_acd_calls1 = total_acd_calls1 + r.call_count::integer;
		total_ca1 = total_ca1 + r.ca::integer;
		total_pdd_calls1 = total_pdd_calls1 + 1;
		end if;
		if r.time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then
		success_asr_calls2 = success_asr_calls2 + r.asr::real*r.call_count_asr::integer;
		total_asr_calls2 = total_asr_calls2 + r.call_count_asr::integer;
		total_acd2 = total_acd2 + case when r.acd::real<0 then 0 else r.acd::real end;
		total_pdd2 = total_pdd2 + r.pdd::integer;
		total_acd_calls2 = total_acd_calls2 + r.call_count::integer;
		total_ca2 = total_ca2 + r.ca::integer;
		total_pdd_calls2 = total_pdd_calls2 + 1;
		end if;
		success_asr_calls3 = success_asr_calls3 + r.asr::real*r.call_count_asr::integer;
		total_asr_calls3 = total_asr_calls3 + r.call_count_asr::integer;
		total_acd3 = total_acd3 + case when r.acd::real<0 then 0 else r.acd::real end;
		total_pdd3 = total_pdd3 + r.pdd::integer;
		total_acd_calls3 = total_acd_calls3 + r.call_count::integer;
		total_ca3 = total_ca3 + r.ca::integer;
		total_pdd_calls3 = total_pdd_calls3 + 1;
	end loop;

	raise notice '%,%,%,%,%,%',success_asr_calls1,total_asr_calls1,total_acd1,total_pdd1,total_acd_calls1,total_ca1;
	if total_asr_calls1>0 then asr1 := success_asr_calls1/total_asr_calls1; end if;
	if total_acd_calls1>0 then acd1 := total_acd1/total_acd_calls1; end if;
	if total_pdd_calls1>0 then pdd1 := total_pdd1/total_pdd_calls1; end if;
	if total_asr_calls2>0 then asr2 := success_asr_calls2/total_asr_calls2; end if;
	if total_acd_calls2>0 then acd2 := total_acd2/total_acd_calls2; end if;
	if total_pdd_calls2>0 then pdd2 := total_pdd2/total_pdd_calls2; end if;
	if total_asr_calls3>0 then asr3 := success_asr_calls3/total_asr_calls3; end if;
	if total_acd_calls3>0 then acd3 := total_acd3/total_acd_calls3; end if;
	if total_pdd_calls3>0 then pdd3 := total_pdd3/total_pdd_calls3; end if;

	select into r1 '1'::text,asr1::text,acd1::text,total_ca1::text,pdd1::text,asr2::text,acd2::text,total_ca2::text,pdd2::text,asr3::text,acd3::text,total_ca3::text,pdd3::text;
	return next r1;

--Route Stats
elsif qos_type=2 then

	for r in
	SELECT
	pro_id,
	case when prefix_id ='' then 1 else 2 end as pro_type,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(acd::real) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from prefix_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by pro_id,case when prefix_id ='' then 1 else 2 end
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.pro_id::text,r.pro_type::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

--Ingress Stats
elsif qos_type=3 then

	for r in
	SELECT
	res_id,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 and acd::real>=0 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 and acd::real>=0 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(case when acd::real<0 then 0 else acd::real end) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='0'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by res_id
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.res_id::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

--Egress Stats
elsif qos_type=4 then

	for r in
	SELECT
	res_id,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 and acd::real>=0 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 and acd::real>=0 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(case when acd::real<0 then 0 else acd::real end) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='1'
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by res_id
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.res_id::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

--Ingress ip Stats
elsif qos_type=5 then

	for r in
	SELECT
	ip_id,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 and acd::real>=0 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 and acd::real>=0 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(case when acd::real<0 then 0 else acd::real end) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='0' and res_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by ip_id
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.ip_id::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

--Egress ip Stats
elsif qos_type=6 then

	for r in
	SELECT
	ip_id,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 and acd::real>=0 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 and acd::real>=0 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(case when acd::real<0 then 0 else acd::real end) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from host_info
	where direction='1' and res_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by ip_id
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.ip_id::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

--Route prefix Stats
elsif qos_type=7 then

	for r in
	SELECT
	prefix_id,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count_asr::integer else 0 end) as total_asr_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then acd::real else 0 end) as total_acd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then pdd::integer else 0 end) as total_pdd_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then call_count::integer else 0 end) as total_acd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then 1 else 0 end) as total_pdd_calls_1,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-15*60 then ca::integer else 0 end) as total_ca_1,

	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then asr::real*call_count_asr::integer else 0 end) as success_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count_asr::integer else 0 end) as total_asr_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then acd::real else 0 end) as total_acd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then pdd::integer else 0 end) as total_pdd_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then call_count::integer else 0 end) as total_acd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then 1 else 0 end) as total_pdd_calls_2,
	sum(case when time::bigint > EXTRACT(EPOCH from current_timestamp(0))-60*60 then ca::integer else 0 end) as total_ca_2,

	sum(asr::real*call_count_asr::integer) as success_asr_calls_3,
	sum(call_count_asr::integer) as total_asr_calls_3,
	sum(acd::real) as total_acd_3,
	sum(pdd::integer) as total_pdd_3,
	sum(call_count::integer) as total_acd_calls_3,
	sum(1) as total_pdd_calls_3,
	sum(ca::integer) as total_ca_3
	from prefix_info
	where direction='1' and pro_id=search_id::text
	and time::bigint > EXTRACT(EPOCH from current_timestamp(0))-24*3600
	group by prefix_id
	loop

	raise notice '%,%,%,%,%,%',r.success_asr_calls_1,r.total_asr_calls_1,r.total_acd_1,r.total_pdd_1,r.total_acd_calls_1,r.total_ca_1;
	if r.total_asr_calls_1>0 then asr1 := r.success_asr_calls_1/r.total_asr_calls_1; else asr1:=0; end if;
	if r.total_acd_calls_1>0 then acd1 := r.total_acd_1/r.total_acd_calls_1; else acd1:=0; end if;
	if r.total_pdd_calls_1>0 then pdd1 := r.total_pdd_1/r.total_pdd_calls_1; else pdd1:=0; end if;
	if r.total_asr_calls_2>0 then asr2 := r.success_asr_calls_2/r.total_asr_calls_2; else asr2:=0; end if;
	if r.total_acd_calls_2>0 then acd2 := r.total_acd_2/r.total_acd_calls_2; else acd2:=0; end if;
	if r.total_pdd_calls_2>0 then pdd2 := r.total_pdd_2/r.total_pdd_calls_2; else pdd2:=0; end if;
	if r.total_asr_calls_3>0 then asr3 := r.success_asr_calls_3/r.total_asr_calls_3; else asr3:=0; end if;
	if r.total_acd_calls_3>0 then acd3 := r.total_acd_3/r.total_acd_calls_3; else acd3:=0; end if;
	if r.total_pdd_calls_3>0 then pdd3 := r.total_pdd_3/r.total_pdd_calls_3; else pdd3:=0; end if;

	select into r1 r.prefix_id::text,asr1::text,acd1::text,r.total_ca_1::text,pdd1::text,asr2::text,acd2::text,r.total_ca_2::text,pdd2::text,asr3::text,acd3::text,r.total_ca_3::text,pdd3::text;
	return next r1;

	end loop;

end if;

	return;

end;
$_$;


ALTER FUNCTION public.qos_report(integer, integer) OWNER TO postgres;

--
-- Name: rate_code_check(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.rate_code_check(integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
	r record;
	id_code_deck alias for $1;
begin

	for r in select * from rate_table where code_deck_id=id_code_deck order by 1
	loop
		update rate
		set end_date=current_timestamp(0)
		where rate_table_id=r.rate_table_id and
		code not in (select code from code where code_deck_id=id_code_deck);
	end loop;

end;

$_$;


ALTER FUNCTION public.rate_code_check(integer) OWNER TO postgres;

--
-- Name: rate_overflow(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.rate_overflow(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  egress_trunk_trace ALIAS FOR $1;
  single_value TEXT;
  tmp integer;
  error_code TEXT;
begin
  if (egress_trunk_trace is null) THEN
    return 0;
  ELSE
    tmp = 0;
    for single_value in select regexp_split_to_table(egress_trunk_trace,';')
    LOOP
      if (tmp = 0) THEN
        tmp = 1;
      ELSE
      select INTO error_code substring(single_value from '..$');
        if (error_code != '21') THEN
          return 0;
        END IF ;
      END IF ;
    END LOOP ;
    return 1;
  END IF ;
end;
$_$;


ALTER FUNCTION public.rate_overflow(text) OWNER TO postgres;

--
-- Name: re_total(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.re_total(begin_time text, end_time text) RETURNS integer
    LANGUAGE plpgsql
    AS $$

declare

	mviews RECORD;

begin

	for mviews in SELECT tablename FROM  pg_tables where tablename like 'statistic_cdr%'

and substring(tablename from 14) > begin_time and substring(tablename from 14) < end_time loop

		execute 'DROP TABLE ' || mviews.tablename;

	end loop;

	return 1;
end

$$;


ALTER FUNCTION public.re_total(begin_time text, end_time text) OWNER TO postgres;

--
-- Name: rerate_cdr(text, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.rerate_cdr(text, integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	orig_term alias for $2;--1:ingress,2:egress
	id_rate_table alias for $3;
	cdr_info alias for $1;
	cdr_text text[];
	r record;
	r1 record;
	new_rate numeric;
	new_cost numeric;
	new_time integer;
	r2 record;
	id_jurisdiction_country numeric;
	ani_jurisdiction integer;
	dnis_jurisdiction integer;
	res text;
	rate_dnis text;
	dp text := ';';
	start_time text;
	end_time text;
	r_zone text;
	l_time timestamp with time zone;
	rate_found boolean := false;
	exe_sql text;
	rec record;
	is_lrn integer;
begin
	SELECT into cdr_text regexp_split_to_array(cdr_info, ';');
	start_time := TIMESTAMP WITH TIME ZONE 'epoch' + cdr_text[9]::bigint/1000000 * INTERVAL '1 second';
	end_time := TIMESTAMP WITH TIME ZONE 'epoch' + cdr_text[10]::bigint/1000000 * INTERVAL '1 second';

	select into is_lrn rate_type from rate_table where rate_table_id=id_rate_table;

	if orig_term=1 then
		if is_lrn=1 then
			raise notice 'rate for lrn';
			rate_dnis := cdr_text[12];
		else
			raise notice 'rate for dnis';
			rate_dnis := cdr_text[13];
		end if;
	elsif orig_term=2 then
		if is_lrn=1 then
			raise notice 'rate for lrn';
			rate_dnis := cdr_text[12];
		else
			raise notice 'rate for dnis';
			rate_dnis := cdr_text[13];
		end if;
	end if;
        --exe_sql := 'select t1.* from (SELECT * from rate where rate_table_id='||id_rate_table||' and code @> \''||rate_dnis||'\'::prefix_range and effective_date<=\''||cdr_text[14]||'\'::timestamp with time zone order by length(code::text) desc,effective_date desc) as t1,(SELECT * from rate where rate_table_id='||id_rate_table||' and code @> \''||rate_dnis||'\'::prefix_range and effective_date<=\''||cdr_text[14]||'\'::timestamp with time zone order by length(code::text) desc,effective_date desc limit 1) as t2 where t1.code=t2.code and t1.effective_date=t2.effective_date';
        --raise notice '%',exe_sql;
        --for rec IN EXECUTE 'EXPLAIN ANALYZE ' || exe_sql LOOP
        --        RAISE NOTICE ' - %', rec;
        --end loop;

	for r1 in select t1.* from (SELECT * from rate where rate_table_id=id_rate_table and code @> rate_dnis and effective_date<=cdr_text[14]::timestamp with time zone and (end_date is null or end_date>=cdr_text[14]::timestamp with time zone) order by length(code::text) desc,effective_date desc) as t1,(SELECT * from rate where rate_table_id=id_rate_table and code @> rate_dnis and effective_date<=cdr_text[14]::timestamp with time zone and (end_date is null or end_date>=cdr_text[14]::timestamp with time zone) order by length(code::text) desc,effective_date desc limit 1) as t2 where t1.code=t2.code and t1.effective_date=t2.effective_date
	loop
		raise notice '---check rate id %',r1.rate_id;
		if r1.zone is null or r1.zone='' or r1.zone='0' then
			r_zone='0:00';
		else
			r_zone := r1.zone;
		end if;
		--l_time := r.time+r_zone::time;
		l_time := cdr_text[14]::timestamp with time zone+r_zone::time;
		--if r1.effective_date > r.time then
		if r1.effective_date > cdr_text[14]::timestamp with time zone then
			raise notice 'effective date % invalid',r1.effective_date;
			continue;
		end if;
		if r1.end_date is not null then
			--if r1.end_date < r.time then
			if r1.end_date < cdr_text[14]::timestamp with time zone then
				raise notice 'end date % invalid',r1.end_date;
				continue;
			end if;
		end if;
		if r1.time_profile_id is not null then
			select into r2 * from time_profile where time_profile_id=r1.time_profile_id;
			if r2.type != 0 then
				if r2.type = 1 then
					if l_time::time not between r2.start_time and r2.end_time then
						raise notice 'time_profile % type week invalid',r1.time_profile_id;
						continue;
					end if;
					if EXTRACT(DOW from l_time) not between r2.start_week and r2.end_week then
						raise notice 'time_profile % type week invalid',r1.time_profile_id;
						continue;
					end if;
				elsif r2.type = 2 then
					if l_time::time not between r2.start_time and r2.end_time then
						raise notice 'time_profile % type time invalid',r1.time_profile_id;
						continue;
					end if;
				end if;
			end if;
		end if;
		if r1.rate_id is not null then
			raise notice 'found it id %',r1.rate_id;
			rate_found := true;
			exit;
		end if;
	end loop;

	if rate_found is false then
		raise notice 'rate not found';
		if orig_term=1 then
			res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'orig rate not found'||dp||'N/A'||dp||'N/A'||dp||'N/A';
		elsif orig_term=2 then
			res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'N/A'||dp||'N/A'||dp||'term rate not found'||dp||'N/A';
		end if;
		return res;
	end if;
	select into id_jurisdiction_country jurisdiction_country_id from rate_table where rate_table_id=id_rate_table;
	if id_jurisdiction_country is null then
		raise notice 'rate table no select jurisdiction_country';
		new_rate := r1.rate;
	else
		select into ani_jurisdiction jurisdiction_id from jurisdiction_prefix where jurisdiction_country_id=id_jurisdiction_country and prefix @> cdr_text[15]::prefix_range order by length(prefix::text) desc limit 1;
		select into dnis_jurisdiction jurisdiction_id from jurisdiction_prefix where jurisdiction_country_id=id_jurisdiction_country and prefix @> rate_dnis::prefix_range order by length(prefix::text) desc limit 1;
		if ani_jurisdiction is not null and dnis_jurisdiction is not null then
			if ani_jurisdiction=dnis_jurisdiction then
				raise notice 'intra rate';
				new_rate := r1.intra_rate;
			else
				raise notice 'inter rate';
				new_rate := r1.inter_rate;
			end if;
		else
			raise notice 'other rate';
			new_rate := r1.rate;
		end if;
	end if;
	--if r.call_duration::integer <= r1.grace_time then
	if cdr_text[4]::integer <= r1.grace_time then
		new_time := 0;
	--elsif r.call_duration::integer <= r1.min_time then
	elsif cdr_text[4]::integer <= r1.min_time then
		new_time := r1.min_time;
	else
		--new_time := ceil(r.call_duration::real/r1.interval)*r1.interval;
		new_time := ceil(cdr_text[4]::real/r1.interval)*r1.interval;
	end if;
	new_cost := new_rate*new_time/r1.seconds;
	raise notice 'new rate %,new bill time %,new cost %',new_rate,new_time,new_cost;


	if orig_term=1 then
		res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||new_rate::numeric(30,6)||dp||new_cost::numeric(30,6)||dp||'N/A'||dp||'N/A';
	elsif orig_term=2 then
		res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'N/A'||dp||'N/A'||dp||new_rate::numeric(30,6)||dp||new_cost::numeric(30,6);
	end if;

	return res;
end;
$_$;


ALTER FUNCTION public.rerate_cdr(text, integer, integer) OWNER TO postgres;

--
-- Name: route_egress(integer, public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.route_egress(route_strategy integer, digit public.prefix_range) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
result  record;
r1      record;
r2      record;
BEGIN
	for r1 in
		SELECT dynamic_route_id, static_route_id FROM route where route_strategy_id = route_strategy and digits  <@ digit

	loop
		if r1.static_route_id is not null then

			for r2 in
				SELECT item_id FROM product_items where product_id = r1.static_route_id
			loop
				for result in
					select resource_id from product_items_resource where item_id = r2.item_id
				loop
					return next result;
				end loop;
			end loop;

		end if;

		if r1.dynamic_route_id is not null then

			for result in
				select resource_id from dynamic_route_items where dynamic_route_id = r1.dynamic_route_id
			loop
				return next result;
			end loop;
		end if;

	end loop;
	return;

END;
$$;


ALTER FUNCTION public.route_egress(route_strategy integer, digit public.prefix_range) OWNER TO postgres;

--
-- Name: second_select(text, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.second_select(text, integer, integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
   declare
       second_rec record;
   begin
       for second_rec in select resource_direction.action,resource_direction.digits
from resource_direction where direction=$3 and dnis@>$1 and resource_id=$2
order by length(dnis::text) DESC limit 1
 loop
           return next second_rec;
       end loop;
	return;
   end;
   $_$;


ALTER FUNCTION public.second_select(text, integer, integer) OWNER TO postgres;

--
-- Name: test(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
begin
   return 1;
end;
$$;


ALTER FUNCTION public.test() OWNER TO postgres;

--
-- Name: test2(date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test2(startdate date, enddate date) RETURNS date
    LANGUAGE plpgsql
    AS $$
declare
today date := CURRENT_DATE;
sqltext text :='';
datetext text :='';
maxaa text :='';
begin
create  temporary table temp_tb(report_time timestamp);
 WHILE Startdate < Enddate LOOP

 	datetext:=to_char(Startdate, 'YYYYMMDD');
 	sqltext:='insert into temp_tb(report_time) SELECT max(report_time)
        FROM cdr_report_detail' || datetext;
        execute sqltext;
    Startdate:=Startdate + cast('1 day' as interval);

 END LOOP;
	today := (SELECT max(report_time)  FROM temp_tb);
    RETURN today;
END;
$$;


ALTER FUNCTION public.test2(startdate date, enddate date) OWNER TO postgres;

--
-- Name: test_bin(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test_bin(OUT c integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

begin
	c = 10* c;

end;
$$;


ALTER FUNCTION public.test_bin(OUT c integer) OWNER TO postgres;

--
-- Name: test_bin(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test_bin(c integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
	a integer := 10;
	b integer;
begin
	b = a * c;
	return b;
end;
$$;


ALTER FUNCTION public.test_bin(c integer) OWNER TO postgres;

--
-- Name: text(public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.text(public.ip4) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_to_text';


ALTER FUNCTION public.text(public.ip4) OWNER TO postgres;

--
-- Name: text(public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.text(public.ip4r) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_cast_to_text';


ALTER FUNCTION public.text(public.ip4r) OWNER TO postgres;

--
-- Name: text(public.prefix_range); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.text(public.prefix_range) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/prefix', 'prefix_range_cast_to_text';


ALTER FUNCTION public.text(public.prefix_range) OWNER TO postgres;

--
-- Name: third_select(integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.third_select(integer, text, text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
   declare
       third_rec record;
   begin
       for third_rec in select ani,dnis,action_ani,action_dnis,ani_method,dnis_method from translation_item where translation_id= $1 and ani@>$2 and dnis@>$3 order by length(dnis::text) DESC,length(ani::text) DESC limit 1
 loop
           return next third_rec;
       end loop;
	return;
   end;
   $_$;


ALTER FUNCTION public.third_select(integer, text, text) OWNER TO postgres;

--
-- Name: to_bigint(public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.to_bigint(public.ip4) RETURNS bigint
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_to_bigint';


ALTER FUNCTION public.to_bigint(public.ip4) OWNER TO postgres;

--
-- Name: to_double(public.ip4); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.to_double(public.ip4) RETURNS double precision
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4_cast_to_double';


ALTER FUNCTION public.to_double(public.ip4) OWNER TO postgres;

--
-- Name: transf(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.transf() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare
begin
 PERFORM cs_log('Refreshing materialized view ');
end;
$$;


ALTER FUNCTION public.transf() OWNER TO postgres;

--
-- Name: trunk_pstn_header_trigfun_record(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.trunk_pstn_header_trigfun_record() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
        if(TG_OP='INSERT')then
                insert into trunk_pstn_header_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'I';
        elseif(TG_OP='DELETE')then
                insert into trunk_pstn_header_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'D';
        elseif(TG_OP='UPDATE')then
                insert into trunk_pstn_header_record select OLD.*,EXTRACT(EPOCH from current_timestamp(0)),'B';
                insert into trunk_pstn_header_record select NEW.*,EXTRACT(EPOCH from current_timestamp(0)),'A';
        end if;
return null;
end;
$$;


ALTER FUNCTION public.trunk_pstn_header_trigfun_record() OWNER TO postgres;

--
-- Name: update_cdr(text, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_cdr(text, integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	orig_term alias for $2;--1:ingress,2:egress
	id_rate_table alias for $3;
	cdr_info alias for $1;
	cdr_text text[];
	r record;
	r1 record;
	new_rate numeric;
	new_cost numeric;
	new_time integer;
	new_mins numeric;
	r2 record;
	id_jurisdiction_country numeric;
	ani_jurisdiction integer;
	dnis_jurisdiction integer;
	res text;
	rate_dnis text;
	dp text := ';';
	start_time text;
	end_time text;
	r_zone text;
	l_time timestamp with time zone;
	rate_found boolean := false;
	exe_sql text;
	is_lrn integer;
begin

	SELECT into cdr_text regexp_split_to_array(cdr_info, ';');
	start_time := TIMESTAMP WITH TIME ZONE 'epoch' + cdr_text[9]::bigint/1000000 * INTERVAL '1 second';
	end_time := TIMESTAMP WITH TIME ZONE 'epoch' + cdr_text[10]::bigint/1000000 * INTERVAL '1 second';

	select into is_lrn rate_type from rate_table where rate_table_id=id_rate_table;

	if orig_term=1 then
		if is_lrn=1 then
			rate_dnis := cdr_text[12];
		else
			rate_dnis := cdr_text[13];
		end if;
	elsif orig_term=2 then
		if is_lrn=1 then
			rate_dnis := cdr_text[12];
		else
			rate_dnis := cdr_text[13];
		end if;
	end if;

	for r1 in select t1.* from (SELECT * from rate where rate_table_id=id_rate_table and code @> rate_dnis and effective_date<=cdr_text[14]::timestamp with time zone and (end_date is null or end_date>=cdr_text[14]::timestamp with time zone) order by length(code::text) desc,effective_date desc) as t1,(SELECT * from rate where rate_table_id=id_rate_table and code @> rate_dnis and effective_date<=cdr_text[14]::timestamp with time zone and (end_date is null or end_date>=cdr_text[14]::timestamp with time zone) order by length(code::text) desc,effective_date desc limit 1) as t2 where t1.code=t2.code and t1.effective_date=t2.effective_date
	loop
		raise notice '---check rate id %',r1.rate_id;
		if r1.zone is null or r1.zone='' or r1.zone='0' then
			r_zone='0:00';
		else
			r_zone := r1.zone;
		end if;
		--l_time := r.time+r_zone::time;
		l_time := cdr_text[14]::timestamp with time zone+r_zone::time;
		--if r1.effective_date > r.time then
		if r1.effective_date > cdr_text[14]::timestamp with time zone then
			raise notice 'effective date % invalid',r1.effective_date;
			continue;
		end if;
		if r1.end_date is not null then
			--if r1.end_date < r.time then
			if r1.end_date < cdr_text[14]::timestamp with time zone then
				raise notice 'end date % invalid',r1.end_date;
				continue;
			end if;
		end if;
		if r1.time_profile_id is not null then
			select into r2 * from time_profile where time_profile_id=r1.time_profile_id;
			if r2.type != 0 then
				if r2.type = 1 then
					if l_time::time not between r2.start_time and r2.end_time then
						raise notice 'time_profile % type week invalid',r1.time_profile_id;
						continue;
					end if;
					if EXTRACT(DOW from l_time) not between r2.start_week and r2.end_week then
						raise notice 'time_profile % type week invalid',r1.time_profile_id;
						continue;
					end if;
				elsif r2.type = 2 then
					if l_time::time not between r2.start_time and r2.end_time then
						raise notice 'time_profile % type time invalid',r1.time_profile_id;
						continue;
					end if;
				end if;
			end if;
		end if;
		if r1.rate_id is not null then
			raise notice 'found it id %',r1.rate_id;
			rate_found := true;
			exit;
		end if;
	end loop;

	if rate_found is false then
		raise notice 'rate not found';
		if orig_term=1 then
			res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'orig rate not found'||dp||'N/A'||dp||'N/A'||dp||'N/A';
		elsif orig_term=2 then
			res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'N/A'||dp||'N/A'||dp||'term rate not found'||dp||'N/A';
		end if;
		return '';
	end if;
	select into id_jurisdiction_country jurisdiction_country_id from rate_table where rate_table_id=id_rate_table;
	if id_jurisdiction_country is null then
		new_rate := r1.rate;
	else
		select into ani_jurisdiction jurisdiction_id from jurisdiction_prefix where jurisdiction_country_id=id_jurisdiction_country and prefix @> cdr_text[15]::prefix_range order by length(prefix::text) desc limit 1;
		select into dnis_jurisdiction jurisdiction_id from jurisdiction_prefix where jurisdiction_country_id=id_jurisdiction_country and prefix @> rate_dnis::prefix_range order by length(prefix::text) desc limit 1;
		if ani_jurisdiction is not null and dnis_jurisdiction is not null then
			if ani_jurisdiction=dnis_jurisdiction then
				new_rate := r1.intra_rate;
			else
				new_rate := r1.inter_rate;
			end if;
		else
			new_rate := r1.rate;
		end if;
	end if;
	--if r.call_duration::integer <= r1.grace_time then
	if cdr_text[4]::integer <= r1.grace_time then
		new_time := 0;
	--elsif r.call_duration::integer <= r1.min_time then
	elsif cdr_text[4]::integer <= r1.min_time then
		new_time := r1.min_time;
	else
		--new_time := ceil(r.call_duration::real/r1.interval)*r1.interval;
		new_time := ceil(cdr_text[4]::real/r1.interval)*r1.interval;
	end if;
	new_cost := new_rate*new_time/r1.seconds;
	new_mins := (new_time::real/r1.seconds)::numeric(30,6);
	raise notice 'new rate %,new bill time %,new cost %',new_rate,new_time,new_cost;


	if orig_term=1 then
		res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||new_rate::numeric(30,6)||dp||new_cost::numeric(30,6)||dp||'N/A'||dp||'N/A';
--update client_cdr set ingress_client_rate=new_rate::numeric(30,6),ingress_client_cost=new_cost::numeric(30,6),ingress_client_bill_result='1',ingress_rate_id=r1.rate_id,rerate_time=current_timestamp(0)
--where id=cdr_text[1]::integer and time=cdr_text[14]::timestamp with time zone;
        exe_sql := 'update client_cdr set ingress_client_rate='||new_rate||'::numeric(30,6),ingress_client_cost='||new_cost||'::numeric(30,6),ingress_client_bill_time='||new_time||',ingress_bill_minutes='||new_mins||',ingress_client_bill_result=\'1\',ingress_rate_id='||r1.rate_id||',orig_code='''||r1.code||''',orig_code_name='''||COALESCE(r1.code_name,'')||''',orig_country='''||COALESCE(r1.country,'')||''',ingress_rate_effective_date=EXTRACT(EPOCH from TIMESTAMP '''||r1.effective_date||'''),rerate_time='''||current_timestamp(0)||''' where id='||cdr_text[1]||'::integer and time='''||cdr_text[14]||'''::timestamp with time zone';
	elsif orig_term=2 then
		res := cdr_text[1]||dp||cdr_text[2]||dp||cdr_text[3]||dp||start_time::text||dp||end_time::text||dp||cdr_text[4]||dp||cdr_text[5]||dp||cdr_text[6]||dp||cdr_text[7]||dp||cdr_text[8]||dp||'N/A'||dp||'N/A'||dp||new_rate::numeric(30,6)||dp||new_cost::numeric(30,6);
--update client_cdr set egress_rate=new_rate::numeric(30,6),egress_cost=new_cost::numeric(30,6),egress_bill_result='1',egress_rate_id=r1.rate_id,rerate_time=current_timestamp(0)
--where id=cdr_text[1]::integer and time=cdr_text[14] ::timestamp with time zone;
        exe_sql := 'update client_cdr set egress_rate='||new_rate||'::numeric(30,6),egress_cost='||new_cost||'::numeric(30,6),egress_bill_time='||new_time||',egress_bill_minutes='||new_mins||',egress_bill_result=\'1\',egress_rate_id='||r1.rate_id||',term_code='''||r1.code||''',term_code_name='''||COALESCE(r1.code_name,'')||''',term_country='''||COALESCE(r1.country,'')||''',egress_rate_effective_date=EXTRACT(EPOCH from TIMESTAMP '''||r1.effective_date||'''),rerate_time='''||current_timestamp(0)||''' where id='||cdr_text[1]||'::integer and time='''||cdr_text[14]||'''::timestamp with time zone';
	end if;

	return exe_sql;
end;
$_$;


ALTER FUNCTION public.update_cdr(text, integer, integer) OWNER TO postgres;

--
-- Name: update_db(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_db() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
	r record;

begin
        for r in select * from resource_replace_action_record_tmp order by record_id asc limit 100000
        loop
                --raise notice 'record currency,record id %',r.record_id;
                insert into resource_replace_action_record
                select r.id,r.resource_id,r.ani_prefix,r.ani,r.ani_min_length,r.ani_max_length,r.time,r.flag;
                delete from resource_replace_action_record_tmp where record_id=r.record_id;
        end loop;

        for r in select * from code_record_tmp order by record_id asc limit 100000
        loop
                --raise notice 'record currency,record id %',r.record_id;
                insert into code_record
                select r.code_id,r.code,r.code_deck_id,r.city,r.state,r.country,r.name,r.time,r.flag;
                delete from code_record_tmp where record_id=r.record_id;
        end loop;

        for r in select * from egress_profile_record_tmp order by record_id asc limit 100000
        loop
                --raise notice 'record currency,record id %',r.record_id;
                insert into egress_profile_record
                select r.id,r.egress_id,r.profile_id,r.server_name,r.ingress_id,r.time,r.flag;
                delete from egress_profile_record_tmp where record_id=r.record_id;
        end loop;

	for r in select * from transaction_fee_items_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into transaction_fee_items_record
		select r.id,r.trans_type,r.transaction_fee_id,r.trans_id,r.use_fee,r.time,r.flag;
		delete from transaction_fee_items_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from switch_profile_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into switch_profile_record
		select r.id,r.switch_name,r.profile_name,r.sip_ip,r.sip_port,r.sip_debug,r.sip_trace,r.proxy_ip,r.proxy_port,r.voip_gateway_id,r.support_rpid,r.support_oli,r.support_priv,r.support_div,r.support_paid,r.support_pci,r.support_x_lrn,r.support_x_header,r.sip_capture_ip,r.sip_capture_port,r.sip_capture_path,r.lan_ip,r.lan_port,r.profile_status,r.time,r.flag;
		delete from switch_profile_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from currency_updates_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into currency_updates_record
		select r.currency_id,r.modify_time,r.rate,r.last_rate,r.currency_updates_id,r.time,r.flag;
		delete from currency_updates_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from service_charge_items_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into service_charge_items_record
		select r.id,r.min_rate,r.max_rate,r.charge_value,r.service_charge_id,r.time,r.flag;
		delete from service_charge_items_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from payment_term_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into payment_term_record
		select r.payment_term_id,r.name,r.type,r.days,r.grace_days,r.notify_days,r.more_days,r.finance_rate,r.time,r.flag;
		delete from payment_term_record_tmp where record_id=r.record_id;
	end loop;

--         for r in select * from resource_rate_record_tmp order by record_id asc limit 100000
--         loop
--                 ----raise notice 'record time profile,record id %',r.record_id;
--                 insert into resource_rate_record
--                 select r.id,r.code,r.rate,r.service_rate,r.finance_rate,r.resource_id,r.order_type,r.min_time,r.interval,r.code_name,r.country,r.ingress_id,r.egress_id,r.time,r.flag;
--                 delete from resource_rate_record_tmp where record_id=r.record_id;
--         end loop;

-- 	for r in select * from buy_order_record_tmp order by record_id asc limit 100000
-- 	loop
-- 		----raise notice 'record time profile,record id %',r.record_id;
-- 		insert into buy_order_record
-- 		select r.id,r.name,r.client_id,r.resource_id,r.code_deck_id,r.rate,r.is_private,r.is_commit,r.commit_minutes,r.create_time,r.update_time,r.cli,r.g729,r.fax,r.active,r.status,r.expire_time,r.country,r.acd,r.asr,r.user_id,r.dtmf,r.state_date,r.end_date,r.limit_price,r.g723,r.g711,r.time_of_date,r.peak,r.offpeak,r.weekend,r.currency_id,r.asr_var,r.acd_var,r.rate_only,r.match_type,r.route_priority,r.invite_id,r.partner_id,r.resource_prefix,r.route_type,r.auto_match,r.auto_match_result,r.dialer,r.interval,r.limit,r.minimal_duration,r.purged,r.cli_type,r.pdd_timeout,r.pdd_var,r.auto_match_time,r.min_threedays,r.time,r.flag;
-- 		delete from buy_order_record_tmp where record_id=r.record_id;
-- 	end loop;

-- 	for r in select * from sell_order_record_tmp order by record_id asc limit 100000
-- 	loop
-- 		----raise notice 'record time profile,record id %',r.record_id;
-- 		insert into sell_order_record
-- 		select r.id,r.name,r.client_id,r.resource_id,r.code_deck_id,r.rate,r.is_private,r.is_commit,r.commit_minutes,r.create_time,r.update_time,r.cli,r.g729,r.fax,r.active,r.status,r.expire_time,r.country,r.acd,r.asr,r.user_id,r.dtmf,r.state_date,r.end_date,r.limit_price,r.g723,r.g711,r.time_of_date,r.peak,r.offpeak,r.weekend,r.invite_id,r.partner_id,r.resource_prefix,r.route_type,r.asr_var,r.acd_var,r.rate_only,r.match_type,r.route_priority,r.auto_match,r.auto_match_result,r.dialer,r.interval,r.limit,r.is_select,r.purged,r.cli_type,r.minimal_duration,r.pdd_timeout,r.auto_match_time,r.is_first,r.time,r.flag;
-- 		delete from sell_order_record_tmp where record_id=r.record_id;
-- 	end loop;

-- 	for r in select * from contract_record_tmp order by record_id asc limit 100000
-- 	loop
-- 		----raise notice 'record time profile,record id %',r.record_id;
-- 		insert into contract_record
-- 		select r.id,r.contract_type,r.order_id,r.order_response_id,r.create_time,r.update_time,r.status,r.expire_time,r.is_commit,r.commit_minutes,r.client_id,r.is_private,r.resource_id,r.confirm_order_number,r.user_id,r.resource_prefix,r.order_response_rate,r.auto_match,r.finance_rate,r.actioned,r.time,r.flag;
-- 		delete from contract_record_tmp where record_id=r.record_id;
-- 	end loop;

	for r in select * from time_profile_record_tmp order by record_id asc limit 100000
	loop
		----raise notice 'record time profile,record id %',r.record_id;
		insert into time_profile_record
		select r.time_profile_id,r.name,r.start_time,r.end_time,r.start_week,r.end_week,r.type,r.time_zone,r.time,r.flag;
		delete from time_profile_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from client_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record client,record id %',r.record_id;
		insert into client_record
		select r.client_id,r.name,r.mode,r.orig_rate_table_id,r.term_rate_table_id,r.currency_id,r.allowed_credit,r.status,r.auto_invoicing,r.payment_term_id,r.invoice_format,r.attach_cdrs_list,r.cdr_list_format,r.last_invoiced,r.notify_client_balance,r.notify_admin_balance,r.low_balance_notice,r.company,r.address,r.email,r.logo,r.login,r.password,r.is_panelaccess,r.is_client_info,r.is_invoices,r.is_rateslist,r.is_summaryreport,r.is_cdrslist,r.is_mutualsettlements,r.is_changepassword,r.role_id,r.create_time,r.profit_margin,r.enough_balance,r.service_charge_id,r.noc_email,r.billing_email,r.rate_email,r.tax_id,r.details,r.invoice_show_details,r.invoice_past_amount,r.is_link_cdr,r.is_trunk,r.is_route,r.is_spam,r.is_location,r.is_orig_term,r.is_usage,r.is_qos,r.is_discon,r.is_bill_mismatch,r.is_active_call,r.is_termin,r.database_name,r.is_rate_anal,r.is_capture,r.is_call_simulation,r.is_ingress_sim,r.is_egress_sim,r.is_report,r.is_tools,r.is_manage,r.mail_sended,r.scc_bellow,r.scc_percent,r.scc_charge,r.user_id,r.profit_type,r.auto_invoice_type,r.cps_limit,r.call_limit,r.invoice_zone,r.invoice_zero,r.update_at,r.update_by,r.corporate_contact_email,r.paypal,r.is_auto_summary,r.auto_send_zone,r.is_daily_balance_notification,r.daily_balance_notification,r.daily_balance_recipient,r.low_balance_number,r.is_auto_balance,r.numer_of_days_balance,r.auto_daily_balance_recipient,r.daily_cdr_generation,r.daily_cdr_generation_zone,r.daily_cdr_generation_type,r.transaction_fee_id,r.unlimited_credit,r.include_payment_history,r.include_available_credit,r.include_payment_history_days,r.auto_summary_not_zero,r.auto_summary_group_by,r.daily_balance_already_sent,r.last_autoreport_time,r.last_lowbalance_time,r.last_cdrdown_time,r.include_tax,r.tax,r.invoice_jurisdictional_detail,r.decimal_place,r.par_id,r.rate_value,r.email_invoice,r.scc_type,r.is_invoice_account_summary,r.is_show_daily_usage,r.invoice_include_payment,r.is_short_duration_call_surcharge_detail,r.usage_detail_fields,r.auto_summary_hour,r.auto_summary_period,r.last_autobalance_time,r.auto_summary_include_cdr,r.time,r.flag;
		delete from client_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from dynamic_route_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record dynamic route,record id %',r.record_id;
		insert into dynamic_route_record
		select r.dynamic_route_id,r.name,r.routing_rule,r.time_profile_id,r.update_at,r.update_by,r.lcr_flag,r.time,r.flag;
		delete from dynamic_route_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from dynamic_route_items_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record dynamic route items,record id %',r.record_id;
		insert into dynamic_route_items_record
		select r.id,r.dynamic_route_id,r.resource_id,r.time,r.flag;
		delete from dynamic_route_items_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from rate_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record rate,record id %',r.record_id;
		insert into rate_record
		select r.rate_id,r.rate_table_id,r.code,r.rate,r.setup_fee,r.effective_date,r.end_date,r.min_time,r.grace_time,r.interval,r.time_profile_id,r.seconds,r.code_name,r.basic_percentages,r.gift_percentages,r.rate_type,r.intra_rate,r.inter_rate,r.local_rate,r.country,r.zone,r.ocn,r.lata,r.time,r.flag;
		delete from rate_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from route_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record route,record id %',r.record_id;
		insert into route_record
		select r.route_id,r.digits,r.dynamic_route_id,r.static_route_id,r.route_type,r.route_strategy_id,r.lnp,r.lrn_block,r.dnis_only,r.code_deck_type,r.update_at,r.update_by,r.intra_static_route_id,r.inter_static_route_id,r.jurisdiction_country_id,r.ani_prefix,r.ani_min_length,r.ani_max_length,r.time,r.flag;
		delete from route_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource,record id %',r.record_id;
		insert into resource_record
		select r.resource_id,r.name,r.ingress,r.egress,r.active,r.rfc_2833,r.t38,r.alias,r.res_strategy,r.cps_limit,r.capacity,r.lnp,r.lrn_block,r.client_id,r.tdm,r.rate_table_id,r.transnexus,r.route_strategy_id,r.media_type,r.pass_through,r.profit_margin,r.enough_balance,r.egress_bill_after_action,r.proto,r.dnis_only,r.ring_timeout,r.ignore_ring,r.ignore_early_media,r.disable_by_alert,r.last_priority,r.priority,r.create_time,r.update_time,r.status,r.wait_ringtime180,r.profit_type,r.lnp_dipping,r.lnp_dipping_rate,r.update_at,r.update_by,r.cli_type,r.auth_type,r.delay_bye_second,r.delay_bye_limit,r.max_duration,r.marketplace,r.rating_type,r.billing_type,r.trunk_type,r.switch_profile_id,r.transaction_fee_id,r.service_type,r.product_id,r.rpid,r.paid,r.oli,r.pci,r.priv,r.div,r.trunk_type2,r.account_id,r.billing_method,r.amount_per_port,r.billing_rule,r.ignore_early_nosdp,r.media_timeout,r.private,r.agent_type,r.bill_by,r.time,r.flag;
		delete from resource_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_ip_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource ip,record id %',r.record_id;
		insert into resource_ip_record
		select r.resource_id,r.resource_ip_id,r.ip,r.port,r.fqdn,r.username,r.password,r.sip_rpid,r.registered,r.need_register,r.disable_by_alert,r.last_priority,r.priority,r.addr_type,r.time,r.flag;
		delete from resource_ip_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_direction_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource direction,record id %',r.record_id;
		insert into resource_direction_record
		select r.direction,r.action,r.digits,r.direction_id,r.dnis,r.resource_id,r.time_profile_id,r.type,r.number_length,r.number_type,r.time,r.flag;
		delete from resource_direction_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_codecs_ref_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource codec,record id %',r.record_id;
		insert into resource_codecs_ref_record
		select r.id,r.resource_id,r.codec_id,r.time,r.flag;
		delete from resource_codecs_ref_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_block_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource block,record id %',r.record_id;
		insert into resource_block_record
		select r.ingress_res_id,r.engress_res_id,r.digit,r.res_block_id,r.time_profile_id,r.ingress_client_id,r.egress_client_id,r.disable_by_alert,r.ani_prefix,r.ani_length,r.dnis_length,r.ani_method,r.dnis_method,r.ani_empty,r.action_type,r.time,r.flag;
		delete from resource_block_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from product_items_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record product item,record id %',r.record_id;
		insert into product_items_record
		select r.item_id,r.product_id,r.alias,r.digits,r.strategy,r.time_profile_id,r.min_len,r.max_len,r.min_asr,r.max_asr,r.min_abr,r.max_abr,r.min_acd,r.max_acd,r.min_pdd,r.max_pdd,r.min_aloc,r.max_aloc,r.limit_price,r.update_at,r.update_by,r.code_name,r.time,r.flag;
		delete from product_items_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from product_items_resource_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record product item resource,record id %',r.record_id;
		insert into product_items_resource_record
		select r.id,r.item_id,r.resource_id,r.by_percentage,r.order_id,r.order_type,r.time,r.flag;
		delete from product_items_resource_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from translation_item_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record translation item,record id %',r.record_id;
		insert into translation_item_record
		select r.ref_id,r.translation_id,r.ani,r.dnis,r.action_ani,r.action_dnis,r.ani_method,r.dnis_method,r.time,r.flag;
		delete from translation_item_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from product_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record product,record id %',r.record_id;
		insert into product_record
		select r.product_id,r.name,r.modify_time,r.introduction,r.dynamic_route_id,r.update_by,r.code_type,r.code_deck_id,r.route_lrn,r.time,r.flag;
		delete from product_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from currency_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record currency,record id %',r.record_id;
		insert into currency_record
		select r.currency_id,r.code,r.active,r.update_by,r.time,r.flag;
		delete from currency_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from rate_table_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record rate table,record id %',r.record_id;
		insert into rate_table_record
		select r.rate_table_id,r.name,r.modify_time,r.create_time,r.code_deck_id,r.currency_id,r.rate_type,r.jurisdiction_country_id,r.update_at,r.update_by,r.lnp_dipping_rate,r.jurisdiction_prefix,r.noprefix_min_length,r.noprefix_max_length,r.prefix_min_length,r.prefix_max_length,r.jur_type,r.is_uploading,r.time,r.flag;
		delete from rate_table_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_ip_limit_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource ip limit,record id %',r.record_id;
		insert into resource_ip_limit_record
		select r.limit_id,r.ip_id,r.cps,r.capacity,r.time_profile_id,r.time,r.flag;
		delete from resource_ip_limit_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_translation_ref_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource translation,record id %',r.record_id;
		insert into resource_translation_ref_record
		select r.ref_id,r.resource_id,r.translation_id,r.time_profile_id,r.time,r.flag;
		delete from resource_translation_ref_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from jurisdiction_prefix_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record jurisdiction prefix,record id %',r.record_id;
		insert into jurisdiction_prefix_record
		select r.id,r.alias,r.prefix,r.jurisdiction_id,r.jurisdiction_country_id,r.jurisdiction_name,r.jurisdiction_country_name,r.ocn,r.lata,r.time,r.flag;
		delete from jurisdiction_prefix_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from sip_error_code_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record sip error code,record id %',r.record_id;
		insert into sip_error_code_record
		select r.sip_error_code_id,r.return_code,r.return_code_str,r.switch_error_code,r.switch_error_code_str,r.resource_id,r.time,r.flag;
		delete from sip_error_code_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_next_route_rule_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource next route,record id %',r.record_id;
		insert into resource_next_route_rule_record
		select r.id,r.route_type,r.reponse_code,r.resource_id,r.return_code,r.return_string,r.time,r.flag;
		delete from resource_next_route_rule_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_prefix_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource prefix,record id %',r.record_id;
		insert into resource_prefix_record
		select r.id,r.resource_id,r.tech_prefix,r.route_strategy_id,r.rate_table_id,r.time,r.flag;
		delete from resource_prefix_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from resource_lrn_action_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record lrn action,record id %',r.record_id;
		insert into resource_lrn_action_record
		select r.id,r.direction,r.action,r.digits,r.dnis,r.resource_id,r.time,r.flag;
		delete from resource_lrn_action_record_tmp where record_id=r.record_id;
	end loop;


	for r in select * from dynamic_route_override_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource,record id %',r.record_id;
		insert into dynamic_route_override_record
		select r.id,r.dynamic_route_id,r.digits,r.resource_id,r.percentage,r.time,r.flag;
		delete from dynamic_route_override_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from dynamic_route_pri_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource,record id %',r.record_id;
		insert into dynamic_route_pri_record
		select r.id,r.dynamic_route_id,r.digits,r.resource_id,r.resource_pri,r.time,r.flag;
		delete from dynamic_route_pri_record_tmp where record_id=r.record_id;
	end loop;

	for r in select * from dynamic_route_qos_record_tmp order by record_id asc limit 100000
	loop
		--raise notice 'record resource,record id %',r.record_id;
		insert into dynamic_route_qos_record
		select r.id,r.dynamic_route_id,r.digits,r.min_asr,r.max_asr,r.min_abr,r.max_abr,r.min_acd,r.max_acd,r.min_pdd,r.max_pdd,r.min_aloc,r.max_aloc,r.limit_price,r.time,r.flag;
		delete from dynamic_route_qos_record_tmp where record_id=r.record_id;
	end loop;


	return null;

end;
$$;


ALTER FUNCTION public.update_db() OWNER TO postgres;

--
-- Name: upper(public.ip4r); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.upper(public.ip4r) RETURNS public.ip4
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/ip4r', 'ip4r_upper';


ALTER FUNCTION public.upper(public.ip4r) OWNER TO postgres;

--
-- Name: array_accum(anyelement); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE public.array_accum(anyelement) (
    SFUNC = array_append,
    STYPE = anyarray,
    INITCOND = '{}'
);


ALTER AGGREGATE public.array_accum(anyelement) OWNER TO postgres;

--
-- Name: textcat_all(text); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE public.textcat_all(text) (
    SFUNC = textcat,
    STYPE = text,
    INITCOND = ''
);


ALTER AGGREGATE public.textcat_all(text) OWNER TO postgres;

--
-- Name: #; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.# (
    PROCEDURE = public.ip4_xor,
    LEFTARG = public.ip4,
    RIGHTARG = public.ip4
);


ALTER OPERATOR public.# (public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: &; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.& (
    PROCEDURE = public.ip4_and,
    LEFTARG = public.ip4,
    RIGHTARG = public.ip4
);


ALTER OPERATOR public.& (public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: &; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.& (
    PROCEDURE = public.prefix_range_inter,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range
);


ALTER OPERATOR public.& (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR & (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.& (public.prefix_range, public.prefix_range) IS 'intersection';


--
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.&& (
    PROCEDURE = public.ip4r_overlaps,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.&&),
    RESTRICT = areasel,
    JOIN = areajoinsel
);


ALTER OPERATOR public.&& (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: &&; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.&& (
    PROCEDURE = public.prefix_range_overlaps,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range,
    COMMUTATOR = OPERATOR(public.&&),
    RESTRICT = areasel,
    JOIN = areajoinsel
);


ALTER OPERATOR public.&& (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR && (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.&& (public.prefix_range, public.prefix_range) IS 'overlaps?';


--
-- Name: +; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.+ (
    PROCEDURE = public.ip4_plus_int,
    LEFTARG = public.ip4,
    RIGHTARG = integer
);


ALTER OPERATOR public.+ (public.ip4, integer) OWNER TO postgres;

--
-- Name: +; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.+ (
    PROCEDURE = public.ip4_plus_bigint,
    LEFTARG = public.ip4,
    RIGHTARG = bigint
);


ALTER OPERATOR public.+ (public.ip4, bigint) OWNER TO postgres;

--
-- Name: -; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.- (
    PROCEDURE = public.ip4_minus_int,
    LEFTARG = public.ip4,
    RIGHTARG = integer
);


ALTER OPERATOR public.- (public.ip4, integer) OWNER TO postgres;

--
-- Name: -; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.- (
    PROCEDURE = public.ip4_minus_bigint,
    LEFTARG = public.ip4,
    RIGHTARG = bigint
);


ALTER OPERATOR public.- (public.ip4, bigint) OWNER TO postgres;

--
-- Name: -; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.- (
    PROCEDURE = public.ip4_minus_ip4,
    LEFTARG = public.ip4,
    RIGHTARG = public.ip4
);


ALTER OPERATOR public.- (public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.< (
    PROCEDURE = public.ip4_lt,
    LEFTARG = public.ip4,
    RIGHTARG = public.ip4,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.< (
    PROCEDURE = public.ip4r_lt,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.>),
    NEGATOR = OPERATOR(public.>=),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.< (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: <; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.< (
    PROCEDURE = public.prefix_range_lt,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range
);


ALTER OPERATOR public.< (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR < (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.< (public.prefix_range, public.prefix_range) IS 'less-than';


--
-- Name: <<; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.<< (
    PROCEDURE = public.ip4r_contained_by_strict,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.>>),
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.<< (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: <<<; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.<<< (
    PROCEDURE = public.ip4r_left_of,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.>>>),
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.<<< (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: <<=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.<<= (
    PROCEDURE = public.ip4r_contained_by,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.>>=),
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.<<= (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.ip4_le,
    LEFTARG = public.ip4,
    RIGHTARG = public.ip4,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.ip4r_le,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.>=),
    NEGATOR = OPERATOR(public.>),
    RESTRICT = scalarltsel,
    JOIN = scalarltjoinsel
);


ALTER OPERATOR public.<= (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: <=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.<= (
    PROCEDURE = public.prefix_range_le,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range
);


ALTER OPERATOR public.<= (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR <= (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.<= (public.prefix_range, public.prefix_range) IS 'less-than-or-equal';


--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.ip4_neq,
    LEFTARG = public.ip4,
    RIGHTARG = public.ip4,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.ip4r_neq,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: <>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.<> (
    PROCEDURE = public.prefix_range_neq,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range,
    COMMUTATOR = OPERATOR(public.<>),
    NEGATOR = OPERATOR(public.=),
    RESTRICT = neqsel,
    JOIN = neqjoinsel
);


ALTER OPERATOR public.<> (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR <> (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.<> (public.prefix_range, public.prefix_range) IS 'not equals?';


--
-- Name: <@; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.<@ (
    PROCEDURE = public.prefix_range_contained_by,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range,
    COMMUTATOR = OPERATOR(public.@>)
);


ALTER OPERATOR public.<@ (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR <@ (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.<@ (public.prefix_range, public.prefix_range) IS 'contained by?';


--
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.= (
    PROCEDURE = public.ip4_eq,
    LEFTARG = public.ip4,
    RIGHTARG = public.ip4,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.= (
    PROCEDURE = public.ip4r_eq,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    MERGES,
    HASHES,
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: =; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.= (
    PROCEDURE = public.prefix_range_eq,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range,
    COMMUTATOR = OPERATOR(public.=),
    NEGATOR = OPERATOR(public.<>),
    RESTRICT = eqsel,
    JOIN = eqjoinsel
);


ALTER OPERATOR public.= (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR = (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.= (public.prefix_range, public.prefix_range) IS 'equals?';


--
-- Name: >; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.> (
    PROCEDURE = public.ip4_gt,
    LEFTARG = public.ip4,
    RIGHTARG = public.ip4,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.> (
    PROCEDURE = public.ip4r_gt,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.<),
    NEGATOR = OPERATOR(public.<=),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.> (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: >; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.> (
    PROCEDURE = public.prefix_range_gt,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range
);


ALTER OPERATOR public.> (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR > (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.> (public.prefix_range, public.prefix_range) IS 'greater-than';


--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.ip4_ge,
    LEFTARG = public.ip4,
    RIGHTARG = public.ip4,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.ip4r_ge,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.<=),
    NEGATOR = OPERATOR(public.<),
    RESTRICT = scalargtsel,
    JOIN = scalargtjoinsel
);


ALTER OPERATOR public.>= (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: >=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.>= (
    PROCEDURE = public.prefix_range_ge,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range
);


ALTER OPERATOR public.>= (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR >= (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.>= (public.prefix_range, public.prefix_range) IS 'greater-than-or-equal';


--
-- Name: >>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.>> (
    PROCEDURE = public.ip4r_contains_strict,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.<<),
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.>> (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: >>=; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.>>= (
    PROCEDURE = public.ip4r_contains,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.<<=),
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.>>= (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: >>>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.>>> (
    PROCEDURE = public.ip4r_right_of,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.<<<),
    RESTRICT = positionsel,
    JOIN = positionjoinsel
);


ALTER OPERATOR public.>>> (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: @; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.@ (
    PROCEDURE = public.ip4r_contains,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.~),
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@ (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: @>; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.@> (
    PROCEDURE = public.prefix_range_contains,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range,
    COMMUTATOR = OPERATOR(public.<@),
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.@> (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR @> (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.@> (public.prefix_range, public.prefix_range) IS 'contains?';


--
-- Name: |; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.| (
    PROCEDURE = public.ip4_or,
    LEFTARG = public.ip4,
    RIGHTARG = public.ip4
);


ALTER OPERATOR public.| (public.ip4, public.ip4) OWNER TO postgres;

--
-- Name: |; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.| (
    PROCEDURE = public.prefix_range_union,
    LEFTARG = public.prefix_range,
    RIGHTARG = public.prefix_range
);


ALTER OPERATOR public.| (public.prefix_range, public.prefix_range) OWNER TO postgres;

--
-- Name: OPERATOR | (public.prefix_range, public.prefix_range); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON OPERATOR public.| (public.prefix_range, public.prefix_range) IS 'union';


--
-- Name: ~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.~ (
    PROCEDURE = public.ip4_not,
    RIGHTARG = public.ip4
);


ALTER OPERATOR public.~ (NONE, public.ip4) OWNER TO postgres;

--
-- Name: ~; Type: OPERATOR; Schema: public; Owner: postgres
--

CREATE OPERATOR public.~ (
    PROCEDURE = public.ip4r_contained_by,
    LEFTARG = public.ip4r,
    RIGHTARG = public.ip4r,
    COMMUTATOR = OPERATOR(public.@),
    RESTRICT = contsel,
    JOIN = contjoinsel
);


ALTER OPERATOR public.~ (public.ip4r, public.ip4r) OWNER TO postgres;

--
-- Name: btree_ip4_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.btree_ip4_ops USING btree;


ALTER OPERATOR FAMILY public.btree_ip4_ops USING btree OWNER TO postgres;

--
-- Name: btree_ip4_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.btree_ip4_ops
    DEFAULT FOR TYPE public.ip4 USING btree FAMILY public.btree_ip4_ops AS
    OPERATOR 1 public.<(public.ip4,public.ip4) ,
    OPERATOR 2 public.<=(public.ip4,public.ip4) ,
    OPERATOR 3 public.=(public.ip4,public.ip4) ,
    OPERATOR 4 public.>=(public.ip4,public.ip4) ,
    OPERATOR 5 public.>(public.ip4,public.ip4) ,
    FUNCTION 1 (public.ip4, public.ip4) public.ip4_cmp(public.ip4,public.ip4);


ALTER OPERATOR CLASS public.btree_ip4_ops USING btree OWNER TO postgres;

--
-- Name: btree_ip4r_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.btree_ip4r_ops USING btree;


ALTER OPERATOR FAMILY public.btree_ip4r_ops USING btree OWNER TO postgres;

--
-- Name: btree_ip4r_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.btree_ip4r_ops
    DEFAULT FOR TYPE public.ip4r USING btree FAMILY public.btree_ip4r_ops AS
    OPERATOR 1 public.<(public.ip4r,public.ip4r) ,
    OPERATOR 2 public.<=(public.ip4r,public.ip4r) ,
    OPERATOR 3 public.=(public.ip4r,public.ip4r) ,
    OPERATOR 4 public.>=(public.ip4r,public.ip4r) ,
    OPERATOR 5 public.>(public.ip4r,public.ip4r) ,
    FUNCTION 1 (public.ip4r, public.ip4r) public.ip4r_cmp(public.ip4r,public.ip4r);


ALTER OPERATOR CLASS public.btree_ip4r_ops USING btree OWNER TO postgres;

--
-- Name: btree_prefix_range_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.btree_prefix_range_ops USING btree;


ALTER OPERATOR FAMILY public.btree_prefix_range_ops USING btree OWNER TO postgres;

--
-- Name: btree_prefix_range_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.btree_prefix_range_ops
    DEFAULT FOR TYPE public.prefix_range USING btree FAMILY public.btree_prefix_range_ops AS
    OPERATOR 1 public.<(public.prefix_range,public.prefix_range) ,
    OPERATOR 2 public.<=(public.prefix_range,public.prefix_range) ,
    OPERATOR 3 public.=(public.prefix_range,public.prefix_range) ,
    OPERATOR 4 public.>=(public.prefix_range,public.prefix_range) ,
    OPERATOR 5 public.>(public.prefix_range,public.prefix_range) ,
    FUNCTION 1 (public.prefix_range, public.prefix_range) public.prefix_range_cmp(public.prefix_range,public.prefix_range);


ALTER OPERATOR CLASS public.btree_prefix_range_ops USING btree OWNER TO postgres;

--
-- Name: gist_bit_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_bit_ops USING gist;


ALTER OPERATOR FAMILY public.gist_bit_ops USING gist OWNER TO postgres;

--
-- Name: gist_bit_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_bit_ops
    DEFAULT FOR TYPE bit USING gist FAMILY public.gist_bit_ops AS
    STORAGE public.gbtreekey_var ,
    OPERATOR 1 <(bit,bit) ,
    OPERATOR 2 <=(bit,bit) ,
    OPERATOR 3 =(bit,bit) ,
    OPERATOR 4 >=(bit,bit) ,
    OPERATOR 5 >(bit,bit) ,
    FUNCTION 1 (bit, bit) public.gbt_bit_consistent(internal,bit,smallint) ,
    FUNCTION 2 (bit, bit) public.gbt_bit_union(bytea,internal) ,
    FUNCTION 3 (bit, bit) public.gbt_bit_compress(internal) ,
    FUNCTION 4 (bit, bit) public.gbt_var_decompress(internal) ,
    FUNCTION 5 (bit, bit) public.gbt_bit_penalty(internal,internal,internal) ,
    FUNCTION 6 (bit, bit) public.gbt_bit_picksplit(internal,internal) ,
    FUNCTION 7 (bit, bit) public.gbt_bit_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_bit_ops USING gist OWNER TO postgres;

--
-- Name: gist_bpchar_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_bpchar_ops USING gist;


ALTER OPERATOR FAMILY public.gist_bpchar_ops USING gist OWNER TO postgres;

--
-- Name: gist_bpchar_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_bpchar_ops
    DEFAULT FOR TYPE character USING gist FAMILY public.gist_bpchar_ops AS
    STORAGE public.gbtreekey_var ,
    OPERATOR 1 <(character,character) ,
    OPERATOR 2 <=(character,character) ,
    OPERATOR 3 =(character,character) ,
    OPERATOR 4 >=(character,character) ,
    OPERATOR 5 >(character,character) ,
    FUNCTION 1 (character, character) public.gbt_bpchar_consistent(internal,character,smallint) ,
    FUNCTION 2 (character, character) public.gbt_text_union(bytea,internal) ,
    FUNCTION 3 (character, character) public.gbt_bpchar_compress(internal) ,
    FUNCTION 4 (character, character) public.gbt_var_decompress(internal) ,
    FUNCTION 5 (character, character) public.gbt_text_penalty(internal,internal,internal) ,
    FUNCTION 6 (character, character) public.gbt_text_picksplit(internal,internal) ,
    FUNCTION 7 (character, character) public.gbt_text_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_bpchar_ops USING gist OWNER TO postgres;

--
-- Name: gist_bytea_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_bytea_ops USING gist;


ALTER OPERATOR FAMILY public.gist_bytea_ops USING gist OWNER TO postgres;

--
-- Name: gist_bytea_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_bytea_ops
    DEFAULT FOR TYPE bytea USING gist FAMILY public.gist_bytea_ops AS
    STORAGE public.gbtreekey_var ,
    OPERATOR 1 <(bytea,bytea) ,
    OPERATOR 2 <=(bytea,bytea) ,
    OPERATOR 3 =(bytea,bytea) ,
    OPERATOR 4 >=(bytea,bytea) ,
    OPERATOR 5 >(bytea,bytea) ,
    FUNCTION 1 (bytea, bytea) public.gbt_bytea_consistent(internal,bytea,smallint) ,
    FUNCTION 2 (bytea, bytea) public.gbt_bytea_union(bytea,internal) ,
    FUNCTION 3 (bytea, bytea) public.gbt_bytea_compress(internal) ,
    FUNCTION 4 (bytea, bytea) public.gbt_var_decompress(internal) ,
    FUNCTION 5 (bytea, bytea) public.gbt_bytea_penalty(internal,internal,internal) ,
    FUNCTION 6 (bytea, bytea) public.gbt_bytea_picksplit(internal,internal) ,
    FUNCTION 7 (bytea, bytea) public.gbt_bytea_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_bytea_ops USING gist OWNER TO postgres;

--
-- Name: gist_cash_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_cash_ops USING gist;


ALTER OPERATOR FAMILY public.gist_cash_ops USING gist OWNER TO postgres;

--
-- Name: gist_cash_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_cash_ops
    DEFAULT FOR TYPE money USING gist FAMILY public.gist_cash_ops AS
    STORAGE public.gbtreekey16 ,
    OPERATOR 1 <(money,money) ,
    OPERATOR 2 <=(money,money) ,
    OPERATOR 3 =(money,money) ,
    OPERATOR 4 >=(money,money) ,
    OPERATOR 5 >(money,money) ,
    FUNCTION 1 (money, money) public.gbt_cash_consistent(internal,money,smallint) ,
    FUNCTION 2 (money, money) public.gbt_cash_union(bytea,internal) ,
    FUNCTION 3 (money, money) public.gbt_cash_compress(internal) ,
    FUNCTION 4 (money, money) public.gbt_decompress(internal) ,
    FUNCTION 5 (money, money) public.gbt_cash_penalty(internal,internal,internal) ,
    FUNCTION 6 (money, money) public.gbt_cash_picksplit(internal,internal) ,
    FUNCTION 7 (money, money) public.gbt_cash_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_cash_ops USING gist OWNER TO postgres;

--
-- Name: gist_cidr_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_cidr_ops USING gist;


ALTER OPERATOR FAMILY public.gist_cidr_ops USING gist OWNER TO postgres;

--
-- Name: gist_cidr_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_cidr_ops
    DEFAULT FOR TYPE cidr USING gist FAMILY public.gist_cidr_ops AS
    STORAGE public.gbtreekey16 ,
    OPERATOR 1 <(inet,inet) ,
    OPERATOR 2 <=(inet,inet) ,
    OPERATOR 3 =(inet,inet) ,
    OPERATOR 4 >=(inet,inet) ,
    OPERATOR 5 >(inet,inet) ,
    FUNCTION 1 (cidr, cidr) public.gbt_inet_consistent(internal,inet,smallint) ,
    FUNCTION 2 (cidr, cidr) public.gbt_inet_union(bytea,internal) ,
    FUNCTION 3 (cidr, cidr) public.gbt_inet_compress(internal) ,
    FUNCTION 4 (cidr, cidr) public.gbt_decompress(internal) ,
    FUNCTION 5 (cidr, cidr) public.gbt_inet_penalty(internal,internal,internal) ,
    FUNCTION 6 (cidr, cidr) public.gbt_inet_picksplit(internal,internal) ,
    FUNCTION 7 (cidr, cidr) public.gbt_inet_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_cidr_ops USING gist OWNER TO postgres;

--
-- Name: gist_date_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_date_ops USING gist;


ALTER OPERATOR FAMILY public.gist_date_ops USING gist OWNER TO postgres;

--
-- Name: gist_date_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_date_ops
    DEFAULT FOR TYPE date USING gist FAMILY public.gist_date_ops AS
    STORAGE public.gbtreekey8 ,
    OPERATOR 1 <(date,date) ,
    OPERATOR 2 <=(date,date) ,
    OPERATOR 3 =(date,date) ,
    OPERATOR 4 >=(date,date) ,
    OPERATOR 5 >(date,date) ,
    FUNCTION 1 (date, date) public.gbt_date_consistent(internal,date,smallint) ,
    FUNCTION 2 (date, date) public.gbt_date_union(bytea,internal) ,
    FUNCTION 3 (date, date) public.gbt_date_compress(internal) ,
    FUNCTION 4 (date, date) public.gbt_decompress(internal) ,
    FUNCTION 5 (date, date) public.gbt_date_penalty(internal,internal,internal) ,
    FUNCTION 6 (date, date) public.gbt_date_picksplit(internal,internal) ,
    FUNCTION 7 (date, date) public.gbt_date_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_date_ops USING gist OWNER TO postgres;

--
-- Name: gist_float4_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_float4_ops USING gist;


ALTER OPERATOR FAMILY public.gist_float4_ops USING gist OWNER TO postgres;

--
-- Name: gist_float4_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_float4_ops
    DEFAULT FOR TYPE real USING gist FAMILY public.gist_float4_ops AS
    STORAGE public.gbtreekey8 ,
    OPERATOR 1 <(real,real) ,
    OPERATOR 2 <=(real,real) ,
    OPERATOR 3 =(real,real) ,
    OPERATOR 4 >=(real,real) ,
    OPERATOR 5 >(real,real) ,
    FUNCTION 1 (real, real) public.gbt_float4_consistent(internal,real,smallint) ,
    FUNCTION 2 (real, real) public.gbt_float4_union(bytea,internal) ,
    FUNCTION 3 (real, real) public.gbt_float4_compress(internal) ,
    FUNCTION 4 (real, real) public.gbt_decompress(internal) ,
    FUNCTION 5 (real, real) public.gbt_float4_penalty(internal,internal,internal) ,
    FUNCTION 6 (real, real) public.gbt_float4_picksplit(internal,internal) ,
    FUNCTION 7 (real, real) public.gbt_float4_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_float4_ops USING gist OWNER TO postgres;

--
-- Name: gist_float8_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_float8_ops USING gist;


ALTER OPERATOR FAMILY public.gist_float8_ops USING gist OWNER TO postgres;

--
-- Name: gist_float8_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_float8_ops
    DEFAULT FOR TYPE double precision USING gist FAMILY public.gist_float8_ops AS
    STORAGE public.gbtreekey16 ,
    OPERATOR 1 <(double precision,double precision) ,
    OPERATOR 2 <=(double precision,double precision) ,
    OPERATOR 3 =(double precision,double precision) ,
    OPERATOR 4 >=(double precision,double precision) ,
    OPERATOR 5 >(double precision,double precision) ,
    FUNCTION 1 (double precision, double precision) public.gbt_float8_consistent(internal,double precision,smallint) ,
    FUNCTION 2 (double precision, double precision) public.gbt_float8_union(bytea,internal) ,
    FUNCTION 3 (double precision, double precision) public.gbt_float8_compress(internal) ,
    FUNCTION 4 (double precision, double precision) public.gbt_decompress(internal) ,
    FUNCTION 5 (double precision, double precision) public.gbt_float8_penalty(internal,internal,internal) ,
    FUNCTION 6 (double precision, double precision) public.gbt_float8_picksplit(internal,internal) ,
    FUNCTION 7 (double precision, double precision) public.gbt_float8_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_float8_ops USING gist OWNER TO postgres;

--
-- Name: gist_inet_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_inet_ops USING gist;


ALTER OPERATOR FAMILY public.gist_inet_ops USING gist OWNER TO postgres;

--
-- Name: gist_inet_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_inet_ops
    DEFAULT FOR TYPE inet USING gist FAMILY public.gist_inet_ops AS
    STORAGE public.gbtreekey16 ,
    OPERATOR 1 <(inet,inet) ,
    OPERATOR 2 <=(inet,inet) ,
    OPERATOR 3 =(inet,inet) ,
    OPERATOR 4 >=(inet,inet) ,
    OPERATOR 5 >(inet,inet) ,
    FUNCTION 1 (inet, inet) public.gbt_inet_consistent(internal,inet,smallint) ,
    FUNCTION 2 (inet, inet) public.gbt_inet_union(bytea,internal) ,
    FUNCTION 3 (inet, inet) public.gbt_inet_compress(internal) ,
    FUNCTION 4 (inet, inet) public.gbt_decompress(internal) ,
    FUNCTION 5 (inet, inet) public.gbt_inet_penalty(internal,internal,internal) ,
    FUNCTION 6 (inet, inet) public.gbt_inet_picksplit(internal,internal) ,
    FUNCTION 7 (inet, inet) public.gbt_inet_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_inet_ops USING gist OWNER TO postgres;

--
-- Name: gist_int2_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_int2_ops USING gist;


ALTER OPERATOR FAMILY public.gist_int2_ops USING gist OWNER TO postgres;

--
-- Name: gist_int2_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_int2_ops
    DEFAULT FOR TYPE smallint USING gist FAMILY public.gist_int2_ops AS
    STORAGE public.gbtreekey4 ,
    OPERATOR 1 <(smallint,smallint) ,
    OPERATOR 2 <=(smallint,smallint) ,
    OPERATOR 3 =(smallint,smallint) ,
    OPERATOR 4 >=(smallint,smallint) ,
    OPERATOR 5 >(smallint,smallint) ,
    FUNCTION 1 (smallint, smallint) public.gbt_int2_consistent(internal,smallint,smallint) ,
    FUNCTION 2 (smallint, smallint) public.gbt_int2_union(bytea,internal) ,
    FUNCTION 3 (smallint, smallint) public.gbt_int2_compress(internal) ,
    FUNCTION 4 (smallint, smallint) public.gbt_decompress(internal) ,
    FUNCTION 5 (smallint, smallint) public.gbt_int2_penalty(internal,internal,internal) ,
    FUNCTION 6 (smallint, smallint) public.gbt_int2_picksplit(internal,internal) ,
    FUNCTION 7 (smallint, smallint) public.gbt_int2_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_int2_ops USING gist OWNER TO postgres;

--
-- Name: gist_int4_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_int4_ops USING gist;


ALTER OPERATOR FAMILY public.gist_int4_ops USING gist OWNER TO postgres;

--
-- Name: gist_int4_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_int4_ops
    DEFAULT FOR TYPE integer USING gist FAMILY public.gist_int4_ops AS
    STORAGE public.gbtreekey8 ,
    OPERATOR 1 <(integer,integer) ,
    OPERATOR 2 <=(integer,integer) ,
    OPERATOR 3 =(integer,integer) ,
    OPERATOR 4 >=(integer,integer) ,
    OPERATOR 5 >(integer,integer) ,
    FUNCTION 1 (integer, integer) public.gbt_int4_consistent(internal,integer,smallint) ,
    FUNCTION 2 (integer, integer) public.gbt_int4_union(bytea,internal) ,
    FUNCTION 3 (integer, integer) public.gbt_int4_compress(internal) ,
    FUNCTION 4 (integer, integer) public.gbt_decompress(internal) ,
    FUNCTION 5 (integer, integer) public.gbt_int4_penalty(internal,internal,internal) ,
    FUNCTION 6 (integer, integer) public.gbt_int4_picksplit(internal,internal) ,
    FUNCTION 7 (integer, integer) public.gbt_int4_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_int4_ops USING gist OWNER TO postgres;

--
-- Name: gist_int8_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_int8_ops USING gist;


ALTER OPERATOR FAMILY public.gist_int8_ops USING gist OWNER TO postgres;

--
-- Name: gist_int8_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_int8_ops
    DEFAULT FOR TYPE bigint USING gist FAMILY public.gist_int8_ops AS
    STORAGE public.gbtreekey16 ,
    OPERATOR 1 <(bigint,bigint) ,
    OPERATOR 2 <=(bigint,bigint) ,
    OPERATOR 3 =(bigint,bigint) ,
    OPERATOR 4 >=(bigint,bigint) ,
    OPERATOR 5 >(bigint,bigint) ,
    FUNCTION 1 (bigint, bigint) public.gbt_int8_consistent(internal,bigint,smallint) ,
    FUNCTION 2 (bigint, bigint) public.gbt_int8_union(bytea,internal) ,
    FUNCTION 3 (bigint, bigint) public.gbt_int8_compress(internal) ,
    FUNCTION 4 (bigint, bigint) public.gbt_decompress(internal) ,
    FUNCTION 5 (bigint, bigint) public.gbt_int8_penalty(internal,internal,internal) ,
    FUNCTION 6 (bigint, bigint) public.gbt_int8_picksplit(internal,internal) ,
    FUNCTION 7 (bigint, bigint) public.gbt_int8_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_int8_ops USING gist OWNER TO postgres;

--
-- Name: gist_interval_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_interval_ops USING gist;


ALTER OPERATOR FAMILY public.gist_interval_ops USING gist OWNER TO postgres;

--
-- Name: gist_interval_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_interval_ops
    DEFAULT FOR TYPE interval USING gist FAMILY public.gist_interval_ops AS
    STORAGE public.gbtreekey32 ,
    OPERATOR 1 <(interval,interval) ,
    OPERATOR 2 <=(interval,interval) ,
    OPERATOR 3 =(interval,interval) ,
    OPERATOR 4 >=(interval,interval) ,
    OPERATOR 5 >(interval,interval) ,
    FUNCTION 1 (interval, interval) public.gbt_intv_consistent(internal,interval,smallint) ,
    FUNCTION 2 (interval, interval) public.gbt_intv_union(bytea,internal) ,
    FUNCTION 3 (interval, interval) public.gbt_intv_compress(internal) ,
    FUNCTION 4 (interval, interval) public.gbt_intv_decompress(internal) ,
    FUNCTION 5 (interval, interval) public.gbt_intv_penalty(internal,internal,internal) ,
    FUNCTION 6 (interval, interval) public.gbt_intv_picksplit(internal,internal) ,
    FUNCTION 7 (interval, interval) public.gbt_intv_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_interval_ops USING gist OWNER TO postgres;

--
-- Name: gist_ip4r_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_ip4r_ops USING gist;


ALTER OPERATOR FAMILY public.gist_ip4r_ops USING gist OWNER TO postgres;

--
-- Name: gist_ip4r_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_ip4r_ops
    DEFAULT FOR TYPE public.ip4r USING gist FAMILY public.gist_ip4r_ops AS
    OPERATOR 1 public.>>=(public.ip4r,public.ip4r) ,
    OPERATOR 2 public.<<=(public.ip4r,public.ip4r) ,
    OPERATOR 3 public.>>(public.ip4r,public.ip4r) ,
    OPERATOR 4 public.<<(public.ip4r,public.ip4r) ,
    OPERATOR 5 public.&&(public.ip4r,public.ip4r) ,
    OPERATOR 6 public.=(public.ip4r,public.ip4r) ,
    FUNCTION 1 (public.ip4r, public.ip4r) public.gip4r_consistent(internal,public.ip4r,integer) ,
    FUNCTION 2 (public.ip4r, public.ip4r) public.gip4r_union(internal,internal) ,
    FUNCTION 3 (public.ip4r, public.ip4r) public.gip4r_compress(internal) ,
    FUNCTION 4 (public.ip4r, public.ip4r) public.gip4r_decompress(internal) ,
    FUNCTION 5 (public.ip4r, public.ip4r) public.gip4r_penalty(internal,internal,internal) ,
    FUNCTION 6 (public.ip4r, public.ip4r) public.gip4r_picksplit(internal,internal) ,
    FUNCTION 7 (public.ip4r, public.ip4r) public.gip4r_same(public.ip4r,public.ip4r,internal);


ALTER OPERATOR CLASS public.gist_ip4r_ops USING gist OWNER TO postgres;

--
-- Name: gist_macaddr_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_macaddr_ops USING gist;


ALTER OPERATOR FAMILY public.gist_macaddr_ops USING gist OWNER TO postgres;

--
-- Name: gist_macaddr_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_macaddr_ops
    DEFAULT FOR TYPE macaddr USING gist FAMILY public.gist_macaddr_ops AS
    STORAGE public.gbtreekey16 ,
    OPERATOR 1 <(macaddr,macaddr) ,
    OPERATOR 2 <=(macaddr,macaddr) ,
    OPERATOR 3 =(macaddr,macaddr) ,
    OPERATOR 4 >=(macaddr,macaddr) ,
    OPERATOR 5 >(macaddr,macaddr) ,
    FUNCTION 1 (macaddr, macaddr) public.gbt_macad_consistent(internal,macaddr,smallint) ,
    FUNCTION 2 (macaddr, macaddr) public.gbt_macad_union(bytea,internal) ,
    FUNCTION 3 (macaddr, macaddr) public.gbt_macad_compress(internal) ,
    FUNCTION 4 (macaddr, macaddr) public.gbt_decompress(internal) ,
    FUNCTION 5 (macaddr, macaddr) public.gbt_macad_penalty(internal,internal,internal) ,
    FUNCTION 6 (macaddr, macaddr) public.gbt_macad_picksplit(internal,internal) ,
    FUNCTION 7 (macaddr, macaddr) public.gbt_macad_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_macaddr_ops USING gist OWNER TO postgres;

--
-- Name: gist_numeric_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_numeric_ops USING gist;


ALTER OPERATOR FAMILY public.gist_numeric_ops USING gist OWNER TO postgres;

--
-- Name: gist_numeric_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_numeric_ops
    DEFAULT FOR TYPE numeric USING gist FAMILY public.gist_numeric_ops AS
    STORAGE public.gbtreekey_var ,
    OPERATOR 1 <(numeric,numeric) ,
    OPERATOR 2 <=(numeric,numeric) ,
    OPERATOR 3 =(numeric,numeric) ,
    OPERATOR 4 >=(numeric,numeric) ,
    OPERATOR 5 >(numeric,numeric) ,
    FUNCTION 1 (numeric, numeric) public.gbt_numeric_consistent(internal,numeric,smallint) ,
    FUNCTION 2 (numeric, numeric) public.gbt_numeric_union(bytea,internal) ,
    FUNCTION 3 (numeric, numeric) public.gbt_numeric_compress(internal) ,
    FUNCTION 4 (numeric, numeric) public.gbt_var_decompress(internal) ,
    FUNCTION 5 (numeric, numeric) public.gbt_numeric_penalty(internal,internal,internal) ,
    FUNCTION 6 (numeric, numeric) public.gbt_numeric_picksplit(internal,internal) ,
    FUNCTION 7 (numeric, numeric) public.gbt_numeric_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_numeric_ops USING gist OWNER TO postgres;

--
-- Name: gist_oid_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_oid_ops USING gist;


ALTER OPERATOR FAMILY public.gist_oid_ops USING gist OWNER TO postgres;

--
-- Name: gist_oid_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_oid_ops
    DEFAULT FOR TYPE oid USING gist FAMILY public.gist_oid_ops AS
    STORAGE public.gbtreekey8 ,
    OPERATOR 1 <(oid,oid) ,
    OPERATOR 2 <=(oid,oid) ,
    OPERATOR 3 =(oid,oid) ,
    OPERATOR 4 >=(oid,oid) ,
    OPERATOR 5 >(oid,oid) ,
    FUNCTION 1 (oid, oid) public.gbt_oid_consistent(internal,oid,smallint) ,
    FUNCTION 2 (oid, oid) public.gbt_oid_union(bytea,internal) ,
    FUNCTION 3 (oid, oid) public.gbt_oid_compress(internal) ,
    FUNCTION 4 (oid, oid) public.gbt_decompress(internal) ,
    FUNCTION 5 (oid, oid) public.gbt_oid_penalty(internal,internal,internal) ,
    FUNCTION 6 (oid, oid) public.gbt_oid_picksplit(internal,internal) ,
    FUNCTION 7 (oid, oid) public.gbt_oid_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_oid_ops USING gist OWNER TO postgres;

--
-- Name: gist_prefix_range_jordan_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_prefix_range_jordan_ops USING gist;


ALTER OPERATOR FAMILY public.gist_prefix_range_jordan_ops USING gist OWNER TO postgres;

--
-- Name: gist_prefix_range_jordan_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_prefix_range_jordan_ops
    FOR TYPE public.prefix_range USING gist FAMILY public.gist_prefix_range_jordan_ops AS
    OPERATOR 1 public.@>(public.prefix_range,public.prefix_range) ,
    FUNCTION 1 (public.prefix_range, public.prefix_range) public.gpr_consistent(internal,public.prefix_range,public.prefix_range) ,
    FUNCTION 2 (public.prefix_range, public.prefix_range) public.gpr_union(internal,internal) ,
    FUNCTION 3 (public.prefix_range, public.prefix_range) public.gpr_compress(internal) ,
    FUNCTION 4 (public.prefix_range, public.prefix_range) public.gpr_decompress(internal) ,
    FUNCTION 5 (public.prefix_range, public.prefix_range) public.gpr_penalty(internal,internal,internal) ,
    FUNCTION 6 (public.prefix_range, public.prefix_range) public.gpr_picksplit_jordan(internal,internal) ,
    FUNCTION 7 (public.prefix_range, public.prefix_range) public.gpr_same(public.prefix_range,public.prefix_range,internal);


ALTER OPERATOR CLASS public.gist_prefix_range_jordan_ops USING gist OWNER TO postgres;

--
-- Name: gist_prefix_range_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_prefix_range_ops USING gist;


ALTER OPERATOR FAMILY public.gist_prefix_range_ops USING gist OWNER TO postgres;

--
-- Name: gist_prefix_range_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_prefix_range_ops
    FOR TYPE public.prefix_range USING gist FAMILY public.gist_prefix_range_ops AS
    OPERATOR 1 public.@>(public.prefix_range,public.prefix_range) ,
    FUNCTION 1 (public.prefix_range, public.prefix_range) public.gpr_consistent(internal,public.prefix_range,public.prefix_range) ,
    FUNCTION 2 (public.prefix_range, public.prefix_range) public.gpr_union(internal,internal) ,
    FUNCTION 3 (public.prefix_range, public.prefix_range) public.gpr_compress(internal) ,
    FUNCTION 4 (public.prefix_range, public.prefix_range) public.gpr_decompress(internal) ,
    FUNCTION 5 (public.prefix_range, public.prefix_range) public.gpr_penalty(internal,internal,internal) ,
    FUNCTION 6 (public.prefix_range, public.prefix_range) public.gpr_picksplit(internal,internal) ,
    FUNCTION 7 (public.prefix_range, public.prefix_range) public.gpr_same(public.prefix_range,public.prefix_range,internal);


ALTER OPERATOR CLASS public.gist_prefix_range_ops USING gist OWNER TO postgres;

--
-- Name: gist_text_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_text_ops USING gist;


ALTER OPERATOR FAMILY public.gist_text_ops USING gist OWNER TO postgres;

--
-- Name: gist_text_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_text_ops
    DEFAULT FOR TYPE text USING gist FAMILY public.gist_text_ops AS
    STORAGE public.gbtreekey_var ,
    OPERATOR 1 <(text,text) ,
    OPERATOR 2 <=(text,text) ,
    OPERATOR 3 =(text,text) ,
    OPERATOR 4 >=(text,text) ,
    OPERATOR 5 >(text,text) ,
    FUNCTION 1 (text, text) public.gbt_text_consistent(internal,text,smallint) ,
    FUNCTION 2 (text, text) public.gbt_text_union(bytea,internal) ,
    FUNCTION 3 (text, text) public.gbt_text_compress(internal) ,
    FUNCTION 4 (text, text) public.gbt_var_decompress(internal) ,
    FUNCTION 5 (text, text) public.gbt_text_penalty(internal,internal,internal) ,
    FUNCTION 6 (text, text) public.gbt_text_picksplit(internal,internal) ,
    FUNCTION 7 (text, text) public.gbt_text_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_text_ops USING gist OWNER TO postgres;

--
-- Name: gist_time_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_time_ops USING gist;


ALTER OPERATOR FAMILY public.gist_time_ops USING gist OWNER TO postgres;

--
-- Name: gist_time_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_time_ops
    DEFAULT FOR TYPE time without time zone USING gist FAMILY public.gist_time_ops AS
    STORAGE public.gbtreekey16 ,
    OPERATOR 1 <(time without time zone,time without time zone) ,
    OPERATOR 2 <=(time without time zone,time without time zone) ,
    OPERATOR 3 =(time without time zone,time without time zone) ,
    OPERATOR 4 >=(time without time zone,time without time zone) ,
    OPERATOR 5 >(time without time zone,time without time zone) ,
    FUNCTION 1 (time without time zone, time without time zone) public.gbt_time_consistent(internal,time without time zone,smallint) ,
    FUNCTION 2 (time without time zone, time without time zone) public.gbt_time_union(bytea,internal) ,
    FUNCTION 3 (time without time zone, time without time zone) public.gbt_time_compress(internal) ,
    FUNCTION 4 (time without time zone, time without time zone) public.gbt_decompress(internal) ,
    FUNCTION 5 (time without time zone, time without time zone) public.gbt_time_penalty(internal,internal,internal) ,
    FUNCTION 6 (time without time zone, time without time zone) public.gbt_time_picksplit(internal,internal) ,
    FUNCTION 7 (time without time zone, time without time zone) public.gbt_time_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_time_ops USING gist OWNER TO postgres;

--
-- Name: gist_timestamp_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_timestamp_ops USING gist;


ALTER OPERATOR FAMILY public.gist_timestamp_ops USING gist OWNER TO postgres;

--
-- Name: gist_timestamp_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_timestamp_ops
    DEFAULT FOR TYPE timestamp without time zone USING gist FAMILY public.gist_timestamp_ops AS
    STORAGE public.gbtreekey16 ,
    OPERATOR 1 <(timestamp without time zone,timestamp without time zone) ,
    OPERATOR 2 <=(timestamp without time zone,timestamp without time zone) ,
    OPERATOR 3 =(timestamp without time zone,timestamp without time zone) ,
    OPERATOR 4 >=(timestamp without time zone,timestamp without time zone) ,
    OPERATOR 5 >(timestamp without time zone,timestamp without time zone) ,
    FUNCTION 1 (timestamp without time zone, timestamp without time zone) public.gbt_ts_consistent(internal,timestamp without time zone,smallint) ,
    FUNCTION 2 (timestamp without time zone, timestamp without time zone) public.gbt_ts_union(bytea,internal) ,
    FUNCTION 3 (timestamp without time zone, timestamp without time zone) public.gbt_ts_compress(internal) ,
    FUNCTION 4 (timestamp without time zone, timestamp without time zone) public.gbt_decompress(internal) ,
    FUNCTION 5 (timestamp without time zone, timestamp without time zone) public.gbt_ts_penalty(internal,internal,internal) ,
    FUNCTION 6 (timestamp without time zone, timestamp without time zone) public.gbt_ts_picksplit(internal,internal) ,
    FUNCTION 7 (timestamp without time zone, timestamp without time zone) public.gbt_ts_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_timestamp_ops USING gist OWNER TO postgres;

--
-- Name: gist_timestamptz_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_timestamptz_ops USING gist;


ALTER OPERATOR FAMILY public.gist_timestamptz_ops USING gist OWNER TO postgres;

--
-- Name: gist_timestamptz_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_timestamptz_ops
    DEFAULT FOR TYPE timestamp with time zone USING gist FAMILY public.gist_timestamptz_ops AS
    STORAGE public.gbtreekey16 ,
    OPERATOR 1 <(timestamp with time zone,timestamp with time zone) ,
    OPERATOR 2 <=(timestamp with time zone,timestamp with time zone) ,
    OPERATOR 3 =(timestamp with time zone,timestamp with time zone) ,
    OPERATOR 4 >=(timestamp with time zone,timestamp with time zone) ,
    OPERATOR 5 >(timestamp with time zone,timestamp with time zone) ,
    FUNCTION 1 (timestamp with time zone, timestamp with time zone) public.gbt_tstz_consistent(internal,timestamp with time zone,smallint) ,
    FUNCTION 2 (timestamp with time zone, timestamp with time zone) public.gbt_ts_union(bytea,internal) ,
    FUNCTION 3 (timestamp with time zone, timestamp with time zone) public.gbt_tstz_compress(internal) ,
    FUNCTION 4 (timestamp with time zone, timestamp with time zone) public.gbt_decompress(internal) ,
    FUNCTION 5 (timestamp with time zone, timestamp with time zone) public.gbt_ts_penalty(internal,internal,internal) ,
    FUNCTION 6 (timestamp with time zone, timestamp with time zone) public.gbt_ts_picksplit(internal,internal) ,
    FUNCTION 7 (timestamp with time zone, timestamp with time zone) public.gbt_ts_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_timestamptz_ops USING gist OWNER TO postgres;

--
-- Name: gist_timetz_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_timetz_ops USING gist;


ALTER OPERATOR FAMILY public.gist_timetz_ops USING gist OWNER TO postgres;

--
-- Name: gist_timetz_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_timetz_ops
    DEFAULT FOR TYPE time with time zone USING gist FAMILY public.gist_timetz_ops AS
    STORAGE public.gbtreekey16 ,
    OPERATOR 1 <(time with time zone,time with time zone) ,
    OPERATOR 2 <=(time with time zone,time with time zone) ,
    OPERATOR 3 =(time with time zone,time with time zone) ,
    OPERATOR 4 >=(time with time zone,time with time zone) ,
    OPERATOR 5 >(time with time zone,time with time zone) ,
    FUNCTION 1 (time with time zone, time with time zone) public.gbt_timetz_consistent(internal,time with time zone,smallint) ,
    FUNCTION 2 (time with time zone, time with time zone) public.gbt_time_union(bytea,internal) ,
    FUNCTION 3 (time with time zone, time with time zone) public.gbt_timetz_compress(internal) ,
    FUNCTION 4 (time with time zone, time with time zone) public.gbt_decompress(internal) ,
    FUNCTION 5 (time with time zone, time with time zone) public.gbt_time_penalty(internal,internal,internal) ,
    FUNCTION 6 (time with time zone, time with time zone) public.gbt_time_picksplit(internal,internal) ,
    FUNCTION 7 (time with time zone, time with time zone) public.gbt_time_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_timetz_ops USING gist OWNER TO postgres;

--
-- Name: gist_vbit_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_vbit_ops USING gist;


ALTER OPERATOR FAMILY public.gist_vbit_ops USING gist OWNER TO postgres;

--
-- Name: gist_vbit_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.gist_vbit_ops
    DEFAULT FOR TYPE bit varying USING gist FAMILY public.gist_vbit_ops AS
    STORAGE public.gbtreekey_var ,
    OPERATOR 1 <(bit varying,bit varying) ,
    OPERATOR 2 <=(bit varying,bit varying) ,
    OPERATOR 3 =(bit varying,bit varying) ,
    OPERATOR 4 >=(bit varying,bit varying) ,
    OPERATOR 5 >(bit varying,bit varying) ,
    FUNCTION 1 (bit varying, bit varying) public.gbt_bit_consistent(internal,bit,smallint) ,
    FUNCTION 2 (bit varying, bit varying) public.gbt_bit_union(bytea,internal) ,
    FUNCTION 3 (bit varying, bit varying) public.gbt_bit_compress(internal) ,
    FUNCTION 4 (bit varying, bit varying) public.gbt_var_decompress(internal) ,
    FUNCTION 5 (bit varying, bit varying) public.gbt_bit_penalty(internal,internal,internal) ,
    FUNCTION 6 (bit varying, bit varying) public.gbt_bit_picksplit(internal,internal) ,
    FUNCTION 7 (bit varying, bit varying) public.gbt_bit_same(internal,internal,internal);


ALTER OPERATOR CLASS public.gist_vbit_ops USING gist OWNER TO postgres;

--
-- Name: hash_ip4_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.hash_ip4_ops USING hash;


ALTER OPERATOR FAMILY public.hash_ip4_ops USING hash OWNER TO postgres;

--
-- Name: hash_ip4_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.hash_ip4_ops
    DEFAULT FOR TYPE public.ip4 USING hash FAMILY public.hash_ip4_ops AS
    OPERATOR 1 public.=(public.ip4,public.ip4) ,
    FUNCTION 1 (public.ip4, public.ip4) public.ip4hash(public.ip4);


ALTER OPERATOR CLASS public.hash_ip4_ops USING hash OWNER TO postgres;

--
-- Name: hash_ip4r_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.hash_ip4r_ops USING hash;


ALTER OPERATOR FAMILY public.hash_ip4r_ops USING hash OWNER TO postgres;

--
-- Name: hash_ip4r_ops; Type: OPERATOR CLASS; Schema: public; Owner: postgres
--

CREATE OPERATOR CLASS public.hash_ip4r_ops
    DEFAULT FOR TYPE public.ip4r USING hash FAMILY public.hash_ip4r_ops AS
    OPERATOR 1 public.=(public.ip4r,public.ip4r) ,
    FUNCTION 1 (public.ip4r, public.ip4r) public.ip4rhash(public.ip4r);


ALTER OPERATOR CLASS public.hash_ip4r_ops USING hash OWNER TO postgres;

--
-- Name: CAST (cidr AS public.ip4r); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (cidr AS public.ip4r) WITH FUNCTION public.ip4r(cidr) AS ASSIGNMENT;


--
-- Name: CAST (double precision AS public.ip4); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (double precision AS public.ip4) WITH FUNCTION public.ip4(double precision);


--
-- Name: CAST (inet AS public.ip4); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (inet AS public.ip4) WITH FUNCTION public.ip4(inet) AS ASSIGNMENT;


--
-- Name: CAST (bigint AS public.ip4); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (bigint AS public.ip4) WITH FUNCTION public.ip4(bigint);


--
-- Name: CAST (public.ip4 AS cidr); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ip4 AS cidr) WITH FUNCTION public.cidr(public.ip4) AS ASSIGNMENT;


--
-- Name: CAST (public.ip4 AS double precision); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ip4 AS double precision) WITH FUNCTION public.to_double(public.ip4);


--
-- Name: CAST (public.ip4 AS bigint); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ip4 AS bigint) WITH FUNCTION public.to_bigint(public.ip4);


--
-- Name: CAST (public.ip4 AS public.ip4r); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ip4 AS public.ip4r) WITH FUNCTION public.ip4r(public.ip4) AS IMPLICIT;


--
-- Name: CAST (public.ip4 AS text); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ip4 AS text) WITH FUNCTION public.text(public.ip4);


--
-- Name: CAST (public.ip4r AS cidr); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ip4r AS cidr) WITH FUNCTION public.cidr(public.ip4r);


--
-- Name: CAST (public.ip4r AS text); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.ip4r AS text) WITH FUNCTION public.text(public.ip4r);


--
-- Name: CAST (public.prefix_range AS text); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (public.prefix_range AS text) WITH FUNCTION public.text(public.prefix_range);


--
-- Name: CAST (text AS public.ip4); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (text AS public.ip4) WITH FUNCTION public.ip4(text);


--
-- Name: CAST (text AS public.ip4r); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (text AS public.ip4r) WITH FUNCTION public.ip4r(text);


--
-- Name: CAST (text AS public.prefix_range); Type: CAST; Schema: -; Owner: 
--

CREATE CAST (text AS public.prefix_range) WITH FUNCTION public.prefix_range(text) AS IMPLICIT;


SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: pga_exception; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pgagent.pga_exception (
    jexid integer NOT NULL,
    jexscid integer NOT NULL,
    jexdate date,
    jextime time without time zone
);


ALTER TABLE pgagent.pga_exception OWNER TO postgres;

--
-- Name: pga_exception_jexid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pgagent.pga_exception_jexid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pgagent.pga_exception_jexid_seq OWNER TO postgres;

--
-- Name: pga_exception_jexid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pgagent.pga_exception_jexid_seq OWNED BY pgagent.pga_exception.jexid;


--
-- Name: pga_job; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pgagent.pga_job (
    jobid integer NOT NULL,
    jobjclid integer NOT NULL,
    jobname text NOT NULL,
    jobdesc text DEFAULT ''::text NOT NULL,
    jobhostagent text DEFAULT ''::text NOT NULL,
    jobenabled boolean DEFAULT true NOT NULL,
    jobcreated timestamp with time zone DEFAULT now() NOT NULL,
    jobchanged timestamp with time zone DEFAULT now() NOT NULL,
    jobagentid integer,
    jobnextrun timestamp with time zone,
    joblastrun timestamp with time zone
);


ALTER TABLE pgagent.pga_job OWNER TO postgres;

--
-- Name: TABLE pga_job; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pgagent.pga_job IS 'Job main entry';


--
-- Name: COLUMN pga_job.jobagentid; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pgagent.pga_job.jobagentid IS 'Agent that currently executes this job.';


--
-- Name: pga_job_jobid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pgagent.pga_job_jobid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pgagent.pga_job_jobid_seq OWNER TO postgres;

--
-- Name: pga_job_jobid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pgagent.pga_job_jobid_seq OWNED BY pgagent.pga_job.jobid;


--
-- Name: pga_jobagent; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pgagent.pga_jobagent (
    jagpid integer NOT NULL,
    jaglogintime timestamp with time zone DEFAULT now() NOT NULL,
    jagstation text NOT NULL
);


ALTER TABLE pgagent.pga_jobagent OWNER TO postgres;

--
-- Name: TABLE pga_jobagent; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pgagent.pga_jobagent IS 'Active job agents';


--
-- Name: pga_jobclass; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pgagent.pga_jobclass (
    jclid integer NOT NULL,
    jclname text NOT NULL
);


ALTER TABLE pgagent.pga_jobclass OWNER TO postgres;

--
-- Name: TABLE pga_jobclass; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pgagent.pga_jobclass IS 'Job classification';


--
-- Name: pga_jobclass_jclid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pgagent.pga_jobclass_jclid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pgagent.pga_jobclass_jclid_seq OWNER TO postgres;

--
-- Name: pga_jobclass_jclid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pgagent.pga_jobclass_jclid_seq OWNED BY pgagent.pga_jobclass.jclid;


--
-- Name: pga_joblog; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pgagent.pga_joblog (
    jlgid integer NOT NULL,
    jlgjobid integer NOT NULL,
    jlgstatus character(1) DEFAULT 'r'::bpchar NOT NULL,
    jlgstart timestamp with time zone DEFAULT now() NOT NULL,
    jlgduration interval,
    CONSTRAINT pga_joblog_jlgstatus_check CHECK ((jlgstatus = ANY (ARRAY['r'::bpchar, 's'::bpchar, 'f'::bpchar, 'i'::bpchar, 'd'::bpchar])))
);


ALTER TABLE pgagent.pga_joblog OWNER TO postgres;

--
-- Name: TABLE pga_joblog; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pgagent.pga_joblog IS 'Job run logs.';


--
-- Name: COLUMN pga_joblog.jlgstatus; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pgagent.pga_joblog.jlgstatus IS 'Status of job: r=running, s=successfully finished, f=failed, i=no steps to execute, d=aborted';


--
-- Name: pga_joblog_jlgid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pgagent.pga_joblog_jlgid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pgagent.pga_joblog_jlgid_seq OWNER TO postgres;

--
-- Name: pga_joblog_jlgid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pgagent.pga_joblog_jlgid_seq OWNED BY pgagent.pga_joblog.jlgid;


--
-- Name: pga_jobstep; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pgagent.pga_jobstep (
    jstid integer NOT NULL,
    jstjobid integer NOT NULL,
    jstname text NOT NULL,
    jstdesc text DEFAULT ''::text NOT NULL,
    jstenabled boolean DEFAULT true NOT NULL,
    jstkind character(1) NOT NULL,
    jstcode text NOT NULL,
    jstdbname name DEFAULT ''::name NOT NULL,
    jstonerror character(1) DEFAULT 'f'::bpchar NOT NULL,
    jscnextrun timestamp with time zone,
    CONSTRAINT pga_jobstep_check CHECK ((((jstdbname <> ''::name) AND (jstkind = 's'::bpchar)) OR ((jstdbname = ''::name) AND (jstkind = 'b'::bpchar)))),
    CONSTRAINT pga_jobstep_jstkind_check CHECK ((jstkind = ANY (ARRAY['b'::bpchar, 's'::bpchar]))),
    CONSTRAINT pga_jobstep_jstonerror_check CHECK ((jstonerror = ANY (ARRAY['f'::bpchar, 's'::bpchar, 'i'::bpchar])))
);


ALTER TABLE pgagent.pga_jobstep OWNER TO postgres;

--
-- Name: TABLE pga_jobstep; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pgagent.pga_jobstep IS 'Job step to be executed';


--
-- Name: COLUMN pga_jobstep.jstkind; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pgagent.pga_jobstep.jstkind IS 'Kind of jobstep: s=sql, b=batch';


--
-- Name: COLUMN pga_jobstep.jstonerror; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pgagent.pga_jobstep.jstonerror IS 'What to do if step returns an error: f=fail the job, s=mark step as succeeded and continue, i=mark as fail but ignore it and proceed';


--
-- Name: pga_jobstep_jstid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pgagent.pga_jobstep_jstid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pgagent.pga_jobstep_jstid_seq OWNER TO postgres;

--
-- Name: pga_jobstep_jstid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pgagent.pga_jobstep_jstid_seq OWNED BY pgagent.pga_jobstep.jstid;


--
-- Name: pga_jobsteplog; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pgagent.pga_jobsteplog (
    jslid integer NOT NULL,
    jsljlgid integer NOT NULL,
    jsljstid integer NOT NULL,
    jslstatus character(1) DEFAULT 'r'::bpchar NOT NULL,
    jslresult integer,
    jslstart timestamp with time zone DEFAULT now() NOT NULL,
    jslduration interval,
    jsloutput text,
    CONSTRAINT pga_jobsteplog_jslstatus_check CHECK ((jslstatus = ANY (ARRAY['r'::bpchar, 's'::bpchar, 'i'::bpchar, 'f'::bpchar, 'd'::bpchar])))
);


ALTER TABLE pgagent.pga_jobsteplog OWNER TO postgres;

--
-- Name: TABLE pga_jobsteplog; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pgagent.pga_jobsteplog IS 'Job step run logs.';


--
-- Name: COLUMN pga_jobsteplog.jslstatus; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pgagent.pga_jobsteplog.jslstatus IS 'Status of job step: r=running, s=successfully finished,  f=failed stopping job, i=ignored failure, d=aborted';


--
-- Name: COLUMN pga_jobsteplog.jslresult; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON COLUMN pgagent.pga_jobsteplog.jslresult IS 'Return code of job step';


--
-- Name: pga_jobsteplog_jslid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pgagent.pga_jobsteplog_jslid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pgagent.pga_jobsteplog_jslid_seq OWNER TO postgres;

--
-- Name: pga_jobsteplog_jslid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pgagent.pga_jobsteplog_jslid_seq OWNED BY pgagent.pga_jobsteplog.jslid;


--
-- Name: pga_schedule; Type: TABLE; Schema: pgagent; Owner: postgres
--

CREATE TABLE pgagent.pga_schedule (
    jscid integer NOT NULL,
    jscjobid integer NOT NULL,
    jscname text NOT NULL,
    jscdesc text DEFAULT ''::text NOT NULL,
    jscenabled boolean DEFAULT true NOT NULL,
    jscstart timestamp with time zone DEFAULT now() NOT NULL,
    jscend timestamp with time zone,
    jscminutes boolean[] DEFAULT '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}'::boolean[] NOT NULL,
    jschours boolean[] DEFAULT '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}'::boolean[] NOT NULL,
    jscweekdays boolean[] DEFAULT '{f,f,f,f,f,f,f}'::boolean[] NOT NULL,
    jscmonthdays boolean[] DEFAULT '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}'::boolean[] NOT NULL,
    jscmonths boolean[] DEFAULT '{f,f,f,f,f,f,f,f,f,f,f,f}'::boolean[] NOT NULL,
    CONSTRAINT pga_schedule_jschours_size CHECK ((array_upper(jschours, 1) = 24)),
    CONSTRAINT pga_schedule_jscminutes_size CHECK ((array_upper(jscminutes, 1) = 60)),
    CONSTRAINT pga_schedule_jscmonthdays_size CHECK ((array_upper(jscmonthdays, 1) = 32)),
    CONSTRAINT pga_schedule_jscmonths_size CHECK ((array_upper(jscmonths, 1) = 12)),
    CONSTRAINT pga_schedule_jscweekdays_size CHECK ((array_upper(jscweekdays, 1) = 7))
);


ALTER TABLE pgagent.pga_schedule OWNER TO postgres;

--
-- Name: TABLE pga_schedule; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TABLE pgagent.pga_schedule IS 'Job schedule exceptions';


--
-- Name: pga_schedule_jscid_seq; Type: SEQUENCE; Schema: pgagent; Owner: postgres
--

CREATE SEQUENCE pgagent.pga_schedule_jscid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE pgagent.pga_schedule_jscid_seq OWNER TO postgres;

--
-- Name: pga_schedule_jscid_seq; Type: SEQUENCE OWNED BY; Schema: pgagent; Owner: postgres
--

ALTER SEQUENCE pgagent.pga_schedule_jscid_seq OWNED BY pgagent.pga_schedule.jscid;


--
-- Name: actual_transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.actual_transaction (
    "time" date,
    amount real,
    client_id character varying,
    type integer,
    id integer NOT NULL,
    balance real
);


ALTER TABLE public.actual_transaction OWNER TO postgres;

--
-- Name: actual_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.actual_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.actual_transaction_id_seq OWNER TO postgres;

--
-- Name: actual_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.actual_transaction_id_seq OWNED BY public.actual_transaction.id;


--
-- Name: admin_alert; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.admin_alert (
    id integer NOT NULL,
    type integer NOT NULL,
    subject character varying(100),
    content text,
    is_view integer DEFAULT 0 NOT NULL,
    create_time timestamp with time zone,
    view_time timestamp with time zone,
    view_by character varying(100)
);


ALTER TABLE public.admin_alert OWNER TO postgres;

--
-- Name: COLUMN admin_alert.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admin_alert.type IS '1 => ''Carrier Daily Usage Limit Exceeded'',
2 => ''Carrier hourly Usage Limit Exceeded'',
3 => ''Invalid Login Alert'',
';


--
-- Name: COLUMN admin_alert.is_view; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admin_alert.is_view IS 'å¦‚æžœ 1è¡¨ç¤ºå·²ç»æŸ¥çœ‹è¿‡';


--
-- Name: COLUMN admin_alert.view_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admin_alert.view_time IS 'æŸ¥çœ‹æ—¶é—´';


--
-- Name: admin_alert_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.admin_alert_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.admin_alert_id_seq OWNER TO postgres;

--
-- Name: admin_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.admin_alert_id_seq OWNED BY public.admin_alert.id;


--
-- Name: agent; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.agent (
    agent_id integer NOT NULL,
    agent_name character varying(100),
    create_on timestamp with time zone,
    email character varying(200),
    commission numeric(5,2),
    method_type integer,
    frequency_type integer,
    status boolean,
    user_id integer,
    agent_role_id integer,
    update_on timestamp with time zone,
    update_by character varying(100),
    edit_permission boolean DEFAULT true
);


ALTER TABLE public.agent OWNER TO postgres;

--
-- Name: COLUMN agent.method_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.agent.method_type IS '0:By Profit; 1:By  Revenue';


--
-- Name: COLUMN agent.frequency_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.agent.frequency_type IS '0:daily;1:weekly;2:monthly';


--
-- Name: agent_agent_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.agent_agent_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.agent_agent_id_seq OWNER TO postgres;

--
-- Name: agent_agent_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.agent_agent_id_seq OWNED BY public.agent.agent_id;


--
-- Name: agent_client; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.agent_client (
    id integer NOT NULL,
    agent_id integer,
    client_id integer,
    commission numeric(5,2),
    update_on timestamp with time zone,
    update_by character varying(100)
);


ALTER TABLE public.agent_client OWNER TO postgres;

--
-- Name: agent_client_client; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.agent_client_client (
    id integer NOT NULL,
    agent_client_id integer NOT NULL,
    client_id integer NOT NULL,
    commission integer
);


ALTER TABLE public.agent_client_client OWNER TO postgres;

--
-- Name: agent_client_client_id_seq1; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.agent_client_client_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.agent_client_client_id_seq1 OWNER TO postgres;

--
-- Name: agent_client_client_id_seq1; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.agent_client_client_id_seq1 OWNED BY public.agent_client_client.id;


--
-- Name: agent_client_client_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.agent_client_client_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.agent_client_client_record_record_id_seq OWNER TO postgres;

--
-- Name: agent_client_client_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.agent_client_client_record (
    id integer,
    agent_client_id integer,
    client_id integer,
    commission integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.agent_client_client_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.agent_client_client_record OWNER TO postgres;

--
-- Name: agent_client_client_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.agent_client_client_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.agent_client_client_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: agent_client_client_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.agent_client_client_record_tmp (
    id integer,
    agent_client_id integer,
    client_id integer,
    commission integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.agent_client_client_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.agent_client_client_record_tmp OWNER TO postgres;

--
-- Name: agent_client_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.agent_client_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.agent_client_id_seq OWNER TO postgres;

--
-- Name: agent_client_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.agent_client_id_seq OWNED BY public.agent_client.id;


--
-- Name: agent_clients; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.agent_clients (
    id integer NOT NULL,
    agent_id integer,
    client_id integer,
    commission numeric(5,2),
    update_on timestamp with time zone,
    update_by character varying(100),
    method_type integer DEFAULT 0
);


ALTER TABLE public.agent_clients OWNER TO postgres;

--
-- Name: agent_clients_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.agent_clients_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.agent_clients_id_seq OWNER TO postgres;

--
-- Name: agent_clients_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.agent_clients_id_seq OWNED BY public.agent_clients.id;


--
-- Name: agent_commission_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.agent_commission_history (
    history_id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    total_date integer,
    amount numeric(7,2),
    agent_id integer,
    create_date date,
    finished boolean DEFAULT false
);


ALTER TABLE public.agent_commission_history OWNER TO postgres;

--
-- Name: agent_commission_history_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.agent_commission_history_detail (
    id integer NOT NULL,
    history_id integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    total_date integer,
    commission numeric(5,2),
    client_id integer,
    client_cost numeric(7,2)
);


ALTER TABLE public.agent_commission_history_detail OWNER TO postgres;

--
-- Name: agent_commission_history_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.agent_commission_history_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.agent_commission_history_detail_id_seq OWNER TO postgres;

--
-- Name: agent_commission_history_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.agent_commission_history_detail_id_seq OWNED BY public.agent_commission_history_detail.id;


--
-- Name: agent_commission_history_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.agent_commission_history_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.agent_commission_history_history_id_seq OWNER TO postgres;

--
-- Name: agent_commission_history_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.agent_commission_history_history_id_seq OWNED BY public.agent_commission_history.history_id;


--
-- Name: agent_commission_payment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.agent_commission_payment (
    id integer NOT NULL,
    history_id integer,
    create_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    create_by character varying(100),
    amount numeric(7,2),
    note text
);


ALTER TABLE public.agent_commission_payment OWNER TO postgres;

--
-- Name: agent_commission_payment_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.agent_commission_payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.agent_commission_payment_id_seq OWNER TO postgres;

--
-- Name: agent_commission_payment_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.agent_commission_payment_id_seq OWNED BY public.agent_commission_payment.id;


--
-- Name: alert_action; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alert_action (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    email_to_noc boolean DEFAULT true NOT NULL,
    email_to_carrier boolean DEFAULT false NOT NULL,
    disable_host boolean DEFAULT false NOT NULL,
    disable_resource boolean DEFAULT false NOT NULL,
    disable_duration integer DEFAULT 0 NOT NULL,
    host_priority integer DEFAULT 0 NOT NULL,
    res_priority integer DEFAULT 0 NOT NULL,
    pri_chg_duration integer DEFAULT 0 NOT NULL,
    disable_code_trunk boolean DEFAULT false NOT NULL,
    code_trunk_disable_duration integer DEFAULT 0 NOT NULL,
    noc_email_subject character varying(1000),
    noc_email_content character varying(1000),
    carrier_email_subject character varying(1000),
    carrier_email_content character varying(1000),
    noc_attach_type integer DEFAULT 0 NOT NULL,
    carrier_attach_type integer DEFAULT 0 NOT NULL,
    backup_type integer DEFAULT 0 NOT NULL,
    email_notification integer,
    update_by character varying,
    update_at timestamp with time zone,
    disable_route_target smallint DEFAULT 0,
    change_prioprity smallint DEFAULT 0,
    change_to_priority integer DEFAULT 0,
    block_ani boolean DEFAULT false,
    trouble_tickets_template integer,
    exclude_ani character varying(255),
    loop_detection boolean DEFAULT false
);


ALTER TABLE public.alert_action OWNER TO postgres;

--
-- Name: COLUMN alert_action.disable_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.disable_duration IS 'å¤šå°‘åˆ†é’ŸåŽé‡æ–°å¯åŠ¨host/resource
ç­‰äºŽ0è¡¨ç¤ºä¸å†å¯åŠ¨';


--
-- Name: COLUMN alert_action.pri_chg_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.pri_chg_duration IS 'å¤šå°‘åˆ†é’ŸåŽæŠŠpriorityæ”¹å›žåŽ»
ç­‰äºŽ0è¡¨ç¤ºä¸å†æ”¹å›žåŽ»';


--
-- Name: COLUMN alert_action.code_trunk_disable_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.code_trunk_disable_duration IS 'åœæ­¢å¤šå°‘åˆ†é’Ÿ';


--
-- Name: COLUMN alert_action.noc_email_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.noc_email_subject IS 'delete';


--
-- Name: COLUMN alert_action.noc_email_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.noc_email_content IS 'delete';


--
-- Name: COLUMN alert_action.carrier_email_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.carrier_email_subject IS 'delete';


--
-- Name: COLUMN alert_action.carrier_email_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.carrier_email_content IS 'delete';


--
-- Name: COLUMN alert_action.noc_attach_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.noc_attach_type IS '0--none
1--pdf
2--xls
3--html
delete';


--
-- Name: COLUMN alert_action.carrier_attach_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.carrier_attach_type IS '0--none
1--pdf
2--xls
3--html
delete';


--
-- Name: COLUMN alert_action.backup_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.backup_type IS '0--none
1--pdf
2--xls
3--html
delete';


--
-- Name: COLUMN alert_action.email_notification; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.email_notification IS '0-None,
1-System''s NOC,
2- Partner''s NOC,
3-Both NOC';


--
-- Name: COLUMN alert_action.disable_route_target; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.disable_route_target IS '0 -- none
1 -- Entire Trunk
2 -- Entire Host';


--
-- Name: COLUMN alert_action.change_prioprity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_action.change_prioprity IS '0  None
1 Trunk
2 Host';


--
-- Name: alert_action_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alert_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alert_action_id_seq OWNER TO postgres;

--
-- Name: alert_action_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alert_action_id_seq OWNED BY public.alert_action.id;


--
-- Name: alert_action_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alert_action_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alert_action_log_id_seq OWNER TO postgres;

--
-- Name: alert_condition; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alert_condition (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    for_all integer DEFAULT 0 NOT NULL,
    acd_comparator integer DEFAULT 0 NOT NULL,
    acd_value_min real DEFAULT 0,
    acd_value_max real DEFAULT 0,
    asr_comparator integer DEFAULT 0 NOT NULL,
    asr_value_min real DEFAULT 0,
    asr_value_max real DEFAULT 0,
    margin_comparator integer DEFAULT 0 NOT NULL,
    margin_value_min real DEFAULT 0,
    margin_value_max real DEFAULT 0,
    acd_ignore integer DEFAULT 0,
    asr_ignore integer DEFAULT 0,
    margin_ignore integer DEFAULT 0,
    update_by character varying,
    update_at timestamp with time zone,
    abr_comparator integer DEFAULT 0,
    abr_value_min real DEFAULT 0,
    abr_value_max real DEFAULT 0,
    special_ani_comparator integer DEFAULT 0 NOT NULL,
    special_ani_value real DEFAULT 0,
    special_cost_comparator integer DEFAULT 0 NOT NULL,
    special_cost_value real DEFAULT 0
);


ALTER TABLE public.alert_condition OWNER TO postgres;

--
-- Name: COLUMN alert_condition.for_all; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_condition.for_all IS '0--or
1--and';


--
-- Name: COLUMN alert_condition.acd_comparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_condition.acd_comparator IS '0--target<XX,target<=XX
1--target>XX,target>=XX,YY>target>XX,
YY>target>=XX,YY>=target>XX,YY>=target>=XX
';


--
-- Name: COLUMN alert_condition.asr_comparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_condition.asr_comparator IS '0--target<XX,target<=XX
1--target>XX,target>=XX,YY>target>XX,
YY>target>=XX,YY>=target>XX,YY>=target>=XX';


--
-- Name: COLUMN alert_condition.margin_comparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_condition.margin_comparator IS '0--target<XX,target<=XX
1--target>XX,target>=XX,YY>target>XX,
YY>target>=XX,YY>=target>XX,YY>=target>=XX';


--
-- Name: COLUMN alert_condition.abr_comparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_condition.abr_comparator IS '0--target<XX,target<=XX
1--target>XX,target>=XX,YY>target>XX,
YY>target>=XX,YY>=target>XX,YY>=target>=XX';


--
-- Name: COLUMN alert_condition.special_ani_comparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_condition.special_ani_comparator IS '0--great than xx
1--less than xx,
2-ignore';


--
-- Name: alert_condition_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alert_condition_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alert_condition_id_seq OWNER TO postgres;

--
-- Name: alert_condition_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alert_condition_id_seq OWNED BY public.alert_condition.id;


--
-- Name: alert_event; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alert_event (
    id integer NOT NULL,
    event_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    event_type integer DEFAULT 8 NOT NULL,
    res_id integer,
    host_id integer,
    product_prefix_id integer,
    old_priority integer,
    new_priority integer,
    email_addr character varying(1000),
    alert_exec_id integer,
    mail_sended boolean DEFAULT false,
    alert_rule_id integer,
    alert_action_id integer,
    mail_subject text,
    mail_content text,
    disable_duration integer,
    is_enable boolean DEFAULT false,
    disable_code public.prefix_range DEFAULT ''::public.prefix_range
);


ALTER TABLE public.alert_event OWNER TO postgres;

--
-- Name: COLUMN alert_event.event_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_event.event_type IS '1--disable trunk
2--disable host
3--enable trunk
4--enable host
5--disable code trunk
6--enable code trunk
7--change priority
8--email
9--change to old priority';


--
-- Name: alert_event_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alert_event_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alert_event_id_seq OWNER TO postgres;

--
-- Name: alert_event_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alert_event_id_seq OWNED BY public.alert_event.id;


--
-- Name: alert_exec_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alert_exec_log (
    id integer DEFAULT nextval('public.alert_action_log_id_seq'::regclass) NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone
);


ALTER TABLE public.alert_exec_log OWNER TO postgres;

--
-- Name: TABLE alert_exec_log; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.alert_exec_log IS 'alertå‘é€é‚®ç®±çš„log';


--
-- Name: alert_mail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alert_mail (
    id integer NOT NULL,
    user_alert_id integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    send_time timestamp with time zone,
    mailed integer DEFAULT 0,
    send_body character varying(1000)
);


ALTER TABLE public.alert_mail OWNER TO postgres;

--
-- Name: alert_mail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alert_mail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alert_mail_id_seq OWNER TO postgres;

--
-- Name: alert_mail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alert_mail_id_seq OWNED BY public.alert_mail.id;


--
-- Name: alert_rule; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alert_rule (
    id integer NOT NULL,
    name character varying(100),
    res_id integer NOT NULL,
    host_id integer DEFAULT 0 NOT NULL,
    ani character varying(100) DEFAULT ''::character varying NOT NULL,
    dnis character varying(100) DEFAULT ''::character varying NOT NULL,
    alert_condition_id integer NOT NULL,
    alert_action_id integer NOT NULL,
    freq_type integer NOT NULL,
    last_runtime timestamp with time zone,
    next_runtime timestamp with time zone,
    sample_size integer,
    switch_ip public.ip4r,
    weekday_time character varying(100),
    status smallint DEFAULT 1,
    freq_value integer,
    update_by character varying,
    update_at timestamp with time zone,
    ingress_trunk_prefix integer,
    source_code_name character varying,
    destination_code_name character varying,
    monitor_type integer,
    min_call_time integer DEFAULT 0,
    apply_type integer,
    mail_duration integer,
    is_origin integer DEFAULT 0
);


ALTER TABLE public.alert_rule OWNER TO postgres;

--
-- Name: TABLE alert_rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.alert_rule IS 'alert rule è§„åˆ™';


--
-- Name: COLUMN alert_rule.host_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rule.host_id IS '0--è¡¨ç¤ºæ‰€æœ‰';


--
-- Name: COLUMN alert_rule.freq_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rule.freq_type IS '1--every xx minutes
2--every æ˜ŸæœŸå‡
0 - Never
';


--
-- Name: COLUMN alert_rule.sample_size; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rule.sample_size IS 'ç»Ÿè®¡å¤šå°‘åˆ†é’Ÿçš„æ•°æ®';


--
-- Name: COLUMN alert_rule.apply_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rule.apply_type IS '0 - Apply To All ä»£è¡¨æ‰€æœ‰

1 - Apply Specific Ani æŒ‡å®šå¤šä¸ªä¸»å« æ˜¯æ£€æµ‹æŒ‡å®šçš„ä¸»å«

2 - Exclude Specific Ani é™¤äº†æŒ‡å®šçš„å‡ ä¸ªä¸»å« æ‰€æœ‰éƒ½æ‹’ç»
';


--
-- Name: alert_rule_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alert_rule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alert_rule_id_seq OWNER TO postgres;

--
-- Name: alert_rule_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alert_rule_id_seq OWNED BY public.alert_rule.id;


--
-- Name: alert_rules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alert_rules (
    id integer NOT NULL,
    rule_name character varying(100),
    trunk_type smallint DEFAULT 1 NOT NULL,
    all_trunk boolean DEFAULT false NOT NULL,
    include smallint DEFAULT 0 NOT NULL,
    in_codes character varying(500),
    in_code_deck integer,
    in_code_name_id character varying(100),
    exclude smallint,
    ex_code_deck integer,
    ex_code_name_id character varying(100),
    acd character(1),
    acd_value real,
    asr character(1),
    asr_value real,
    abr character(1),
    abr_value real,
    pdd character(1),
    pdd_value double precision,
    profitability character(1),
    profitability_value real,
    revenue character(1),
    revenue_value real,
    min_call_attempt integer,
    step3_type smallint DEFAULT 2 NOT NULL,
    disable_scope smallint,
    trouble_ticket_sent_to smallint,
    trouble_ticket_sent_from integer,
    trouble_ticket_subject character varying(100),
    trouble_ticket_content text,
    auto_enable_type smallint,
    auto_enable integer,
    execution_schedule smallint,
    specific_minutes integer,
    daily_time smallint,
    weekly_time smallint,
    weekly_value smallint,
    sample_size integer,
    ex_codes character varying(500),
    update_by character varying(100),
    update_at timestamp with time zone,
    last_run_time timestamp with time zone,
    active boolean DEFAULT true,
    is_block boolean DEFAULT true,
    is_email boolean DEFAULT true,
    status boolean DEFAULT false,
    monitor_by integer DEFAULT 0,
    res_id text,
    next_run_time timestamp with time zone,
    unblock_after_min integer,
    auto_define boolean DEFAULT false,
    sdp_type integer DEFAULT 0,
    sdp_sign integer DEFAULT 0,
    sdp_value integer DEFAULT 0
);


ALTER TABLE public.alert_rules OWNER TO postgres;

--
-- Name: COLUMN alert_rules.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.id IS 'id ä¸»é”®';


--
-- Name: COLUMN alert_rules.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.trunk_type IS '1:ingress
2:egress';


--
-- Name: COLUMN alert_rules.all_trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.all_trunk IS '1ä¸ºå…¨éƒ¨';


--
-- Name: COLUMN alert_rules.include; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.include IS '0:all code
1:Specific Codes
2:Specific Code Names';


--
-- Name: COLUMN alert_rules.in_codes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.in_codes IS 'ä»¥é€—å·éš”å¼€çš„code';


--
-- Name: COLUMN alert_rules.in_code_deck; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.in_code_deck IS 'code deck id';


--
-- Name: COLUMN alert_rules.in_code_name_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.in_code_name_id IS 'ä»¥é€—å·éš”å¼€çš„code name id';


--
-- Name: COLUMN alert_rules.exclude; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.exclude IS '0:ä¸é€‰æ‹©
1ï¼šSpecific Codes
2ï¼šSpecific Code Names';


--
-- Name: COLUMN alert_rules.ex_code_deck; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.ex_code_deck IS 'ä¸åŒ…æ‹¬ çš„ code deck id';


--
-- Name: COLUMN alert_rules.ex_code_name_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.ex_code_name_id IS 'ä¸åŒ…æ‹¬çš„ code name id';


--
-- Name: COLUMN alert_rules.acd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.acd IS '''1'':ignore
''>'':å¤§äºŽ
''<'':å°äºŽ
''='':ç­‰äºŽ';


--
-- Name: COLUMN alert_rules.acd_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.acd_value IS 'acd çš„å€¼';


--
-- Name: COLUMN alert_rules.asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.asr IS '''1'':ignore
''>'':å¤§äºŽ
''<'':å°äºŽ
''='':ç­‰äºŽ';


--
-- Name: COLUMN alert_rules.asr_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.asr_value IS 'asr çš„å€¼';


--
-- Name: COLUMN alert_rules.abr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.abr IS '''1'':ignore
''>'':å¤§äºŽ
''<'':å°äºŽ
''='':ç­‰äºŽ';


--
-- Name: COLUMN alert_rules.abr_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.abr_value IS 'abr çš„å€¼';


--
-- Name: COLUMN alert_rules.pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.pdd IS '''1'':ignore
''>'':å¤§äºŽ
''<'':å°äºŽ
''='':ç­‰äºŽ';


--
-- Name: COLUMN alert_rules.pdd_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.pdd_value IS 'pdd çš„å€¼';


--
-- Name: COLUMN alert_rules.profitability; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.profitability IS '''1'':ignore
''>'':å¤§äºŽ
''<'':å°äºŽ
''='':ç­‰äºŽ';


--
-- Name: COLUMN alert_rules.profitability_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.profitability_value IS 'profitability çš„å€¼';


--
-- Name: COLUMN alert_rules.step3_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.step3_type IS '1:Send Trouble Ticket Email
2:Disable Trunks';


--
-- Name: COLUMN alert_rules.disable_scope; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.disable_scope IS '1:Disable Entire Trunk
2:Disable Specific Code
3:Disable Specific Code Name

step3 é‡Œçš„Disable Scope';


--
-- Name: COLUMN alert_rules.trouble_ticket_sent_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.trouble_ticket_sent_to IS '1:Your Own NOC Email
2:Partnerâ€™s NOC Email
3:Both';


--
-- Name: COLUMN alert_rules.trouble_ticket_sent_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.trouble_ticket_sent_from IS 'mail sender id';


--
-- Name: COLUMN alert_rules.trouble_ticket_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.trouble_ticket_content IS 'å†…å®¹';


--
-- Name: COLUMN alert_rules.auto_enable_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.auto_enable_type IS '1:Never
2:After';


--
-- Name: COLUMN alert_rules.auto_enable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.auto_enable IS 'auto_enable çš„å€¼';


--
-- Name: COLUMN alert_rules.execution_schedule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.execution_schedule IS '0:never
1:Every Specific Minutes
2:Daily
3:Weekly';


--
-- Name: COLUMN alert_rules.specific_minutes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.specific_minutes IS 'å½“Execution Schedule é€‰æ‹©Every Specific Minutesæ—¶çš„å€¼';


--
-- Name: COLUMN alert_rules.daily_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.daily_time IS '0-23 å°æ—¶å€¼';


--
-- Name: COLUMN alert_rules.weekly_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.weekly_time IS '0-23å°æ—¶å€¼';


--
-- Name: COLUMN alert_rules.weekly_value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.weekly_value IS '0-6
0ä¸ºæ˜ŸæœŸå¤©';


--
-- Name: COLUMN alert_rules.is_block; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.is_block IS 'æ˜¯å¦block';


--
-- Name: COLUMN alert_rules.is_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.alert_rules.is_email IS 'æ˜¯å¦å‘é‚®ä»¶';


--
-- Name: alert_rules_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alert_rules_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alert_rules_id_seq OWNER TO postgres;

--
-- Name: alert_rules_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alert_rules_id_seq OWNED BY public.alert_rules.id;


--
-- Name: alert_rules_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alert_rules_log (
    id integer NOT NULL,
    alert_rules_id integer,
    create_on timestamp with time zone,
    status integer,
    finish_time timestamp with time zone,
    limit_acd_value real,
    limit_asr_value real,
    limit_abr_value real,
    limit_pdd_value double precision,
    limit_profitability_value real,
    limit_revenue_value real,
    limit_asr character(1),
    limit_abr character(1),
    limit_acd character(1),
    limit_pdd character(1),
    limit_profitability character(1),
    limit_revenue character(1),
    "time" numeric DEFAULT date_part('epoch'::text, ('now'::text)::timestamp(0) with time zone),
    call_attempt numeric NOT NULL,
    sdp_sign integer DEFAULT 0,
    sdp_type integer DEFAULT 0,
    sdp_value integer DEFAULT 0
);


ALTER TABLE public.alert_rules_log OWNER TO postgres;

--
-- Name: alert_rules_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.alert_rules_log_detail (
    id integer NOT NULL,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    alert_rules_log_id integer,
    resource_id integer,
    code character varying(50),
    asr real,
    abr real,
    acd real,
    pdd real,
    profitability real,
    revenue real,
    system_email_address character varying(100),
    system_email_status boolean,
    partner_email_address character varying(100),
    partner_email_status boolean,
    is_email boolean,
    is_block boolean,
    resource_block_id integer,
    email_type integer,
    valid_to numeric,
    exclude integer,
    include integer,
    trunk_type integer,
    monitor_by integer,
    prefix text,
    "time" numeric DEFAULT date_part('epoch'::text, ('now'::text)::timestamp(0) with time zone),
    country character varying(100),
    code_name character varying(100),
    origination_source_number character varying(100),
    routing_digits character varying(100),
    sdp_value integer DEFAULT 0
);


ALTER TABLE public.alert_rules_log_detail OWNER TO postgres;

--
-- Name: alert_rules_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alert_rules_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alert_rules_log_detail_id_seq OWNER TO postgres;

--
-- Name: alert_rules_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alert_rules_log_detail_id_seq OWNED BY public.alert_rules_log_detail.id;


--
-- Name: alert_rules_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.alert_rules_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alert_rules_log_id_seq OWNER TO postgres;

--
-- Name: alert_rules_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.alert_rules_log_id_seq OWNED BY public.alert_rules_log.id;


--
-- Name: allowed_sendto_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.allowed_sendto_ip (
    id integer NOT NULL,
    resource_id integer,
    direction integer,
    sip_profile_ip public.ip4r,
    sip_profile_port integer
);


ALTER TABLE public.allowed_sendto_ip OWNER TO postgres;

--
-- Name: allowed_sendto_ip_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.allowed_sendto_ip_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.allowed_sendto_ip_id_seq OWNER TO postgres;

--
-- Name: allowed_sendto_ip_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.allowed_sendto_ip_id_seq OWNED BY public.allowed_sendto_ip.id;


--
-- Name: allowed_sendto_ip_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.allowed_sendto_ip_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.allowed_sendto_ip_record_record_id_seq OWNER TO postgres;

--
-- Name: allowed_sendto_ip_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.allowed_sendto_ip_record (
    id integer,
    resource_id integer,
    direction integer,
    sip_profile_ip public.ip4r,
    sip_profile_port integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.allowed_sendto_ip_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.allowed_sendto_ip_record OWNER TO postgres;

--
-- Name: dynamic_route_dynamic_route_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_dynamic_route_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_dynamic_route_id_seq OWNER TO postgres;

--
-- Name: dynamic_route; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route (
    dynamic_route_id integer DEFAULT nextval('public.dynamic_route_dynamic_route_id_seq'::regclass) NOT NULL,
    name character varying(100) NOT NULL,
    routing_rule integer DEFAULT 6 NOT NULL,
    time_profile_id integer,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    lcr_flag integer DEFAULT 1,
    is_virtual boolean
);


ALTER TABLE public.dynamic_route OWNER TO postgres;

--
-- Name: TABLE dynamic_route; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.dynamic_route IS 'åŠ¨æ€è·¯ç”±';


--
-- Name: COLUMN dynamic_route.routing_rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dynamic_route.routing_rule IS 'è·¯ç”±è§„åˆ™ï¼š4 â€“ æŒ‰æœ€å¤§ASRï¼›5 â€“ æŒ‰æœ€å¤§ACDï¼›6 â€“ æŒ‰æœ€ä½Žè´¹ç”¨';


--
-- Name: COLUMN dynamic_route.lcr_flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dynamic_route.lcr_flag IS '1-15åˆ†é’Ÿ
2-30åˆ†é’Ÿ
3-1å°æ—¶
4-1å¤©';


--
-- Name: dynamic_route_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_items (
    id integer NOT NULL,
    dynamic_route_id integer NOT NULL,
    resource_id integer NOT NULL
);


ALTER TABLE public.dynamic_route_items OWNER TO postgres;

--
-- Name: product_product_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_product_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE public.product_product_id_seq OWNER TO postgres;

--
-- Name: product; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product (
    product_id integer DEFAULT nextval('public.product_product_id_seq'::regclass) NOT NULL,
    name character varying(100),
    modify_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    introduction character varying(80),
    dynamic_route_id integer,
    update_by character varying,
    code_type integer DEFAULT 0,
    code_deck_id integer,
    route_lrn integer
);


ALTER TABLE public.product OWNER TO postgres;

--
-- Name: TABLE product; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.product IS 'é™æ€è·¯ç”±è¡¨';


--
-- Name: COLUMN product.product_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product.product_id IS 'ä¸»é”®';


--
-- Name: COLUMN product.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product.name IS 'åç§°';


--
-- Name: COLUMN product.modify_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product.modify_time IS 'ä¿®æ”¹æ—¶é—´';


--
-- Name: COLUMN product.introduction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product.introduction IS 'è¯´æ˜Ž';


--
-- Name: COLUMN product.dynamic_route_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product.dynamic_route_id IS 'åŠ¨æ€è·¯ç”±è½¬æ¢ç”Ÿæˆ';


--
-- Name: COLUMN product.route_lrn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product.route_lrn IS '0-dnis
1-lrn';


--
-- Name: product_items_item_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_items_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_items_item_id_seq OWNER TO postgres;

--
-- Name: product_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_items (
    item_id integer DEFAULT nextval('public.product_items_item_id_seq'::regclass) NOT NULL,
    product_id integer,
    alias character varying(100),
    digits public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    strategy integer DEFAULT 1 NOT NULL,
    time_profile_id integer,
    min_len integer DEFAULT 0,
    max_len integer DEFAULT 32,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    code_name character(100)
);


ALTER TABLE public.product_items OWNER TO postgres;

--
-- Name: TABLE product_items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.product_items IS 'é™æ€è·¯ç”±';


--
-- Name: COLUMN product_items.strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product_items.strategy IS '0-;By Percentage
1-Top-Down
2-Round-Robin';


--
-- Name: product_items_resource; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_items_resource (
    id integer NOT NULL,
    item_id integer NOT NULL,
    resource_id integer NOT NULL,
    by_percentage integer,
    order_id integer,
    order_type integer
);


ALTER TABLE public.product_items_resource OWNER TO postgres;

--
-- Name: COLUMN product_items_resource.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product_items_resource.order_type IS '1-buy order
2-sell order';


--
-- Name: resource_resource_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_resource_id_seq OWNER TO postgres;

--
-- Name: resource; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource (
    resource_id integer DEFAULT nextval('public.resource_resource_id_seq'::regclass) NOT NULL,
    name character varying(100),
    ingress boolean,
    egress boolean,
    active boolean DEFAULT true NOT NULL,
    rfc_2833 boolean DEFAULT false NOT NULL,
    t38 boolean DEFAULT false NOT NULL,
    alias character varying(100) DEFAULT NULL::character varying NOT NULL,
    res_strategy smallint,
    cps_limit integer,
    capacity integer,
    lnp boolean DEFAULT false NOT NULL,
    lrn_block boolean DEFAULT false NOT NULL,
    client_id integer,
    tdm boolean DEFAULT true NOT NULL,
    rate_table_id integer,
    transnexus integer,
    route_strategy_id integer,
    media_type integer DEFAULT 2 NOT NULL,
    pass_through integer,
    profit_margin double precision DEFAULT 0 NOT NULL,
    enough_balance boolean DEFAULT true,
    egress_bill_after_action boolean DEFAULT true,
    proto integer DEFAULT 1,
    dnis_only boolean DEFAULT true NOT NULL,
    ring_timeout integer DEFAULT 60 NOT NULL,
    ignore_ring boolean DEFAULT false,
    ignore_early_media boolean DEFAULT false,
    disable_by_alert boolean DEFAULT false,
    priority integer DEFAULT 0,
    last_priority integer DEFAULT 0,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status integer DEFAULT 1,
    wait_ringtime180 integer DEFAULT 6000,
    profit_type integer DEFAULT 1 NOT NULL,
    lnp_dipping boolean DEFAULT false,
    lnp_dipping_rate real,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    cli_type integer,
    auth_type integer DEFAULT 0,
    delay_bye_second integer,
    delay_bye_limit integer,
    max_duration integer,
    marketplace integer DEFAULT 0,
    rating_type integer DEFAULT 0,
    billing_type integer DEFAULT 0,
    trunk_type integer,
    switch_profile_id integer,
    transaction_fee_id integer,
    service_type integer DEFAULT 0 NOT NULL,
    product_id integer,
    rpid smallint,
    paid smallint,
    oli smallint,
    pci smallint,
    priv smallint,
    div smallint,
    trunk_type2 smallint DEFAULT 0 NOT NULL,
    account_id character(32),
    billing_method smallint,
    amount_per_port numeric,
    billing_rule integer,
    ignore_early_nosdp integer,
    media_timeout integer,
    private integer DEFAULT 0 NOT NULL,
    agent_type integer,
    bill_by integer DEFAULT 4,
    rate_profile integer DEFAULT 0,
    us_route integer DEFAULT 0,
    intl_route integer DEFAULT 0,
    canada_route integer DEFAULT 0,
    rate_decimal integer DEFAULT 6,
    rate_rounding integer DEFAULT 0,
    us_other integer DEFAULT 0,
    canada_other integer DEFAULT 0,
    redirect integer DEFAULT 0,
    lrn_prefix integer DEFAULT 1 NOT NULL,
    pass_response_code integer DEFAULT 0,
    is_del integer DEFAULT 0,
    dtmf_type integer DEFAULT 3,
    dtmf_detect integer DEFAULT 0,
    rpid_screen integer DEFAULT 0,
    rpid_party integer DEFAULT 0,
    display_name integer,
    rpid_id_type integer DEFAULT 0,
    rpid_privacy integer DEFAULT 0,
    counter_time integer,
    number integer,
    block_time integer,
    re_invite integer,
    re_invite_interval integer,
    info integer,
    rfc2833 integer,
    inband integer,
    dummy_trunk boolean,
    random_table_id integer,
    is_virtual boolean,
    rfc_r833_payload integer,
    resource_template_id integer,
    rate_use_rpid boolean DEFAULT false,
    group_id integer,
    resource_block_group_id integer,
    block_404_number_time integer,
    billing_port_type integer DEFAULT 0,
    cost_per_port numeric DEFAULT 0,
    price_per_actual_channel double precision,
    price_per_max_channel double precision,
    enfource_cid boolean DEFAULT false,
    ani_cps_limit integer,
    ani_cap_limit integer,
    dnis_cps_limit integer,
    dnis_cap_limit integer,
    jurisdiction_use_dnis boolean DEFAULT false,
    cid_min_asr integer,
    cid_min_acd integer,
    cid_max_sdp integer,
    tech_prefix character varying(255)
);


ALTER TABLE public.resource OWNER TO postgres;

--
-- Name: TABLE resource; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource IS 'ç½‘å…³ç»„';


--
-- Name: COLUMN resource.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.resource_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.name IS 'åå­—';


--
-- Name: COLUMN resource.ingress; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.ingress IS 'å¯¹æŽ¥ç½‘å…³';


--
-- Name: COLUMN resource.egress; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.egress IS 'è½åœ°ç½‘å…³';


--
-- Name: COLUMN resource.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.active IS 'å¯ç”¨ï¼ç¦ç”¨';


--
-- Name: COLUMN resource.rfc_2833; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rfc_2833 IS 'rfc_2833';


--
-- Name: COLUMN resource.t38; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.t38 IS 't38';


--
-- Name: COLUMN resource.alias; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.alias IS 'åˆ«åresourceID';


--
-- Name: COLUMN resource.res_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.res_strategy IS 'è½åœ°ç½‘å…³é€‰æ‹©ç­–ç•¥
1ï¼ï¼top-down
2ï¼ï¼round-robin';


--
-- Name: COLUMN resource.cps_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.cps_limit IS 'å®¹è®¸æ¯ç§’å‘¼å«æ•°';


--
-- Name: COLUMN resource.capacity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.capacity IS 'å®¹è®¸åœ¨çº¿å‘¼å«æ•°';


--
-- Name: COLUMN resource.lnp; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.lnp IS 'lrn';


--
-- Name: COLUMN resource.lrn_block; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.lrn_block IS 'lrn block';


--
-- Name: COLUMN resource.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.client_id IS 'æ‰¹å‘å•†';


--
-- Name: COLUMN resource.tdm; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.tdm IS 'TDM';


--
-- Name: COLUMN resource.rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rate_table_id IS 'è´¹çŽ‡æ¨¡æ¿';


--
-- Name: COLUMN resource.transnexus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.transnexus IS 'transnexus';


--
-- Name: COLUMN resource.route_strategy_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.route_strategy_id IS 'è·¯ç”±ç­–ç•¥';


--
-- Name: COLUMN resource.media_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.media_type IS '0ï¼ï¼Proxy Media + Transcoding
1ï¼ï¼Proxy Media
2ï¼ï¼Bypass Media';


--
-- Name: COLUMN resource.pass_through; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.pass_through IS 'å·ç é€ä¼ è§„åˆ™
1--é€ä¼
2--ä¸é€ä¼
3--ä¸é€ä¼ ç¦æ˜¾ ';


--
-- Name: COLUMN resource.profit_margin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.profit_margin IS 'æœ€ä½Žåˆ©æ¶¦çŽ‡';


--
-- Name: COLUMN resource.enough_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.enough_balance IS 'æ˜¯å¦ä½™é¢ä¸è¶³';


--
-- Name: COLUMN resource.proto; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.proto IS '1--sip
2--h323
0--all';


--
-- Name: COLUMN resource.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.status IS '1--untested
2--tested
3--failed';


--
-- Name: COLUMN resource.profit_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.profit_type IS '1--ç™¾åˆ†æ¯”
2--æ•°å€¼';


--
-- Name: COLUMN resource.cli_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.cli_type IS '0-white
1-white non cli
2-grey';


--
-- Name: COLUMN resource.auth_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.auth_type IS 'æƒé™å­—æ®µ

0 - ALL

1 - resource_auth

';


--
-- Name: COLUMN resource.marketplace; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.marketplace IS '0:International A-Z
1:US Domestic';


--
-- Name: COLUMN resource.rating_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rating_type IS '0:US JD
1:US Non-JD
2:OCN-LATA JD
3:OCN-LATA Non-JD';


--
-- Name: COLUMN resource.billing_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.billing_type IS '0:DNIS
1:LRN
2:LRN Block All
3:LRN Block Higher Rate Codes Only
';


--
-- Name: COLUMN resource.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.trunk_type IS '1-class4
2-exchange
3-product_default
4-product_agent';


--
-- Name: COLUMN resource.service_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.service_type IS '0:Self  Service
1:Standand Deck';


--
-- Name: COLUMN resource.rpid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rpid IS 'Remote-Party-ID:

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.paid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.paid IS 'P-Asserted-Identity:

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.oli; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.oli IS 'From: <...;isup-oli=>

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.pci; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.pci IS 'P-Charge-Info:

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.priv; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.priv IS 'Privacy:

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.div; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.div IS 'Diversion:

egress:
0 - false ä¸ä¿¡ä»»
1 - true ä¿¡ä»»

ingress:
0 - NEVER ä¸å†™
1 - PASS_THROUGH é€ç©¿
2 - ALWAYS æ–°å»º';


--
-- Name: COLUMN resource.billing_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.billing_method IS '0 - by minutes

1- by port';


--
-- Name: COLUMN resource.amount_per_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.amount_per_port IS 'money per port';


--
-- Name: COLUMN resource.agent_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.agent_type IS '1-exchange
2-default agent
3-client agent';


--
-- Name: COLUMN resource.bill_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.bill_by IS '0 -- DNISï¼ŒDNISè®¡è´¹ï¼Œä¸éœ€è¦æŸ¥è¯¢LRN
1 -- LRNï¼ŒLRNè®¡è´¹ï¼Œå¿½ç•¥è¿è¥å•†å˜åŒ–
2 -- LRN Blockï¼ŒLRNè®¡è´¹å·ç è¿è¥å•†æœ‰æ”¹å˜ï¼Œåˆ™æ‹’ç»
3 -- LRN Block Higher Rateï¼ŒLRNè´¹çŽ‡é«˜äºŽDNISè´¹çŽ‡
4 -- Follow Rate Deckï¼Œä½¿ç”¨è´¹çŽ‡è¡¨çš„ä»¥ä¸Šé…ç½®';


--
-- Name: COLUMN resource.rate_profile; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rate_profile IS '0 --- false
1 --- true';


--
-- Name: COLUMN resource.us_route; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.us_route IS '0 --- other
1 --- intra
2 --- inter
3 --- highest';


--
-- Name: COLUMN resource.intl_route; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.intl_route IS '0 --- other
1 --- intra
2 --- inter
3 --- highest';


--
-- Name: COLUMN resource.canada_route; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.canada_route IS '0 --- other
1 --- intra
2 --- inter
3 --- highest';


--
-- Name: COLUMN resource.rate_decimal; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rate_decimal IS 'å†³å®šè´¹çŽ‡çš„å°æ•°ä½å–å¤šå°‘ä½ã€‚';


--
-- Name: COLUMN resource.rate_rounding; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rate_rounding IS 'è´¹çŽ‡å°æ•°ä½æ–¹æ³•ï¼š
0 --- èˆå…¥
1 --- èˆå¼ƒ';


--
-- Name: COLUMN resource.us_other; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.us_other IS '0 --- other

1 --- intra

2 --- inter

3 --- highest';


--
-- Name: COLUMN resource.canada_other; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.canada_other IS '0 --- other

1 --- intra

2 --- inter

3 --- highest';


--
-- Name: COLUMN resource.redirect; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.redirect IS '0 --- false
1 --- true';


--
-- Name: COLUMN resource.lrn_prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.lrn_prefix IS '0 --- false
1 --- true (default)';


--
-- Name: COLUMN resource.pass_response_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.pass_response_code IS '0 -- false, 1 -- true, å¦‚æžœæ­¤é€‰é¡¹è®¾ç½®true, åˆ™ä»Žegressè¿”å›žè¿‡æ¥çš„æœ€åŽä¸€ä¸ªsipé”™è¯¯ç è¿”å›žç»™ingress';


--
-- Name: COLUMN resource.is_del; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.is_del IS '0: not del
1: is del';


--
-- Name: COLUMN resource.dtmf_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.dtmf_type IS '0 -- æ‰€æœ‰
1 -- info
2 -- rfc2833
3 -- inband

baohq 20140408 create
baohq 20140520 update';


--
-- Name: COLUMN resource.dtmf_detect; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.dtmf_detect IS '0 -- è‡ªåŠ¨æ£€æµ‹ï¼Œmedia_type = transcode
1 -- é¢„å®šæ£€æµ‹ï¼Œmedia_type = transcodeå¹¶ä¸”ä¸»è¢«å«dtmfä¸åŒå¹¶ä¸”æœ‰ç›¸åŒè¯­éŸ³ç¼–ç 

baohq add 20140408';


--
-- Name: COLUMN resource.rpid_screen; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rpid_screen IS '0 -- none ä¸å¸¦screen
1 -- no
2 -- yes
3 -- proxy ä½¿ç”¨ä¸»å«RPID screen

baohq20140514';


--
-- Name: COLUMN resource.rpid_party; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rpid_party IS '0 --- none å‘¼å‡ºä¸å¸¦party
1 --- calling
2 --- called
3 --- proxy ä½¿ç”¨ä¸»å«RPID party

baohq20140514';


--
-- Name: COLUMN resource.display_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.display_name IS '0 --- false
1 --- true

å‘¼å‡ºæ—¶æ˜¯å¦é€ä¼ ä¸»å«çš„æ˜¾ç¤ºåå­—

baohq20140514';


--
-- Name: COLUMN resource.rpid_id_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rpid_id_type IS '0 --- none å‘¼å‡ºä¸å¸¦id_type
1 --- subscriber
2 --- user
3 --- term
4 --- proxy ä½¿ç”¨ä¸»å«RPID id_type

baohq20140514';


--
-- Name: COLUMN resource.rpid_privacy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rpid_privacy IS '0 --- none å‘¼å‡ºä¸å¸¦privacy
1 --- full
2 --- name
3 --- url
4 --- off
5 --- ipaddr
6 --- proxy ä½¿ç”¨ä¸»å«RPID privacy

baohq20140514';


--
-- Name: COLUMN resource.counter_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.counter_time IS 'loop detectionä½¿ç”¨ï¼Œå•ä½ç§’
è¿™ä¸ªæ—¶é—´æ®µå†…æ”¶åˆ°å¤šå°‘ä¸ªä¸»è¢«å«ä¸€æ ·çš„å‘¼å«ï¼Œåˆ™blockã€‚

baohq-20140620';


--
-- Name: COLUMN resource.number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.number IS 'loop detectionä½¿ç”¨ï¼Œè¡¨ç¤ºæ•°é‡
æŸä¸ªæ—¶é—´æ®µå†…æ”¶åˆ°è¿™ä¸ªæ•°å­—çš„ä¸»è¢«å«ä¸€æ ·çš„å‘¼å«ï¼Œåˆ™blockã€‚

baohq-20140620';


--
-- Name: COLUMN resource.block_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.block_time IS 'loop detectionä½¿ç”¨ï¼Œå•ä½ç§’
æ»¡è¶³blockçš„æ¡ä»¶åŽblockå¤šé•¿æ—¶é—´ã€‚

baohq-20140620';


--
-- Name: COLUMN resource.re_invite; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.re_invite IS '0 -- false
1 -- true

å‘é€re-INVITEæ£€æµ‹å¯¹æ–¹æ˜¯å¦æ´»è·ƒ';


--
-- Name: COLUMN resource.re_invite_interval; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.re_invite_interval IS 'ç§’å•ä½ï¼Œå»ºè®®ä¸å°äºŽ60ç§’';


--
-- Name: COLUMN resource.info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.info IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource.rfc2833; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.rfc2833 IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource.inband; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.inband IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource.dummy_trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource.dummy_trunk IS 'æ˜¯å¦ä¸ºorigination clientä¸­çš„failoverçš„trunk';


--
-- Name: route; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.route (
    route_id integer NOT NULL,
    digits public.prefix_range DEFAULT ''::public.prefix_range,
    dynamic_route_id integer,
    static_route_id integer,
    route_type integer NOT NULL,
    route_strategy_id integer NOT NULL,
    lnp boolean DEFAULT false,
    lrn_block boolean DEFAULT false,
    dnis_only boolean DEFAULT true,
    code_deck_type integer DEFAULT 0,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    intra_static_route_id integer,
    inter_static_route_id integer,
    jurisdiction_country_id integer,
    ani_prefix public.prefix_range,
    ani_min_length integer DEFAULT 0,
    ani_max_length integer DEFAULT 32,
    digits_min_length integer DEFAULT 0,
    digits_max_length integer DEFAULT 32,
    code_name character varying,
    country character varying(50),
    route_type_flg integer
);


ALTER TABLE public.route OWNER TO postgres;

--
-- Name: TABLE route; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.route IS 'è·¯ç”±';


--
-- Name: COLUMN route.route_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.route.route_id IS 'ä¸»é”®';


--
-- Name: COLUMN route.digits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.route.digits IS 'å‰ç¼€';


--
-- Name: COLUMN route.dynamic_route_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.route.dynamic_route_id IS 'åŠ¨æ€è·¯ç”±';


--
-- Name: COLUMN route.static_route_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.route.static_route_id IS 'é™æ€è·¯ç”±';


--
-- Name: COLUMN route.route_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.route.route_type IS 'è·¯ç”±æ–¹å¼
1--åŠ¨æ€è·¯ç”±
2--é™æ€è·¯ç”±
3--åŠ¨æ€è·¯ç”±åŽå†é™æ€è·¯ç”±
4--é™æ€è·¯ç”±åŽå†åŠ¨æ€è·¯ç”±';


--
-- Name: COLUMN route.route_strategy_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.route.route_strategy_id IS 'è·¯ç”±ç­–ç•¥';


--
-- Name: COLUMN route.code_deck_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.route.code_deck_type IS '0-icx code deck
1-custom code deck';


--
-- Name: route_strategy; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.route_strategy (
    route_strategy_id integer NOT NULL,
    name character varying(256) NOT NULL,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    is_virtual boolean
);


ALTER TABLE public.route_strategy OWNER TO postgres;

--
-- Name: TABLE route_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.route_strategy IS 'è·¯ç”±ç­–ç•¥';


--
-- Name: COLUMN route_strategy.route_strategy_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.route_strategy.route_strategy_id IS 'ä¸»é”®';


--
-- Name: COLUMN route_strategy.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.route_strategy.name IS 'åç§°';


--
-- Name: alternative_route_report; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.alternative_route_report AS
 SELECT product.name,
    product_items.digits,
    'Static Route'::text AS type
   FROM (((public.product_items
     JOIN public.product ON ((product_items.product_id = product.product_id)))
     JOIN public.product_items_resource ON ((product_items.item_id = product_items_resource.item_id)))
     JOIN public.resource ON ((product_items_resource.resource_id = resource.resource_id)))
  WHERE (product_items.item_id IN ( SELECT product_items_resource_1.item_id
           FROM public.product_items_resource product_items_resource_1
          GROUP BY product_items_resource_1.item_id
         HAVING (count(*) = 1)))
UNION
 SELECT dynamic_route.name,
    ''::public.prefix_range AS digits,
    'Dynamic Route'::text AS type
   FROM ((public.dynamic_route
     JOIN public.dynamic_route_items ON ((dynamic_route.dynamic_route_id = dynamic_route_items.dynamic_route_id)))
     JOIN public.resource ON ((dynamic_route_items.resource_id = resource.resource_id)))
  WHERE (dynamic_route.dynamic_route_id IN ( SELECT dynamic_route_items_1.dynamic_route_id
           FROM public.dynamic_route_items dynamic_route_items_1
          GROUP BY dynamic_route_items_1.dynamic_route_id
         HAVING (count(*) = 1)))
UNION
 SELECT route_strategy.name,
    route.digits,
    'Route Plan'::text AS type
   FROM (public.route_strategy
     LEFT JOIN public.route ON ((route_strategy.route_strategy_id = route.route_strategy_id)))
  WHERE ((EXISTS ( SELECT dynamic_route_items.dynamic_route_id
           FROM public.dynamic_route_items
          GROUP BY dynamic_route_items.dynamic_route_id
         HAVING ((count(*) = 1) AND (dynamic_route_items.dynamic_route_id = route.dynamic_route_id)))) OR (EXISTS ( SELECT product_items_resource.item_id
           FROM (public.product_items_resource
             JOIN public.product_items ON ((product_items_resource.item_id = product_items.item_id)))
          WHERE (product_items.product_id = route.static_route_id)
          GROUP BY product_items_resource.item_id
         HAVING (count(*) = 1))));


ALTER TABLE public.alternative_route_report OWNER TO postgres;

--
-- Name: ani_blocking_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ani_blocking_log (
    id integer NOT NULL,
    rule_name character varying(100),
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    type integer DEFAULT 0 NOT NULL,
    res_block_id integer,
    dialer_detection_id integer,
    ani character varying(50)
);


ALTER TABLE public.ani_blocking_log OWNER TO postgres;

--
-- Name: ani_blocking_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ani_blocking_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ani_blocking_log_id_seq OWNER TO postgres;

--
-- Name: ani_blocking_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ani_blocking_log_id_seq OWNED BY public.ani_blocking_log.id;


--
-- Name: api_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.api_log (
    id integer NOT NULL,
    "time" integer,
    request text,
    status integer
);


ALTER TABLE public.api_log OWNER TO postgres;

--
-- Name: api_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.api_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.api_log_id_seq OWNER TO postgres;

--
-- Name: api_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.api_log_id_seq OWNED BY public.api_log.id;


--
-- Name: authorization_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.authorization_logs (
    id integer,
    direction integer,
    auth_type integer,
    error_type integer,
    request_ip public.ip4r,
    request_port integer,
    username character varying(64),
    authname character varying(64),
    sip_callid character varying(128),
    "time" bigint
);


ALTER TABLE public.authorization_logs OWNER TO postgres;

--
-- Name: TABLE authorization_logs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.authorization_logs IS 'èº«ä»½éªŒè¯ç›¸å…³çš„æ—¥å¿—

baohq20140430';


--
-- Name: COLUMN authorization_logs.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.authorization_logs.id IS 'é€’å¢žçš„åºåˆ—å·

baohq20140504';


--
-- Name: COLUMN authorization_logs.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.authorization_logs.direction IS 'in -- 0
out -- 1

baohq20140504
';


--
-- Name: COLUMN authorization_logs.auth_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.authorization_logs.auth_type IS 'REGISTER -- 0
INVITE -- 1

baohq20140504';


--
-- Name: COLUMN authorization_logs.error_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.authorization_logs.error_type IS '0 -- normal
1 -- auth params incomplete
2 -- user nothingness
3 -- wrong password
4 -- wrong username

baohq20140504';


--
-- Name: COLUMN authorization_logs.request_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.authorization_logs.request_ip IS 'å‘é€æºIP

baohq20140504';


--
-- Name: COLUMN authorization_logs.request_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.authorization_logs.request_port IS 'å‘åŒ…æºç«¯å£

baohq20140504';


--
-- Name: COLUMN authorization_logs.username; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.authorization_logs.username IS 'sip ç”¨æˆ·åæˆ–ç”¨æˆ·IDï¼Œ ä¹Ÿæ˜¯fromçš„ç”µè¯å·ç 

baohq20140504';


--
-- Name: COLUMN authorization_logs.authname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.authorization_logs.authname IS 'è®¤è¯ä½¿ç”¨çš„ç”¨æˆ·åï¼Œä¸æ˜¯to, fromç­‰ç”¨æˆ·åï¼Œæ˜¯authorizationåŠ å¯†çš„ç”¨æˆ·åã€‚

baohq20140504';


--
-- Name: COLUMN authorization_logs.sip_callid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.authorization_logs.sip_callid IS 'REGISTERæˆ–INVITEæ¶ˆæ¯çš„sip call id

baohq20140504';


--
-- Name: COLUMN authorization_logs."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.authorization_logs."time" IS 'å‘ç”Ÿè®°å½•æ—¶é—´ï¼Œä¹Ÿå°±æ˜¯é”™è¯¯äº§ç”Ÿæ—¶é—´ã€‚

baohq20140504';


--
-- Name: automatic_rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.automatic_rate (
    id integer NOT NULL,
    egress_id integer,
    day integer,
    start_line integer,
    format character varying(255),
    end_date_type integer,
    end_date_when integer,
    from_email character varying(255)
);


ALTER TABLE public.automatic_rate OWNER TO postgres;

--
-- Name: COLUMN automatic_rate.end_date_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.automatic_rate.end_date_type IS '0 --  End Date All Codes
1 -- End Date Uploaded Codes
';


--
-- Name: COLUMN automatic_rate.end_date_when; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.automatic_rate.end_date_when IS '0 -- Set End Date to 7 days after rate is received.
1 -- Set End Date to right before the earliest effective date.';


--
-- Name: automatic_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.automatic_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.automatic_rate_id_seq OWNER TO postgres;

--
-- Name: automatic_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.automatic_rate_id_seq OWNED BY public.automatic_rate.id;


--
-- Name: backup_clean; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.backup_clean (
    id integer NOT NULL,
    clean_type integer
);


ALTER TABLE public.backup_clean OWNER TO postgres;

--
-- Name: COLUMN backup_clean.clean_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.backup_clean.clean_type IS 'cdr
record
qos';


--
-- Name: backup_clean_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.backup_clean_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.backup_clean_id_seq OWNER TO postgres;

--
-- Name: backup_clean_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.backup_clean_id_seq OWNED BY public.backup_clean.id;


--
-- Name: backup_limit_state; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.backup_limit_state (
    cps character varying(100),
    cap character varying(100),
    cps_i character varying(100),
    cap_i character varying(100),
    cps_e character varying(100),
    cap_e character varying(100),
    cap_w character varying(100),
    cap_o character varying(100),
    id_type character varying(100),
    long_time character varying(100),
    pid character varying(100),
    key character varying(100),
    listen_ip character varying(100),
    listen_port character varying(100),
    up_time character varying(100)
);


ALTER TABLE public.backup_limit_state OWNER TO postgres;

--
-- Name: backup_peak_state; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.backup_peak_state (
    curr character varying(100),
    _24hr character varying(100),
    _7day character varying(100),
    rece character varying(100),
    curr_t character varying(100),
    _24hr_t character varying(100),
    _7day_t character varying(100),
    id_type character varying(100),
    pid character varying(100),
    listen_ip character varying(100),
    listen_port character varying(100),
    up_time character varying(100)
);


ALTER TABLE public.backup_peak_state OWNER TO postgres;

--
-- Name: bad_number_detection_rules_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.bad_number_detection_rules_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bad_number_detection_rules_seq OWNER TO postgres;

--
-- Name: bad_number_detection_rules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.bad_number_detection_rules (
    id integer DEFAULT nextval('public.bad_number_detection_rules_seq'::regclass),
    name character varying(30) NOT NULL,
    target integer,
    valid_attempts integer,
    p200 integer,
    p404 integer,
    p503 integer,
    p480 integer,
    p486 integer,
    p487 integer,
    p45 integer,
    asr integer,
    acd integer,
    block_type integer,
    trunk_list text,
    exec_every integer,
    from_last integer,
    last_executed timestamp with time zone,
    ip character varying(15)
);


ALTER TABLE public.bad_number_detection_rules OWNER TO postgres;

--
-- Name: balance_daily_reset_task; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.balance_daily_reset_task (
    id integer NOT NULL,
    start_time timestamp with time zone,
    reset_balance smallint,
    mutual smallint,
    actual smallint,
    client_id integer,
    status smallint DEFAULT 0 NOT NULL,
    finished_time timestamp with time zone,
    create_by character varying(100),
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE public.balance_daily_reset_task OWNER TO postgres;

--
-- Name: COLUMN balance_daily_reset_task.start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.balance_daily_reset_task.start_time IS 'The start time of balance daily resetting';


--
-- Name: COLUMN balance_daily_reset_task.reset_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.balance_daily_reset_task.reset_balance IS '1 for reset client balance, other for ignore';


--
-- Name: COLUMN balance_daily_reset_task.mutual; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.balance_daily_reset_task.mutual IS '1 for reset mutual balance, other for ignore';


--
-- Name: COLUMN balance_daily_reset_task.actual; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.balance_daily_reset_task.actual IS '1 for reset actual balance, other for ignore';


--
-- Name: COLUMN balance_daily_reset_task.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.balance_daily_reset_task.client_id IS '0 for all client, other is the specified client ID';


--
-- Name: COLUMN balance_daily_reset_task.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.balance_daily_reset_task.status IS '0 for initial; 1 for in process, 2 for finished; 3 for error';


--
-- Name: balance_daily_reset_task_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.balance_daily_reset_task_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.balance_daily_reset_task_id_seq OWNER TO postgres;

--
-- Name: balance_daily_reset_task_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.balance_daily_reset_task_id_seq OWNED BY public.balance_daily_reset_task.id;


--
-- Name: balance_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.balance_history (
    id integer NOT NULL,
    date date,
    payment_received numeric(20,5) DEFAULT 0 NOT NULL,
    credit_note_sent numeric(20,5) DEFAULT 0 NOT NULL,
    debit_note_sent numeric(20,5) DEFAULT 0 NOT NULL,
    payment_sent numeric(20,5) DEFAULT 0 NOT NULL,
    credit_note_received numeric(20,5) DEFAULT 0 NOT NULL,
    debit_note_received numeric(20,5) DEFAULT 0 NOT NULL,
    invoice_set numeric(20,5) DEFAULT 0 NOT NULL,
    invoice_received numeric(20,5) DEFAULT 0 NOT NULL,
    mutual_balance numeric(20,5) NOT NULL,
    client_id integer,
    mutual_ingress_balance numeric(20,5) DEFAULT 0 NOT NULL,
    mutual_egress_balance numeric(20,5) DEFAULT 0 NOT NULL
);


ALTER TABLE public.balance_history OWNER TO postgres;

--
-- Name: balance_history_actual; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.balance_history_actual (
    id integer NOT NULL,
    date date,
    payment_received numeric(20,5) DEFAULT 0 NOT NULL,
    credit_note_sent numeric(20,5) DEFAULT 0 NOT NULL,
    debit_note_sent numeric(20,5) DEFAULT 0 NOT NULL,
    unbilled_incoming_traffic numeric(20,5) DEFAULT 0 NOT NULL,
    short_charges numeric(20,5) DEFAULT 0 NOT NULL,
    payment_sent numeric(20,5) DEFAULT 0 NOT NULL,
    credit_note_received numeric(20,5) DEFAULT 0 NOT NULL,
    debit_note_received numeric(20,5) DEFAULT 0 NOT NULL,
    unbilled_outgoing_traffic numeric(20,5) DEFAULT 0 NOT NULL,
    actual_balance numeric(20,5) NOT NULL,
    client_id integer,
    actual_ingress_balance numeric(20,5) DEFAULT 0 NOT NULL,
    actual_egress_balance numeric(20,5) DEFAULT 0 NOT NULL
);


ALTER TABLE public.balance_history_actual OWNER TO postgres;

--
-- Name: balance_history_actual_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.balance_history_actual_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.balance_history_actual_id_seq OWNER TO postgres;

--
-- Name: balance_history_actual_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.balance_history_actual_id_seq OWNED BY public.balance_history_actual.id;


--
-- Name: balance_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.balance_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.balance_history_id_seq OWNER TO postgres;

--
-- Name: balance_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.balance_history_id_seq OWNED BY public.balance_history.id;


--
-- Name: balance_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.balance_log (
    id integer NOT NULL,
    client_id integer,
    balance numeric(30,6),
    date date DEFAULT ('now'::text)::date,
    ingress_balance numeric(30,6),
    egress_balance numeric(30,6)
);


ALTER TABLE public.balance_log OWNER TO postgres;

--
-- Name: balance_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.balance_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.balance_log_id_seq OWNER TO postgres;

--
-- Name: balance_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.balance_log_id_seq OWNED BY public.balance_log.id;


--
-- Name: block_ani; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.block_ani (
    id integer NOT NULL,
    ingress integer,
    asr real,
    acd real,
    blocked_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    email boolean DEFAULT false,
    block boolean DEFAULT false,
    ani character varying(255),
    egress integer,
    calls integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    action_id integer,
    unblock_time timestamp without time zone,
    rule_id integer,
    condition_id integer,
    code_name character varying(100)
);


ALTER TABLE public.block_ani OWNER TO postgres;

--
-- Name: block_ani_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.block_ani_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.block_ani_id_seq OWNER TO postgres;

--
-- Name: block_ani_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.block_ani_id_seq OWNED BY public.block_ani.id;


--
-- Name: block_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.block_log (
    log_id integer NOT NULL,
    block_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    block_by character varying(100),
    code_detail character varying(500),
    re_enable_time timestamp with time zone,
    asr character varying(100),
    abr character varying(100),
    acd character varying(100),
    pdd character varying(100),
    margin character varying(100),
    re_enable boolean DEFAULT false,
    type smallint DEFAULT 0 NOT NULL
);


ALTER TABLE public.block_log OWNER TO postgres;

--
-- Name: COLUMN block_log.block_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.block_log.block_by IS 'rule name';


--
-- Name: COLUMN block_log.code_detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.block_log.code_detail IS 'Code Name/Code';


--
-- Name: COLUMN block_log.re_enable_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.block_log.re_enable_time IS 'è‡ªåŠ¨é‡å¯çš„æ—¶é—´';


--
-- Name: COLUMN block_log.margin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.block_log.margin IS 'profitability';


--
-- Name: COLUMN block_log.re_enable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.block_log.re_enable IS 'æ˜¯å¦å·²ç»è¿˜åŽŸ';


--
-- Name: block_log_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.block_log_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.block_log_log_id_seq OWNER TO postgres;

--
-- Name: block_log_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.block_log_log_id_seq OWNED BY public.block_log.log_id;


--
-- Name: block_loop; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.block_loop (
    id integer NOT NULL,
    name character varying(100),
    loop_interval integer,
    loop_count integer,
    block_interval integer
);


ALTER TABLE public.block_loop OWNER TO postgres;

--
-- Name: COLUMN block_loop.block_interval; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.block_loop.block_interval IS '0-forever';


--
-- Name: block_loop_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.block_loop_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.block_loop_id_seq OWNER TO postgres;

--
-- Name: block_loop_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.block_loop_id_seq OWNED BY public.block_loop.id;


--
-- Name: block_loop_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.block_loop_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    loop_count integer
);


ALTER TABLE public.block_loop_log OWNER TO postgres;

--
-- Name: block_loop_log_calls; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.block_loop_log_calls (
    id integer NOT NULL,
    block_loop_log_id integer NOT NULL,
    ani character varying(50),
    dnis character varying(50),
    loop_count integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone
);


ALTER TABLE public.block_loop_log_calls OWNER TO postgres;

--
-- Name: block_loop_log_calls_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.block_loop_log_calls_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.block_loop_log_calls_id_seq OWNER TO postgres;

--
-- Name: block_loop_log_calls_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.block_loop_log_calls_id_seq OWNED BY public.block_loop_log_calls.id;


--
-- Name: block_loop_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.block_loop_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.block_loop_log_id_seq OWNER TO postgres;

--
-- Name: block_loop_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.block_loop_log_id_seq OWNED BY public.block_loop_log.id;


--
-- Name: block_ticket; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.block_ticket (
    id integer NOT NULL,
    ingress integer,
    asr real,
    acd real,
    blocked_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    email boolean DEFAULT false,
    block boolean DEFAULT false,
    dnis character varying(255),
    egress integer,
    calls integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    code_name character varying(100),
    rule_name character varying(100),
    not_zero_calls integer,
    unblock_time timestamp without time zone
);


ALTER TABLE public.block_ticket OWNER TO postgres;

--
-- Name: block_ticket_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.block_ticket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.block_ticket_id_seq OWNER TO postgres;

--
-- Name: block_ticket_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.block_ticket_id_seq OWNED BY public.block_ticket.id;


--
-- Name: block_trouble_ticket; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.block_trouble_ticket (
    id integer NOT NULL,
    block_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    block_by character varying(100),
    code_detail character varying(500),
    asr character varying(100),
    abr character varying(100),
    acd character varying(100),
    pdd character varying(100),
    margin character varying(100),
    email character varying(100)
);


ALTER TABLE public.block_trouble_ticket OWNER TO postgres;

--
-- Name: COLUMN block_trouble_ticket.block_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.block_trouble_ticket.block_by IS 'rule name';


--
-- Name: COLUMN block_trouble_ticket.code_detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.block_trouble_ticket.code_detail IS 'Code Name/Code';


--
-- Name: COLUMN block_trouble_ticket.margin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.block_trouble_ticket.margin IS 'profitability';


--
-- Name: COLUMN block_trouble_ticket.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.block_trouble_ticket.email IS 'noc_email';


--
-- Name: block_trouble_ticket_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.block_trouble_ticket_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.block_trouble_ticket_id_seq OWNER TO postgres;

--
-- Name: block_trouble_ticket_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.block_trouble_ticket_id_seq OWNED BY public.block_trouble_ticket.id;


--
-- Name: buy_order; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.buy_order (
    id integer NOT NULL,
    name character varying(40),
    client_id integer NOT NULL,
    resource_id integer NOT NULL,
    code_deck_id integer DEFAULT 1,
    rate numeric(30,10) NOT NULL,
    is_private boolean DEFAULT false NOT NULL,
    is_commit boolean DEFAULT false NOT NULL,
    commit_minutes integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    cli boolean DEFAULT false NOT NULL,
    g729 boolean DEFAULT false NOT NULL,
    fax boolean DEFAULT false NOT NULL,
    active boolean DEFAULT true NOT NULL,
    status integer DEFAULT 0 NOT NULL,
    expire_time timestamp with time zone,
    country character varying(100),
    acd real,
    asr real,
    user_id integer NOT NULL,
    dtmf boolean DEFAULT false NOT NULL,
    state_date timestamp with time zone NOT NULL,
    end_date timestamp with time zone,
    limit_price numeric(30,10),
    g723 boolean DEFAULT false NOT NULL,
    g711 boolean DEFAULT false NOT NULL,
    time_of_date boolean DEFAULT false NOT NULL,
    peak boolean DEFAULT false NOT NULL,
    offpeak boolean DEFAULT false NOT NULL,
    weekend boolean DEFAULT false NOT NULL,
    currency_id integer,
    asr_var real,
    acd_var real,
    rate_only boolean DEFAULT false NOT NULL,
    match_type integer DEFAULT 2 NOT NULL,
    route_priority integer DEFAULT 1 NOT NULL,
    invite_id integer,
    partner_id integer,
    resource_prefix public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    route_type integer DEFAULT 1 NOT NULL,
    auto_match boolean DEFAULT false NOT NULL,
    auto_match_result integer,
    dialer boolean DEFAULT false NOT NULL,
    "interval" integer DEFAULT 1 NOT NULL,
    "limit" integer,
    minimal_duration integer,
    purged boolean DEFAULT false NOT NULL,
    cli_type integer DEFAULT 0 NOT NULL,
    pdd_timeout integer,
    pdd_var integer,
    auto_match_time timestamp with time zone,
    min_threedays integer
);


ALTER TABLE public.buy_order OWNER TO postgres;

--
-- Name: COLUMN buy_order.match_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.buy_order.match_type IS '1--var
2--soft
3--hard';


--
-- Name: COLUMN buy_order.route_priority; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.buy_order.route_priority IS '1--quality
2--price';


--
-- Name: COLUMN buy_order.route_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.buy_order.route_type IS '1:Prime,
2:Select,
3:Direct
';


--
-- Name: COLUMN buy_order.auto_match_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.buy_order.auto_match_result IS '0-fail
1-success';


--
-- Name: COLUMN buy_order.minimal_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.buy_order.minimal_duration IS 'rateçš„min_time';


--
-- Name: COLUMN buy_order.cli_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.buy_order.cli_type IS '0-white
1-white non cli
2-grey';


--
-- Name: buy_order_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.buy_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.buy_order_id_seq OWNER TO postgres;

--
-- Name: buy_order_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.buy_order_id_seq OWNED BY public.buy_order.id;


--
-- Name: buy_order_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.buy_order_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.buy_order_record_record_id_seq OWNER TO postgres;

--
-- Name: buy_order_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.buy_order_record (
    id integer,
    name character varying(40),
    client_id integer,
    resource_id integer,
    code_deck_id integer,
    rate numeric(30,10),
    is_private boolean,
    is_commit boolean,
    commit_minutes integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    cli boolean,
    g729 boolean,
    fax boolean,
    active boolean,
    status integer,
    expire_time timestamp with time zone,
    country character varying(100),
    acd real,
    asr real,
    user_id integer,
    dtmf boolean,
    state_date timestamp with time zone,
    end_date timestamp with time zone,
    limit_price numeric(30,10),
    g723 boolean,
    g711 boolean,
    time_of_date boolean,
    peak boolean,
    offpeak boolean,
    weekend boolean,
    currency_id integer,
    asr_var real,
    acd_var real,
    rate_only boolean,
    match_type integer,
    route_priority integer,
    invite_id integer,
    partner_id integer,
    resource_prefix public.prefix_range,
    route_type integer,
    auto_match boolean,
    auto_match_result integer,
    dialer boolean,
    "interval" integer,
    "limit" integer,
    minimal_duration integer,
    purged boolean,
    cli_type integer,
    pdd_timeout integer,
    pdd_var integer,
    auto_match_time timestamp with time zone,
    min_threedays integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.buy_order_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.buy_order_record OWNER TO postgres;

--
-- Name: buy_order_response; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.buy_order_response (
    id integer NOT NULL,
    buy_order_id integer,
    client_id integer,
    is_commit boolean DEFAULT true NOT NULL,
    commit_minutes integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    status integer DEFAULT 0 NOT NULL,
    expire_time timestamp with time zone,
    resource_id integer,
    pdd_timeout integer,
    pdd_var integer
);


ALTER TABLE public.buy_order_response OWNER TO postgres;

--
-- Name: COLUMN buy_order_response.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.buy_order_response.client_id IS 'ä¹°è€…çš„client_id';


--
-- Name: buy_order_response_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.buy_order_response_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.buy_order_response_id_seq OWNER TO postgres;

--
-- Name: buy_order_response_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.buy_order_response_id_seq OWNED BY public.buy_order_response.id;


--
-- Name: buy_order_response_resource_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.buy_order_response_resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.buy_order_response_resource_id_seq OWNER TO postgres;

--
-- Name: c4_client_balance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.c4_client_balance (
    id integer NOT NULL,
    client_id character varying(100) NOT NULL,
    balance numeric(30,6) DEFAULT 0.00 NOT NULL,
    ingress_balance numeric(30,6) DEFAULT 0.00 NOT NULL,
    egress_balance numeric(30,6) DEFAULT 0.00 NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL
);


ALTER TABLE public.c4_client_balance OWNER TO postgres;

--
-- Name: COLUMN c4_client_balance.balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.c4_client_balance.balance IS 'current balance';


--
-- Name: COLUMN c4_client_balance.create_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.c4_client_balance.create_time IS 'balance update time';


--
-- Name: c4_client_balance_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.c4_client_balance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.c4_client_balance_id_seq OWNER TO postgres;

--
-- Name: c4_client_balance_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.c4_client_balance_id_seq OWNED BY public.c4_client_balance.id;


--
-- Name: c4_client_balance_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.c4_client_balance_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.c4_client_balance_record_record_id_seq OWNER TO postgres;

--
-- Name: c4_client_balance_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.c4_client_balance_record (
    id integer,
    client_id character varying(100),
    balance numeric(30,6),
    ingress_balance numeric(30,6),
    egress_balance numeric(30,6),
    create_time timestamp with time zone,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.c4_client_balance_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.c4_client_balance_record OWNER TO postgres;

--
-- Name: c4_livecall_user; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.c4_livecall_user (
    id integer NOT NULL,
    name character varying(50) NOT NULL,
    password character varying(50) NOT NULL,
    user_type smallint DEFAULT 0 NOT NULL
);


ALTER TABLE public.c4_livecall_user OWNER TO postgres;

--
-- Name: COLUMN c4_livecall_user.user_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.c4_livecall_user.user_type IS '0 for softswitch; 1 for web user';


--
-- Name: c4_livecall_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.c4_livecall_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.c4_livecall_user_id_seq OWNER TO postgres;

--
-- Name: c4_livecall_user_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.c4_livecall_user_id_seq OWNED BY public.c4_livecall_user.id;


--
-- Name: c4_livecall_user_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.c4_livecall_user_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.c4_livecall_user_record_record_id_seq OWNER TO postgres;

--
-- Name: c4_livecall_user_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.c4_livecall_user_record (
    id integer,
    name character varying(50),
    password character varying(50),
    user_type smallint,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.c4_livecall_user_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.c4_livecall_user_record OWNER TO postgres;

--
-- Name: c4_lrn; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.c4_lrn (
    id integer NOT NULL,
    srv1_ip character varying(16),
    srv1_port integer DEFAULT 5060 NOT NULL,
    srv2_ip character varying(16),
    srv2_port integer DEFAULT 5060 NOT NULL
);


ALTER TABLE public.c4_lrn OWNER TO postgres;

--
-- Name: COLUMN c4_lrn.srv1_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.c4_lrn.srv1_ip IS 'Master lrn server ip';


--
-- Name: COLUMN c4_lrn.srv2_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.c4_lrn.srv2_ip IS 'Slave lrn server ip';


--
-- Name: c4_lrn_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.c4_lrn_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.c4_lrn_id_seq OWNER TO postgres;

--
-- Name: c4_lrn_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.c4_lrn_id_seq OWNED BY public.c4_lrn.id;


--
-- Name: c4_lrn_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.c4_lrn_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.c4_lrn_record_record_id_seq OWNER TO postgres;

--
-- Name: c4_lrn_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.c4_lrn_record (
    id integer,
    srv1_ip character varying(16),
    srv1_port integer,
    srv2_ip character varying(16),
    srv2_port integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.c4_lrn_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.c4_lrn_record OWNER TO postgres;

--
-- Name: c4_spam_traffic_ip_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.c4_spam_traffic_ip_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.c4_spam_traffic_ip_record_record_id_seq OWNER TO postgres;

--
-- Name: call_monitor; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.call_monitor (
    id integer NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    ani character varying(50),
    dnis character varying(50),
    remote_ip character varying(50),
    remote_port character varying(50),
    status smallint DEFAULT 0
);


ALTER TABLE public.call_monitor OWNER TO postgres;

--
-- Name: call_monitor_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.call_monitor_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.call_monitor_id_seq OWNER TO postgres;

--
-- Name: call_monitor_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.call_monitor_id_seq OWNED BY public.call_monitor.id;


--
-- Name: captcha; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.captcha (
    captcha_id integer NOT NULL,
    captcha_time integer NOT NULL,
    ip_address character varying(16) DEFAULT 0 NOT NULL,
    word character varying(20) NOT NULL
);


ALTER TABLE public.captcha OWNER TO postgres;

--
-- Name: TABLE captcha; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.captcha IS 'ç™»å½•é¡µé¢çš„éªŒè¯ç ';


--
-- Name: captcha_captcha_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.captcha_captcha_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.captcha_captcha_id_seq OWNER TO postgres;

--
-- Name: captcha_captcha_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.captcha_captcha_id_seq OWNED BY public.captcha.captcha_id;


--
-- Name: capture_capture_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.capture_capture_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999
    CACHE 1;


ALTER TABLE public.capture_capture_id_seq OWNER TO postgres;

--
-- Name: capture; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.capture (
    capture_id integer DEFAULT nextval('public.capture_capture_id_seq'::regclass) NOT NULL,
    capture_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    file_name character varying(256),
    src_ip public.ip4r,
    src_port character varying(10),
    dest_ip public.ip4r,
    dest_port character varying(10),
    time_val integer,
    key_word character varying(100),
    view boolean NOT NULL,
    user_id integer,
    flag integer DEFAULT 2,
    ani character varying(40),
    dnis character varying(40),
    server_ip character varying,
    file_size integer,
    server_port integer
);


ALTER TABLE public.capture OWNER TO postgres;

--
-- Name: TABLE capture; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.capture IS 'æŠ“åŒ…è®°å½•';


--
-- Name: COLUMN capture.capture_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.capture_id IS 'ä¸»é”®';


--
-- Name: COLUMN capture.capture_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.capture_time IS 'æŠ“åŒ…æ—¶é—´';


--
-- Name: COLUMN capture.file_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.file_name IS 'æ–‡ä»¶åç§°';


--
-- Name: COLUMN capture.src_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.src_ip IS 'æºåœ°å€';


--
-- Name: COLUMN capture.src_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.src_port IS 'æºç«¯å£';


--
-- Name: COLUMN capture.dest_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.dest_ip IS 'ç›®çš„åœ°å€';


--
-- Name: COLUMN capture.dest_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.dest_port IS 'ç›®æ ‡ç«¯å£';


--
-- Name: COLUMN capture.time_val; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.time_val IS 'æŠ“åŒ…æ—¶é•¿';


--
-- Name: COLUMN capture.key_word; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.key_word IS 'å…³é”®å­—';


--
-- Name: COLUMN capture.view; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.view IS 'èƒ½å¦æŸ¥çœ‹';


--
-- Name: COLUMN capture.flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.capture.flag IS '1---capture ç»“æŸ
2---capture æœªç»“æŸ';


--
-- Name: carrier_group; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.carrier_group (
    group_id integer NOT NULL,
    group_name character varying
);


ALTER TABLE public.carrier_group OWNER TO postgres;

--
-- Name: carrier_group_group_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.carrier_group_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.carrier_group_group_id_seq OWNER TO postgres;

--
-- Name: carrier_group_group_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.carrier_group_group_id_seq OWNED BY public.carrier_group.group_id;


--
-- Name: carrier_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.carrier_template (
    template_name character varying(100),
    create_by character varying(100),
    update_on timestamp with time zone,
    create_on timestamp with time zone,
    mode integer DEFAULT 1 NOT NULL,
    currency_id integer NOT NULL,
    unlimited_credit integer DEFAULT 0,
    allowed_credit numeric(30,10) DEFAULT 0 NOT NULL,
    profit_margin double precision DEFAULT 0 NOT NULL,
    profit_type integer DEFAULT 1 NOT NULL,
    cps_limit integer,
    call_limit integer,
    daily_limit integer,
    hourly_limit integer,
    auto_summary_hour integer,
    auto_summary_period integer DEFAULT 24,
    auto_send_zone character varying DEFAULT '+00:00'::character varying,
    auto_summary_include_cdr integer DEFAULT 0,
    auto_daily_balance_recipient integer DEFAULT 0,
    is_auto_summary integer DEFAULT 0,
    auto_summary_not_zero smallint DEFAULT 0,
    auto_summary_group_by smallint DEFAULT 0,
    is_auto_balance integer DEFAULT 0,
    numer_of_days_balance integer DEFAULT 1,
    daily_cdr_generation_zone character varying DEFAULT '+00:00'::character varying,
    daily_cdr_generation_type smallint DEFAULT 0,
    scc_bellow integer DEFAULT 0,
    scc_percent integer DEFAULT 0,
    scc_charge numeric(30,10),
    scc_type integer DEFAULT 0,
    auto_invoicing integer DEFAULT 1 NOT NULL,
    include_tax integer DEFAULT 0,
    tax integer,
    invoice_start_from date,
    attach_cdrs_list integer,
    invoice_show_details integer DEFAULT 0,
    invoice_jurisdictional_detail integer DEFAULT 0,
    decimal_place integer DEFAULT 5,
    rate_value integer DEFAULT 0,
    is_email_invoice integer DEFAULT 0,
    email_invoice integer DEFAULT 0,
    include_available_credit smallint DEFAULT 0,
    is_invoice_account_summary integer DEFAULT 0,
    invoice_use_balance_type integer DEFAULT 0,
    is_show_daily_usage integer DEFAULT 0,
    is_short_duration_call_surcharge_detail integer DEFAULT 0,
    invoice_include_payment integer,
    is_show_daily_trunk integer DEFAULT 0,
    is_show_total_trunk integer DEFAULT 0,
    is_show_code_100 integer DEFAULT 0,
    is_show_code_name integer DEFAULT 0,
    is_show_country integer DEFAULT 0,
    is_show_by_date integer DEFAULT 0,
    usage_detail_fields text,
    is_breakdown_by_rate_table integer,
    breakdown_by_rate_table smallint,
    daily_balance_send_time time without time zone,
    daily_balance_send_time_zone character varying(20),
    is_daily_balance_notification integer DEFAULT 0,
    notify_client_balance_type integer DEFAULT 0,
    daily_balance_notification integer,
    daily_balance_recipient integer,
    id integer NOT NULL,
    daily_cdr_generation integer DEFAULT 0,
    auto_invoice_type integer DEFAULT 0,
    invoice_format integer DEFAULT 1,
    invoice_zone character varying(10),
    invoice_zero integer DEFAULT 1,
    cdr_list_format integer,
    last_invoiced timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    notify_client_balance numeric(30,10) DEFAULT 0,
    is_send_as_link boolean DEFAULT false,
    is_send_trunk_update boolean DEFAULT true,
    is_show_detail_trunk boolean DEFAULT false
);


ALTER TABLE public.carrier_template OWNER TO postgres;

--
-- Name: carrier_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.carrier_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.carrier_template_id_seq OWNER TO postgres;

--
-- Name: carrier_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.carrier_template_id_seq OWNED BY public.carrier_template.id;


--
-- Name: cdr_api_export_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_api_export_log (
    id integer NOT NULL,
    request_id character varying(255),
    status integer DEFAULT 0,
    type integer,
    user_id integer,
    filename character varying,
    start_time integer NOT NULL,
    end_time integer NOT NULL,
    ftp_url character varying(255),
    ftp_port integer,
    ftp_user character varying(255),
    ftp_password character varying(255),
    ftp_directory character varying,
    create_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    total_records integer,
    completed_records integer
);


ALTER TABLE public.cdr_api_export_log OWNER TO postgres;

--
-- Name: cdr_api_export_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cdr_api_export_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cdr_api_export_log_id_seq OWNER TO postgres;

--
-- Name: cdr_api_export_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cdr_api_export_log_id_seq OWNED BY public.cdr_api_export_log.id;


--
-- Name: cdr_backup; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_backup (
    method integer,
    user_name character varying(100),
    user_password character varying(100),
    host_ip public.ip4r,
    host_dir character varying(100),
    period text,
    usr_port integer
);


ALTER TABLE public.cdr_backup OWNER TO postgres;

--
-- Name: COLUMN cdr_backup.method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_backup.method IS '1-scp
2-ftp
3-local';


--
-- Name: cdr_compare; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_compare (
    id integer NOT NULL,
    source_filename text,
    diff_filename text,
    is_rate boolean DEFAULT false,
    duration_diff integer,
    calltime_diff integer,
    status integer DEFAULT 0,
    diff_report_file text,
    diff_cdr_file text,
    create_time timestamp with time zone,
    finish_time timestamp with time zone,
    format integer DEFAULT 0
);


ALTER TABLE public.cdr_compare OWNER TO postgres;

--
-- Name: TABLE cdr_compare; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.cdr_compare IS 'å¯¹æ¯”';


--
-- Name: COLUMN cdr_compare.is_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare.is_rate IS 'æš‚ä¸ä½¿ç”¨';


--
-- Name: COLUMN cdr_compare.duration_diff; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare.duration_diff IS 'æš‚ä¸ä½¿ç”¨';


--
-- Name: COLUMN cdr_compare.calltime_diff; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare.calltime_diff IS 'æš‚ä¸ä½¿ç”¨';


--
-- Name: COLUMN cdr_compare.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare.status IS '0 æœªæ‰§è¡Œ
1 æ­£åœ¨æ‰§è¡Œ
2 å®Œæˆ
-1 æ‰“å¼€cdræ–‡ä»¶å¤±è´¥
-2 cdræ–‡ä»¶æ ¼å¼ä¸å¯¹
-3 unkown error';


--
-- Name: COLUMN cdr_compare.format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare.format IS '0.Line-by-Line ç›´æŽ¥æ¯”è¾ƒ
1.Aggregated Comparison  æ ¹æ®code name æ±‡æ€»ç»“æžœ';


--
-- Name: cdr_compare_cloud; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_compare_cloud (
    id integer NOT NULL,
    source_filename text NOT NULL,
    diff_filename text NOT NULL,
    status integer DEFAULT 0 NOT NULL,
    diff_report_file text,
    diff_cdr_file text,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    finish_time timestamp with time zone,
    format integer DEFAULT 0,
    compare_type integer NOT NULL,
    client_id integer,
    sf_count integer DEFAULT 0,
    sf_nozero_count integer DEFAULT 0,
    sf_total_duration real DEFAULT 0,
    sf_total_cost real DEFAULT 0,
    sf_mismatch_count integer DEFAULT 0,
    sf_match_count integer DEFAULT 0,
    df_count integer DEFAULT 0,
    df_nozero_count integer DEFAULT 0,
    df_total_duration real DEFAULT 0,
    df_total_cost real DEFAULT 0,
    df_mismatch_count integer DEFAULT 0,
    df_match_count integer DEFAULT 0,
    match_cdr_file character varying,
    mismatch_cdr_file character varying,
    left_right_cdr_file character varying,
    aggregated_analysis_file character varying,
    source_csv_heads character varying,
    diff_csv_heads character varying,
    source_csv_line integer,
    diff_csv_line integer,
    source_duration_type smallint DEFAULT 1,
    diff_duration_type smallint DEFAULT 1,
    active integer DEFAULT 1 NOT NULL,
    source_compare_based integer,
    diff_compare_based integer,
    source_filename_real text,
    diff_filename_real text
);


ALTER TABLE public.cdr_compare_cloud OWNER TO postgres;

--
-- Name: TABLE cdr_compare_cloud; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.cdr_compare_cloud IS 'å¯¹æ¯”';


--
-- Name: COLUMN cdr_compare_cloud.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare_cloud.status IS '0 æœªæ‰§è¡Œ
1 æ­£åœ¨æ‰§è¡Œ
2 å®Œæˆ
-1 æ‰“å¼€cdræ–‡ä»¶å¤±è´¥
-2 cdræ–‡ä»¶æ ¼å¼ä¸å¯¹
-3 unkown error';


--
-- Name: COLUMN cdr_compare_cloud.diff_report_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare_cloud.diff_report_file IS 'ä¸å†ä½¿ç”¨';


--
-- Name: COLUMN cdr_compare_cloud.diff_cdr_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare_cloud.diff_cdr_file IS 'ä¸å†ä½¿ç”¨';


--
-- Name: COLUMN cdr_compare_cloud.format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare_cloud.format IS 'ä¸å†ä½¿ç”¨
0.Line-by-Line
1.Aggregated Comparison';


--
-- Name: COLUMN cdr_compare_cloud.compare_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare_cloud.compare_type IS '0-
1-
2-';


--
-- Name: COLUMN cdr_compare_cloud.source_duration_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare_cloud.source_duration_type IS '1-min
2-sec';


--
-- Name: COLUMN cdr_compare_cloud.source_compare_based; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare_cloud.source_compare_based IS '1:Compare Based on DNIS only
2:Compare Based on ANI and DNIS';


--
-- Name: COLUMN cdr_compare_cloud.diff_compare_based; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_compare_cloud.diff_compare_based IS '1:Compare Based on DNIS only
2:Compare Based on ANI and DNIS';


--
-- Name: cdr_compare_cloud_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cdr_compare_cloud_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cdr_compare_cloud_id_seq OWNER TO postgres;

--
-- Name: cdr_compare_cloud_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cdr_compare_cloud_id_seq OWNED BY public.cdr_compare_cloud.id;


--
-- Name: cdr_compare_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cdr_compare_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cdr_compare_id_seq OWNER TO postgres;

--
-- Name: cdr_compare_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cdr_compare_id_seq OWNED BY public.cdr_compare.id;


--
-- Name: cdr_export_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_export_log (
    id integer NOT NULL,
    export_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status integer DEFAULT 0,
    file_name character varying(500),
    user_id integer,
    is_dipp boolean,
    backend_pid integer DEFAULT 0,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    sql character varying,
    file_rows integer,
    error_msg text,
    send_mail character varying(200),
    where_sql character varying,
    show_fields_sql character varying,
    total_hours integer DEFAULT 0,
    finished_hours integer DEFAULT 0,
    stop_time timestamp with time zone,
    download_cdr_from character varying(200),
    download_cdr_subject text,
    download_cdr_content text,
    download_cdr_cc character varying(200),
    send_type integer,
    total_date integer DEFAULT 0,
    finished_date integer DEFAULT 0,
    finished_time timestamp with time zone,
    job_id integer,
    pid integer,
    file_dir text,
    file_path text,
    total_days integer,
    completed_days integer
);


ALTER TABLE public.cdr_export_log OWNER TO postgres;

--
-- Name: COLUMN cdr_export_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_export_log.status IS '0 -waiting
1 - in progress
2 - query
3 - compress
4 - done
';


--
-- Name: COLUMN cdr_export_log.file_rows; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_export_log.file_rows IS 'è®°å½•æ¡æ•°';


--
-- Name: cdr_export_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cdr_export_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cdr_export_log_id_seq OWNER TO postgres;

--
-- Name: cdr_export_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cdr_export_log_id_seq OWNED BY public.cdr_export_log.id;


--
-- Name: cdr_list_export_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_list_export_log (
    id integer NOT NULL,
    file_path character varying(200),
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    job_start_time timestamp with time zone,
    job_end_time timestamp with time zone,
    line_count integer DEFAULT 0,
    status integer DEFAULT 0,
    query character varying,
    report_ip character varying(100),
    report_port integer DEFAULT 3300,
    file_type smallint DEFAULT 0,
    client_id integer
);


ALTER TABLE public.cdr_list_export_log OWNER TO postgres;

--
-- Name: cdr_list_export_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cdr_list_export_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cdr_list_export_log_id_seq OWNER TO postgres;

--
-- Name: cdr_list_export_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cdr_list_export_log_id_seq OWNED BY public.cdr_list_export_log.id;


--
-- Name: cdr_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_log (
    id integer NOT NULL,
    cdr_filename character varying(100),
    status integer,
    copy_time timestamp with time zone,
    finish_time timestamp with time zone,
    error_info text
);


ALTER TABLE public.cdr_log OWNER TO postgres;

--
-- Name: COLUMN cdr_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_log.status IS '-2--copy cdr data error
-1--open fail
1--import success
2--file empty';


--
-- Name: cdr_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cdr_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cdr_log_id_seq OWNER TO postgres;

--
-- Name: cdr_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cdr_log_id_seq OWNED BY public.cdr_log.id;


--
-- Name: cdr_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_report (
    report_time timestamp with time zone,
    duration integer,
    ingress_bill_time integer,
    ingress_call_cost numeric(15,6),
    lnp_cost numeric(15,8),
    ingress_total_calls integer,
    not_zero_calls integer,
    ingress_success_calls integer,
    ingress_busy_calls integer,
    lrn_calls integer,
    pdd bigint,
    ingress_cancel_calls integer,
    ingress_client_id integer,
    ingress_id integer,
    ingress_country character varying(100),
    ingress_code_name character varying(100),
    ingress_code character varying(100),
    egress_client_id integer,
    egress_id integer,
    egress_country character varying(100),
    egress_code_name character varying(100),
    egress_code character varying(100),
    ingress_prefix character varying(100),
    egress_bill_time integer,
    egress_call_cost numeric(15,6),
    egress_total_calls integer,
    egress_success_calls integer,
    egress_busy_calls integer,
    egress_cancel_calls integer,
    incoming_bandwidth integer,
    outgoing_bandwidth integer,
    ingress_call_cost_intra numeric(15,6),
    ingress_call_cost_inter numeric(15,6),
    egress_call_cost_intra numeric(15,6),
    egress_call_cost_inter numeric(15,6),
    ingress_bill_time_intra integer,
    ingress_bill_time_inter integer,
    egress_bill_time_intra integer,
    egress_bill_time_inter integer,
    agent_id integer,
    agent_rate double precision,
    agent_cost numeric(12,6),
    ingress_rate_table_id integer,
    route_plan_id integer,
    orig_jur_type integer,
    term_jur_type integer,
    par_id integer,
    origination_destination_host_name character varying(255),
    termination_source_host_name character varying(255),
    binary_value_of_release_cause_from_protocol_stack character varying(100),
    release_cause smallint,
    release_cause_from_protocol_stack character varying(100),
    q850_cause_count integer,
    npr_count integer,
    ingress_call_cost_local numeric(15,6),
    ingress_call_cost_ij numeric(15,6),
    egress_call_cost_local numeric(15,6),
    egress_call_cost_ij numeric(15,6),
    egress_no_ring integer,
    ring_pdd integer
);


ALTER TABLE public.cdr_report OWNER TO postgres;

--
-- Name: cdr_report_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_report_detail (
    report_time timestamp with time zone,
    duration integer,
    ingress_bill_time integer,
    ingress_call_cost numeric(15,6),
    lnp_cost numeric(15,8),
    ingress_total_calls integer,
    not_zero_calls integer,
    ingress_success_calls integer,
    ingress_busy_calls integer,
    lrn_calls integer,
    pdd bigint,
    ingress_cancel_calls integer,
    ingress_client_id integer,
    ingress_id integer,
    ingress_country character varying(100),
    ingress_code_name character varying(100),
    egress_client_id integer,
    egress_id integer,
    egress_country character varying(100),
    egress_code_name character varying(100),
    egress_code character varying(100),
    ingress_prefix character varying(100),
    egress_bill_time integer,
    egress_call_cost numeric(15,6),
    egress_total_calls integer,
    egress_success_calls integer,
    egress_busy_calls integer,
    egress_cancel_calls integer,
    not_zero_calls_30 integer,
    duration_30 integer,
    not_zero_calls_6 integer,
    duration_6 integer,
    call_18s integer,
    call_24s integer,
    call_2h integer,
    call_3h integer,
    call_4h integer,
    call_12s integer,
    ingress_rate double precision,
    egress_rate double precision,
    product_rout_id integer,
    ingress_rate_date bigint,
    egress_rate_date bigint,
    incoming_bandwidth integer,
    outgoing_bandwidth integer,
    ingress_call_cost_intra numeric(15,6),
    ingress_call_cost_inter numeric(15,6),
    egress_call_cost_intra numeric(15,6),
    egress_call_cost_inter numeric(15,6),
    ingress_bill_time_intra integer,
    ingress_bill_time_inter integer,
    egress_bill_time_intra integer,
    egress_bill_time_inter integer,
    agent_id integer,
    agent_rate double precision,
    agent_cost numeric(12,6),
    ingress_rate_table_id integer,
    route_plan_id integer,
    orig_jur_type integer,
    term_jur_type integer,
    par_id integer,
    origination_destination_host_name character varying(255),
    termination_source_host_name character varying(255),
    binary_value_of_release_cause_from_protocol_stack character varying(100),
    release_cause smallint,
    release_cause_from_protocol_stack character varying(100),
    inter_ingress_total_calls integer,
    intra_ingress_total_calls integer,
    inter_duration integer,
    intra_duration integer,
    inter_not_zero_calls integer,
    intra_not_zero_calls integer,
    q850_cause_count integer,
    npr_count integer,
    ingress_call_cost_local numeric(15,6),
    ingress_call_cost_ij numeric(15,6),
    egress_call_cost_local numeric(15,6),
    egress_call_cost_ij numeric(15,6),
    cdr_date character varying(24),
    ingress_code character varying(100),
    ring_pdd integer,
    egress_no_ring integer
);


ALTER TABLE public.cdr_report_detail OWNER TO postgres;

--
-- Name: TABLE cdr_report_detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.cdr_report_detail IS 'é¢„ç»Ÿè®¡';


--
-- Name: COLUMN cdr_report_detail.not_zero_calls_30; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_detail.not_zero_calls_30 IS 'calls between 24s and 30s';


--
-- Name: COLUMN cdr_report_detail.duration_30; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_detail.duration_30 IS 'durations between 24s and 30s';


--
-- Name: COLUMN cdr_report_detail.not_zero_calls_6; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_detail.not_zero_calls_6 IS 'calls between 1s and 6s';


--
-- Name: COLUMN cdr_report_detail.duration_6; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_detail.duration_6 IS 'durations between 1s and 6s';


--
-- Name: COLUMN cdr_report_detail.call_18s; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_detail.call_18s IS 'calls between 12s and 18s';


--
-- Name: COLUMN cdr_report_detail.call_24s; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_detail.call_24s IS 'calls between 18s and 24s';


--
-- Name: COLUMN cdr_report_detail.call_2h; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_detail.call_2h IS 'calls between 30s and 2h';


--
-- Name: COLUMN cdr_report_detail.call_3h; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_detail.call_3h IS 'calls between 2h and 3h';


--
-- Name: COLUMN cdr_report_detail.call_4h; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_detail.call_4h IS 'calls between 3h and 4h';


--
-- Name: COLUMN cdr_report_detail.call_12s; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_detail.call_12s IS 'calls between 6s and 12s';


--
-- Name: cdr_report_regenerate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_report_regenerate_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    executed_on timestamp with time zone,
    executed_by character varying(50),
    process_start_on timestamp with time zone,
    process_end_on timestamp with time zone,
    status integer DEFAULT 0,
    complete numeric(5,2) DEFAULT 0,
    is_stop boolean DEFAULT false,
    stop_time timestamp with time zone
);


ALTER TABLE public.cdr_report_regenerate_log OWNER TO postgres;

--
-- Name: COLUMN cdr_report_regenerate_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_report_regenerate_log.status IS '-2 --Stop
-1 -- Fail,
0 -- Waitingï¼Œ
1 -- In Progressï¼Œ
2 -- Finished';


--
-- Name: cdr_report_regenerate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cdr_report_regenerate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cdr_report_regenerate_log_id_seq OWNER TO postgres;

--
-- Name: cdr_report_regenerate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cdr_report_regenerate_log_id_seq OWNED BY public.cdr_report_regenerate_log.id;


--
-- Name: cdr_rerate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_rerate (
    id integer NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    finish_time timestamp with time zone,
    status integer DEFAULT 0 NOT NULL,
    rerate_type integer DEFAULT 1 NOT NULL,
    rerate_rate_time timestamp with time zone,
    rate_table_id integer,
    rate_table_name character varying(255),
    cdr_backup_file character varying(255),
    where_condition text,
    start_time timestamp with time zone NOT NULL,
    end_time timestamp with time zone NOT NULL,
    pid integer
);


ALTER TABLE public.cdr_rerate OWNER TO postgres;

--
-- Name: TABLE cdr_rerate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.cdr_rerate IS 'é‡æ–°è®¡è´¹
';


--
-- Name: COLUMN cdr_rerate.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cdr_rerate.status IS '0-æ²¡æœ‰å¤„ç†
1-è®¡è´¹å®Œæˆ
2-å¼€å§‹å¤„ç†
3-å¤‡ä»½cdr
4-åˆ é™¤cdr
5-æ‰§è¡Œé‡è®¡è´¹
6-redo report
-1-rerate exec file error
-2-rerate exec conf error
-3-rerate cdr backup conf error
-4-open cdr backup file error
-5-cdr backup error
-6-delete cdr error
-7-rerate exec error';


--
-- Name: cdr_rerate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cdr_rerate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cdr_rerate_id_seq OWNER TO postgres;

--
-- Name: cdr_rerate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cdr_rerate_id_seq OWNED BY public.cdr_rerate.id;


--
-- Name: cdr_transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cdr_transaction (
    id integer NOT NULL,
    client_id text,
    amount real,
    balance real,
    "time" timestamp with time zone
);


ALTER TABLE public.cdr_transaction OWNER TO postgres;

--
-- Name: cdr_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cdr_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cdr_transaction_id_seq OWNER TO postgres;

--
-- Name: cdr_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cdr_transaction_id_seq OWNED BY public.cdr_transaction.id;


--
-- Name: class4_call_id_cloud_shark_id_map; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.class4_call_id_cloud_shark_id_map (
    id integer NOT NULL,
    call_id character varying,
    type smallint,
    cloud_shark_id character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE public.class4_call_id_cloud_shark_id_map OWNER TO postgres;

--
-- Name: class4_call_id_cloud_shark_id_map_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.class4_call_id_cloud_shark_id_map_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.class4_call_id_cloud_shark_id_map_id_seq OWNER TO postgres;

--
-- Name: class4_call_id_cloud_shark_id_map_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.class4_call_id_cloud_shark_id_map_id_seq OWNED BY public.class4_call_id_cloud_shark_id_map.id;


--
-- Name: class4_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.class4_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    msg_info text,
    run_pid integer,
    run_type integer
);


ALTER TABLE public.class4_log OWNER TO postgres;

--
-- Name: COLUMN class4_log.run_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.class4_log.run_type IS 'create_cdr_report_table=1,0 0 * * *
update_db_record=2,*/1 * * * *
upload_check=3,no crontab
alert_route=4,*/1 * * * *
cdr_report=5,58 * * * *
create_invoice=6,57 * * * *
qos_report=7,*/1 * * * *
ftp_cdr=8,59 * * * *
rerate_cdr=9,*/10 * * * *
cdr_import=10,*/1 * * * *
dns_dig=11,*/1 * * * *
finance_transaction=12,1 1 * * *
summary_report=13,0 * * * *
low_balance_alert=14,1 * * * *
real_cdr=15,no use
cdr_down=16,59 * * * *
rate_mail=17,no use
lnp_report=18,56 * * * *
loop_alert=19,*/1 * * * *
did_report=20,58 * * * *
summary_report_minute=21,*/1 * * * *
did_invoice=22,57 * * * *
summary_balance=23,0 * * * *';


--
-- Name: class4_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.class4_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.class4_log_id_seq OWNER TO postgres;

--
-- Name: class4_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.class4_log_id_seq OWNED BY public.class4_log.id;


--
-- Name: class4_seq_invoice_no; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.class4_seq_invoice_no
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.class4_seq_invoice_no OWNER TO postgres;

--
-- Name: cleanup; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cleanup (
    id integer NOT NULL,
    name character varying(255),
    backup_frequency integer,
    data_size integer,
    data_cleansing_frequency integer,
    data_removal integer,
    ftp_server character varying(255),
    ftp_user character varying(255),
    ftp_password character varying(255),
    actived boolean DEFAULT true,
    last_time timestamp with time zone
);


ALTER TABLE public.cleanup OWNER TO postgres;

--
-- Name: cleanup_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cleanup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cleanup_id_seq OWNER TO postgres;

--
-- Name: cleanup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cleanup_id_seq OWNED BY public.cleanup.id;


--
-- Name: client_client_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_client_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_client_id_seq OWNER TO postgres;

--
-- Name: client; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client (
    client_id integer DEFAULT nextval('public.client_client_id_seq'::regclass) NOT NULL,
    name character varying(500),
    mode integer DEFAULT 1 NOT NULL,
    orig_rate_table_id integer,
    term_rate_table_id integer,
    currency_id integer NOT NULL,
    allowed_credit numeric(30,10) DEFAULT 0 NOT NULL,
    status boolean DEFAULT true NOT NULL,
    auto_invoicing boolean DEFAULT true NOT NULL,
    payment_term_id integer,
    invoice_format integer,
    attach_cdrs_list boolean,
    cdr_list_format integer,
    last_invoiced timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    notify_client_balance numeric(30,10) DEFAULT 0,
    notify_admin_balance numeric(30,10) DEFAULT 0,
    low_balance_notice boolean DEFAULT true NOT NULL,
    company character varying,
    address character varying(500),
    email character varying(100),
    logo character varying(100),
    login character varying(40),
    password character varying(50),
    is_panelaccess boolean,
    is_panel_accountsummary boolean DEFAULT true,
    is_panel_ratetable boolean DEFAULT true,
    is_panel_trunks boolean DEFAULT true,
    is_panel_products boolean DEFAULT true,
    is_panel_balance boolean DEFAULT true,
    is_panel_paymenthistory boolean DEFAULT true,
    is_panel_onlinepayment boolean DEFAULT true,
    role_id integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    profit_margin double precision DEFAULT 0 NOT NULL,
    enough_balance boolean DEFAULT true,
    service_charge_id integer,
    noc_email character varying(100),
    billing_email character varying,
    rate_email character varying(100),
    tax_id character varying(100),
    details character varying(1000),
    invoice_show_details boolean DEFAULT false,
    invoice_past_amount numeric(30,10) DEFAULT 0,
    is_link_cdr boolean DEFAULT true,
    is_trunk boolean DEFAULT false,
    is_route boolean DEFAULT false,
    is_spam boolean DEFAULT false,
    is_location boolean DEFAULT false,
    is_orig_term boolean DEFAULT false,
    is_usage boolean DEFAULT false,
    is_qos boolean DEFAULT false,
    is_discon boolean DEFAULT false,
    is_bill_mismatch boolean DEFAULT false,
    is_active_call boolean DEFAULT false,
    is_termin boolean DEFAULT false,
    database_name character varying(50),
    is_rate_anal boolean DEFAULT false,
    is_capture boolean DEFAULT false,
    is_call_simulation boolean DEFAULT false,
    is_ingress_sim boolean DEFAULT false,
    is_egress_sim boolean DEFAULT false,
    is_report boolean DEFAULT false,
    is_tools boolean DEFAULT false,
    is_manage boolean DEFAULT false,
    mail_sended integer DEFAULT 0,
    scc_bellow integer DEFAULT 0,
    scc_percent integer DEFAULT 0,
    scc_charge numeric(30,10),
    user_id integer,
    profit_type integer DEFAULT 1 NOT NULL,
    auto_invoice_type integer DEFAULT 2 NOT NULL,
    cps_limit integer,
    call_limit integer,
    invoice_zone character varying(10),
    invoice_zero boolean DEFAULT true,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    corporate_contact_email character varying(100),
    paypal character varying(100),
    is_auto_summary boolean DEFAULT false,
    auto_send_zone character varying DEFAULT '+00:00'::character varying,
    is_daily_balance_notification boolean DEFAULT false,
    daily_balance_notification integer,
    daily_balance_recipient integer,
    low_balance_number integer,
    is_auto_balance boolean DEFAULT false,
    numer_of_days_balance integer DEFAULT 1,
    auto_daily_balance_recipient integer DEFAULT 0,
    daily_cdr_generation boolean DEFAULT false,
    daily_cdr_generation_zone character varying DEFAULT '+00:00'::character varying,
    daily_cdr_generation_type smallint DEFAULT 0,
    transaction_fee_id integer,
    unlimited_credit boolean DEFAULT false,
    include_payment_history smallint DEFAULT 0,
    include_available_credit smallint DEFAULT 0,
    include_payment_history_days integer DEFAULT 1,
    auto_summary_not_zero smallint DEFAULT 0,
    auto_summary_group_by smallint DEFAULT 0,
    daily_balance_already_sent boolean DEFAULT false,
    last_autoreport_time timestamp with time zone,
    last_lowbalance_time timestamp with time zone,
    last_cdrdown_time timestamp with time zone,
    include_tax boolean DEFAULT false,
    tax numeric(5,2),
    invoice_jurisdictional_detail boolean DEFAULT false,
    decimal_place integer DEFAULT 5,
    par_id integer,
    rate_value integer DEFAULT 0,
    email_invoice boolean DEFAULT false,
    scc_type integer DEFAULT 0,
    is_invoice_account_summary boolean DEFAULT false,
    is_show_daily_usage boolean DEFAULT false,
    invoice_include_payment boolean,
    is_short_duration_call_surcharge_detail boolean DEFAULT false,
    usage_detail_fields text,
    auto_summary_hour integer,
    auto_summary_period integer DEFAULT 24,
    last_autobalance_time timestamp with time zone,
    auto_summary_include_cdr boolean DEFAULT false NOT NULL,
    client_type integer,
    rate_delivery_email character varying(250),
    invoice_use_balance_type integer DEFAULT 0,
    notify_client_balance_type integer DEFAULT 0,
    finance_email_cc character varying,
    decimals_num integer,
    invoice_start_from date,
    low_balance_notification_time_type integer DEFAULT 0,
    low_balance_notification_time_cycle integer DEFAULT 1,
    daily_balance_send_time time without time zone,
    daily_balance_send_time_zone character varying(20),
    is_breakdown_by_rate_table boolean,
    breakdown_by_rate_table smallint,
    offset_balance boolean DEFAULT true,
    is_show_detail_trunk boolean DEFAULT false,
    is_show_total_trunk boolean DEFAULT false,
    is_show_code_100 boolean DEFAULT false,
    is_show_code_name boolean DEFAULT false,
    is_show_country boolean DEFAULT false,
    is_show_by_date boolean DEFAULT false,
    daily_limit integer,
    hourly_limit integer,
    carrier_template_id integer DEFAULT 0 NOT NULL,
    is_send_trunk_update boolean DEFAULT true,
    phone character varying(20),
    is_panel_invoices boolean DEFAULT true,
    is_panel_cdrslist boolean DEFAULT true,
    is_panel_summaryreport boolean DEFAULT true,
    is_panel_sippacket boolean DEFAULT true,
    is_panel_mydid boolean DEFAULT true,
    is_panel_didrequest boolean DEFAULT true,
    is_send_as_link boolean DEFAULT false,
    is_vendor_invoice boolean DEFAULT false,
    vendor_payment_term_id integer,
    group_id integer,
    zero_balance_notice_time integer DEFAULT 0,
    zero_balance_notice_last_sent timestamp with time zone,
    zero_balance_notice_first_sended boolean DEFAULT false,
    zero_balance_notice boolean,
    auto_report_type integer,
    daily_cdr_generation_last_qcreated timestamp with time zone,
    enable_payment_alert boolean DEFAULT false,
    is_panel_cid_blocking boolean DEFAULT true,
    did_invoice_include character varying(255),
    auto_invoice_hour integer
);


ALTER TABLE public.client OWNER TO postgres;

--
-- Name: TABLE client; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.client IS 'å®¢æˆ·';


--
-- Name: COLUMN client.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.client_id IS 'ä¸»é”®';


--
-- Name: COLUMN client.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.name IS 'åç§°';


--
-- Name: COLUMN client.mode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.mode IS 'ä»˜è´¹æ¨¡å¼ï¼š1ï¼é¢„ä»˜ï¼Œ2ï¼åŽä»˜';


--
-- Name: COLUMN client.orig_rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.orig_rate_table_id IS 'æ‰“è¿›è´¹çŽ‡';


--
-- Name: COLUMN client.term_rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.term_rate_table_id IS 'æ‰“å‡ºè´¹ï¼ï¼æ²¡ç”¨ï¼Œå‡†å¤‡åˆ é™¤';


--
-- Name: COLUMN client.currency_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.currency_id IS 'è´§å¸';


--
-- Name: COLUMN client.allowed_credit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.allowed_credit IS 'å®¹è®¸æ¬ è´¹';


--
-- Name: COLUMN client.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.status IS 'çŠ¶æ€ï¼štrue-activeï¼Œfalse-inactive';


--
-- Name: COLUMN client.auto_invoicing; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.auto_invoicing IS 'æ˜¯å¦è‡ªåŠ¨ç”Ÿæˆå‘ç¥¨';


--
-- Name: COLUMN client.payment_term_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.payment_term_id IS 'ç¼´è´¹è§„åˆ™';


--
-- Name: COLUMN client.invoice_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.invoice_format IS 'ç”Ÿæˆå‘ç¥¨æ ¼å¼ï¼š1ï¼PDFï¼Œ2ï¼Excelï¼Œ3ï¼HTML';


--
-- Name: COLUMN client.attach_cdrs_list; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.attach_cdrs_list IS 'æ˜¯å¦é™„ä»¶è¯å•è¯¦ç»†';


--
-- Name: COLUMN client.cdr_list_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.cdr_list_format IS 'è¯å•æ ¼å¼ï¼š1ï¼Excelï¼Œ2ï¼CSV,
3-zip, 4-tar.gz';


--
-- Name: COLUMN client.last_invoiced; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.last_invoiced IS 'ä¸Šæ¬¡å‘ç¥¨ç”Ÿæˆæ—¥æœŸ';


--
-- Name: COLUMN client.notify_client_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.notify_client_balance IS 'æç¤ºå®¢æˆ·ä½™é¢';


--
-- Name: COLUMN client.notify_admin_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.notify_admin_balance IS 'æç¤ºç³»ç»Ÿä½™é¢';


--
-- Name: COLUMN client.low_balance_notice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.low_balance_notice IS 'æ˜¯å¦æä¾›ä½™é¢ä¸è¶³æç¤º';


--
-- Name: COLUMN client.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.company IS 'å…¬å¸åç§°';


--
-- Name: COLUMN client.address; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.address IS 'åœ°å€';


--
-- Name: COLUMN client.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.email IS 'ç”µå­é‚®ä»¶';


--
-- Name: COLUMN client.logo; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.logo IS 'logo';


--
-- Name: COLUMN client.login; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.login IS 'å®¢æˆ·æ¨¡æ¿è®¿é—®å¸å·

å®¢æˆ·ç™»å½•å¸å·';


--
-- Name: COLUMN client.password; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.password IS 'å®¢æˆ·æ¨¡æ¿è®¿é—®å¯†ç ';


--
-- Name: COLUMN client.is_panelaccess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panelaccess IS 'æ˜¯å¦èƒ½è®¿é—®å®¢æˆ·æ¨¡æ¿ï¼ï¼ä¸å†ä½¿ç”¨ï¼Œå‡†å¤‡åˆ é™¤';


--
-- Name: COLUMN client.is_panel_accountsummary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_accountsummary IS 'æ˜¯å¦èƒ½è®¿é—® Account Summary';


--
-- Name: COLUMN client.is_panel_ratetable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_ratetable IS 'æ˜¯å¦èƒ½è®¿é—® RateTable';


--
-- Name: COLUMN client.is_panel_trunks; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_trunks IS 'æ˜¯å¦èƒ½è®¿é—® Trunks';


--
-- Name: COLUMN client.is_panel_products; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_products IS 'æ˜¯å¦èƒ½è®¿é—®products';


--
-- Name: COLUMN client.is_panel_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_balance IS 'æ˜¯å¦èƒ½è®¿é—® Balance';


--
-- Name: COLUMN client.is_panel_paymenthistory; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_paymenthistory IS 'æ˜¯å¦å¯ä»¥è®¿é—®Payment History';


--
-- Name: COLUMN client.is_panel_onlinepayment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_onlinepayment IS 'æ˜¯å¦èƒ½è®¿é—® Online Payment';


--
-- Name: COLUMN client.role_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.role_id IS 'è§’è‰²';


--
-- Name: COLUMN client.create_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.create_time IS 'æ²¡ç”¨ï¼ï¼å‡†å¤‡åˆ é™¤';


--
-- Name: COLUMN client.profit_margin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.profit_margin IS 'æœ€ä½Žåˆ©æ¶¦çŽ‡';


--
-- Name: COLUMN client.enough_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.enough_balance IS 'æ˜¯å¦ä½™é¢ä¸è¶³';


--
-- Name: COLUMN client.is_link_cdr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_link_cdr IS 'æ˜¯å¦å¯ä»¥ é“¾æŽ¥ä¸‹è½½cdr';


--
-- Name: COLUMN client.mail_sended; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.mail_sended IS '0-æ²¡æœ‰å‘é€
1-ä½™é¢ä¸è¶³å‘é€';


--
-- Name: COLUMN client.scc_bellow; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.scc_bellow IS 'call_durationå‘¼å«æ—¶é•¿å°‘äºŽè¿™ä¸ªå€¼çš„è®¡ä¸€ä¸ªshort call';


--
-- Name: COLUMN client.scc_percent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.scc_percent IS 'short callçš„answered*100/allå¤§äºŽè¿™ä¸ªå€¼å°±åœ¨invoiceä¸­å¢žåŠ çŸ­æš‚å‘¼å«ç½šæ¬¾';


--
-- Name: COLUMN client.scc_charge; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.scc_charge IS 'çŸ­æš‚å‘¼å«ç½šæ¬¾é‡‘é¢';


--
-- Name: COLUMN client.profit_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.profit_type IS '1--ç™¾åˆ†æ¯”
2--æ•°å€¼';


--
-- Name: COLUMN client.auto_invoice_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.auto_invoice_type IS '0:buy(client)
1:sell(vendor)
2:both';


--
-- Name: COLUMN client.invoice_zero; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.invoice_zero IS 'é»˜è®¤ä¸ç”Ÿæˆ';


--
-- Name: COLUMN client.daily_balance_recipient; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.daily_balance_recipient IS '0:Partner''s Billing Contact
1:Owner''s Billing Contact
2:Both';


--
-- Name: COLUMN client.auto_summary_group_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.auto_summary_group_by IS '<option value="0">By Country</option>
<option value="1">By Code Name</option>
 <option value="2">By Code</option>';


--
-- Name: COLUMN client.decimal_place; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.decimal_place IS 'å°æ•°ä½æ•°ï¼Œé»˜è®¤5ä½';


--
-- Name: COLUMN client.scc_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.scc_type IS '0 meeting the short duration defined above
1 that exceed the defined percentage';


--
-- Name: COLUMN client.auto_summary_period; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.auto_summary_period IS '1
2
4
6
8
12
24
-15
-30';


--
-- Name: COLUMN client.client_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.client_type IS 'did
0 vendor
1 client
';


--
-- Name: COLUMN client.invoice_use_balance_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.invoice_use_balance_type IS '0-actual
1-mutual';


--
-- Name: COLUMN client.is_breakdown_by_rate_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_breakdown_by_rate_table IS 'invoice æ˜¯å¦æ˜¾ç¤º Break Down by Rate Table';


--
-- Name: COLUMN client.breakdown_by_rate_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.breakdown_by_rate_table IS 'breakdown_by_rate_table çš„ç±»åž‹
1ï¼šBreakdown A-Z Rate Table by Destination
2ï¼š Breakdown US Rate Table by Jurisdiction';


--
-- Name: COLUMN client.carrier_template_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.carrier_template_id IS 'ä½¿ç”¨Carrier Templateæ¨¡æ¿ï¼Œé»˜è®¤ä¸º0ï¼Œä¸ä½¿ç”¨æ¨¡æ¿';


--
-- Name: COLUMN client.is_send_trunk_update; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_send_trunk_update IS 'åœ¨æ”¹å˜å…¶trunk ipæ—¶æ˜¯å¦å‘é€é‚®ä»¶';


--
-- Name: COLUMN client.is_panel_invoices; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_invoices IS 'æ˜¯å¦èƒ½è®¿é—® Invoices';


--
-- Name: COLUMN client.is_panel_cdrslist; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_cdrslist IS 'æ˜¯å¦èƒ½è®¿é—® CDRs List';


--
-- Name: COLUMN client.is_panel_summaryreport; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_summaryreport IS 'æ˜¯å¦èƒ½è®¿é—® Summary Report';


--
-- Name: COLUMN client.is_panel_sippacket; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_sippacket IS 'æ˜¯å¦èƒ½è®¿é—® SIP PACKET Search';


--
-- Name: COLUMN client.is_panel_mydid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_mydid IS 'æ˜¯å¦èƒ½è®¿é—® My DID';


--
-- Name: COLUMN client.is_panel_didrequest; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client.is_panel_didrequest IS 'æ˜¯å¦èƒ½è®¿é—® DID Request';


--
-- Name: client_balance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_balance (
    client_id character varying(100) NOT NULL,
    balance character varying(100) DEFAULT 0.00 NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    ingress_balance character varying(100) DEFAULT 0,
    egress_balance character varying(100) DEFAULT 0,
    bod_balance character varying(100) DEFAULT 0.00 NOT NULL
);


ALTER TABLE public.client_balance OWNER TO postgres;

--
-- Name: TABLE client_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.client_balance IS 'å®¢æˆ·æ¯æ¬¡é€šè¯ï¼Œæˆ–è€…æ¯æ¬¡å……å€¼çš„ä½™é¢è®¡ç®—è¡¨';


--
-- Name: COLUMN client_balance.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_balance.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN client_balance.balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_balance.balance IS 'å½“å‰ä½™é¢';


--
-- Name: COLUMN client_balance.create_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_balance.create_time IS 'æ”¹åŠ¨æ—¶é—´';


--
-- Name: COLUMN client_balance.bod_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_balance.bod_balance IS 'begin of day balance:å½“å¤©0ç‚¹æ—¶çš„balance';


--
-- Name: client_balance_operation_action; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_balance_operation_action (
    id integer NOT NULL,
    client_id integer,
    balance numeric(12,6) DEFAULT 0.00 NOT NULL,
    ingress_balance numeric(12,6) DEFAULT 0.00 NOT NULL,
    egress_balance numeric(12,6) DEFAULT 0.00 NOT NULL,
    action integer,
    update_result integer DEFAULT 0 NOT NULL,
    update_by character varying(100),
    update_time timestamp with time zone,
    create_by character varying(100),
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL
);


ALTER TABLE public.client_balance_operation_action OWNER TO postgres;

--
-- Name: COLUMN client_balance_operation_action.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_balance_operation_action.action IS '0-Added a new client balance, 1-Reset client balance, ingress balance, egress balance, 2-Increase ingress balance, 3-Decrease ingress balance, 4-Increase egress balance, 5-Decrease egress balance';


--
-- Name: COLUMN client_balance_operation_action.update_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_balance_operation_action.update_result IS '0-Initial, 1-Update completed, 2-Update failed';


--
-- Name: client_balance_operation_action_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_balance_operation_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_balance_operation_action_id_seq OWNER TO postgres;

--
-- Name: client_balance_operation_action_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.client_balance_operation_action_id_seq OWNED BY public.client_balance_operation_action.id;


--
-- Name: client_balance_test; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_balance_test (
    client_id character varying(100),
    balance numeric(20,10),
    create_time timestamp with time zone,
    ingress_balance numeric(20,10),
    egress_balance numeric(20,10),
    bod_balance character varying(100)
);


ALTER TABLE public.client_balance_test OWNER TO postgres;

--
-- Name: client_cdr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_cdr (
    id bigint,
    record_sequence_number character varying(100),
    version_number character varying(100),
    record_type character varying(100),
    connection_type character varying(100),
    session_id character varying(100),
    release_cause smallint,
    start_time_of_date bigint,
    answer_time_of_date bigint,
    release_tod bigint,
    minutes_west_of_greenwich_mean_time smallint,
    release_cause_from_protocol_stack character varying(100),
    binary_value_of_release_cause_from_protocol_stack character varying(100),
    first_release_dialogue character varying(100),
    trunk_id_origination character varying(100),
    voip_protocol_origination character varying(100),
    origination_source_number character varying(100),
    origination_source_host_name character varying(100),
    origination_destination_number character varying(100),
    origination_destination_host_name character varying(100),
    origination_call_id character varying(150),
    origination_remote_payload_ip_address character varying(100),
    origination_remote_payload_udp_address integer,
    origination_local_payload_ip_address character varying(100),
    origination_local_payload_udp_address integer,
    origination_codec_list character varying(100),
    origination_ingress_packets integer,
    origination_egress_packets integer,
    origination_ingress_octets integer,
    origination_egress_octets integer,
    origination_ingress_packet_loss integer,
    origination_ingress_delay integer,
    origination_ingress_packet_jitter integer,
    trunk_id_termination character varying(100),
    voip_protocol_termination character varying(100),
    termination_source_number character varying(100),
    termination_source_host_name character varying(100),
    termination_destination_number character varying(100),
    termination_destination_host_name character varying(100),
    termination_call_id character varying(150),
    termination_remote_payload_ip_address character varying(100),
    termination_remote_payload_udp_address integer,
    termination_local_payload_ip_address character varying(100),
    termination_local_payload_udp_address integer,
    termination_codec_list character varying(100),
    termination_ingress_packets integer,
    termination_egress_packets integer,
    termination_ingress_octets integer,
    termination_egress_octets integer,
    termination_ingress_packet_loss integer,
    termination_ingress_delay integer,
    termination_ingress_packet_jitter integer,
    final_route_indication character varying(100),
    routing_digits character varying(100),
    call_duration integer,
    pdd integer,
    ring_time bigint,
    callduration_in_ms integer,
    conf_id character varying(100),
    call_type smallint,
    ingress_id integer,
    ingress_client_id integer,
    ingress_client_rate_table_id integer,
    ingress_client_currency_id integer,
    ingress_client_rate double precision,
    ingress_client_currency character varying(100),
    ingress_client_bill_time integer,
    ingress_client_bill_result smallint,
    ingress_client_cost numeric(12,6),
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    egress_id integer,
    egress_rate_table_id integer,
    egress_rate double precision,
    egress_cost numeric(12,6),
    egress_bill_time integer,
    egress_client_id integer,
    egress_client_currency_id integer,
    egress_client_currency character varying(100),
    egress_six_seconds integer,
    egress_bill_minutes real,
    egress_bill_result smallint,
    ingress_bill_minutes real,
    ingress_dnis_type smallint,
    ingress_rate_type smallint,
    lrn_dnis character varying(100),
    egress_dnis_type smallint,
    egress_rate_type smallint,
    translation_ani character varying(100),
    ani_code_id integer,
    dnis_code_id integer,
    item_id integer,
    ingress_rate_id integer,
    egress_rate_id integer,
    rerate_time timestamp with time zone,
    orig_code character varying(100),
    orig_code_name character varying(100),
    orig_country character varying(100),
    term_code character varying(100),
    term_code_name character varying(100),
    term_country character varying(100),
    ingress_rate_effective_date bigint,
    egress_rate_effective_date bigint,
    egress_erro_string text,
    route_plan integer,
    dynamic_route integer,
    static_route integer,
    contract_id character varying(100),
    order_id character varying(100),
    order_type character varying(100),
    lrn_number_vendor smallint,
    lnp_dipping_cost numeric(10,8),
    is_final_call smallint,
    egress_code_asr real,
    egress_code_acd real,
    route_prefix character varying(100),
    is_manual_kill boolean DEFAULT false,
    orig_call_duration integer,
    orig_delay_second integer,
    term_delay_second integer,
    trunk_type smallint,
    origination_profile_port integer,
    termination_profile_port integer,
    o_trunk_type2 smallint,
    o_billing_method smallint,
    t_trunk_type2 smallint,
    t_billing_method smallint,
    campaign_id integer,
    tax integer,
    agent_id integer,
    agent_rate double precision,
    agent_cost numeric(12,6),
    orig_jur_type integer,
    term_jur_type integer,
    ring_epoch bigint,
    end_epoch bigint,
    par_id integer,
    paid_user character varying(100),
    rpid_user character varying(100),
    timeout_type smallint,
    q850_cause integer,
    q850_cause_string character varying(100),
    route_id integer
);


ALTER TABLE public.client_cdr OWNER TO postgres;

--
-- Name: COLUMN client_cdr.release_cause; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.release_cause IS 'è¿”å›žç»™ä¸»å«çš„é”™è¯¯ç ï¼Œä¸€å…±20ç§ã€‚

        REC_CALL_ARGS = 0,
        REC_SYSTEM_CAP = 1,
        REC_SYSTEM_CPS = 2,
        REC_INGRESS_IP_CHECK = 3,
        REC_INGRESS_RESOURCE = 4,
        REC_PRODUCT_CHECK = 5,
        REC_IN_RESORUCE_CAP = 6,
        REC_IN_RESORUCE_CPS = 7,
        REC_IN_RESORUCE_IP_CAP = 8,
        REC_IN_RESORUCE_IP_CPS = 9,
        REC_RESOURCE_CODEC = 10,
        REC_INGRESS_LRN_BLOCK = 11,
        REC_INGRESS_RATE = 12,
        REC_EGRESS_NOT_FOUND = 13,
        REC_EGRESS_RESPONSE404 = 14,
        REC_EGRESS_RESPONSE486 = 15,
        REC_EGRESS_RESPONSE487 = 16,
        REC_EGRESS_RESPONSE200 = 17,
        REC_ALL_EGRESS_FAILED = 81,
        REC_NORMAL = 19

        { "0", "404", "Not Found" },
        { "1", "503", "Service Unavailable" },
        { "2", "503", "Service Unavailable" },
        { "3", "403", "Forbidden" },
        { "4", "403", "Forbidden" },
        { "5", "403", "Forbidden" },
        { "6", "503", "Service Unavailable" },
        { "7", "503", "Service Unavailable" },
        { "8", "503", "Service Unavailable" },
        { "9", "503", "Service Unavailable" },
        { "10", "415", "Unsupported Media Type" },
        { "11", "403", "Forbidden" },
        { "12", "403", "Forbidden" },
        { "13", "403", "Forbidden" },
        { "14", "404", "Not Found" },
        { "15", "486", "Busy Here" },
        { "16", "503", "Service Unavailable" },
        { "17", "200", "OK" },
        { "18", "503", "Service Unavailable" },
        { "19", "200", "OK" }



ç³»ç»Ÿå®šä¹‰é”™è¯¯ç ç¿»è¯‘ï¼Œå¦‚æžœæœ‰ä¸å¦¥å½“çš„è¯·æ¢å¤ä¸€ä¸‹ã€‚

REC_CALL_ARGS Invalid Argument
REC_SYSTEM_CAP System Limit Exceeded
REC_SYSTEM_CPS System Limit Exceeded
REC_INGRESS_IP_CHECK Unauthorized IP Address
REC_INGRESS_RESOURCE No Ingress Resource Found
REC_PRODUCT_CHECK No Product Found
REC_IN_RESORUCE_CAP Trunk Limit Exceeded
REC_IN_RESORUCE_CPS Trunk Limit Exceeded
REC_IN_RESORUCE_IP_CAP IP Limit Exceeded
REC_IN_RESORUCE_IP_CPS IP Limit Exceeded
REC_RESOURCE_CODEC Invalid Codec Negotiation
REC_INGRESS_LRN_BLOCK Block due to LRN
REC_INGRESS_RATE Ingress Rate Not Found
REC_EGRESS_NOT_FOUND Egress Trunk Not Found
REC_EGRESS_RESPONSE404 From egress response 404
REC_EGRESS_RESPONSE486 From egress response 486
REC_EGRESS_RESPONSE487 From egress response 487
REC_EGRESS_RESPONSE200 From egress response 200
REC_ALL_EGRESS_FAILED All egress not available
REC_NORMAL Normal



';


--
-- Name: COLUMN client_cdr.release_cause_from_protocol_stack; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.release_cause_from_protocol_stack IS '
ingress
æ‰“è¿›ç¹å¿™çš„call 486
æ‰“è¿›æ²¡æœ‰é€šé“çš„call  503
è¢«å«è¿”å›žçš„

ingress_to_egress

è¿”å›žç»™egress çš„ åŽŸå› Response From Egress';


--
-- Name: COLUMN client_cdr.binary_value_of_release_cause_from_protocol_stack; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.binary_value_of_release_cause_from_protocol_stack IS 'è¿”å›žç»™ä¸»å«çš„åŽŸå›
ingress_to_ingress

è¿”å›žç»™ingress çš„åŽŸå›     Response TO Ingress';


--
-- Name: COLUMN client_cdr.trunk_id_origination; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.trunk_id_origination IS 'trunk_id_origination

å¯¹æŽ¥ç½‘å…³çš„alais';


--
-- Name: COLUMN client_cdr.trunk_id_termination; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.trunk_id_termination IS 'è¢«å«ä¿¡æ¯ï¼Œè½åœ°ç½‘å…³ï¼Œegress alias
ä¸ºç©º ï¼ï¼æ‰¾ä¸åˆ°è·¯ç”±çš„cdr';


--
-- Name: COLUMN client_cdr.routing_digits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.routing_digits IS 'è¢«å«å·';


--
-- Name: COLUMN client_cdr.call_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.call_duration IS 'é€šè¯æ—¶é•¿
æ‰“è¿›-ä¸ä¸º0çš„call call_duration>0çš„cdr';


--
-- Name: COLUMN client_cdr.ingress_client_bill_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.ingress_client_bill_result IS ' æ‰“è¿› è®¡è´¹ç»“æžœ
1ï¼ï¼æˆåŠŸ
2ï¼ï¼Calls with unknown clients

3ï¼ï¼è´¹çŽ‡æ¨¡æ¿æ‰¾ä¸åˆ°
4ï¼ï¼è´¹çŽ‡æ‰¾ä¸åˆ°
5--Calls with unknown destinations (known clients)
6--';


--
-- Name: COLUMN client_cdr.ingress_client_cost; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.ingress_client_cost IS 'é€šè¯è´¹ç”¨(å¯¹æŽ¥ç½‘å…³çš„é’±)

incoming';


--
-- Name: COLUMN client_cdr."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr."time" IS 'æ’å…¥æ•°æ®åº“çš„æ—¶é—´';


--
-- Name: COLUMN client_cdr.egress_cost; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.egress_cost IS 'æˆæœ¬ï¼ï¼è½åœ°ç½‘å…³çš„é’±
outgoing';


--
-- Name: COLUMN client_cdr.egress_bill_minutes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.egress_bill_minutes IS 'æ‰“å‡º  è®¡è´¹ç»“æžœ';


--
-- Name: COLUMN client_cdr.egress_bill_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.egress_bill_result IS '
Termination
è®¡è´¹ç»“æžœ
1ï¼ï¼æˆåŠŸ
2ï¼ï¼è´¦å·æ‰¾ä¸åˆ°
3ï¼ï¼è´¹çŽ‡æ¨¡æ¿æ‰¾ä¸åˆ°
4ï¼ï¼è´¹çŽ‡æ‰¾ä¸åˆ°';


--
-- Name: COLUMN client_cdr.ingress_dnis_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.ingress_dnis_type IS '0-dnis
1-lrn
2-lrn block';


--
-- Name: COLUMN client_cdr.ingress_rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.ingress_rate_type IS '1ï¼ï¼interstate
2ï¼ï¼intrastate
3ï¼ï¼others
4 -- error
5 -- local rate';


--
-- Name: COLUMN client_cdr.egress_dnis_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.egress_dnis_type IS '0-dnis
1-lrn
2-lrn block';


--
-- Name: COLUMN client_cdr.egress_rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.egress_rate_type IS '1. --interstate
2. --intrastate
3. --others
4. --error
5. --local rate

';


--
-- Name: COLUMN client_cdr.translation_ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.translation_ani IS 'è½¬æ¢åŽçš„ä¸»å«å·';


--
-- Name: COLUMN client_cdr.item_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.item_id IS 'é™æ€è·¯ç”±è¡¨prefix ID';


--
-- Name: COLUMN client_cdr.rerate_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.rerate_time IS 'é‡æ–°è®¡è´¹çš„æ—¶é—´';


--
-- Name: COLUMN client_cdr.orig_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.orig_code IS 'æ‰“è¿›å·ç ';


--
-- Name: COLUMN client_cdr.orig_code_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.orig_code_name IS 'æ‰“è¿›å·ç åç§°';


--
-- Name: COLUMN client_cdr.orig_country; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.orig_country IS 'æ‰“è¿›å›½å®¶';


--
-- Name: COLUMN client_cdr.egress_erro_string; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.egress_erro_string IS 'è¿”å›žé”™è¯¯åŽŸå› ';


--
-- Name: COLUMN client_cdr.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.order_type IS '1--buy order
2--sell order';


--
-- Name: COLUMN client_cdr.lrn_number_vendor; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.lrn_number_vendor IS '1-client
2-lrn server';


--
-- Name: COLUMN client_cdr.lnp_dipping_cost; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.lnp_dipping_cost IS 'ï¼ï¼lrn_number_vendorä¸º2ï¼Œæ­¤å˜é‡æœ‰æ•ˆ
ï¼ï¼client_balanceé‡Œå®žæ—¶æ‰£è´¹
ï¼ï¼å¤±è´¥çš„å‘¼å«ä¹Ÿä¼šæ‰£æ­¤è´¹ç”¨';


--
-- Name: COLUMN client_cdr.is_final_call; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.is_final_call IS '0-é»˜è®¤å¿½ç•¥
1-æœ€åŽä¸€ä¸ªè·¯ç”±';


--
-- Name: COLUMN client_cdr.orig_jur_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.orig_jur_type IS 'from rate_table jur_type';


--
-- Name: COLUMN client_cdr.term_jur_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.term_jur_type IS 'from rate_table';


--
-- Name: COLUMN client_cdr.ring_epoch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.ring_epoch IS 'å¾—åˆ°180æˆ–183çš„æ—¶é—´';


--
-- Name: COLUMN client_cdr.end_epoch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_cdr.end_epoch IS 'è¢«å«æ”¶åˆ°byeæˆ–å‘ç»™è¢«å«byeçš„æ—¶é—´';


--
-- Name: client_cdr_delete_bak; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_cdr_delete_bak (
    id bigint NOT NULL,
    record_sequence_number character varying(100),
    version_number character varying(100),
    record_type character varying(100),
    connection_type character varying(100),
    session_id character varying(100),
    release_cause smallint,
    start_time_of_date bigint,
    answer_time_of_date bigint,
    release_tod bigint,
    minutes_west_of_greenwich_mean_time smallint,
    release_cause_from_protocol_stack character varying(100),
    binary_value_of_release_cause_from_protocol_stack character varying(100),
    first_release_dialogue character varying(100),
    trunk_id_origination character varying(100),
    voip_protocol_origination character varying(100),
    origination_source_number character varying(100),
    origination_source_host_name character varying(100),
    origination_destination_number character varying(100),
    origination_destination_host_name character varying(100),
    origination_call_id character varying(150),
    origination_remote_payload_ip_address character varying(100),
    origination_remote_payload_udp_address integer,
    origination_local_payload_ip_address character varying(100),
    origination_local_payload_udp_address integer,
    origination_codec_list character varying(100),
    origination_ingress_packets integer,
    origination_egress_packets integer,
    origination_ingress_octets integer,
    origination_egress_octets integer,
    origination_ingress_packet_loss integer,
    origination_ingress_delay integer,
    origination_ingress_packet_jitter integer,
    trunk_id_termination character varying(100),
    voip_protocol_termination character varying(100),
    termination_source_number character varying(100),
    termination_source_host_name character varying(100),
    termination_destination_number character varying(100),
    termination_destination_host_name character varying(100),
    termination_call_id character varying(150),
    termination_remote_payload_ip_address character varying(100),
    termination_remote_payload_udp_address integer,
    termination_local_payload_ip_address character varying(100),
    termination_local_payload_udp_address integer,
    termination_codec_list character varying(100),
    termination_ingress_packets integer,
    termination_egress_packets integer,
    termination_ingress_octets integer,
    termination_egress_octets integer,
    termination_ingress_packet_loss integer,
    termination_ingress_delay integer,
    termination_ingress_packet_jitter integer,
    final_route_indication character varying(100),
    routing_digits character varying(100),
    call_duration integer,
    pdd integer,
    ring_time bigint,
    callduration_in_ms integer,
    conf_id character varying(100),
    call_type smallint,
    ingress_id integer,
    ingress_client_id integer,
    ingress_client_rate_table_id integer,
    ingress_client_currency_id integer,
    ingress_client_rate double precision,
    ingress_client_currency character varying(100),
    ingress_client_bill_time integer,
    ingress_client_bill_result smallint,
    ingress_client_cost numeric(12,6),
    "time" timestamp with time zone,
    egress_id integer,
    egress_rate_table_id integer,
    egress_rate double precision,
    egress_cost numeric(12,6),
    egress_bill_time integer,
    egress_client_id integer,
    egress_client_currency_id integer,
    egress_client_currency character varying(100),
    egress_six_seconds integer,
    egress_bill_minutes real,
    egress_bill_result smallint,
    ingress_bill_minutes real,
    ingress_dnis_type smallint,
    ingress_rate_type smallint,
    lrn_dnis character varying(100),
    egress_dnis_type smallint,
    egress_rate_type smallint,
    translation_ani character varying(100),
    ani_code_id integer,
    dnis_code_id integer,
    item_id integer,
    ingress_rate_id integer,
    egress_rate_id integer,
    rerate_time timestamp with time zone,
    orig_code character varying(100),
    orig_code_name character varying(100),
    orig_country character varying(100),
    term_code character varying(100),
    term_code_name character varying(100),
    term_country character varying(100),
    ingress_rate_effective_date bigint,
    egress_rate_effective_date bigint,
    egress_erro_string text,
    route_plan integer,
    dynamic_route integer,
    static_route integer,
    contract_id character varying(100),
    order_id character varying(100),
    order_type character varying(100),
    lrn_number_vendor smallint,
    lnp_dipping_cost numeric(10,8),
    is_final_call smallint,
    egress_code_asr real,
    egress_code_acd real,
    route_prefix character varying(100),
    is_manual_kill boolean,
    orig_call_duration integer,
    orig_delay_second integer,
    term_delay_second integer,
    trunk_type smallint,
    origination_profile_port integer,
    termination_profile_port integer,
    o_trunk_type2 smallint,
    o_billing_method smallint,
    t_trunk_type2 smallint,
    t_billing_method smallint,
    campaign_id integer,
    tax integer,
    agent_id integer,
    agent_rate double precision,
    agent_cost numeric(12,6),
    orig_jur_type integer,
    term_jur_type integer,
    ring_epoch bigint,
    end_epoch bigint,
    par_id integer,
    paid_user character varying(100),
    rpid_user character varying(100),
    timeout_type smallint,
    q850_cause integer,
    q850_cause_string character varying(100)
);


ALTER TABLE public.client_cdr_delete_bak OWNER TO postgres;

--
-- Name: client_cdr_new_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_cdr_new_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_cdr_new_id_seq OWNER TO postgres;

--
-- Name: client_commit_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_commit_code (
    id integer NOT NULL,
    ingress_id integer,
    egress_id integer,
    code public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    contract_id integer
);


ALTER TABLE public.client_commit_code OWNER TO postgres;

--
-- Name: client_commit_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_commit_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_commit_code_id_seq OWNER TO postgres;

--
-- Name: client_commit_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.client_commit_code_id_seq OWNED BY public.client_commit_code.id;


--
-- Name: client_commit_code_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_commit_code_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_commit_code_record_record_id_seq OWNER TO postgres;

--
-- Name: client_commit_code_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_commit_code_record (
    id integer,
    ingress_id integer,
    egress_id integer,
    code public.prefix_range,
    contract_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.client_commit_code_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.client_commit_code_record OWNER TO postgres;

--
-- Name: client_commit_minutes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_commit_minutes (
    id integer NOT NULL,
    client_id integer,
    ingress_id integer,
    commit_minutes bigint DEFAULT 0 NOT NULL,
    contract_id integer
);


ALTER TABLE public.client_commit_minutes OWNER TO postgres;

--
-- Name: client_commit_minutes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_commit_minutes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_commit_minutes_id_seq OWNER TO postgres;

--
-- Name: client_commit_minutes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.client_commit_minutes_id_seq OWNED BY public.client_commit_minutes.id;


--
-- Name: client_commit_minutes_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_commit_minutes_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_commit_minutes_record_record_id_seq OWNER TO postgres;

--
-- Name: client_commit_minutes_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_commit_minutes_record (
    id integer,
    client_id integer,
    ingress_id integer,
    commit_minutes bigint,
    contract_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.client_commit_minutes_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.client_commit_minutes_record OWNER TO postgres;

--
-- Name: client_day_cost; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_day_cost (
    client_id integer,
    cost_date timestamp with time zone,
    buy_cost numeric(30,10),
    sell_cost numeric(30,10)
);


ALTER TABLE public.client_day_cost OWNER TO postgres;

--
-- Name: client_finance_transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_finance_transaction (
    id integer NOT NULL,
    client_id integer,
    amount real,
    transaction_type integer,
    transaction_time timestamp with time zone
);


ALTER TABLE public.client_finance_transaction OWNER TO postgres;

--
-- Name: COLUMN client_finance_transaction.transaction_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_finance_transaction.transaction_type IS '1-buy
2-sell
3-deposit
4-withdraw
0-balance';


--
-- Name: client_finance_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_finance_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_finance_transaction_id_seq OWNER TO postgres;

--
-- Name: client_finance_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.client_finance_transaction_id_seq OWNED BY public.client_finance_transaction.id;


--
-- Name: client_low_balance_config; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_low_balance_config (
    client_id integer NOT NULL,
    is_notify boolean,
    value_type integer,
    actual_notify_balance numeric(30,2),
    percentage_notify_balance numeric(30,2),
    send_time_type integer,
    daily_send_time integer,
    duplicate_days integer,
    send_to integer,
    duplicate_send_days integer DEFAULT 0 NOT NULL,
    last_alert_time timestamp with time zone,
    disable_trunks_days integer DEFAULT 5
);


ALTER TABLE public.client_low_balance_config OWNER TO postgres;

--
-- Name: COLUMN client_low_balance_config.is_notify; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_low_balance_config.is_notify IS 'æ˜¯å¦æ£€æµ‹';


--
-- Name: COLUMN client_low_balance_config.value_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_low_balance_config.value_type IS '0 =>Actual Balance,1 =>Percentage';


--
-- Name: COLUMN client_low_balance_config.send_time_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_low_balance_config.send_time_type IS '0 => daily, 1=> hourly';


--
-- Name: COLUMN client_low_balance_config.daily_send_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_low_balance_config.daily_send_time IS 'if selected daily to choose between 00:00 - 23:00 GMT';


--
-- Name: COLUMN client_low_balance_config.duplicate_days; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_low_balance_config.duplicate_days IS 'é‡å¤å‘é€å‡ å¤©';


--
-- Name: COLUMN client_low_balance_config.send_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_low_balance_config.send_to IS '0 => Owner''sBilling Contact,  1 =>  Partner''s Billing Contact,  2 => Both';


--
-- Name: COLUMN client_low_balance_config.duplicate_send_days; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_low_balance_config.duplicate_send_days IS 'å·²ç»å‘é€çš„å¤©æ•°';


--
-- Name: client_payment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_payment (
    client_payment_id integer NOT NULL,
    payment_time timestamp with time zone NOT NULL,
    amount numeric(20,10) NOT NULL,
    result boolean NOT NULL,
    client_id integer,
    cause character varying(20),
    description character varying(500),
    approved boolean,
    current_balance numeric(30,10) DEFAULT 0,
    invoice_number character varying(100),
    payment_type integer DEFAULT 1,
    payment_method integer,
    email_sended boolean DEFAULT false,
    update_by character varying,
    receiving_time timestamp with time zone,
    egress_amount numeric
);


ALTER TABLE public.client_payment OWNER TO postgres;

--
-- Name: TABLE client_payment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.client_payment IS 'å®¢æˆ·æ¯æ¬¡å……å€¼è®°å½•è¡¨';


--
-- Name: COLUMN client_payment.client_payment_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_payment.client_payment_id IS 'ä¸»é”®';


--
-- Name: COLUMN client_payment.payment_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_payment.payment_time IS 'å……å€¼æ—¶é—´';


--
-- Name: COLUMN client_payment.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_payment.amount IS 'å……å€¼é‡‘é¢';


--
-- Name: COLUMN client_payment.result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_payment.result IS 'å……å€¼ç»“æžœ(æˆåŠŸ/å¤±è´¥)';


--
-- Name: COLUMN client_payment.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_payment.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN client_payment.cause; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_payment.cause IS 'æ²¡ç”¨ï¼ï¼å‡†å¤‡åˆ é™¤';


--
-- Name: COLUMN client_payment.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_payment.description IS 'è®¾ç½®reset balance çš„note';


--
-- Name: COLUMN client_payment.approved; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_payment.approved IS 'æ˜¯å¦ç»è¿‡å®¡æ ¸';


--
-- Name: COLUMN client_payment.payment_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_payment.payment_type IS '3:invoice payment sent
4:invoice payment received
5:prepay payment received
6:payment sent
7:credit note received
8:credit note sent
9:reset
10:offset
11: debit received
12:debit sent
13:mutual reset
14:actual reset
15:scc cost';


--
-- Name: client_payment_client_payment_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_payment_client_payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_payment_client_payment_id_seq OWNER TO postgres;

--
-- Name: client_payment_client_payment_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.client_payment_client_payment_id_seq OWNED BY public.client_payment.client_payment_id;


--
-- Name: client_rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_rate (
    client_id integer,
    rate_table_id integer,
    code character varying(20),
    code_name character varying(50),
    country character varying(50),
    rate numeric(30,10),
    "interval" integer DEFAULT 1,
    effective_date timestamp with time zone,
    end_date timestamp with time zone,
    send_date timestamp with time zone
);


ALTER TABLE public.client_rate OWNER TO postgres;

--
-- Name: client_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_record_record_id_seq OWNER TO postgres;

--
-- Name: client_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_record (
    client_id integer,
    name character varying(500),
    mode integer,
    orig_rate_table_id integer,
    term_rate_table_id integer,
    currency_id integer,
    allowed_credit numeric(30,10),
    status boolean,
    auto_invoicing boolean,
    payment_term_id integer,
    invoice_format integer,
    attach_cdrs_list boolean,
    cdr_list_format integer,
    last_invoiced timestamp with time zone,
    notify_client_balance numeric(30,10),
    notify_admin_balance numeric(30,10),
    low_balance_notice boolean,
    company character varying,
    address character varying(500),
    email character varying(100),
    logo character varying(100),
    login character varying(40),
    password character varying(50),
    is_panelaccess boolean,
    is_panel_accountsummary boolean,
    is_panel_ratetable boolean,
    is_panel_trunks boolean,
    is_panel_products boolean,
    is_panel_balance boolean,
    is_panel_paymenthistory boolean,
    is_panel_onlinepayment boolean,
    role_id integer,
    create_time timestamp with time zone,
    profit_margin double precision,
    enough_balance boolean,
    service_charge_id integer,
    noc_email character varying(100),
    billing_email character varying,
    rate_email character varying(100),
    tax_id character varying(100),
    details character varying(1000),
    invoice_show_details boolean,
    invoice_past_amount numeric(30,10),
    is_link_cdr boolean,
    is_trunk boolean,
    is_route boolean,
    is_spam boolean,
    is_location boolean,
    is_orig_term boolean,
    is_usage boolean,
    is_qos boolean,
    is_discon boolean,
    is_bill_mismatch boolean,
    is_active_call boolean,
    is_termin boolean,
    database_name character varying(50),
    is_rate_anal boolean,
    is_capture boolean,
    is_call_simulation boolean,
    is_ingress_sim boolean,
    is_egress_sim boolean,
    is_report boolean,
    is_tools boolean,
    is_manage boolean,
    mail_sended integer,
    scc_bellow integer,
    scc_percent integer,
    scc_charge numeric(30,10),
    user_id integer,
    profit_type integer,
    auto_invoice_type integer,
    cps_limit integer,
    call_limit integer,
    invoice_zone character varying(10),
    invoice_zero boolean,
    update_at timestamp with time zone,
    update_by character varying,
    corporate_contact_email character varying(100),
    paypal character varying(100),
    is_auto_summary boolean,
    auto_send_zone character varying,
    is_daily_balance_notification boolean,
    daily_balance_notification integer,
    daily_balance_recipient integer,
    low_balance_number integer,
    is_auto_balance boolean,
    numer_of_days_balance integer,
    auto_daily_balance_recipient integer,
    daily_cdr_generation boolean,
    daily_cdr_generation_zone character varying,
    daily_cdr_generation_type smallint,
    transaction_fee_id integer,
    unlimited_credit boolean,
    include_payment_history smallint,
    include_available_credit smallint,
    include_payment_history_days integer,
    auto_summary_not_zero smallint,
    auto_summary_group_by smallint,
    daily_balance_already_sent boolean,
    last_autoreport_time timestamp with time zone,
    last_lowbalance_time timestamp with time zone,
    last_cdrdown_time timestamp with time zone,
    include_tax boolean,
    tax numeric(5,2),
    invoice_jurisdictional_detail boolean,
    decimal_place integer,
    par_id integer,
    rate_value integer,
    email_invoice boolean,
    scc_type integer,
    is_invoice_account_summary boolean,
    is_show_daily_usage boolean,
    invoice_include_payment boolean,
    is_short_duration_call_surcharge_detail boolean,
    usage_detail_fields text,
    auto_summary_hour integer,
    auto_summary_period integer,
    last_autobalance_time timestamp with time zone,
    auto_summary_include_cdr boolean,
    client_type integer,
    rate_delivery_email character varying(250),
    invoice_use_balance_type integer,
    notify_client_balance_type integer,
    finance_email_cc character varying,
    decimals_num integer,
    invoice_start_from date,
    low_balance_notification_time_type integer,
    low_balance_notification_time_cycle integer,
    daily_balance_send_time time without time zone,
    daily_balance_send_time_zone character varying(20),
    is_breakdown_by_rate_table boolean,
    breakdown_by_rate_table smallint,
    offset_balance boolean,
    is_show_detail_trunk boolean,
    is_show_total_trunk boolean,
    is_show_code_100 boolean,
    is_show_code_name boolean,
    is_show_country boolean,
    is_show_by_date boolean,
    daily_limit integer,
    hourly_limit integer,
    carrier_template_id integer,
    is_send_trunk_update boolean,
    phone character varying(20),
    is_panel_invoices boolean,
    is_panel_cdrslist boolean,
    is_panel_summaryreport boolean,
    is_panel_sippacket boolean,
    is_panel_mydid boolean,
    is_panel_didrequest boolean,
    is_send_as_link boolean,
    is_vendor_invoice boolean,
    vendor_payment_term_id integer,
    group_id integer,
    zero_balance_notice_time integer,
    zero_balance_notice_last_sent timestamp with time zone,
    zero_balance_notice_first_sended boolean,
    zero_balance_notice boolean,
    auto_report_type integer,
    daily_cdr_generation_last_qcreated timestamp with time zone,
    enable_payment_alert boolean,
    is_panel_cid_blocking boolean,
    did_invoice_include character varying(255),
    auto_invoice_hour integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.client_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.client_record OWNER TO postgres;

--
-- Name: client_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: client_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_record_tmp (
    client_id integer,
    name character varying(500),
    mode integer,
    orig_rate_table_id integer,
    term_rate_table_id integer,
    currency_id integer,
    allowed_credit numeric(30,10),
    status boolean,
    auto_invoicing boolean,
    payment_term_id integer,
    invoice_format integer,
    attach_cdrs_list boolean,
    cdr_list_format integer,
    last_invoiced timestamp with time zone,
    notify_client_balance numeric(30,10),
    notify_admin_balance numeric(30,10),
    low_balance_notice boolean,
    company character varying,
    address character varying(500),
    email character varying(100),
    logo character varying(100),
    login character varying(40),
    password character varying(50),
    is_panelaccess boolean,
    is_panel_accountsummary boolean,
    is_panel_ratetable boolean,
    is_panel_trunks boolean,
    is_panel_products boolean,
    is_panel_balance boolean,
    is_panel_paymenthistory boolean,
    is_panel_onlinepayment boolean,
    role_id integer,
    create_time timestamp with time zone,
    profit_margin double precision,
    enough_balance boolean,
    service_charge_id integer,
    noc_email character varying(100),
    billing_email character varying,
    rate_email character varying(100),
    tax_id character varying(100),
    details character varying(1000),
    invoice_show_details boolean,
    invoice_past_amount numeric(30,10),
    is_link_cdr boolean,
    is_trunk boolean,
    is_route boolean,
    is_spam boolean,
    is_location boolean,
    is_orig_term boolean,
    is_usage boolean,
    is_qos boolean,
    is_discon boolean,
    is_bill_mismatch boolean,
    is_active_call boolean,
    is_termin boolean,
    database_name character varying(50),
    is_rate_anal boolean,
    is_capture boolean,
    is_call_simulation boolean,
    is_ingress_sim boolean,
    is_egress_sim boolean,
    is_report boolean,
    is_tools boolean,
    is_manage boolean,
    mail_sended integer,
    scc_bellow integer,
    scc_percent integer,
    scc_charge numeric(30,10),
    user_id integer,
    profit_type integer,
    auto_invoice_type integer,
    cps_limit integer,
    call_limit integer,
    invoice_zone character varying(10),
    invoice_zero boolean,
    update_at timestamp with time zone,
    update_by character varying,
    corporate_contact_email character varying(100),
    paypal character varying(100),
    is_auto_summary boolean,
    auto_send_zone character varying,
    is_daily_balance_notification boolean,
    daily_balance_notification integer,
    daily_balance_recipient integer,
    low_balance_number integer,
    is_auto_balance boolean,
    numer_of_days_balance integer,
    auto_daily_balance_recipient integer,
    daily_cdr_generation boolean,
    daily_cdr_generation_zone character varying,
    daily_cdr_generation_type smallint,
    transaction_fee_id integer,
    unlimited_credit boolean,
    include_payment_history smallint,
    include_available_credit smallint,
    include_payment_history_days integer,
    auto_summary_not_zero smallint,
    auto_summary_group_by smallint,
    daily_balance_already_sent boolean,
    last_autoreport_time timestamp with time zone,
    last_lowbalance_time timestamp with time zone,
    last_cdrdown_time timestamp with time zone,
    include_tax boolean,
    tax numeric(5,2),
    invoice_jurisdictional_detail boolean,
    decimal_place integer,
    par_id integer,
    rate_value integer,
    email_invoice boolean,
    scc_type integer,
    is_invoice_account_summary boolean,
    is_show_daily_usage boolean,
    invoice_include_payment boolean,
    is_short_duration_call_surcharge_detail boolean,
    usage_detail_fields text,
    auto_summary_hour integer,
    auto_summary_period integer,
    last_autobalance_time timestamp with time zone,
    auto_summary_include_cdr boolean,
    client_type integer,
    rate_delivery_email character varying(250),
    invoice_use_balance_type integer,
    notify_client_balance_type integer,
    finance_email_cc character varying,
    decimals_num integer,
    invoice_start_from date,
    low_balance_notification_time_type integer,
    low_balance_notification_time_cycle integer,
    daily_balance_send_time time without time zone,
    daily_balance_send_time_zone character varying(20),
    is_breakdown_by_rate_table boolean,
    breakdown_by_rate_table smallint,
    offset_balance boolean,
    is_show_detail_trunk boolean,
    is_show_total_trunk boolean,
    is_show_code_100 boolean,
    is_show_code_name boolean,
    is_show_country boolean,
    is_show_by_date boolean,
    daily_limit integer,
    hourly_limit integer,
    carrier_template_id integer,
    is_send_trunk_update boolean,
    phone character varying(20),
    is_panel_invoices boolean,
    is_panel_cdrslist boolean,
    is_panel_summaryreport boolean,
    is_panel_sippacket boolean,
    is_panel_mydid boolean,
    is_panel_didrequest boolean,
    is_send_as_link boolean,
    is_vendor_invoice boolean,
    vendor_payment_term_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.client_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.client_record_tmp OWNER TO postgres;

--
-- Name: client_route_request; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_route_request (
    id integer NOT NULL,
    client_id integer,
    rate real,
    asr real,
    acd real,
    request_time timestamp with time zone,
    dtmf boolean,
    t38 boolean,
    g729 boolean,
    g723 boolean,
    g711 boolean,
    route_quality integer,
    traffic integer,
    resource_id numeric
);


ALTER TABLE public.client_route_request OWNER TO postgres;

--
-- Name: client_route_request_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_route_request_code (
    id integer NOT NULL,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    request_id integer
);


ALTER TABLE public.client_route_request_code OWNER TO postgres;

--
-- Name: client_route_request_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_route_request_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_route_request_code_id_seq OWNER TO postgres;

--
-- Name: client_route_request_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.client_route_request_code_id_seq OWNED BY public.client_route_request_code.id;


--
-- Name: client_route_request_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_route_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_route_request_id_seq OWNER TO postgres;

--
-- Name: client_route_request_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.client_route_request_id_seq OWNED BY public.client_route_request.id;


--
-- Name: client_route_strategy; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_route_strategy (
    id integer NOT NULL,
    prefix public.prefix_range DEFAULT ''::public.prefix_range,
    routing_rule integer DEFAULT 1,
    priority integer DEFAULT 1,
    priority_val integer DEFAULT 0,
    client_id integer NOT NULL
);


ALTER TABLE public.client_route_strategy OWNER TO postgres;

--
-- Name: COLUMN client_route_strategy.prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_route_strategy.prefix IS 'å·ç å‰ç¼€ï¼Œæ‰‹åŠ¨è¾“å…¥';


--
-- Name: COLUMN client_route_strategy.routing_rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_route_strategy.routing_rule IS '1ï¼šManually Buy, Manually Sell, Automatic Match
2ï¼šManually Buy, Automatic Match, Manually Sell
3ï¼šManually Sell, Manually Buy, Automatic Match,
4ï¼šManually Sell, Automatic Match, Manually Buy
5ï¼šAutomatic Match, Manually Buy, Manually Sell
6ï¼šAutomatic Match, Manually Sell, Manually Buy';


--
-- Name: COLUMN client_route_strategy.priority; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_route_strategy.priority IS '1ï¼šprice
2ï¼šQOS';


--
-- Name: COLUMN client_route_strategy.priority_val; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_route_strategy.priority_val IS '1: ASR
2: ACD
3: PDD';


--
-- Name: COLUMN client_route_strategy.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.client_route_strategy.client_id IS 'å®¢æˆ·id';


--
-- Name: client_route_strategy_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_route_strategy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_route_strategy_id_seq OWNER TO postgres;

--
-- Name: client_route_strategy_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.client_route_strategy_id_seq OWNED BY public.client_route_strategy.id;


--
-- Name: client_taxes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_taxes (
    id integer NOT NULL,
    client_id integer NOT NULL,
    tax_name character varying(255) NOT NULL,
    tax_percent numeric NOT NULL
);


ALTER TABLE public.client_taxes OWNER TO postgres;

--
-- Name: client_taxes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_taxes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_taxes_id_seq OWNER TO postgres;

--
-- Name: client_taxes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.client_taxes_id_seq OWNED BY public.client_taxes.id;


--
-- Name: client_transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.client_transaction (
    client_id integer,
    amount real,
    balance real,
    type integer,
    date timestamp with time zone,
    id integer NOT NULL
);


ALTER TABLE public.client_transaction OWNER TO postgres;

--
-- Name: client_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.client_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.client_transaction_id_seq OWNER TO postgres;

--
-- Name: client_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.client_transaction_id_seq OWNED BY public.client_transaction.id;


--
-- Name: code_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.code_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.code_code_id_seq OWNER TO postgres;

--
-- Name: code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.code (
    code_id integer DEFAULT nextval('public.code_code_id_seq'::regclass) NOT NULL,
    code public.prefix_range NOT NULL,
    code_deck_id integer,
    city character varying(20),
    state character varying(20),
    country character varying(100),
    name character varying(100)
);


ALTER TABLE public.code OWNER TO postgres;

--
-- Name: TABLE code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.code IS 'è´¹çŽ‡å‰ç¼€';


--
-- Name: COLUMN code.code_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code.code_id IS 'ä¸»é”®';


--
-- Name: COLUMN code.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code.code IS 'å‰ç¼€';


--
-- Name: COLUMN code.code_deck_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code.code_deck_id IS 'å‰ç¼€ç»„(å·ç ç»„)';


--
-- Name: COLUMN code.city; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code.city IS 'åŸŽå¸‚';


--
-- Name: COLUMN code.state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code.state IS 'çœä»½';


--
-- Name: COLUMN code.country; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code.country IS 'å›½å®¶';


--
-- Name: COLUMN code.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code.name IS 'åç§°';


--
-- Name: code_based_report_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.code_based_report_log (
    id integer NOT NULL,
    user_id integer,
    status_id integer DEFAULT 0,
    export_start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    export_end_time timestamp with time zone,
    file_name character varying(500),
    search_start_date timestamp with time zone,
    search_end_date timestamp with time zone,
    email_when_done integer DEFAULT 0,
    ingress_trunk_id integer DEFAULT 0,
    egress_trunk_id integer DEFAULT 0
);


ALTER TABLE public.code_based_report_log OWNER TO postgres;

--
-- Name: code_based_report_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.code_based_report_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.code_based_report_log_id_seq OWNER TO postgres;

--
-- Name: code_based_report_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.code_based_report_log_id_seq OWNED BY public.code_based_report_log.id;


--
-- Name: code_based_report_log_status; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.code_based_report_log_status (
    id integer NOT NULL,
    status_value character varying(200)
);


ALTER TABLE public.code_based_report_log_status OWNER TO postgres;

--
-- Name: code_based_report_log_status_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.code_based_report_log_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.code_based_report_log_status_id_seq OWNER TO postgres;

--
-- Name: code_based_report_log_status_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.code_based_report_log_status_id_seq OWNED BY public.code_based_report_log_status.id;


--
-- Name: code_country; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.code_country (
    country character varying(80),
    country_code character varying(20)
);


ALTER TABLE public.code_country OWNER TO postgres;

--
-- Name: code_deck; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.code_deck (
    code_deck_id integer NOT NULL,
    name character varying(100) NOT NULL,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    client_id integer
);


ALTER TABLE public.code_deck OWNER TO postgres;

--
-- Name: TABLE code_deck; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.code_deck IS 'è´¹çŽ‡å‰ç¼€ç»„';


--
-- Name: COLUMN code_deck.code_deck_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_deck.code_deck_id IS 'ä¸»é”®';


--
-- Name: COLUMN code_deck.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_deck.name IS 'åç§°';


--
-- Name: COLUMN code_deck.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_deck.client_id IS 'ç­‰äºŽé›¶éƒ½æ˜¯é»˜è®¤çš„
0-a/z
-1-us
å…¶å®ƒå€¼ä¸ºè¯¥code deck ä¸“ç”¨';


--
-- Name: code_deck_code_deck_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.code_deck_code_deck_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.code_deck_code_deck_id_seq OWNER TO postgres;

--
-- Name: code_deck_code_deck_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.code_deck_code_deck_id_seq OWNED BY public.code_deck.code_deck_id;


--
-- Name: code_name_rate_table_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.code_name_rate_table_ref (
    "time" bigint,
    code_name character varying(100),
    rate_table_id integer,
    min_rate numeric,
    max_rate numeric,
    min_rate_fee numeric,
    max_rate_fee numeric
);


ALTER TABLE public.code_name_rate_table_ref OWNER TO postgres;

--
-- Name: TABLE code_name_rate_table_ref; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.code_name_rate_table_ref IS 'exchangeä½¿ç”¨ï¼Œcode decké‡Œçš„code nameå’Œrate tableå¯¹åº”è¡¨ã€‚';


--
-- Name: COLUMN code_name_rate_table_ref."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_name_rate_table_ref."time" IS 'äº§ç”Ÿè®°å½•æ—¶é—´ï¼Œé•¿æ•´å½¢ï¼Œç§’ç²¾åº¦ã€‚';


--
-- Name: COLUMN code_name_rate_table_ref.code_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_name_rate_table_ref.code_name IS 'å¯¹åº”code_decké‡Œçš„code_name';


--
-- Name: COLUMN code_name_rate_table_ref.min_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_name_rate_table_ref.min_rate IS 'åœ°åŒºæœ€ä½Žè´¹çŽ‡';


--
-- Name: COLUMN code_name_rate_table_ref.max_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_name_rate_table_ref.max_rate IS 'åœ°åŒºæœ€é«˜è´¹çŽ‡';


--
-- Name: COLUMN code_name_rate_table_ref.min_rate_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_name_rate_table_ref.min_rate_fee IS 'åœ°åŒºæœ€ä½Žè´¹çŽ‡ï¼Œå·²ç®—è¿›transaction fee';


--
-- Name: COLUMN code_name_rate_table_ref.max_rate_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_name_rate_table_ref.max_rate_fee IS 'åœ°åŒºæœ€é«˜è´¹çŽ‡ï¼Œå·²ç®—è¿›transaction fee';


--
-- Name: code_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.code_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.code_record_record_id_seq OWNER TO postgres;

--
-- Name: code_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.code_record (
    code_id integer,
    code public.prefix_range,
    code_deck_id integer,
    city character varying(20),
    state character varying(20),
    country character varying(100),
    name character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.code_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.code_record OWNER TO postgres;

--
-- Name: code_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.code_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.code_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: code_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.code_record_tmp (
    code_id integer,
    code public.prefix_range,
    code_deck_id integer,
    city character varying(20),
    state character varying(20),
    country character varying(100),
    name character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.code_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.code_record_tmp OWNER TO postgres;

--
-- Name: code_stats; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.code_stats (
    id integer NOT NULL,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    call_duration real,
    asr real,
    acd real,
    ca integer,
    success_calls integer,
    failed_calls integer,
    avg_buy_rate numeric(30,10),
    avg_sell_rate numeric(30,10),
    total_buy_volume integer,
    total_sell_volume integer,
    stat_time timestamp with time zone
);


ALTER TABLE public.code_stats OWNER TO postgres;

--
-- Name: COLUMN code_stats.asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_stats.asr IS 'success_calls/ca';


--
-- Name: COLUMN code_stats.acd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_stats.acd IS 'call_duration/success_calls';


--
-- Name: COLUMN code_stats.failed_calls; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.code_stats.failed_calls IS 'ca-success_calls';


--
-- Name: code_stats_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.code_stats_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.code_stats_id_seq OWNER TO postgres;

--
-- Name: code_stats_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.code_stats_id_seq OWNED BY public.code_stats.id;


--
-- Name: codecs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.codecs (
    id integer NOT NULL,
    name character varying(40) NOT NULL,
    detail character varying(100)
);


ALTER TABLE public.codecs OWNER TO postgres;

--
-- Name: TABLE codecs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.codecs IS 'ç¼–ç ';


--
-- Name: COLUMN codecs.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.codecs.id IS 'ä¸»é”®';


--
-- Name: COLUMN codecs.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.codecs.name IS 'åç§°';


--
-- Name: COLUMN codecs.detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.codecs.detail IS 'æè¿°';


--
-- Name: contract; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.contract (
    id integer NOT NULL,
    contract_type integer,
    order_id integer NOT NULL,
    order_response_id integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    status integer,
    expire_time timestamp with time zone,
    is_commit boolean DEFAULT false NOT NULL,
    commit_minutes integer,
    client_id integer NOT NULL,
    is_private boolean DEFAULT false NOT NULL,
    resource_id integer NOT NULL,
    confirm_order_number integer NOT NULL,
    user_id integer NOT NULL,
    resource_prefix public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    order_response_rate numeric(30,10) NOT NULL,
    auto_match boolean DEFAULT false NOT NULL,
    finance_rate real,
    actioned boolean DEFAULT false
);


ALTER TABLE public.contract OWNER TO postgres;

--
-- Name: COLUMN contract.contract_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contract.contract_type IS 'åˆåŒç±»åž‹
1ï¼ï¼buy orderå‘å¸ƒ
2ï¼ï¼sell orderå‘å¸ƒ';


--
-- Name: COLUMN contract.order_response_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contract.order_response_id IS 'è·Ÿä»–äº¤æ˜“çš„order_id';


--
-- Name: COLUMN contract.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contract.status IS '1ï¼ï¼active
2ï¼ï¼expired
3ï¼ï¼order creater hold
4ï¼ï¼order responser hold
5ï¼ï¼è¢«æ”¹åŠ¨è‡ªåŠ¨hold
6ï¼ï¼å‡†å¤‡åˆ é™¤
7ï¼ï¼ä»·æ ¼å˜åŠ¨';


--
-- Name: COLUMN contract.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contract.client_id IS 'è·Ÿä»–äº¤æ˜“çš„client_id';


--
-- Name: COLUMN contract.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contract.resource_id IS 'è·Ÿä»–äº¤æ˜“çš„resource_id';


--
-- Name: COLUMN contract.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contract.user_id IS 'è·Ÿä»–äº¤æ˜“çš„user_id';


--
-- Name: COLUMN contract.order_response_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.contract.order_response_rate IS 'åŠ è¿‡æœåŠ¡è´¹çš„æˆäº¤ä»·æ ¼';


--
-- Name: contract_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.contract_code (
    id integer NOT NULL,
    contract_id integer NOT NULL,
    code character varying(100),
    code_name character varying(100),
    country character varying(100)
);


ALTER TABLE public.contract_code OWNER TO postgres;

--
-- Name: contract_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.contract_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.contract_code_id_seq OWNER TO postgres;

--
-- Name: contract_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.contract_code_id_seq OWNED BY public.contract_code.id;


--
-- Name: contract_confirm_order_number_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.contract_confirm_order_number_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.contract_confirm_order_number_seq OWNER TO postgres;

--
-- Name: contract_confirm_order_number_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.contract_confirm_order_number_seq OWNED BY public.contract.confirm_order_number;


--
-- Name: contract_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.contract_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.contract_id_seq OWNER TO postgres;

--
-- Name: contract_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.contract_id_seq OWNED BY public.contract.id;


--
-- Name: contract_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.contract_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.contract_record_record_id_seq OWNER TO postgres;

--
-- Name: contract_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.contract_record (
    id integer,
    contract_type integer,
    order_id integer,
    order_response_id integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    status integer,
    expire_time timestamp with time zone,
    is_commit boolean,
    commit_minutes integer,
    client_id integer,
    is_private boolean,
    resource_id integer,
    confirm_order_number integer,
    user_id integer,
    resource_prefix public.prefix_range,
    order_response_rate numeric(30,10),
    auto_match boolean,
    finance_rate real,
    actioned boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.contract_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.contract_record OWNER TO postgres;

--
-- Name: credit_application; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.credit_application (
    id integer NOT NULL,
    user_id integer,
    client_id integer,
    legal_name character varying(500),
    register_number character varying(500),
    established character varying(500),
    country_incorporation character varying(500),
    gross_annual_revenue character varying(500),
    principals character varying(500),
    head_office_address character varying(500),
    phone character varying(500),
    email character varying(500),
    company_url character varying(500),
    annual_sales_volumes character varying(500),
    d_b character varying(500),
    bank_name character varying(500),
    address character varying(500),
    city character varying(500),
    postal_code character varying(500),
    country character varying(500),
    bank_officer character varying(500),
    account_type character varying(500),
    account character varying(500),
    swift character varying(500),
    bank_phone character varying(500),
    bank_email character varying(500),
    company_name_1 character varying(500),
    years_doing_business_1 character varying(500),
    contact_person_1 character varying(500),
    position_1 character varying(500),
    trade_phone_1 character varying(500),
    trade_fax_1 character varying(500),
    trade_email_1 character varying(500),
    company_name_2 character varying(500),
    years_doing_business_2 character varying(500),
    contact_person_2 character varying(500),
    position_2 character varying(500),
    trade_phone_2 character varying(500),
    trade_fax_2 character varying(500),
    trade_email_2 character varying(500),
    company_name_3 character varying(500),
    years_doing_business_3 character varying(500),
    contact_person_3 character varying(500),
    position_3 character varying(500),
    trade_phone_3 character varying(500),
    trade_fax_3 character varying(500),
    trade_email_3 character varying(500),
    application_name character varying(100),
    application_position character varying(500),
    application_date timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    flag integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.credit_application OWNER TO postgres;

--
-- Name: COLUMN credit_application.flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.credit_application.flag IS '0æ–°çš„ç”³è¯·
1æ‰¹å‡†ç”³è¯·';


--
-- Name: credit_application_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.credit_application_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.credit_application_id_seq OWNER TO postgres;

--
-- Name: credit_application_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.credit_application_id_seq OWNED BY public.credit_application.id;


--
-- Name: credit_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.credit_log (
    id integer NOT NULL,
    modified_by character varying(200),
    modified_from numeric(30,10),
    modified_to numeric(30,10),
    modified_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    carrier_name character varying(200)
);


ALTER TABLE public.credit_log OWNER TO postgres;

--
-- Name: credit_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.credit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.credit_log_id_seq OWNER TO postgres;

--
-- Name: credit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.credit_log_id_seq OWNED BY public.credit_log.id;


--
-- Name: currency_currency_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.currency_currency_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.currency_currency_id_seq OWNER TO postgres;

--
-- Name: currency; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.currency (
    currency_id integer DEFAULT nextval('public.currency_currency_id_seq'::regclass) NOT NULL,
    code character varying(100) NOT NULL,
    active boolean DEFAULT true NOT NULL,
    update_by character varying
);


ALTER TABLE public.currency OWNER TO postgres;

--
-- Name: TABLE currency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.currency IS 'è´§å¸';


--
-- Name: COLUMN currency.currency_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.currency.currency_id IS 'ä¸»é”®';


--
-- Name: COLUMN currency.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.currency.code IS 'è´§å¸å›½å®¶ä»£å·';


--
-- Name: COLUMN currency.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.currency.active IS 'æ˜¯å¦å¯ç”¨';


--
-- Name: currency_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.currency_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.currency_record_record_id_seq OWNER TO postgres;

--
-- Name: currency_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.currency_record (
    currency_id integer,
    code character varying(100),
    active boolean,
    update_by character varying,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.currency_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.currency_record OWNER TO postgres;

--
-- Name: currency_updates_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.currency_updates_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999999
    CACHE 1;


ALTER TABLE public.currency_updates_id_seq OWNER TO postgres;

--
-- Name: currency_updates; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.currency_updates (
    currency_id integer NOT NULL,
    modify_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    rate numeric(30,6) NOT NULL,
    last_rate numeric(30,10),
    currency_updates_id integer DEFAULT nextval('public.currency_updates_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.currency_updates OWNER TO postgres;

--
-- Name: TABLE currency_updates; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.currency_updates IS 'è´§å¸æ±‡çŽ‡æ›´æ–°è®°å½•';


--
-- Name: COLUMN currency_updates.currency_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.currency_updates.currency_id IS 'è´§å¸';


--
-- Name: COLUMN currency_updates.modify_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.currency_updates.modify_time IS 'ä¿®æ”¹æ—¶é—´';


--
-- Name: COLUMN currency_updates.rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.currency_updates.rate IS 'æ±‡çŽ‡';


--
-- Name: COLUMN currency_updates.last_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.currency_updates.last_rate IS 'ä¸Šæ¬¡æ±‡çŽ‡';


--
-- Name: COLUMN currency_updates.currency_updates_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.currency_updates.currency_updates_id IS 'ä¸»é”®

//currency_updates_currency_updates_id_seq';


--
-- Name: currency_updates_currency_updates_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.currency_updates_currency_updates_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.currency_updates_currency_updates_id_seq OWNER TO postgres;

--
-- Name: currency_updates_currency_updates_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.currency_updates_currency_updates_id_seq OWNED BY public.currency_updates.currency_updates_id;


--
-- Name: currency_updates_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.currency_updates_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.currency_updates_record_record_id_seq OWNER TO postgres;

--
-- Name: currency_updates_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.currency_updates_record (
    currency_id integer,
    modify_time timestamp with time zone,
    rate numeric(30,6),
    last_rate numeric(30,10),
    currency_updates_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.currency_updates_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.currency_updates_record OWNER TO postgres;

--
-- Name: currency_updates_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.currency_updates_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.currency_updates_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: currency_updates_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.currency_updates_record_tmp (
    currency_id integer,
    modify_time timestamp with time zone,
    rate numeric(30,6),
    last_rate numeric(30,10),
    currency_updates_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.currency_updates_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.currency_updates_record_tmp OWNER TO postgres;

--
-- Name: current_dashboard_data; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.current_dashboard_data (
    id integer NOT NULL,
    cps integer DEFAULT 0,
    channel integer DEFAULT 0,
    call integer DEFAULT 0,
    create_time timestamp without time zone,
    select_time timestamp with time zone,
    identifier integer,
    server character varying(100)
);


ALTER TABLE public.current_dashboard_data OWNER TO postgres;

--
-- Name: current_dashboard_data_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.current_dashboard_data_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.current_dashboard_data_id_seq OWNER TO postgres;

--
-- Name: current_dashboard_data_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.current_dashboard_data_id_seq OWNED BY public.current_dashboard_data.id;


--
-- Name: daily_cdr_fields; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.daily_cdr_fields (
    id integer NOT NULL,
    type smallint,
    field character varying,
    label character varying
);


ALTER TABLE public.daily_cdr_fields OWNER TO postgres;

--
-- Name: TABLE daily_cdr_fields; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.daily_cdr_fields IS 'daily cdr æ¯å¤©å‘é€é‚®ä»¶';


--
-- Name: daily_cdr_fields_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.daily_cdr_fields_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.daily_cdr_fields_id_seq OWNER TO postgres;

--
-- Name: daily_cdr_fields_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.daily_cdr_fields_id_seq OWNED BY public.daily_cdr_fields.id;


--
-- Name: email_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.email_log (
    id integer NOT NULL,
    send_time timestamp with time zone,
    client_id integer,
    email_addresses character varying(500),
    files character varying(500),
    type smallint,
    email_res text,
    alert_block_egress_id integer,
    alert_block_code_name text,
    status smallint,
    error text,
    resend_email text,
    subject character varying(100),
    content text,
    is_view integer DEFAULT 0 NOT NULL,
    alert_rule character varying(500)
);


ALTER TABLE public.email_log OWNER TO postgres;

--
-- Name: COLUMN email_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.email_log.type IS '1,low balance
2,daily summary
3,auto delivery
4,alert_route
5,cdr_down
6,exchange_alert_route
7,invoice
21, Payment Received
22, Rule Alert
';


--
-- Name: COLUMN email_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.email_log.status IS '0ï¼Œnull-successï¼›1-fail';


--
-- Name: COLUMN email_log.error; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.email_log.error IS 'email error';


--
-- Name: COLUMN email_log.is_view; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.email_log.is_view IS 'æ˜¯å¦åœ¨è‡ªåŠ©é¡µé¢æŸ¥çœ‹';


--
-- Name: daily_email_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.daily_email_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.daily_email_log_id_seq OWNER TO postgres;

--
-- Name: daily_email_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.daily_email_log_id_seq OWNED BY public.email_log.id;


--
-- Name: dashboard_time_option; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dashboard_time_option (
    id integer NOT NULL,
    admin_point_time timestamp with time zone,
    client_point_time timestamp with time zone,
    iden character varying(30)
);


ALTER TABLE public.dashboard_time_option OWNER TO postgres;

--
-- Name: COLUMN dashboard_time_option.iden; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dashboard_time_option.iden IS 'user_id + _Ymd + _His';


--
-- Name: dashboard_time_option_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dashboard_time_option_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dashboard_time_option_id_seq OWNER TO postgres;

--
-- Name: dashboard_time_option_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.dashboard_time_option_id_seq OWNED BY public.dashboard_time_option.id;


--
-- Name: default_fields; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.default_fields (
    report_name character varying(255),
    fields text
);


ALTER TABLE public.default_fields OWNER TO postgres;

--
-- Name: dex; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dex (
    id integer NOT NULL,
    dex_name character varying(100),
    dex_prefix character varying(100)
);


ALTER TABLE public.dex OWNER TO postgres;

--
-- Name: dex_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dex_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dex_id_seq OWNER TO postgres;

--
-- Name: dex_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.dex_id_seq OWNED BY public.dex.id;


--
-- Name: dex_resource; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dex_resource (
    dex_id integer NOT NULL,
    resource_id integer NOT NULL,
    id integer NOT NULL
);


ALTER TABLE public.dex_resource OWNER TO postgres;

--
-- Name: dex_resource_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dex_resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dex_resource_id_seq OWNER TO postgres;

--
-- Name: dex_resource_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.dex_resource_id_seq OWNED BY public.dex_resource.id;


--
-- Name: dex_resource_unactive_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dex_resource_unactive_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dex_resource_unactive_id_seq OWNER TO postgres;

--
-- Name: dex_resource_unactive; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dex_resource_unactive (
    id integer DEFAULT nextval('public.dex_resource_unactive_id_seq'::regclass) NOT NULL,
    dex_id integer,
    dex_resource integer,
    ingress_id integer
);


ALTER TABLE public.dex_resource_unactive OWNER TO postgres;

--
-- Name: dex_resource_uactive_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dex_resource_uactive_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dex_resource_uactive_id_seq OWNER TO postgres;

--
-- Name: dex_resource_uactive_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.dex_resource_uactive_id_seq OWNED BY public.dex_resource_unactive.id;


--
-- Name: dialer_detection; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dialer_detection (
    ani_scope integer,
    ani_within_mins smallint,
    dialer_detection_type smallint DEFAULT 0 NOT NULL,
    unblock_ani_mins integer,
    sent_type smallint,
    id integer NOT NULL,
    action boolean DEFAULT false NOT NULL,
    ani_pid integer,
    dnis_scope integer,
    dnis_within_second smallint,
    dnis_pid integer,
    trunk_type smallint,
    name character varying(100),
    trunk character varying(100),
    min_call integer,
    unblock_ani_type smallint,
    last_run_time timestamp without time zone,
    dialer_detection_subject text,
    dialer_detection_content text,
    send_email integer,
    block_ani integer
);


ALTER TABLE public.dialer_detection OWNER TO postgres;

--
-- Name: TABLE dialer_detection; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.dialer_detection IS 'monitoring dialer_detectionçš„æ•°æ®';


--
-- Name: COLUMN dialer_detection.ani_scope; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.ani_scope IS 'Number of Occurrence of an ANI >=(ani_scope)';


--
-- Name: COLUMN dialer_detection.ani_within_mins; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.ani_within_mins IS 'Number of Occurrence of an ANI >=    _______   within _(within_second)_ mins';


--
-- Name: COLUMN dialer_detection.dialer_detection_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.dialer_detection_type IS '0:Email to Ingress Carrier
1:Block ANI ';


--
-- Name: COLUMN dialer_detection.unblock_ani_mins; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.unblock_ani_mins IS 'Unblock ANI: Never / After _____ mins';


--
-- Name: COLUMN dialer_detection.sent_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.sent_type IS '0:Your Own NOC
1:Partnerâ€™s NOC
2:Both';


--
-- Name: COLUMN dialer_detection.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.action IS 'æ˜¯å¦å¼€å¯';


--
-- Name: COLUMN dialer_detection.ani_pid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.ani_pid IS 'pid  aniåˆ¤æ–­';


--
-- Name: COLUMN dialer_detection.dnis_scope; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.dnis_scope IS 'Number of Occurrence of an DNIS >=(dnis_scope)';


--
-- Name: COLUMN dialer_detection.dnis_within_second; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.dnis_within_second IS 'Number of Occurrence of an dnis >=    _______ ';


--
-- Name: COLUMN dialer_detection.dnis_pid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.dnis_pid IS 'pid  dnisåˆ¤æ–­';


--
-- Name: COLUMN dialer_detection.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.trunk_type IS '1:ingress
2:egress';


--
-- Name: COLUMN dialer_detection.trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.trunk IS 'trunk alias or ALL';


--
-- Name: COLUMN dialer_detection.min_call; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.min_call IS 'è‡³å°‘æœ‰å¤šå°‘ä¸ªç”µè¯æ‰ç®—æ˜¯ç¬¦åˆæ¡ä»¶';


--
-- Name: COLUMN dialer_detection.unblock_ani_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.unblock_ani_type IS '0ä¸ºNever
1ä¸ºAfter';


--
-- Name: COLUMN dialer_detection.last_run_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.last_run_time IS 'ä¸Šæ¬¡æ‰§è¡Œæ—¶é—´';


--
-- Name: COLUMN dialer_detection.send_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.send_email IS 'o false
1 true';


--
-- Name: COLUMN dialer_detection.block_ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.dialer_detection.block_ani IS '0 false
1 true';


--
-- Name: dialer_detection_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dialer_detection_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dialer_detection_id_seq OWNER TO postgres;

--
-- Name: dialer_detection_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.dialer_detection_id_seq OWNED BY public.dialer_detection.id;


--
-- Name: did_assign; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.did_assign (
    number public.prefix_range NOT NULL,
    egress_id integer NOT NULL,
    created_time timestamp with time zone,
    assigned_time timestamp with time zone,
    status smallint DEFAULT 0,
    ingress_id integer
);


ALTER TABLE public.did_assign OWNER TO postgres;

--
-- Name: did_billing_brief; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.did_billing_brief (
    id integer NOT NULL,
    did_number character varying(50),
    vendor_billing_plan_id integer,
    client_billing_plan_id integer,
    vendor_trunk_id integer,
    client_trunk_id integer,
    start_date date,
    enable_for_clients boolean DEFAULT false,
    last_charged_monthly_fees integer DEFAULT '-1'::integer,
    end_date date
);


ALTER TABLE public.did_billing_brief OWNER TO postgres;

--
-- Name: did_billing_brief_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.did_billing_brief_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.did_billing_brief_id_seq OWNER TO postgres;

--
-- Name: did_billing_brief_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.did_billing_brief_id_seq OWNED BY public.did_billing_brief.id;


--
-- Name: did_billing_plan; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.did_billing_plan (
    id integer NOT NULL,
    did_price real DEFAULT 0,
    min_price real DEFAULT 0,
    name character varying(255),
    payphone_subcharge character varying,
    monthly_charge numeric,
    rate_table_id integer,
    rate_type integer,
    pay_type smallint DEFAULT 0,
    fee_per_port numeric DEFAULT 0,
    price_type smallint DEFAULT 0
);


ALTER TABLE public.did_billing_plan OWNER TO postgres;

--
-- Name: COLUMN did_billing_plan.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.did_billing_plan.rate_type IS '1 - Fixed rate; 2 - Variable rate';


--
-- Name: COLUMN did_billing_plan.pay_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.did_billing_plan.pay_type IS '0 - Weekly; 1 - Monthly';


--
-- Name: did_billing_plan_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.did_billing_plan_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.did_billing_plan_id_seq OWNER TO postgres;

--
-- Name: did_billing_plan_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.did_billing_plan_id_seq OWNED BY public.did_billing_plan.id;


--
-- Name: did_billing_rel; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.did_billing_rel (
    id integer NOT NULL,
    did character varying(50),
    sell_billing_plan_id integer,
    buy_billing_plan_id integer,
    did_billing_id integer,
    start_date date,
    ingress_res_id integer,
    egress_res_id integer,
    end_date date,
    enable_for_clients boolean DEFAULT false,
    rate_id integer,
    fee_per_port numeric DEFAULT 0
);


ALTER TABLE public.did_billing_rel OWNER TO postgres;

--
-- Name: did_billing_rel_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.did_billing_rel_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.did_billing_rel_id_seq OWNER TO postgres;

--
-- Name: did_billing_rel_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.did_billing_rel_id_seq OWNED BY public.did_billing_rel.id;


--
-- Name: did_number_upload_task; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.did_number_upload_task (
    id integer NOT NULL,
    operator_user character varying(40),
    upload_file_path character varying(256),
    upload_orig_file character varying(100),
    upload_format_file character varying(100),
    result_file_path character varying(256),
    repeated_action smallint DEFAULT 0 NOT NULL,
    status smallint DEFAULT 0 NOT NULL,
    progress character varying(200),
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    start_time timestamp with time zone,
    end_time timestamp with time zone
);


ALTER TABLE public.did_number_upload_task OWNER TO postgres;

--
-- Name: COLUMN did_number_upload_task.upload_format_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.did_number_upload_task.upload_format_file IS 'Must be a CSV file';


--
-- Name: COLUMN did_number_upload_task.repeated_action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.did_number_upload_task.repeated_action IS '0 - Ignore, 1 - Overwrite';


--
-- Name: COLUMN did_number_upload_task.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.did_number_upload_task.status IS '0 - Initial; 1 - In Process; 2 - Copy To DB; 3 - Finished; 4 - Error';


--
-- Name: did_number_upload_task_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.did_number_upload_task_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.did_number_upload_task_id_seq OWNER TO postgres;

--
-- Name: did_number_upload_task_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.did_number_upload_task_id_seq OWNED BY public.did_number_upload_task.id;


--
-- Name: did_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.did_report (
    report_time timestamp with time zone,
    duration integer,
    ingress_bill_time integer,
    ingress_call_cost numeric(15,6),
    ingress_total_calls integer,
    not_zero_calls integer,
    ingress_success_calls integer,
    ingress_client_id integer,
    ingress_id integer,
    egress_client_id integer,
    egress_id integer,
    egress_bill_time integer,
    egress_call_cost numeric(15,6),
    egress_total_calls integer,
    egress_success_calls integer,
    did character varying(100),
    ingress_ip character varying(20),
    egress_ip character varying(20),
    pdd integer,
    ingress_busy_calls integer,
    egress_busy_calls integer,
    ingress_cancel_calls integer,
    egress_cancel_calls integer,
    cdr_date character varying(24)
);


ALTER TABLE public.did_report OWNER TO postgres;

--
-- Name: did_request; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.did_request (
    id integer NOT NULL,
    user_id integer,
    created_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status integer DEFAULT 0
);


ALTER TABLE public.did_request OWNER TO postgres;

--
-- Name: did_request_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.did_request_detail (
    id integer NOT NULL,
    did_request_id integer,
    number character varying(255),
    egress_id integer,
    status integer DEFAULT 0 NOT NULL,
    assigned_time timestamp with time zone
);


ALTER TABLE public.did_request_detail OWNER TO postgres;

--
-- Name: did_request_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.did_request_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.did_request_detail_id_seq OWNER TO postgres;

--
-- Name: did_request_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.did_request_detail_id_seq OWNED BY public.did_request_detail.id;


--
-- Name: did_request_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.did_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.did_request_id_seq OWNER TO postgres;

--
-- Name: did_request_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.did_request_id_seq OWNED BY public.did_request.id;


--
-- Name: did_special_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.did_special_code (
    id integer NOT NULL,
    code public.prefix_range NOT NULL,
    pricing real DEFAULT 0
);


ALTER TABLE public.did_special_code OWNER TO postgres;

--
-- Name: did_special_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.did_special_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.did_special_code_id_seq OWNER TO postgres;

--
-- Name: did_special_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.did_special_code_id_seq OWNED BY public.did_special_code.id;


--
-- Name: digit_translation_translation_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.digit_translation_translation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.digit_translation_translation_id_seq OWNER TO postgres;

--
-- Name: digit_translation; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.digit_translation (
    translation_id integer DEFAULT nextval('public.digit_translation_translation_id_seq'::regclass) NOT NULL,
    translation_name character varying(100) NOT NULL,
    translation timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL
);


ALTER TABLE public.digit_translation OWNER TO postgres;

--
-- Name: TABLE digit_translation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.digit_translation IS 'ä¸»è¢«å«å·ç è½¬æ¢';


--
-- Name: COLUMN digit_translation.translation_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.digit_translation.translation_id IS 'ä¸»é”®';


--
-- Name: COLUMN digit_translation.translation_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.digit_translation.translation_name IS 'åç§°';


--
-- Name: COLUMN digit_translation.translation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.digit_translation.translation IS 'æ›´æ–°æ—¶é—´';


--
-- Name: direct_seller_enrollment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.direct_seller_enrollment (
    id integer NOT NULL,
    user_id integer,
    request_time timestamp with time zone,
    action integer
);


ALTER TABLE public.direct_seller_enrollment OWNER TO postgres;

--
-- Name: direct_seller_enrollment_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.direct_seller_enrollment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.direct_seller_enrollment_id_seq OWNER TO postgres;

--
-- Name: direct_seller_enrollment_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.direct_seller_enrollment_id_seq OWNED BY public.direct_seller_enrollment.id;


--
-- Name: disabled_trunk; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.disabled_trunk AS
 SELECT ( SELECT alert_rule.name
           FROM public.alert_rule
          WHERE (alert_rule.id = alert_event.alert_rule_id)) AS name,
    alert_event.event_type,
    resource.alias,
    resource.ingress,
    resource.egress,
    alert_event.disable_code,
    alert_event.event_time,
    (alert_event.event_time + ((alert_event.disable_duration)::double precision * '00:01:00'::interval)) AS enable_time
   FROM (public.alert_event
     JOIN public.resource ON ((resource.resource_id = alert_event.res_id)))
  WHERE (alert_event.disable_duration IS NOT NULL);


ALTER TABLE public.disabled_trunk OWNER TO postgres;

--
-- Name: dynamic_route_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_items_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.dynamic_route_items_id_seq OWNED BY public.dynamic_route_items.id;


--
-- Name: dynamic_route_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_items_record_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_items_record (
    id integer,
    dynamic_route_id integer,
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.dynamic_route_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.dynamic_route_items_record OWNER TO postgres;

--
-- Name: dynamic_route_items_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_items_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_items_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_items_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_items_record_tmp (
    id integer,
    dynamic_route_id integer,
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.dynamic_route_items_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.dynamic_route_items_record_tmp OWNER TO postgres;

--
-- Name: dynamic_route_old_dynamic_route_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_old_dynamic_route_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_old_dynamic_route_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_override; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_override (
    id integer NOT NULL,
    dynamic_route_id integer NOT NULL,
    digits public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    resource_id integer NOT NULL,
    percentage integer NOT NULL
);


ALTER TABLE public.dynamic_route_override OWNER TO postgres;

--
-- Name: dynamic_route_override_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_override_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_override_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_override_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.dynamic_route_override_id_seq OWNED BY public.dynamic_route_override.id;


--
-- Name: dynamic_route_override_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_override_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_override_record_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_override_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_override_record (
    id integer,
    dynamic_route_id integer,
    digits public.prefix_range,
    resource_id integer,
    percentage integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.dynamic_route_override_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.dynamic_route_override_record OWNER TO postgres;

--
-- Name: dynamic_route_override_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_override_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_override_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_override_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_override_record_tmp (
    id integer,
    dynamic_route_id integer,
    digits public.prefix_range,
    resource_id integer,
    percentage integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.dynamic_route_override_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.dynamic_route_override_record_tmp OWNER TO postgres;

--
-- Name: dynamic_route_pri; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_pri (
    id integer NOT NULL,
    dynamic_route_id integer NOT NULL,
    digits public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    resource_id integer NOT NULL,
    resource_pri integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.dynamic_route_pri OWNER TO postgres;

--
-- Name: dynamic_route_pri_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_pri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_pri_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_pri_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.dynamic_route_pri_id_seq OWNED BY public.dynamic_route_pri.id;


--
-- Name: dynamic_route_pri_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_pri_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_pri_record_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_pri_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_pri_record (
    id integer,
    dynamic_route_id integer,
    digits public.prefix_range,
    resource_id integer,
    resource_pri integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.dynamic_route_pri_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.dynamic_route_pri_record OWNER TO postgres;

--
-- Name: dynamic_route_pri_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_pri_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_pri_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_pri_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_pri_record_tmp (
    id integer,
    dynamic_route_id integer,
    digits public.prefix_range,
    resource_id integer,
    resource_pri integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.dynamic_route_pri_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.dynamic_route_pri_record_tmp OWNER TO postgres;

--
-- Name: dynamic_route_qos; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_qos (
    id integer NOT NULL,
    dynamic_route_id integer NOT NULL,
    digits public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real
);


ALTER TABLE public.dynamic_route_qos OWNER TO postgres;

--
-- Name: dynamic_route_qos_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_qos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_qos_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_qos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.dynamic_route_qos_id_seq OWNED BY public.dynamic_route_qos.id;


--
-- Name: dynamic_route_qos_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_qos_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_qos_record_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_qos_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_qos_record (
    id integer,
    dynamic_route_id integer,
    digits public.prefix_range,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.dynamic_route_qos_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.dynamic_route_qos_record OWNER TO postgres;

--
-- Name: dynamic_route_qos_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_qos_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_qos_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_qos_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_qos_record_tmp (
    id integer,
    dynamic_route_id integer,
    digits public.prefix_range,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.dynamic_route_qos_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.dynamic_route_qos_record_tmp OWNER TO postgres;

--
-- Name: dynamic_route_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_record_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_record (
    dynamic_route_id integer,
    name character varying(100),
    routing_rule integer,
    time_profile_id integer,
    update_at timestamp with time zone,
    update_by character varying,
    lcr_flag integer,
    is_virtual boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.dynamic_route_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.dynamic_route_record OWNER TO postgres;

--
-- Name: dynamic_route_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.dynamic_route_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dynamic_route_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: dynamic_route_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.dynamic_route_record_tmp (
    dynamic_route_id integer,
    name character varying(100),
    routing_rule integer,
    time_profile_id integer,
    update_at timestamp with time zone,
    update_by character varying,
    lcr_flag integer,
    is_virtual boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.dynamic_route_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.dynamic_route_record_tmp OWNER TO postgres;

--
-- Name: egress_profile; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.egress_profile (
    id integer NOT NULL,
    egress_id integer,
    profile_id integer,
    server_name character varying(200),
    ingress_id integer
);


ALTER TABLE public.egress_profile OWNER TO postgres;

--
-- Name: COLUMN egress_profile.ingress_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_profile.ingress_id IS 'ï¼ï¼ ingress_id + egress_id + server_nameéœ€è¦å”¯ä¸€';


--
-- Name: egress_profile_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.egress_profile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.egress_profile_id_seq OWNER TO postgres;

--
-- Name: egress_profile_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.egress_profile_id_seq OWNED BY public.egress_profile.id;


--
-- Name: egress_profile_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.egress_profile_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.egress_profile_record_record_id_seq OWNER TO postgres;

--
-- Name: egress_profile_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.egress_profile_record (
    id integer,
    egress_id integer,
    profile_id integer,
    server_name character varying(200),
    ingress_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.egress_profile_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.egress_profile_record OWNER TO postgres;

--
-- Name: egress_profile_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.egress_profile_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.egress_profile_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: egress_profile_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.egress_profile_record_tmp (
    id integer,
    egress_id integer,
    profile_id integer,
    server_name character varying(200),
    ingress_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.egress_profile_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.egress_profile_record_tmp OWNER TO postgres;

--
-- Name: egress_test; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.egress_test (
    id integer NOT NULL,
    egress_id integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    code_name character varying(100),
    success_calls integer,
    total_calls integer,
    fas real,
    asr real,
    pdd integer,
    ingress_id integer,
    ingress_client_id integer,
    agent_id integer,
    product_id integer,
    public_link_key character varying,
    fas_calls integer,
    total_pdd integer,
    is_send_email integer,
    sec integer,
    create_by character varying(100)
);


ALTER TABLE public.egress_test OWNER TO postgres;

--
-- Name: COLUMN egress_test.success_calls; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test.success_calls IS 'success_calls / total_calls = asr';


--
-- Name: COLUMN egress_test.fas_calls; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test.fas_calls IS 'fas_calls / total_call = fas';


--
-- Name: COLUMN egress_test.total_pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test.total_pdd IS 'total_pdd/total_calls = pdd';


--
-- Name: egress_test_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.egress_test_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.egress_test_id_seq OWNER TO postgres;

--
-- Name: egress_test_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.egress_test_id_seq OWNED BY public.egress_test.id;


--
-- Name: egress_test_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.egress_test_result (
    id integer NOT NULL,
    egress_test_id integer NOT NULL,
    ani character varying(100),
    dnis character varying(100),
    start_time timestamp with time zone,
    answer_time timestamp with time zone,
    end_time timestamp with time zone,
    pdd integer,
    call_result character varying(100),
    sip_file text,
    ring_file text,
    media_file text,
    sip_view_file text,
    ring_wav_file text,
    media_wav_file text,
    call_result_code character varying(100),
    media_packets integer,
    call_id character varying,
    pcap_id character varying,
    cdr_time timestamp with time zone,
    duration integer,
    switch_ip character varying(100)
);


ALTER TABLE public.egress_test_result OWNER TO postgres;

--
-- Name: COLUMN egress_test_result.ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test_result.ani IS 'SRC Number';


--
-- Name: COLUMN egress_test_result.dnis; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test_result.dnis IS 'DEST Number';


--
-- Name: COLUMN egress_test_result.start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test_result.start_time IS 'DUR = end_time - answer_time';


--
-- Name: COLUMN egress_test_result.answer_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test_result.answer_time IS 'Ring Time = answer_time - start_time';


--
-- Name: COLUMN egress_test_result.end_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test_result.end_time IS 'Initiated';


--
-- Name: COLUMN egress_test_result.call_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test_result.call_result IS 'Result';


--
-- Name: COLUMN egress_test_result.ring_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test_result.ring_file IS 'RBT';


--
-- Name: COLUMN egress_test_result.media_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test_result.media_file IS 'Audio';


--
-- Name: COLUMN egress_test_result.call_result_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test_result.call_result_code IS 'Diconnect Code/Reason';


--
-- Name: COLUMN egress_test_result.media_packets; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.egress_test_result.media_packets IS 'Media Packets';


--
-- Name: egress_test_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.egress_test_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.egress_test_result_id_seq OWNER TO postgres;

--
-- Name: egress_test_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.egress_test_result_id_seq OWNED BY public.egress_test_result.id;


--
-- Name: egress_trunk_trace_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.egress_trunk_trace_report (
    report_time timestamp with time zone,
    total_record integer,
    egress_id integer,
    carrier_call_limit integer,
    carrier_cps_limit integer,
    trunk_call_limit integer,
    trunk_cps_limit integer,
    no_profitable_route integer,
    no_capacity integer,
    egress_trunk_block integer,
    code_block integer
);


ALTER TABLE public.egress_trunk_trace_report OWNER TO postgres;

--
-- Name: email_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.email_record (
    id integer NOT NULL,
    mail_to character varying(100),
    mail_subject character varying(1000),
    mail_body text,
    mail_var character varying(1000),
    send_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status integer DEFAULT 0
);


ALTER TABLE public.email_record OWNER TO postgres;

--
-- Name: email_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.email_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.email_record_id_seq OWNER TO postgres;

--
-- Name: email_record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.email_record_id_seq OWNED BY public.email_record.id;


--
-- Name: mail_sender; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mail_sender (
    id integer NOT NULL,
    smtp_host character varying(255),
    smtp_port character varying(255),
    username character varying(255),
    password character varying(255),
    email character varying(255),
    name character varying(255),
    secure integer DEFAULT 0 NOT NULL,
    loginemail character varying(12),
    last_modified_on timestamp with time zone,
    modified_by character varying(40)
);


ALTER TABLE public.mail_sender OWNER TO postgres;

--
-- Name: emails_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.emails_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.emails_id_seq OWNER TO postgres;

--
-- Name: emails_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.emails_id_seq OWNED BY public.mail_sender.id;


--
-- Name: error_info_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.error_info_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.error_info_id_seq OWNER TO postgres;

--
-- Name: error_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.error_info (
    id integer DEFAULT nextval('public.error_info_id_seq'::regclass) NOT NULL,
    uploadtime timestamp with time zone,
    downloadtime timestamp with time zone,
    filename character varying(80),
    errorfilename character varying(80),
    status smallint,
    objectives character varying(80),
    filepath character varying(300),
    filesize integer,
    realfilename character varying(80),
    reseller_id integer,
    type integer,
    upload_param integer,
    user_id integer,
    download_sql text,
    delimiter integer,
    header integer,
    upload_table character varying(50),
    upload_table_id integer,
    upload_real_table character varying(20),
    client_id integer,
    account_id integer
);


ALTER TABLE public.error_info OWNER TO postgres;

--
-- Name: TABLE error_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.error_info IS 'ä¸Šä¼ æˆ–è€…ä¸‹è½½æ–‡ä»¶åŽçš„ä¿¡æ¯ï¼Œæ˜¯å¦æˆåŠŸ';


--
-- Name: COLUMN error_info.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.id IS 'ä¸»é”®';


--
-- Name: COLUMN error_info.uploadtime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.uploadtime IS 'ä¸Šä¼ å¼€å§‹æ—¶é—´';


--
-- Name: COLUMN error_info.downloadtime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.downloadtime IS 'ä¸Šä¼ å®Œæˆæ—¶é—´
ä¸‹è½½æ—¶é—´';


--
-- Name: COLUMN error_info.filename; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.filename IS 'ä¸Šä¼ æ–‡ä»¶å';


--
-- Name: COLUMN error_info.errorfilename; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.errorfilename IS 'ä¸Šä¼ å¤±è´¥æ—¶è¿”å›žçš„é”™è¯¯æ–‡ä»¶å';


--
-- Name: COLUMN error_info.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.status IS '
 0â€”æ–‡ä»¶ä¸Šä¼ æˆåŠŸã€‚ æ•°æ®è¿˜æ²¡éªŒè¯ã€‚

1  -ä¸Šä¼ çš„æ–‡ä»¶è¶…è¿‡äº† php.ini ä¸­ upload_max_filesize é€‰é¡¹é™åˆ¶çš„å€¼ã€‚

2-    ä¸Šä¼ æ–‡ä»¶çš„å¤§å°è¶…è¿‡äº† HTML è¡¨å•ä¸­ MAX_FILE_SIZE é€‰é¡¹æŒ‡å®šçš„å€¼ã€‚

status==3    æ–‡ä»¶åªæœ‰éƒ¨åˆ†è¢«ä¸Šä¼
.status==4      æ²¡æœ‰æ–‡ä»¶è¢«ä¸Šä¼

status==5æ–‡ä»¶ä¸Šä¼ taida
status==6æ–‡ä»¶å·²ç»å­˜åœ¨

7  --14--æ–‡ä»¶ä¸Šä¼ æˆåŠŸå·²ç»è¢«åˆ é™¤
status==8æ–‡ä»¶å·²ç»éªŒè¯å®Œæ¯•ï¼ŒæˆåŠŸå¯¼å…¥ä¸»è¡¨



ä¸‹è½½çŠ¶æ€
12---ä¸‹è½½å®Œæˆ
11--ä¸‹è½½å¤±è´¥
13ï¼æ–‡ä»¶å·²ç»è¢«åˆ é™¤
14--æ–‡ä»¶ä¸Šä¼ æˆåŠŸå·²ç»è¢«åˆ é™¤						    ';


--
-- Name: COLUMN error_info.objectives; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.objectives IS 'ä¸Šä¼ ï¼Œä¸‹è½½çš„ç§ç±»
';


--
-- Name: COLUMN error_info.filepath; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.filepath IS 'æ–‡ä»¶è·¯å¾„';


--
-- Name: COLUMN error_info.filesize; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.filesize IS 'æ–‡ä»¶å¤§å°';


--
-- Name: COLUMN error_info.realfilename; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.realfilename IS 'ä¸Šä¼ åŽä¿å­˜çš„æ–‡ä»¶å';


--
-- Name: COLUMN error_info.reseller_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.reseller_id IS 'æ˜¯å“ªä¸ªä»£ç†å•†ä¸Šä¼ çš„';


--
-- Name: COLUMN error_info.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.type IS '1--ä¸Šä¼
2--ä¸‹è½½';


--
-- Name: COLUMN error_info.upload_param; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.upload_param IS 'ä¸Šä¼ å‚æ•°
1--è¦†ç›–é‡å¤çš„ï¼Œä¸Šä¼ æ‰€æœ‰çš„
2-å¿½ç•¥é‡å¤çš„ï¼Œåªä¸Šä¼ ä¸å­˜åœ¨çš„
3--åˆ é™¤é‡å¤çš„
4-å‡ºé”™è¿”å›žé”™è¯¯ä¿¡æ¯
';


--
-- Name: COLUMN error_info.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.user_id IS 'ç”¨æˆ·';


--
-- Name: COLUMN error_info.download_sql; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.download_sql IS 'ä¸‹è½½ä½¿ç”¨çš„sql';


--
-- Name: COLUMN error_info.delimiter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.delimiter IS 'å¯¼å‡ºç”¨åˆ°çš„åˆ†éš”ç¬¦
1--,
2--|
3--;
';


--
-- Name: COLUMN error_info.header; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.header IS 'å¯¼å‡ºæ˜¯å¦è¦å­—æ®µå¤´
1--æ˜¯
2--å¦';


--
-- Name: COLUMN error_info.upload_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.upload_table IS 'ä¸Šä¼ è¡¨';


--
-- Name: COLUMN error_info.upload_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.upload_table_id IS 'å·ç ç»„IDï¼Œ
è´¹çŽ‡æ¨¡æ¿ID';


--
-- Name: COLUMN error_info.upload_real_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_info.upload_real_table IS 'ä¸Šä¼ çš„çœŸå®žè¡¨';


--
-- Name: error_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.error_log (
    id integer NOT NULL,
    detail character varying(500),
    error_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    sent boolean DEFAULT false,
    users character varying(100)
);


ALTER TABLE public.error_log OWNER TO postgres;

--
-- Name: COLUMN error_log.sent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.error_log.sent IS '1:å·²å‘é€é‚®ä»¶
0ï¼šæœªå‘é€é‚®ä»¶';


--
-- Name: error_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.error_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.error_log_id_seq OWNER TO postgres;

--
-- Name: error_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.error_log_id_seq OWNED BY public.error_log.id;


--
-- Name: event_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.event_log (
    event_log_id integer NOT NULL,
    type integer,
    message text,
    action_date timestamp with time zone,
    sender integer
);


ALTER TABLE public.event_log OWNER TO postgres;

--
-- Name: TABLE event_log; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.event_log IS 'äº‹ä»¶æ—¥å¿—';


--
-- Name: COLUMN event_log.event_log_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_log.event_log_id IS 'ä¸»é”®';


--
-- Name: COLUMN event_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_log.type IS 'ç±»åž‹ï¼š
1 ï¼ æç¤º
2 ï¼ è­¦å‘Š
3 ï¼ é”™è¯¯';


--
-- Name: COLUMN event_log.message; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_log.message IS 'å†…å®¹';


--
-- Name: COLUMN event_log.action_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.event_log.action_date IS 'æ—¥æœŸ';


--
-- Name: event_log_event_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.event_log_event_log_id_seq
    START WITH 3
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.event_log_event_log_id_seq OWNER TO postgres;

--
-- Name: event_log_event_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.event_log_event_log_id_seq OWNED BY public.event_log.event_log_id;


--
-- Name: exchange_agent_email_type; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_email_type (
    id integer NOT NULL,
    email_type integer NOT NULL,
    email_action integer NOT NULL
);


ALTER TABLE public.exchange_agent_email_type OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_email_type.email_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_email_type.email_type IS '1:Primary Email
2:Technical Email
3:Billing Email
4:Rate Email';


--
-- Name: COLUMN exchange_agent_email_type.email_action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_email_type.email_action IS '1:push list
2:target list
3:Trouble Ticket
4:Invoice
5:Finance Alert
6:Rate';


--
-- Name: exchange_agent_email_type_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_email_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_email_type_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_email_type_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_email_type_id_seq OWNED BY public.exchange_agent_email_type.id;


--
-- Name: exchange_agent_exchange_push_list_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_exchange_push_list_log (
    id integer NOT NULL,
    create_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    finish_time timestamp without time zone,
    product_id integer,
    status integer,
    rate_type integer,
    day_num integer,
    agent_id integer
);


ALTER TABLE public.exchange_agent_exchange_push_list_log OWNER TO postgres;

--
-- Name: exchange_agent_exchange_push_list_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_exchange_push_list_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_exchange_push_list_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_exchange_push_list_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_exchange_push_list_log_id_seq OWNED BY public.exchange_agent_exchange_push_list_log.id;


--
-- Name: exchange_agent_exchange_push_list_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_exchange_push_list_result (
    id integer NOT NULL,
    code_name character varying,
    min_rate numeric,
    max_rate numeric,
    asr_1_day numeric,
    acd_1_day numeric,
    asr_3_day numeric,
    acd_3_day numeric,
    asr_7_day numeric,
    acd_7_day numeric,
    exchange_push_log_id integer,
    trunk_id character varying,
    product_id integer,
    date_time timestamp with time zone,
    file_target character varying,
    type integer,
    file_push_list character varying
);


ALTER TABLE public.exchange_agent_exchange_push_list_result OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_exchange_push_list_result.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_exchange_push_list_result.type IS '0:a-z
1:us
2:All(a-z:White)
3:All(a-z:Grey)
4:All(a-z:White Non CLI)
5:US(DNIS)
6:US(LRN)
7:ALL a-z product
8:ALL us product';


--
-- Name: exchange_agent_exchange_push_list_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_exchange_push_list_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_exchange_push_list_result_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_exchange_push_list_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_exchange_push_list_result_id_seq OWNED BY public.exchange_agent_exchange_push_list_result.id;


--
-- Name: exchange_agent_exchange_push_list_send_member; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_exchange_push_list_send_member (
    id integer NOT NULL,
    exchange_push_list_log_id integer,
    status integer,
    client_id integer,
    email_templete integer
);


ALTER TABLE public.exchange_agent_exchange_push_list_send_member OWNER TO postgres;

--
-- Name: exchange_agent_exchange_push_list_send_member_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_exchange_push_list_send_member_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_exchange_push_list_send_member_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_exchange_push_list_send_member_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_exchange_push_list_send_member_id_seq OWNED BY public.exchange_agent_exchange_push_list_send_member.id;


--
-- Name: exchange_agent_generate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_generate (
    id integer NOT NULL,
    country character varying(256),
    code_name character varying(256),
    code character varying(256),
    current_rate numeric,
    "interval" integer,
    min_time integer,
    effective_date timestamp with time zone,
    product_id integer,
    new_rate numeric,
    status integer,
    new_inter_rate numeric,
    new_intra_rate numeric,
    current_inter_rate numeric,
    current_intra_rate numeric
);


ALTER TABLE public.exchange_agent_generate OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_generate.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_generate.status IS '0:new
1:increase
2:decrease
3:invariant';


--
-- Name: exchange_agent_generate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_generate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_generate_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_generate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_generate_id_seq OWNED BY public.exchange_agent_generate.id;


--
-- Name: exchange_agent_generate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_generate_log (
    id integer NOT NULL,
    product_id integer,
    status integer,
    create_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    finish_time timestamp without time zone,
    error_file_path character varying,
    upload integer
);


ALTER TABLE public.exchange_agent_generate_log OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_generate_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_generate_log.status IS '0:
1:
2:
-1:';


--
-- Name: COLUMN exchange_agent_generate_log.upload; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_generate_log.upload IS '1-upload to rate table';


--
-- Name: exchange_agent_generate_insert_send_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_generate_insert_send_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_generate_insert_send_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_generate_insert_send_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_generate_insert_send_log_id_seq OWNED BY public.exchange_agent_generate_log.id;


--
-- Name: exchange_agent_import_target_push; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_import_target_push (
    id integer NOT NULL,
    file_path character varying NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    status integer DEFAULT 1 NOT NULL,
    job_name character varying NOT NULL,
    agent_id integer NOT NULL,
    create_by character varying
);


ALTER TABLE public.exchange_agent_import_target_push OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_import_target_push.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_import_target_push.status IS '1:loading
2:success';


--
-- Name: exchange_agent_import_target_push_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_import_target_push_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_import_target_push_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_import_target_push_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_import_target_push_id_seq OWNED BY public.exchange_agent_import_target_push.id;


--
-- Name: exchange_agent_import_target_push_job; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_import_target_push_job (
    id integer NOT NULL,
    code_name character varying,
    rate numeric,
    import_id integer,
    type integer DEFAULT 0 NOT NULL,
    agent_id integer,
    old_code_name character varying
);


ALTER TABLE public.exchange_agent_import_target_push_job OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_import_target_push_job.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_import_target_push_job.type IS '0:right
1:error';


--
-- Name: exchange_agent_import_target_push_job_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_import_target_push_job_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_import_target_push_job_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_import_target_push_job_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_import_target_push_job_id_seq OWNED BY public.exchange_agent_import_target_push_job.id;


--
-- Name: exchange_agent_mail_tmplate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_mail_tmplate (
    id integer NOT NULL,
    generate_email_content text,
    generate_email_subject text,
    target_email_content text,
    target_email_subject text,
    agent_id integer,
    exchange_push_list_email_content text,
    exchange_push_list_email_subject text,
    product_push_list_email_content text,
    product_push_list_email_subject text,
    type integer,
    email_name character varying,
    email_content character varying,
    email_subject character varying,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_time timestamp with time zone,
    par_id integer,
    carbon_copy text
);


ALTER TABLE public.exchange_agent_mail_tmplate OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_mail_tmplate.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_mail_tmplate.type IS '0:send rate
1:target
2:product push list
3:exchange push list
4:tech_info
5:block
6:vinder test
7:send test message to client(product job)
8:send valuable destination';


--
-- Name: exchange_agent_mail_tmplate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_mail_tmplate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_mail_tmplate_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_mail_tmplate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_mail_tmplate_id_seq OWNED BY public.exchange_agent_mail_tmplate.id;


--
-- Name: exchange_agent_partition_login_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_partition_login_log (
    id integer NOT NULL,
    login_name character varying,
    login_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    login_type integer DEFAULT 1 NOT NULL,
    login_ip character varying,
    login_browser character varying
);


ALTER TABLE public.exchange_agent_partition_login_log OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_partition_login_log.login_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_partition_login_log.login_type IS '1:exchange
2:agent
3:partition';


--
-- Name: exchange_agent_partition_login_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_partition_login_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_partition_login_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_partition_login_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_partition_login_log_id_seq OWNED BY public.exchange_agent_partition_login_log.id;


--
-- Name: exchange_agent_product_agent_mapping; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_product_agent_mapping (
    id integer NOT NULL,
    product_id integer,
    agent_id integer
);


ALTER TABLE public.exchange_agent_product_agent_mapping OWNER TO postgres;

--
-- Name: exchange_agent_product_agent_mapping_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_product_agent_mapping_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_product_agent_mapping_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_agent_mapping_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_product_agent_mapping_id_seq OWNED BY public.exchange_agent_product_agent_mapping.id;


--
-- Name: exchange_agent_product_client_mapping; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_product_client_mapping (
    id integer NOT NULL,
    product_id integer,
    client_id integer
);


ALTER TABLE public.exchange_agent_product_client_mapping OWNER TO postgres;

--
-- Name: exchange_agent_product_client_mapping_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_product_client_mapping_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_product_client_mapping_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_client_mapping_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_product_client_mapping_id_seq OWNED BY public.exchange_agent_product_client_mapping.id;


--
-- Name: exchange_agent_product_no_route; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_product_no_route (
    id integer NOT NULL,
    destination character varying,
    min_sell_rate numeric,
    max_sell_rate numeric,
    min_buy_rate numeric,
    max_buy_rate numeric,
    product_id integer,
    is_new boolean DEFAULT false NOT NULL,
    total_call_1hr integer,
    not_zero_calls_1hr integer,
    duration_1hr integer,
    total_call_24hr integer,
    not_zero_calls_24hr integer,
    duration_24hr integer,
    total_call_3d integer,
    not_zero_calls_3d integer,
    duration_3d integer
);


ALTER TABLE public.exchange_agent_product_no_route OWNER TO postgres;

--
-- Name: exchange_agent_product_no_route_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_product_no_route_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_product_no_route_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_no_route_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_product_no_route_id_seq OWNED BY public.exchange_agent_product_no_route.id;


--
-- Name: exchange_agent_product_no_route_now; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_product_no_route_now (
    id integer NOT NULL,
    product_id integer,
    status smallint DEFAULT 0 NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone
);


ALTER TABLE public.exchange_agent_product_no_route_now OWNER TO postgres;

--
-- Name: exchange_agent_product_no_route_now_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_product_no_route_now_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_product_no_route_now_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_no_route_now_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_product_no_route_now_id_seq OWNED BY public.exchange_agent_product_no_route_now.id;


--
-- Name: exchange_agent_product_push_list_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_product_push_list_log (
    id integer NOT NULL,
    create_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    finish_time timestamp without time zone,
    product_id integer,
    status integer
);


ALTER TABLE public.exchange_agent_product_push_list_log OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_product_push_list_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_product_push_list_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_product_push_list_log_id_seq OWNED BY public.exchange_agent_product_push_list_log.id;


--
-- Name: exchange_agent_product_push_list_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_product_push_list_result (
    id integer NOT NULL,
    code_name character varying,
    min_rate numeric,
    max_rate numeric,
    asr_1_day numeric,
    acd_1_day numeric,
    asr_3_day numeric,
    acd_3_day numeric,
    asr_7_day numeric,
    acd_7_day numeric,
    product_push_log_id integer
);


ALTER TABLE public.exchange_agent_product_push_list_result OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_product_push_list_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_product_push_list_result_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_product_push_list_result_id_seq OWNED BY public.exchange_agent_product_push_list_result.id;


--
-- Name: exchange_agent_product_push_list_send_member; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_product_push_list_send_member (
    id integer NOT NULL,
    product_push_list_log_id integer,
    status integer,
    client_id integer,
    email_templete integer
);


ALTER TABLE public.exchange_agent_product_push_list_send_member OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_send_member_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_product_push_list_send_member_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_product_push_list_send_member_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_product_push_list_send_member_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_product_push_list_send_member_id_seq OWNED BY public.exchange_agent_product_push_list_send_member.id;


--
-- Name: exchange_agent_rout_country_mapping; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_rout_country_mapping (
);


ALTER TABLE public.exchange_agent_rout_country_mapping OWNER TO postgres;

--
-- Name: exchange_agent_send_mail_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_send_mail_log (
    id integer NOT NULL,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    email_template integer,
    create_by character varying,
    end_time timestamp with time zone,
    status integer
);


ALTER TABLE public.exchange_agent_send_mail_log OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_send_mail_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_send_mail_log.status IS '1:loading
2:success';


--
-- Name: exchange_agent_send_mail_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_send_mail_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_send_mail_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_send_mail_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_send_mail_log_id_seq OWNED BY public.exchange_agent_send_mail_log.id;


--
-- Name: exchange_agent_send_mail_log_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_send_mail_log_list (
    id integer NOT NULL,
    client_id integer,
    status integer,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    error_msg text,
    log_id integer,
    email character varying
);


ALTER TABLE public.exchange_agent_send_mail_log_list OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_send_mail_log_list.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_send_mail_log_list.status IS '0:success
1:error
';


--
-- Name: exchange_agent_send_mail_log_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_send_mail_log_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_send_mail_log_list_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_send_mail_log_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_send_mail_log_list_id_seq OWNED BY public.exchange_agent_send_mail_log_list.id;


--
-- Name: exchange_agent_send_rate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_send_rate_log (
    id integer NOT NULL,
    last_rate_delivery timestamp without time zone,
    product_id integer,
    client_id integer,
    status integer,
    send_changed_rates boolean,
    send_all_rates boolean,
    email_templete integer,
    email character varying,
    email_file character varying,
    rate_type integer,
    error_msg text,
    from_where integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.exchange_agent_send_rate_log OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_send_rate_log.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_send_rate_log.rate_type IS '0-generate rate
1-rate table rate';


--
-- Name: COLUMN exchange_agent_send_rate_log.from_where; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_send_rate_log.from_where IS '0:agent
1:partition';


--
-- Name: exchange_agent_send_rate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_send_rate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_send_rate_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_send_rate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_send_rate_log_id_seq OWNED BY public.exchange_agent_send_rate_log.id;


--
-- Name: exchange_agent_target_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_target_log (
    id integer NOT NULL,
    create_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    finish_time timestamp without time zone,
    product_id integer,
    status integer
);


ALTER TABLE public.exchange_agent_target_log OWNER TO postgres;

--
-- Name: exchange_agent_target_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_target_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_target_log_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_target_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_target_log_id_seq OWNED BY public.exchange_agent_target_log.id;


--
-- Name: exchange_agent_target_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_target_result (
    id integer NOT NULL,
    code_name character varying,
    min_rate numeric,
    max_rate character varying,
    day_1_vo numeric,
    day_7_vo numeric,
    target_log_id integer
);


ALTER TABLE public.exchange_agent_target_result OWNER TO postgres;

--
-- Name: exchange_agent_target_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_target_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_target_result_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_target_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_target_result_id_seq OWNED BY public.exchange_agent_target_result.id;


--
-- Name: exchange_agent_target_send_member; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_target_send_member (
    id integer NOT NULL,
    status integer,
    target_log_id integer,
    client_id integer,
    email_templete integer,
    email character varying
);


ALTER TABLE public.exchange_agent_target_send_member OWNER TO postgres;

--
-- Name: exchange_agent_target_send_member_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_target_send_member_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_target_send_member_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_target_send_member_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_target_send_member_id_seq OWNED BY public.exchange_agent_target_send_member.id;


--
-- Name: exchange_agent_user; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_user (
    id integer NOT NULL,
    name character varying,
    pwd character varying,
    status integer DEFAULT 1 NOT NULL,
    agent_client_id integer NOT NULL,
    last_login_time timestamp with time zone,
    role_id integer
);


ALTER TABLE public.exchange_agent_user OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_user.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_user.status IS '0:unactive
1:active';


--
-- Name: exchange_agent_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_user_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_user_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_user_id_seq OWNED BY public.exchange_agent_user.id;


--
-- Name: exchange_agent_vendor_test_number; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_vendor_test_number (
    dnis character varying(40),
    code character varying(20),
    code_name character varying(100),
    country character varying(100)
);


ALTER TABLE public.exchange_agent_vendor_test_number OWNER TO postgres;

--
-- Name: exchange_agent_vendor_test_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_agent_vendor_test_result (
    id integer NOT NULL,
    egress_id integer,
    client_id integer,
    egress_ip character varying(30),
    egress_alias character varying(100),
    country character varying(100),
    code_name character varying(100),
    code character varying(20),
    dnis character varying(40),
    result_code integer,
    duration integer,
    test_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    type integer DEFAULT 0 NOT NULL,
    ani character varying(100),
    start_time timestamp with time zone,
    answer_time timestamp with time zone,
    end_time timestamp with time zone,
    pdd timestamp with time zone,
    call_result character varying(100),
    call_result_code character varying(100),
    sip_file text,
    ring_file text,
    media_file text,
    sip_view_file text,
    ring_wav_file text,
    media_wav_file text,
    media_packets integer,
    test_id integer
);


ALTER TABLE public.exchange_agent_vendor_test_result OWNER TO postgres;

--
-- Name: COLUMN exchange_agent_vendor_test_result.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_agent_vendor_test_result.type IS '0:no connect
1:connect';


--
-- Name: exchange_agent_vendor_test_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_agent_vendor_test_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_agent_vendor_test_result_id_seq OWNER TO postgres;

--
-- Name: exchange_agent_vendor_test_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_agent_vendor_test_result_id_seq OWNED BY public.exchange_agent_vendor_test_result.id;


--
-- Name: exchange_block_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_block_log (
    id integer NOT NULL,
    create_time timestamp with time zone,
    destination character varying(256),
    code character varying(256),
    egress_trunk character varying(256),
    ingress_trunk character varying(256),
    client_id integer,
    action integer,
    buy_client_id integer
);


ALTER TABLE public.exchange_block_log OWNER TO postgres;

--
-- Name: COLUMN exchange_block_log.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_block_log.action IS '0:add
1:delete';


--
-- Name: exchange_block_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_block_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_block_log_id_seq OWNER TO postgres;

--
-- Name: exchange_block_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_block_log_id_seq OWNED BY public.exchange_block_log.id;


--
-- Name: exchange_ci_sessions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_ci_sessions (
    session_id character varying DEFAULT '0'::character varying NOT NULL,
    ip_address character varying DEFAULT '0'::character varying NOT NULL,
    user_agent character varying NOT NULL,
    last_activity integer DEFAULT 0 NOT NULL,
    user_data text DEFAULT ''::text NOT NULL
);


ALTER TABLE public.exchange_ci_sessions OWNER TO postgres;

--
-- Name: exchange_client_user_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_client_user_list (
    id integer NOT NULL,
    client_id integer,
    user_id integer
);


ALTER TABLE public.exchange_client_user_list OWNER TO postgres;

--
-- Name: exchange_client_user_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_client_user_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_client_user_list_id_seq OWNER TO postgres;

--
-- Name: exchange_client_user_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_client_user_list_id_seq OWNED BY public.exchange_client_user_list.id;


--
-- Name: exchange_code_name_mapping; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_code_name_mapping (
    id integer NOT NULL,
    client_code_name character varying,
    our_code_name character varying,
    client_id integer
);


ALTER TABLE public.exchange_code_name_mapping OWNER TO postgres;

--
-- Name: exchange_code_name_mapping_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_code_name_mapping_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_code_name_mapping_id_seq OWNER TO postgres;

--
-- Name: exchange_code_name_mapping_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_code_name_mapping_id_seq OWNED BY public.exchange_code_name_mapping.id;


--
-- Name: exchange_egress_did; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_egress_did (
    id integer NOT NULL,
    number character varying,
    egress_id integer
);


ALTER TABLE public.exchange_egress_did OWNER TO postgres;

--
-- Name: exchange_egress_did_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_egress_did_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_egress_did_id_seq OWNER TO postgres;

--
-- Name: exchange_egress_did_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_egress_did_id_seq OWNED BY public.exchange_egress_did.id;


--
-- Name: exchange_false_del; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_false_del (
    id integer NOT NULL,
    resource_id integer
);


ALTER TABLE public.exchange_false_del OWNER TO postgres;

--
-- Name: exchange_false_del_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_false_del_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_false_del_id_seq OWNER TO postgres;

--
-- Name: exchange_false_del_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_false_del_id_seq OWNED BY public.exchange_false_del.id;


--
-- Name: exchange_finance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_finance (
    id integer NOT NULL,
    client_id integer,
    action_type integer,
    action_time timestamp with time zone,
    status integer DEFAULT 1 NOT NULL,
    amount numeric(30,10),
    actual_amount numeric(30,10),
    complete_time timestamp with time zone,
    action_method integer,
    action_fee numeric(30,10),
    action_number character varying(100),
    descript character varying(1000),
    vali_code character varying(32),
    pay_flag boolean DEFAULT false,
    account character varying(200),
    payer_company character varying(255),
    payer_email character varying(255)
);


ALTER TABLE public.exchange_finance OWNER TO postgres;

--
-- Name: COLUMN exchange_finance.action_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_finance.action_type IS '1--è½¬å‡º
2--è½¬å…¥';


--
-- Name: COLUMN exchange_finance.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_finance.status IS '1: waiting
2: complete
3: refuse
4:In Process
';


--
-- Name: COLUMN exchange_finance.vali_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_finance.vali_code IS 'å‘é€é‚®ç®±åŽé¢è·Ÿçš„ç¼–ç•Œç ';


--
-- Name: COLUMN exchange_finance.pay_flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_finance.pay_flag IS 'æ”¯ä»˜çŠ¶æ€  FALSE æœªæ”¯ä»˜  TRUE å·²æ”¯ä»˜';


--
-- Name: COLUMN exchange_finance.account; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_finance.account IS 'è½¬å¸åˆ°icxçš„é“¶è¡Œæˆ–paypalå¸å·';


--
-- Name: exchange_finance_agent; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_finance_agent (
    id integer NOT NULL,
    agent_id integer,
    total_amount numeric,
    status integer,
    action_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    complete_time timestamp with time zone,
    action_method integer DEFAULT 1 NOT NULL,
    action_number character varying,
    actual_amount numeric DEFAULT 0 NOT NULL,
    action_fee numeric DEFAULT 0 NOT NULL
);


ALTER TABLE public.exchange_finance_agent OWNER TO postgres;

--
-- Name: COLUMN exchange_finance_agent.action_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_finance_agent.action_method IS '1:paypal
2:wire';


--
-- Name: exchange_finance_agent_clients; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_finance_agent_clients (
    id integer NOT NULL,
    exchange_finance_agent_id integer,
    client_id integer,
    amount numeric,
    actual_amount numeric DEFAULT 0 NOT NULL,
    action_fee numeric DEFAULT 0 NOT NULL
);


ALTER TABLE public.exchange_finance_agent_clients OWNER TO postgres;

--
-- Name: exchange_finance_agent_clients_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_finance_agent_clients_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_finance_agent_clients_id_seq OWNER TO postgres;

--
-- Name: exchange_finance_agent_clients_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_finance_agent_clients_id_seq OWNED BY public.exchange_finance_agent_clients.id;


--
-- Name: exchange_finance_agent_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_finance_agent_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_finance_agent_id_seq OWNER TO postgres;

--
-- Name: exchange_finance_agent_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_finance_agent_id_seq OWNED BY public.exchange_finance_agent.id;


--
-- Name: exchange_finance_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_finance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_finance_id_seq OWNER TO postgres;

--
-- Name: exchange_finance_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_finance_id_seq OWNED BY public.exchange_finance.id;


--
-- Name: exchange_interpeering_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_interpeering_log (
    id integer NOT NULL,
    resource_id integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    file_path character varying,
    end_time timestamp with time zone,
    status integer DEFAULT 1 NOT NULL,
    error_message text,
    do_type integer DEFAULT 1 NOT NULL
);


ALTER TABLE public.exchange_interpeering_log OWNER TO postgres;

--
-- Name: COLUMN exchange_interpeering_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_interpeering_log.status IS '1:loading
2:success,
3:error';


--
-- Name: COLUMN exchange_interpeering_log.do_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_interpeering_log.do_type IS '1:Remove Existing
2:Append to Existing';


--
-- Name: exchange_interpeering_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_interpeering_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_interpeering_log_id_seq OWNER TO postgres;

--
-- Name: exchange_interpeering_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_interpeering_log_id_seq OWNED BY public.exchange_interpeering_log.id;


--
-- Name: exchange_job; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_job (
    id integer NOT NULL,
    type integer,
    test_for_fas boolean,
    block_working_route boolean DEFAULT false NOT NULL,
    block_non_working_route boolean DEFAULT true NOT NULL,
    start_time timestamp with time zone,
    test_method integer,
    low_rate_num integer,
    hig_rate_num integer,
    "position" integer,
    block_asr_xiao boolean,
    xiao_asr numeric,
    unblock_asr_da boolean,
    da_asr numeric,
    auto_block_fas boolean,
    job_name character varying,
    scheduler character varying,
    number_number integer DEFAULT 1 NOT NULL,
    trunk_type integer DEFAULT 3 NOT NULL,
    test_block integer DEFAULT 1 NOT NULL,
    product_id integer,
    buy_route_da boolean DEFAULT false,
    remove_route_xiao boolean DEFAULT false,
    test_method_first integer DEFAULT 0,
    buy_route_da_asr numeric,
    remove_route_xiao_asr numeric,
    just_test_num_ok_asr numeric,
    test_ok_num integer,
    is_test_ok_num boolean,
    active integer,
    auto_method integer,
    select_code_name_first integer,
    product_code_name_type integer,
    product_asr numeric,
    product_acd numeric,
    product_pdd integer,
    product_att integer,
    target_push_job_id integer,
    last_test_time timestamp with time zone
);


ALTER TABLE public.exchange_job OWNER TO postgres;

--
-- Name: COLUMN exchange_job.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job.type IS '0: code name
1:by trunk
2:by product
3:by block';


--
-- Name: COLUMN exchange_job.test_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job.test_method IS '1:Test All Vendors
2:Test the bottom .... Vendors with lowest rates
3:Test the top Vendors with highest rates
4:Test All Destinations
5:All Destinations that are within position of LCR
';


--
-- Name: COLUMN exchange_job.scheduler; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job.scheduler IS '1:M
2:T
3:W
4:Th
5:Fri
6:Sa
7:Su ';


--
-- Name: COLUMN exchange_job.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job.trunk_type IS '0:White
1:White Non-CLI
2:Grey
3:all
';


--
-- Name: COLUMN exchange_job.test_block; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job.test_block IS '1:test
2:no test';


--
-- Name: COLUMN exchange_job.test_method_first; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job.test_method_first IS '0:all
1:just buy
2:just not buy
3:just select trunk in page
';


--
-- Name: COLUMN exchange_job.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job.active IS '0: not start
1:start';


--
-- Name: COLUMN exchange_job.auto_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job.auto_method IS '3:3hour
6:6hour
12:12hour
24:hour
';


--
-- Name: COLUMN exchange_job.select_code_name_first; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job.select_code_name_first IS '0:all
1:select now';


--
-- Name: COLUMN exchange_job.product_code_name_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job.product_code_name_type IS '0:page select code name
1:report select code name';


--
-- Name: exchange_job_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_job_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_job_id_seq OWNER TO postgres;

--
-- Name: exchange_job_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_job_id_seq OWNED BY public.exchange_job.id;


--
-- Name: exchange_job_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_job_list (
    id integer NOT NULL,
    job_id integer,
    trunk_id integer,
    code_name character varying
);


ALTER TABLE public.exchange_job_list OWNER TO postgres;

--
-- Name: exchange_job_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_job_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_job_list_id_seq OWNER TO postgres;

--
-- Name: exchange_job_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_job_list_id_seq OWNED BY public.exchange_job_list.id;


--
-- Name: exchange_job_session; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_job_session (
    id integer NOT NULL,
    job_id integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    status integer,
    message text,
    group_number integer,
    block_group_number integer,
    create_by character varying,
    stop integer,
    stop_by character varying
);


ALTER TABLE public.exchange_job_session OWNER TO postgres;

--
-- Name: COLUMN exchange_job_session.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job_session.status IS '1:loading
2:success
3:error
';


--
-- Name: COLUMN exchange_job_session.stop; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job_session.stop IS '-1:stop';


--
-- Name: exchange_job_session_block_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_job_session_block_log (
    id integer NOT NULL,
    session_id integer,
    trunk_id integer,
    code_name character varying,
    type integer DEFAULT 1 NOT NULL,
    be_msg character varying
);


ALTER TABLE public.exchange_job_session_block_log OWNER TO postgres;

--
-- Name: COLUMN exchange_job_session_block_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job_session_block_log.type IS '1:block
2:unblock';


--
-- Name: exchange_job_session_block_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_job_session_block_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_job_session_block_log_id_seq OWNER TO postgres;

--
-- Name: exchange_job_session_block_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_job_session_block_log_id_seq OWNED BY public.exchange_job_session_block_log.id;


--
-- Name: exchange_job_session_buy_route_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_job_session_buy_route_log (
    id integer NOT NULL,
    session_id integer,
    trunk_id integer,
    code_name character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    product_id integer,
    type integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.exchange_job_session_buy_route_log OWNER TO postgres;

--
-- Name: COLUMN exchange_job_session_buy_route_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job_session_buy_route_log.type IS '0:add
1:remove';


--
-- Name: exchange_job_session_buy_route_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_job_session_buy_route_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_job_session_buy_route_log_id_seq OWNER TO postgres;

--
-- Name: exchange_job_session_buy_route_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_job_session_buy_route_log_id_seq OWNED BY public.exchange_job_session_buy_route_log.id;


--
-- Name: exchange_job_session_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_job_session_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_job_session_id_seq OWNER TO postgres;

--
-- Name: exchange_job_session_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_job_session_id_seq OWNED BY public.exchange_job_session.id;


--
-- Name: exchange_job_session_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_job_session_list (
    id integer NOT NULL,
    code character varying,
    code_name character varying,
    trunk_id integer,
    total_calls integer,
    success_calls integer,
    pdd integer,
    session_id integer,
    fas boolean,
    asr boolean,
    status integer,
    error_message text,
    caller_id character varying,
    port_msg character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE public.exchange_job_session_list OWNER TO postgres;

--
-- Name: COLUMN exchange_job_session_list.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_job_session_list.status IS '0:not connect
1:connect';


--
-- Name: exchange_job_session_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_job_session_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_job_session_list_id_seq OWNER TO postgres;

--
-- Name: exchange_job_session_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_job_session_list_id_seq OWNED BY public.exchange_job_session_list.id;


--
-- Name: exchange_job_session_remove_route_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_job_session_remove_route_log (
    id integer NOT NULL,
    session_id integer,
    trunk_id integer,
    code_name character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    product_id integer
);


ALTER TABLE public.exchange_job_session_remove_route_log OWNER TO postgres;

--
-- Name: exchange_job_session_remove_route_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_job_session_remove_route_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_job_session_remove_route_log_id_seq OWNER TO postgres;

--
-- Name: exchange_job_session_remove_route_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_job_session_remove_route_log_id_seq OWNED BY public.exchange_job_session_remove_route_log.id;


--
-- Name: exchange_mass_edit_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_mass_edit_log (
    id integer NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    status integer,
    log_msg text,
    ingress_trunk_id integer,
    mass_edit_for integer,
    select_num integer,
    routes_buy integer,
    rate_type integer,
    set_price_limit_using integer,
    per numeric,
    client_id integer,
    complete boolean DEFAULT false,
    agent_id integer,
    product_id integer,
    sell_trunks text,
    trunk_type character varying,
    ingress_prefix character varying(10),
    route_strategy_id integer,
    par_id integer,
    set_rate integer,
    rate_par numeric,
    send_email integer DEFAULT 0 NOT NULL,
    select_type integer,
    email_value character varying
);


ALTER TABLE public.exchange_mass_edit_log OWNER TO postgres;

--
-- Name: TABLE exchange_mass_edit_log; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.exchange_mass_edit_log IS 'mass_edit
';


--
-- Name: COLUMN exchange_mass_edit_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_mass_edit_log.status IS '1-running
2-done';


--
-- Name: COLUMN exchange_mass_edit_log.routes_buy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_mass_edit_log.routes_buy IS '1:Lowest ASR
2:Highest ASR
3:Lowest Cost
4:Highest Cost';


--
-- Name: COLUMN exchange_mass_edit_log.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_mass_edit_log.rate_type IS '1:ASR
2:ACD or LCR';


--
-- Name: COLUMN exchange_mass_edit_log.send_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_mass_edit_log.send_email IS '1:send
0:no send';


--
-- Name: COLUMN exchange_mass_edit_log.select_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_mass_edit_log.select_type IS '1:min
2:max';


--
-- Name: exchange_mass_edit_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_mass_edit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_mass_edit_log_id_seq OWNER TO postgres;

--
-- Name: exchange_mass_edit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_mass_edit_log_id_seq OWNED BY public.exchange_mass_edit_log.id;


--
-- Name: exchange_member_egress_test; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_member_egress_test (
    id integer NOT NULL,
    code character varying,
    code_name character varying,
    trunk_id integer,
    session_id integer,
    fas boolean,
    asr boolean,
    status integer,
    error_message text,
    caller_id character varying,
    port_msg character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE public.exchange_member_egress_test OWNER TO postgres;

--
-- Name: COLUMN exchange_member_egress_test.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_member_egress_test.status IS '0:not connect
1:connect';


--
-- Name: exchange_member_egress_test_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_member_egress_test_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_member_egress_test_id_seq OWNER TO postgres;

--
-- Name: exchange_member_egress_test_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_member_egress_test_id_seq OWNED BY public.exchange_member_egress_test.id;


--
-- Name: exchange_my_route_download_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_my_route_download_log (
    id integer NOT NULL,
    client_id integer,
    file_name character varying,
    ingress_trunk_id integer,
    status integer DEFAULT 0 NOT NULL,
    route_strategy_id integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone
);


ALTER TABLE public.exchange_my_route_download_log OWNER TO postgres;

--
-- Name: COLUMN exchange_my_route_download_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_my_route_download_log.status IS '0:waiting
1:running
2:success
-1:error';


--
-- Name: exchange_my_route_download_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_my_route_download_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_my_route_download_log_id_seq OWNER TO postgres;

--
-- Name: exchange_my_route_download_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_my_route_download_log_id_seq OWNED BY public.exchange_my_route_download_log.id;


--
-- Name: exchange_opp_email; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_opp_email (
    id integer NOT NULL,
    "from" text,
    subject text,
    header text,
    footer text,
    email_name character varying,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_time timestamp with time zone,
    agent_id integer,
    par_id integer
);


ALTER TABLE public.exchange_opp_email OWNER TO postgres;

--
-- Name: exchange_opp_email_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_opp_email_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_opp_email_id_seq OWNER TO postgres;

--
-- Name: exchange_opp_email_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_opp_email_id_seq OWNED BY public.exchange_opp_email.id;


--
-- Name: exchange_par_account; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_par_account (
    id integer NOT NULL,
    username character varying,
    pwd character varying,
    company_name character varying,
    paypal_account character varying,
    balance numeric,
    domain_name character varying,
    status integer DEFAULT 1 NOT NULL,
    logo character varying,
    last_login_time character varying,
    email character varying,
    phone_number character varying,
    invoice_text text,
    service_ip_id integer,
    ip character varying,
    par_name character varying,
    primary_email character varying,
    technical_email character varying,
    rate_send_to character varying,
    billing_email character varying,
    rate_send_from character varying,
    static_ip integer,
    static_port integer,
    service_ip_start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    service_ip_end_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    role_id integer,
    port_type integer DEFAULT 3 NOT NULL,
    smtp_email character varying,
    smtp_pwd character varying,
    host character varying,
    port character varying,
    admin_login_key character varying,
    invoice_logo character varying,
    cps integer DEFAULT 0,
    cap integer DEFAULT 2
);


ALTER TABLE public.exchange_par_account OWNER TO postgres;

--
-- Name: COLUMN exchange_par_account.port_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_par_account.port_type IS '0:by month
1:by minutes
3:no selected(default)';


--
-- Name: exchange_par_account_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_par_account_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_par_account_id_seq OWNER TO postgres;

--
-- Name: exchange_par_account_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_par_account_id_seq OWNED BY public.exchange_par_account.id;


--
-- Name: exchange_par_account_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_par_account_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_par_account_record_record_id_seq OWNER TO postgres;

--
-- Name: exchange_par_account_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_par_account_record (
    id integer,
    username character varying,
    pwd character varying,
    company_name character varying,
    paypal_account character varying,
    balance numeric,
    domain_name character varying,
    status integer,
    logo character varying,
    last_login_time character varying,
    email character varying,
    phone_number character varying,
    invoice_text text,
    service_ip_id integer,
    ip character varying,
    par_name character varying,
    primary_email character varying,
    technical_email character varying,
    rate_send_to character varying,
    billing_email character varying,
    rate_send_from character varying,
    static_ip integer,
    static_port integer,
    service_ip_start_time timestamp with time zone,
    service_ip_end_time timestamp with time zone,
    role_id integer,
    port_type integer,
    smtp_email character varying,
    smtp_pwd character varying,
    host character varying,
    port character varying,
    admin_login_key character varying,
    invoice_logo character varying,
    cps integer,
    cap integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.exchange_par_account_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.exchange_par_account_record OWNER TO postgres;

--
-- Name: exchange_par_account_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_par_account_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_par_account_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: exchange_par_account_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_par_account_record_tmp (
    id integer,
    username character varying,
    pwd character varying,
    company_name character varying,
    paypal_account character varying,
    balance numeric,
    domain_name character varying,
    status integer,
    logo character varying,
    last_login_time character varying,
    email character varying,
    phone_number character varying,
    invoice_text text,
    service_ip_id integer,
    ip character varying,
    par_name character varying,
    primary_email character varying,
    technical_email character varying,
    rate_send_to character varying,
    billing_email character varying,
    rate_send_from character varying,
    static_ip integer,
    static_port integer,
    service_ip_start_time timestamp with time zone,
    service_ip_end_time timestamp with time zone,
    role_id integer,
    port_type integer,
    smtp_email character varying,
    smtp_pwd character varying,
    host character varying,
    port character varying,
    admin_login_key character varying,
    invoice_logo character varying,
    cps integer,
    cap integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.exchange_par_account_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.exchange_par_account_record_tmp OWNER TO postgres;

--
-- Name: exchange_par_active_ips; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_par_active_ips (
    id integer NOT NULL,
    ip_port character varying,
    status integer DEFAULT 0 NOT NULL,
    to_buy_start_time timestamp with time zone
);


ALTER TABLE public.exchange_par_active_ips OWNER TO postgres;

--
-- Name: COLUMN exchange_par_active_ips.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_par_active_ips.status IS '0:no userd
1:be userd';


--
-- Name: exchange_par_active_ips_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_par_active_ips_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_par_active_ips_id_seq OWNER TO postgres;

--
-- Name: exchange_par_active_ips_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_par_active_ips_id_seq OWNED BY public.exchange_par_active_ips.id;


--
-- Name: exchange_par_plan; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_par_plan (
    id integer NOT NULL,
    remain_minute numeric,
    cost_min numeric,
    money numeric,
    type integer DEFAULT 0 NOT NULL,
    port integer,
    minutes numeric,
    cps integer
);


ALTER TABLE public.exchange_par_plan OWNER TO postgres;

--
-- Name: COLUMN exchange_par_plan.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_par_plan.type IS '0:by Month
1:by Minute';


--
-- Name: exchange_par_plan_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_par_plan_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_par_plan_id_seq OWNER TO postgres;

--
-- Name: exchange_par_plan_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_par_plan_id_seq OWNED BY public.exchange_par_plan.id;


--
-- Name: exchange_par_plan_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_par_plan_record (
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    exchange_par_plan_id integer,
    status integer DEFAULT 0 NOT NULL,
    par_id integer,
    des character varying,
    id integer NOT NULL,
    amount numeric,
    month_num integer,
    action_fee numeric DEFAULT 0 NOT NULL,
    ip_id integer,
    icx_get_amount numeric,
    error_status integer,
    unit_price numeric
);


ALTER TABLE public.exchange_par_plan_record OWNER TO postgres;

--
-- Name: COLUMN exchange_par_plan_record.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_par_plan_record.status IS '0:plan uncommitted
1:plan success
2:new ip uncommitted
3:new ip success
4:extend exists ip uncommitted
5:extend exists ip success';


--
-- Name: COLUMN exchange_par_plan_record.error_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_par_plan_record.error_status IS '0:payment but no exchange_par_switch_profiles log
1:zhe ip overdate
2:actived ip (exchange_par_active_ips)
3.partition account error
4.partition port_type error
5:port plan no find
6:extend ip --->not has ip_id
7:extend ip----->not has ip';


--
-- Name: exchange_par_plan_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_par_plan_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_par_plan_record_id_seq OWNER TO postgres;

--
-- Name: exchange_par_plan_record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_par_plan_record_id_seq OWNED BY public.exchange_par_plan_record.id;


--
-- Name: exchange_par_port; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_par_port (
    id integer NOT NULL,
    par_id integer,
    port integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    minutes numeric
);


ALTER TABLE public.exchange_par_port OWNER TO postgres;

--
-- Name: exchange_par_port_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_par_port_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_par_port_id_seq OWNER TO postgres;

--
-- Name: exchange_par_port_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_par_port_id_seq OWNED BY public.exchange_par_port.id;


--
-- Name: exchange_par_script; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_par_script (
    id integer NOT NULL,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    error text,
    message text,
    type integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.exchange_par_script OWNER TO postgres;

--
-- Name: COLUMN exchange_par_script.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_par_script.type IS '0:check_switch_ip
1:check_par_port';


--
-- Name: exchange_par_script_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_par_script_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_par_script_id_seq OWNER TO postgres;

--
-- Name: exchange_par_script_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_par_script_id_seq OWNED BY public.exchange_par_script.id;


--
-- Name: exchange_par_switch_profiles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_par_switch_profiles (
    id integer NOT NULL,
    par_id integer,
    service_ip_id integer,
    service_ip_start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    service_ip_end_time timestamp with time zone,
    type integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.exchange_par_switch_profiles OWNER TO postgres;

--
-- Name: COLUMN exchange_par_switch_profiles.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_par_switch_profiles.type IS '0:public
1:private';


--
-- Name: exchange_par_switch_profiles_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_par_switch_profiles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_par_switch_profiles_id_seq OWNER TO postgres;

--
-- Name: exchange_par_switch_profiles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_par_switch_profiles_id_seq OWNED BY public.exchange_par_switch_profiles.id;


--
-- Name: exchange_par_system_parm; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_par_system_parm (
    id integer NOT NULL,
    ip_month_money numeric
);


ALTER TABLE public.exchange_par_system_parm OWNER TO postgres;

--
-- Name: exchange_par_system_parm_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_par_system_parm_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_par_system_parm_id_seq OWNER TO postgres;

--
-- Name: exchange_par_system_parm_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_par_system_parm_id_seq OWNED BY public.exchange_par_system_parm.id;


--
-- Name: exchange_partition_payment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_partition_payment (
    id integer,
    par_id integer,
    total_amount numeric,
    status integer,
    action_time timestamp with time zone,
    complete_time timestamp with time zone,
    action_method integer,
    action_number character varying,
    actual_amount numeric,
    action_fee numeric
);


ALTER TABLE public.exchange_partition_payment OWNER TO postgres;

--
-- Name: exchange_product_copy_rate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_product_copy_rate_log (
    id integer NOT NULL,
    agent_id integer,
    product_id integer,
    from_product_id integer,
    status integer DEFAULT 0 NOT NULL,
    par_id integer
);


ALTER TABLE public.exchange_product_copy_rate_log OWNER TO postgres;

--
-- Name: exchange_product_copy_rate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_product_copy_rate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_product_copy_rate_log_id_seq OWNER TO postgres;

--
-- Name: exchange_product_copy_rate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_product_copy_rate_log_id_seq OWNED BY public.exchange_product_copy_rate_log.id;


--
-- Name: exchange_product_copy_route_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_product_copy_route_log (
    id integer NOT NULL,
    agent_id integer,
    product_id integer,
    from_product_id integer,
    status integer DEFAULT 0 NOT NULL,
    par_id integer
);


ALTER TABLE public.exchange_product_copy_route_log OWNER TO postgres;

--
-- Name: exchange_product_copy_route_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_product_copy_route_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_product_copy_route_log_id_seq OWNER TO postgres;

--
-- Name: exchange_product_copy_route_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_product_copy_route_log_id_seq OWNED BY public.exchange_product_copy_route_log.id;


--
-- Name: exchange_product_copy_route_rate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_product_copy_route_rate_log (
    id integer NOT NULL,
    agent_id integer,
    product_id integer,
    from_product_id integer,
    status integer,
    par_id integer
);


ALTER TABLE public.exchange_product_copy_route_rate_log OWNER TO postgres;

--
-- Name: exchange_product_copy_route_rate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_product_copy_route_rate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_product_copy_route_rate_log_id_seq OWNER TO postgres;

--
-- Name: exchange_product_copy_route_rate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_product_copy_route_rate_log_id_seq OWNED BY public.exchange_product_copy_route_rate_log.id;


--
-- Name: exchange_product_user_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_product_user_list (
    id integer NOT NULL,
    product_id integer,
    user_id integer
);


ALTER TABLE public.exchange_product_user_list OWNER TO postgres;

--
-- Name: exchange_public_user_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_public_user_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_public_user_list_id_seq OWNER TO postgres;

--
-- Name: exchange_public_user_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_public_user_list_id_seq OWNED BY public.exchange_product_user_list.id;


--
-- Name: exchange_reg_country; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_reg_country (
    id integer NOT NULL,
    country character varying
);


ALTER TABLE public.exchange_reg_country OWNER TO postgres;

--
-- Name: exchange_reg_country_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_reg_country_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_reg_country_id_seq OWNER TO postgres;

--
-- Name: exchange_reg_country_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_reg_country_id_seq OWNED BY public.exchange_reg_country.id;


--
-- Name: exchange_resource_private; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_resource_private (
    id integer NOT NULL,
    ingress_trunk_id integer,
    code_name character varying,
    egress_trunk_id integer,
    create_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    change_key character varying,
    status integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.exchange_resource_private OWNER TO postgres;

--
-- Name: exchange_resource_private_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_resource_private_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_resource_private_id_seq OWNER TO postgres;

--
-- Name: exchange_resource_private_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_resource_private_id_seq OWNED BY public.exchange_resource_private.id;


--
-- Name: exchange_simple_session; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_simple_session (
    id integer NOT NULL,
    status integer DEFAULT 1,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_time timestamp with time zone,
    message text,
    group_number integer,
    create_by character varying
);


ALTER TABLE public.exchange_simple_session OWNER TO postgres;

--
-- Name: exchange_simple_session_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_simple_session_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_simple_session_id_seq OWNER TO postgres;

--
-- Name: exchange_simple_session_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_simple_session_id_seq OWNED BY public.exchange_simple_session.id;


--
-- Name: exchange_simple_session_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_simple_session_list (
    id integer NOT NULL,
    code character varying,
    code_name character varying,
    trunk_id integer,
    total_calls integer,
    success_calls integer,
    pdd integer,
    session_id integer,
    fas boolean,
    asr boolean,
    status integer,
    error_message text,
    caller_id character varying,
    port_msg character varying,
    "time" integer
);


ALTER TABLE public.exchange_simple_session_list OWNER TO postgres;

--
-- Name: COLUMN exchange_simple_session_list.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_simple_session_list.status IS '0: not content
1:content';


--
-- Name: exchange_simple_session_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_simple_session_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_simple_session_list_id_seq OWNER TO postgres;

--
-- Name: exchange_simple_session_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_simple_session_list_id_seq OWNED BY public.exchange_simple_session_list.id;


--
-- Name: exchange_sys_module; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_sys_module (
    id integer NOT NULL,
    module_name character varying,
    order_num integer,
    type integer
);


ALTER TABLE public.exchange_sys_module OWNER TO postgres;

--
-- Name: COLUMN exchange_sys_module.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_sys_module.type IS '0:exchange
1:agent
2:partition
';


--
-- Name: exchange_sys_module_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_sys_module_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_sys_module_id_seq OWNER TO postgres;

--
-- Name: exchange_sys_module_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_sys_module_id_seq OWNED BY public.exchange_sys_module.id;


--
-- Name: exchange_sys_pri; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_sys_pri (
    id integer NOT NULL,
    pri_name character varying(100) NOT NULL,
    module_id integer,
    pri_val character varying(100) NOT NULL,
    flag boolean DEFAULT true NOT NULL,
    pri_url character varying(200)
);


ALTER TABLE public.exchange_sys_pri OWNER TO postgres;

--
-- Name: TABLE exchange_sys_pri; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.exchange_sys_pri IS 'ç³»ç»ŸåŠ¨ä½œï¼Œæœ¬ç³»ç»Ÿè®¤ä¸ºæ˜¯å„æ ç›®';


--
-- Name: COLUMN exchange_sys_pri.pri_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_sys_pri.pri_name IS 'æ¨¡å—åï¼Œå†…éƒ¨ä½¿ç”¨';


--
-- Name: COLUMN exchange_sys_pri.pri_val; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_sys_pri.pri_val IS 'æ¨¡å—æ˜¾ç¤ºå';


--
-- Name: COLUMN exchange_sys_pri.pri_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_sys_pri.pri_url IS 'æ¨¡å—çš„urlæŒ‡å‘';


--
-- Name: exchange_sys_pri_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_sys_pri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_sys_pri_id_seq OWNER TO postgres;

--
-- Name: exchange_sys_pri_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_sys_pri_id_seq OWNED BY public.exchange_sys_pri.id;


--
-- Name: exchange_sys_role; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_sys_role (
    role_id integer NOT NULL,
    role_name character varying(100),
    role_info character varying(1000),
    view_all boolean DEFAULT false,
    delete_invoice smallint DEFAULT 0,
    delete_payment smallint DEFAULT 0,
    delete_credit_note smallint DEFAULT 0,
    delete_debit_note smallint DEFAULT 0,
    reset_balance smallint DEFAULT 0,
    modify_credit_limit smallint DEFAULT 0,
    modify_min_profit smallint DEFAULT 0,
    type integer DEFAULT 1 NOT NULL,
    agent_id integer,
    client_id integer,
    par_id integer
);


ALTER TABLE public.exchange_sys_role OWNER TO postgres;

--
-- Name: COLUMN exchange_sys_role.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.exchange_sys_role.type IS '0:exchange
1:agent
2:partition

3:agent_user
4:exchange_user
5:partition_user';


--
-- Name: exchange_sys_role_pri; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_sys_role_pri (
    id integer NOT NULL,
    role_id integer,
    pri_name character varying(100) NOT NULL,
    model_r boolean DEFAULT false NOT NULL,
    model_w boolean DEFAULT false NOT NULL,
    model_x boolean DEFAULT false NOT NULL,
    pri_id integer
);


ALTER TABLE public.exchange_sys_role_pri OWNER TO postgres;

--
-- Name: exchange_sys_role_pri_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_sys_role_pri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_sys_role_pri_id_seq OWNER TO postgres;

--
-- Name: exchange_sys_role_pri_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_sys_role_pri_id_seq OWNED BY public.exchange_sys_role_pri.id;


--
-- Name: exchange_sys_role_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.exchange_sys_role_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.exchange_sys_role_role_id_seq OWNER TO postgres;

--
-- Name: exchange_sys_role_role_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.exchange_sys_role_role_id_seq OWNED BY public.exchange_sys_role.role_id;


--
-- Name: exchange_vendor_test_number; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.exchange_vendor_test_number (
    id integer NOT NULL,
    code_name character varying(100),
    code character varying(100)
);


ALTER TABLE public.exchange_vendor_test_number OWNER TO postgres;

--
-- Name: execution_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.execution_log (
    id integer NOT NULL,
    rule_name character varying(100),
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    ani_find character varying(500),
    of_calls character varying(100),
    msg text,
    status integer,
    exec_type integer
);


ALTER TABLE public.execution_log OWNER TO postgres;

--
-- Name: TABLE execution_log; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.execution_log IS 'dialer detection æ¯æ¬¡æ‰§è¡Œçš„æ—¶é—´å’Œç»“æžœ';


--
-- Name: COLUMN execution_log.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.execution_log.id IS 'ä¸»é”®';


--
-- Name: execution_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.execution_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.execution_log_id_seq OWNER TO postgres;

--
-- Name: execution_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.execution_log_id_seq OWNED BY public.execution_log.id;


--
-- Name: export_task_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.export_task_log (
    id bigint NOT NULL,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    ingress_carrier_id numeric,
    egress_carrier_id numeric,
    egress_trunk_id numeric,
    ingress_code_name character varying,
    egress_code_name character varying,
    ingress_code numeric,
    egress_code numeric,
    ingress_country character varying,
    non_zero boolean,
    switch_profile_ip character varying,
    ingress_ani character varying,
    egress_ani character varying,
    ingress_dnis character varying,
    egress_dnis character varying,
    routing_digit character varying,
    ingress_call_id numeric,
    egress_call_id numeric,
    unauthorized_ip boolean DEFAULT true,
    status numeric DEFAULT 0,
    progress numeric DEFAULT 0,
    path character varying,
    requested_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    started_on timestamp with time zone,
    finished_on timestamp with time zone,
    ingress_trunk_id numeric,
    egress_country character varying,
    return_filter character varying,
    gcs_url character varying,
    error character varying,
    websocket_files text,
    use_client_cdr boolean DEFAULT true,
    task_type numeric DEFAULT 1,
    rate_table_id integer,
    routing_plan_id integer,
    group_by text,
    time_group_by text,
    cause integer,
    carrier_id integer,
    trunk_id integer,
    code_name integer
);


ALTER TABLE public.export_task_log OWNER TO postgres;

--
-- Name: COLUMN export_task_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.export_task_log.status IS '0: Waiting. 1: in progress ,2: success 3: failed';


--
-- Name: export_task_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.export_task_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.export_task_log_id_seq OWNER TO postgres;

--
-- Name: export_task_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.export_task_log_id_seq OWNED BY public.export_task_log.id;


--
-- Name: fas_check_result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.fas_check_result (
    id integer NOT NULL,
    callid character varying(255) NOT NULL,
    calltime character varying(255) NOT NULL,
    result smallint
);


ALTER TABLE public.fas_check_result OWNER TO postgres;

--
-- Name: fas_check_result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.fas_check_result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fas_check_result_id_seq OWNER TO postgres;

--
-- Name: fas_check_result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.fas_check_result_id_seq OWNED BY public.fas_check_result.id;


--
-- Name: fraud_detection; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.fraud_detection (
    id integer NOT NULL,
    rule_name character varying(100),
    active boolean,
    hourly_minute integer,
    hourly_revenue integer,
    daily_minute integer,
    daily_revenue integer,
    is_block boolean,
    is_send_mail boolean,
    email_to integer,
    ingress_ids character varying(500),
    update_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying(100)
);


ALTER TABLE public.fraud_detection OWNER TO postgres;

--
-- Name: COLUMN fraud_detection.hourly_minute; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.fraud_detection.hourly_minute IS '1å°æ—¶å†…çš„åˆ†é’Ÿæ•°';


--
-- Name: COLUMN fraud_detection.hourly_revenue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.fraud_detection.hourly_revenue IS '1å°æ—¶å†…çš„åˆ©æ¶¦';


--
-- Name: COLUMN fraud_detection.daily_minute; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.fraud_detection.daily_minute IS '24å°æ—¶å†…çš„åˆ†é’Ÿæ•°';


--
-- Name: COLUMN fraud_detection.daily_revenue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.fraud_detection.daily_revenue IS '24å°æ—¶å†…çš„åˆ©æ¶¦';


--
-- Name: COLUMN fraud_detection.email_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.fraud_detection.email_to IS '0: switch NOC
1: Partnerâ€™s NOC
2:both';


--
-- Name: fraud_detection_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.fraud_detection_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fraud_detection_id_seq OWNER TO postgres;

--
-- Name: fraud_detection_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.fraud_detection_id_seq OWNED BY public.fraud_detection.id;


--
-- Name: fraud_detection_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.fraud_detection_log (
    id integer NOT NULL,
    fraud_detection_id integer,
    create_on timestamp with time zone,
    create_by integer,
    status integer,
    finish_time timestamp with time zone,
    "time" numeric DEFAULT date_part('epoch'::text, ('now'::text)::timestamp(0) with time zone)
);


ALTER TABLE public.fraud_detection_log OWNER TO postgres;

--
-- Name: COLUMN fraud_detection_log.create_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.fraud_detection_log.create_by IS '0 auto
1 Manual';


--
-- Name: COLUMN fraud_detection_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.fraud_detection_log.status IS '0 normal
1 over limit';


--
-- Name: fraud_detection_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.fraud_detection_log_detail (
    id integer NOT NULL,
    fraud_detection_log_id integer,
    ingress_id integer,
    block_type integer,
    limit_value integer,
    actual_value character varying(50),
    partner_email_msg text,
    partner_email_status boolean,
    partner_email character varying(200),
    system_email_msg text,
    system_email_status boolean,
    system_email character varying(200),
    is_block boolean DEFAULT false,
    is_send_email boolean DEFAULT false
);


ALTER TABLE public.fraud_detection_log_detail OWNER TO postgres;

--
-- Name: COLUMN fraud_detection_log_detail.block_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.fraud_detection_log_detail.block_type IS '0 1h minute
1 1h revenue
2 24h minute
3 24h revenue
';


--
-- Name: fraud_detection_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.fraud_detection_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fraud_detection_log_detail_id_seq OWNER TO postgres;

--
-- Name: fraud_detection_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.fraud_detection_log_detail_id_seq OWNED BY public.fraud_detection_log_detail.id;


--
-- Name: fraud_detection_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.fraud_detection_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fraud_detection_log_id_seq OWNER TO postgres;

--
-- Name: fraud_detection_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.fraud_detection_log_id_seq OWNED BY public.fraud_detection_log.id;


--
-- Name: ftp_cdr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ftp_cdr (
    ftp_user character varying(100),
    ftp_pw character varying(100),
    run_freq integer,
    cdr_fields text,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    last_run_time timestamp with time zone,
    cdr_alias text
);


ALTER TABLE public.ftp_cdr OWNER TO postgres;

--
-- Name: ftp_cdr_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ftp_cdr_log (
    id integer NOT NULL,
    ftp_start_time timestamp with time zone,
    ftp_end_time timestamp with time zone,
    status integer,
    ftp_ip character varying(255),
    ftp_dir character varying,
    alias character varying(255),
    ftp_conf_id integer,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    pid integer,
    detail text
);


ALTER TABLE public.ftp_cdr_log OWNER TO postgres;

--
-- Name: COLUMN ftp_cdr_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ftp_cdr_log.status IS '-1--ftp error
-2--cdr file error
-3--db error
1--done';


--
-- Name: ftp_cdr_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ftp_cdr_log_detail (
    id integer NOT NULL,
    ftp_cdr_log_id integer,
    create_time timestamp with time zone,
    file_name character varying,
    ftp_ip character varying(255),
    ftp_dir character varying,
    detail text,
    local_file_path character varying(500)
);


ALTER TABLE public.ftp_cdr_log_detail OWNER TO postgres;

--
-- Name: ftp_cdr_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ftp_cdr_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ftp_cdr_log_detail_id_seq OWNER TO postgres;

--
-- Name: ftp_cdr_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ftp_cdr_log_detail_id_seq OWNED BY public.ftp_cdr_log_detail.id;


--
-- Name: ftp_cdr_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ftp_cdr_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ftp_cdr_log_id_seq OWNER TO postgres;

--
-- Name: ftp_cdr_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ftp_cdr_log_id_seq OWNED BY public.ftp_cdr_log.id;


--
-- Name: ftp_conf; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ftp_conf (
    id integer NOT NULL,
    server_ip character varying(100),
    server_port character varying(100),
    username character varying(100),
    password character varying(100),
    frequency smallint DEFAULT 0,
    fields text,
    headers text,
    contain_headers boolean,
    file_type integer,
    ingress_carriers text,
    egress_carriers text,
    ingress_carriers_all boolean DEFAULT false,
    egress_carriers_all boolean DEFAULT false,
    duration integer,
    ingress_release_cause text,
    egress_release_cause text,
    conditions text,
    ingresses text,
    egresses text,
    ingresses_all boolean DEFAULT false,
    egresses_all boolean DEFAULT false,
    "time" character varying(255),
    alias character varying(255),
    server_dir character varying(255),
    max_lines integer DEFAULT 10000 NOT NULL,
    active boolean DEFAULT true,
    every_hours integer DEFAULT 1,
    file_breakdown integer DEFAULT 0,
    every_minutes integer DEFAULT 15,
    every_day integer
);


ALTER TABLE public.ftp_conf OWNER TO postgres;

--
-- Name: COLUMN ftp_conf.file_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ftp_conf.file_type IS '1--gz
2--tar.gz
3--tar.bz2';


--
-- Name: ftp_conf_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ftp_conf_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ftp_conf_id_seq OWNER TO postgres;

--
-- Name: ftp_conf_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ftp_conf_id_seq OWNED BY public.ftp_conf.id;


--
-- Name: ftp_server_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ftp_server_log (
    id integer NOT NULL,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    cmd text,
    response text
);


ALTER TABLE public.ftp_server_log OWNER TO postgres;

--
-- Name: ftp_server_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ftp_server_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ftp_server_log_id_seq OWNER TO postgres;

--
-- Name: ftp_server_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ftp_server_log_id_seq OWNED BY public.ftp_server_log.id;


--
-- Name: global_failover; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.global_failover (
    id integer NOT NULL,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100)
);


ALTER TABLE public.global_failover OWNER TO postgres;

--
-- Name: global_failover_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.global_failover_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.global_failover_id_seq OWNER TO postgres;

--
-- Name: global_failover_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.global_failover_id_seq OWNED BY public.global_failover.id;


--
-- Name: global_route_error; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.global_route_error (
    id integer NOT NULL,
    error_code integer,
    error_description character varying(100),
    to_sip_code integer,
    to_sip_string character varying(100),
    default_to_sip_code integer,
    default_to_sip_string character varying(100)
);


ALTER TABLE public.global_route_error OWNER TO postgres;

--
-- Name: TABLE global_route_error; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.global_route_error IS 'class4æ— æ³•è·¯ç”±é”™è¯¯ä¸Žè¿”å›žç»™ä¸»å«çš„é”™è¯¯ç å…¨å±€é…ç½®

baohq20140423';


--
-- Name: COLUMN global_route_error.error_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.global_route_error.error_code IS 'route error type

baohq20140423';


--
-- Name: COLUMN global_route_error.error_description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.global_route_error.error_description IS 'route error description

baohq20140423';


--
-- Name: COLUMN global_route_error.to_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.global_route_error.to_sip_code IS 'è¿”å›žç»™ä¸»å«çš„sipé”™è¯¯ç 

baohq20140423';


--
-- Name: COLUMN global_route_error.to_sip_string; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.global_route_error.to_sip_string IS 'è¿”å›žç»™ä¸»å«çš„sipæè¿°

baohq20140423';


--
-- Name: COLUMN global_route_error.default_to_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.global_route_error.default_to_sip_code IS 'baohq20140423';


--
-- Name: COLUMN global_route_error.default_to_sip_string; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.global_route_error.default_to_sip_string IS 'baohq20140423';


--
-- Name: global_route_error_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.global_route_error_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.global_route_error_id_seq OWNER TO postgres;

--
-- Name: global_route_error_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.global_route_error_id_seq OWNED BY public.global_route_error.id;


--
-- Name: global_route_error_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.global_route_error_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.global_route_error_record_record_id_seq OWNER TO postgres;

--
-- Name: global_route_error_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.global_route_error_record (
    id integer,
    error_code integer,
    error_description character varying(100),
    to_sip_code integer,
    to_sip_string character varying(100),
    default_to_sip_code integer,
    default_to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.global_route_error_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.global_route_error_record OWNER TO postgres;

--
-- Name: global_route_error_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.global_route_error_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.global_route_error_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: global_route_error_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.global_route_error_record_tmp (
    id integer,
    error_code integer,
    error_description character varying(100),
    to_sip_code integer,
    to_sip_string character varying(100),
    default_to_sip_code integer,
    default_to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.global_route_error_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.global_route_error_record_tmp OWNER TO postgres;

--
-- Name: hang_calls_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.hang_calls_history (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    total_cdrs integer,
    huang_cdr_counts integer
);


ALTER TABLE public.hang_calls_history OWNER TO postgres;

--
-- Name: hang_calls_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.hang_calls_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.hang_calls_history_id_seq OWNER TO postgres;

--
-- Name: hang_calls_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.hang_calls_history_id_seq OWNED BY public.hang_calls_history.id;


--
-- Name: hang_calls_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.hang_calls_list (
    hang_calls_history_id integer,
    "time" timestamp with time zone,
    duration integer,
    ingress_trunk character varying(20),
    egress_trunk character varying(20),
    ingresss_ip character varying(20),
    egress_ip character varying(20),
    ingress_profile_ip character varying(20),
    egress_profile_ip character varying(20),
    orig_ani character varying(20),
    orig_dnis character varying(20),
    term_ani character varying(20),
    term_dnis character varying(20)
);


ALTER TABLE public.hang_calls_list OWNER TO postgres;

--
-- Name: host_based_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.host_based_report (
    report_time timestamp with time zone,
    duration integer,
    ingress_bill_time integer,
    ingress_call_cost numeric(15,6),
    ingress_total_calls integer,
    not_zero_calls integer,
    ingress_success_calls integer,
    ingress_busy_calls integer,
    pdd bigint,
    ingress_cancel_calls integer,
    ingress_client_id integer,
    egress_client_id integer,
    egress_bill_time integer,
    egress_call_cost numeric(15,6),
    egress_total_calls integer,
    egress_success_calls integer,
    egress_busy_calls integer,
    egress_cancel_calls integer,
    ingress_ip character varying(50),
    egress_ip character varying(50),
    ingress_avg_rate double precision,
    egress_avg_rate double precision,
    cdr_date character varying(24)
);


ALTER TABLE public.host_based_report OWNER TO postgres;

--
-- Name: host_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.host_info (
    "time" character varying(100),
    res_id character varying(100),
    ip_id character varying(100),
    acd character varying(100),
    asr character varying(100),
    ca character varying(100),
    call_count character varying(100),
    direction character varying(100),
    call_count_asr character varying(100),
    pdd character varying(100),
    ip character varying(100)
);


ALTER TABLE public.host_info OWNER TO postgres;

--
-- Name: TABLE host_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.host_info IS 'host monitor';


--
-- Name: COLUMN host_info."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info."time" IS 'æ—¶é—´';


--
-- Name: COLUMN host_info.res_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info.res_id IS 'ç½‘å…³';


--
-- Name: COLUMN host_info.ip_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info.ip_id IS 'host';


--
-- Name: COLUMN host_info.acd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info.acd IS 'å¹³å‡é€šè¯æ—¶é•¿';


--
-- Name: COLUMN host_info.asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info.asr IS 'æŽ¥é€šæˆåŠŸçŽ‡';


--
-- Name: COLUMN host_info.ca; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info.ca IS 'ca';


--
-- Name: COLUMN host_info.call_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info.call_count IS 'call_count';


--
-- Name: COLUMN host_info.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info.direction IS 'ingress,egress
direction = 0 æ‰“è¿›
ingress
direction = 1æ‰“å‡º
egress';


--
-- Name: COLUMN host_info.call_count_asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info.call_count_asr IS 'call_count_asr';


--
-- Name: COLUMN host_info.pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info.pdd IS 'å‘¼å«å»¶è¿Ÿæ—¶é—´';


--
-- Name: COLUMN host_info.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.host_info.ip IS 'æœåŠ¡æœŸåœ°å€';


--
-- Name: hung_calls_detection_configuration; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.hung_calls_detection_configuration (
    id integer NOT NULL,
    duration integer,
    "interval" smallint,
    day_of_week integer,
    "time" character varying(50),
    action smallint,
    receiver character varying(200)
);


ALTER TABLE public.hung_calls_detection_configuration OWNER TO postgres;

--
-- Name: hung_calls_detection_configuration_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.hung_calls_detection_configuration_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.hung_calls_detection_configuration_id_seq OWNER TO postgres;

--
-- Name: hung_calls_detection_configuration_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.hung_calls_detection_configuration_id_seq OWNED BY public.hung_calls_detection_configuration.id;


--
-- Name: hung_calls_report_delete_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.hung_calls_report_delete_log (
    id integer NOT NULL,
    bak_ids character varying(500),
    delete_time timestamp with time zone,
    delete_by character varying(50)
);


ALTER TABLE public.hung_calls_report_delete_log OWNER TO postgres;

--
-- Name: hung_calls_report_delete_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.hung_calls_report_delete_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.hung_calls_report_delete_log_id_seq OWNER TO postgres;

--
-- Name: hung_calls_report_delete_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.hung_calls_report_delete_log_id_seq OWNED BY public.hung_calls_report_delete_log.id;


--
-- Name: import_code_constraints_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.import_code_constraints_log (
    id integer NOT NULL,
    create_time timestamp with time zone,
    file_path character varying(256),
    file_name character varying(256),
    status integer DEFAULT 0,
    client_id integer,
    file_header character varying(256),
    file_start_line integer
);


ALTER TABLE public.import_code_constraints_log OWNER TO postgres;

--
-- Name: import_code_constraints_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.import_code_constraints_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.import_code_constraints_log_id_seq OWNER TO postgres;

--
-- Name: import_code_constraints_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.import_code_constraints_log_id_seq OWNED BY public.import_code_constraints_log.id;


--
-- Name: import_export_logs_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.import_export_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.import_export_logs_id_seq OWNER TO postgres;

--
-- Name: import_export_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.import_export_logs (
    id integer DEFAULT nextval('public.import_export_logs_id_seq'::regclass) NOT NULL,
    file_path character varying(300) DEFAULT ''::character varying NOT NULL,
    error_file_path character varying(300) DEFAULT ''::character varying NOT NULL,
    status integer DEFAULT 0 NOT NULL,
    user_id integer DEFAULT 0 NOT NULL,
    obj character varying(80),
    log_type integer DEFAULT 0 NOT NULL,
    "time" timestamp with time zone,
    finished_time timestamp with time zone,
    duplicate_type character varying(16),
    ext_attributes text,
    server_id integer DEFAULT 0 NOT NULL,
    upload_table character varying(100),
    upload_type integer,
    db_error_file_path character varying(100),
    duplicate_numbers integer DEFAULT 0,
    foreign_id integer,
    success_numbers integer DEFAULT 0,
    error_row integer DEFAULT 0,
    error_rollback boolean DEFAULT false,
    php_process_number bigint DEFAULT 0,
    db_process_number bigint DEFAULT 0,
    foreign_name character varying(80),
    auto_enddate integer DEFAULT 0,
    custom_end_date timestamp with time zone,
    pid integer,
    myfile_filename character varying(100)
);


ALTER TABLE public.import_export_logs OWNER TO postgres;

--
-- Name: TABLE import_export_logs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.import_export_logs IS 'ä¸Šè½½ï¼ä¸‹è½½ï¼Œæ—¥å¿—';


--
-- Name: COLUMN import_export_logs.file_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.file_path IS 'ä¸Šä¼  ä¸‹è½½ çš„æ–‡ä»¶çš„è·¯å¾„';


--
-- Name: COLUMN import_export_logs.error_file_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.error_file_path IS 'ä¸Šä¼ æ–‡ä»¶æ—¶ï¼Œ å¤„ç†å‡ºé”™è®°å½•æ–‡ä»¶è·¯å¾„ ';


--
-- Name: COLUMN import_export_logs.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.status IS 'status==0ä¸Šä¼ æ–‡ä»¶åˆ°æœåŠ¡å™¨
status==10
status==8æ–‡ä»¶å·²ç»éªŒè¯å®Œæ¯•ï¼ŒæˆåŠŸå¯¼å…¥ä¸´æ—¶è¡¨
status==9  PHPå¼€å§‹éªŒè¯ ï¼ï¼å¯¼å…¥ä¸´æ—¶è¡¨å¤„ç†ä¸­
status==7æ­£åœ¨è¿›è¡Œæ•°æ®åº“éªŒè¯
status==6æ•°æ®åº“éªŒè¯å®Œæˆ  ä¸Šä¼ å®Œæˆ
status==-1è¡¨æœ‰é”™è¯¯(å¤–é”®ä¸å­˜åœ¨)

1--processing
2--done
-2--upload file open error
-3--upload error file open error
-4--csv head error
-5--database error';


--
-- Name: COLUMN import_export_logs.log_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.log_type IS 'LOG_TYPE_EXPORT = 0;
LOG_TYPE_IMPORT = 1;';


--
-- Name: COLUMN import_export_logs."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs."time" IS 'ä¸Šä¼  ä¸‹è½½çš„æ—¶é—´';


--
-- Name: COLUMN import_export_logs.finished_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.finished_time IS 'ä¸Šä¼  å¤„ç†å®Œçš„æ—¶é—´';


--
-- Name: COLUMN import_export_logs.duplicate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.duplicate_type IS 'ä¸Šä¼ æ—¶ï¼Œ é‡å¤çš„å¤„ç†æ–¹å¼';


--
-- Name: COLUMN import_export_logs.ext_attributes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.ext_attributes IS 'ä¿å­˜ä¸€äº›å…¶å®ƒå‚æ•°ï¼Œ ä¿å­˜ serializeä¹‹åŽçš„æ ¼å¼';


--
-- Name: COLUMN import_export_logs.upload_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.upload_table IS 'ä¸´æ—¶è¡¨å';


--
-- Name: COLUMN import_export_logs.upload_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.upload_type IS '1-ingress
2-egress
3-host
4-resource action
5-resource digit mapping
6-digit translation
7-resource block
8-jurisdiction
9-code deck
10-rate
11-static route
12-route plan';


--
-- Name: COLUMN import_export_logs.db_error_file_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.db_error_file_path IS 'æ•°æ®åº“éªŒè¯é”™è¯¯æ–‡ä»¶ç›®å½•';


--
-- Name: COLUMN import_export_logs.duplicate_numbers; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.duplicate_numbers IS 'é‡å¤çš„è¡Œæ•°';


--
-- Name: COLUMN import_export_logs.foreign_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.foreign_id IS 'å¤–é”®çš„id
6-digit translation
9-code deck
10-rate
11-static route
12-route plan';


--
-- Name: COLUMN import_export_logs.error_row; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.error_row IS 'é”™è¯¯å¤šå°‘è¡Œ';


--
-- Name: COLUMN import_export_logs.php_process_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.php_process_number IS 'php éªŒè¯å¤„ç†å¤šå°‘è¡Œ';


--
-- Name: COLUMN import_export_logs.db_process_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.db_process_number IS 'æ•°æ®åº“éªŒè¯å¤„ç†å¤šå°‘è¡Œ';


--
-- Name: COLUMN import_export_logs.foreign_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_export_logs.foreign_name IS 'å¤–é”®å¯¹åº”çš„name';


--
-- Name: import_rate_file_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.import_rate_file_log (
    id integer NOT NULL,
    file_path character varying(256),
    file_name character varying(225),
    client_id integer,
    egress_trunk_id integer,
    end_date character varying(225),
    date_format character varying(225),
    sample_do character varying(225),
    ratetable_id integer,
    status integer DEFAULT 1,
    product_id integer,
    agent_id integer,
    par_id integer,
    old_file_path character varying
);


ALTER TABLE public.import_rate_file_log OWNER TO postgres;

--
-- Name: import_rate_file_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.import_rate_file_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.import_rate_file_log_id_seq OWNER TO postgres;

--
-- Name: import_rate_file_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.import_rate_file_log_id_seq OWNED BY public.import_rate_file_log.id;


--
-- Name: import_rate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.import_rate_log (
    id integer NOT NULL,
    import_file character varying(300),
    status integer DEFAULT 0 NOT NULL,
    cli_type integer,
    dtmf boolean,
    g729 boolean,
    resource_id integer,
    prefix character varying(30),
    order_type integer DEFAULT 1 NOT NULL,
    client_id integer,
    error_file integer,
    create_time timestamp with time zone,
    duplicate_type character varying(30),
    code_deck_id integer DEFAULT 1
);


ALTER TABLE public.import_rate_log OWNER TO postgres;

--
-- Name: COLUMN import_rate_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_rate_log.status IS '0:æ–‡ä»¶ä¸Šä¼ å®Œæˆ
1:orderç”Ÿæˆå®Œæˆ';


--
-- Name: COLUMN import_rate_log.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_rate_log.order_type IS '1ï¼šbuy
2ï¼šsell';


--
-- Name: import_rate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.import_rate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.import_rate_log_id_seq OWNER TO postgres;

--
-- Name: import_rate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.import_rate_log_id_seq OWNED BY public.import_rate_log.id;


--
-- Name: import_rate_status; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.import_rate_status (
    id integer NOT NULL,
    rate_table_id integer,
    status integer DEFAULT 0,
    delete_queue integer DEFAULT 0,
    update_queue integer DEFAULT 0,
    insert_queue integer DEFAULT 0,
    error_counter integer DEFAULT 0,
    reimport_counter integer DEFAULT 0,
    error_log_file character varying(256),
    reimport_log_file character varying(256),
    "time" timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    upload_file_name character varying(256),
    local_file character varying(256),
    method integer DEFAULT 0,
    user_id integer,
    start_epoch bigint,
    end_epoch bigint,
    sql_record text,
    default_info character varying(200)
);


ALTER TABLE public.import_rate_status OWNER TO postgres;

--
-- Name: TABLE import_rate_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.import_rate_status IS 'exchange ä¸Šä¼ è´¹çŽ‡çš„log';


--
-- Name: COLUMN import_rate_status.reimport_counter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_rate_status.reimport_counter IS 'é”™è¯¯çš„åˆå‡ºé‡æ–°ä¸Šä¼ å¤šå°‘è®°å½•';


--
-- Name: COLUMN import_rate_status.reimport_log_file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_rate_status.reimport_log_file IS 'é”™è¯¯ å¹¶ä¸”é‡æ–°ä¸Šä¼ çš„é”™çŽ°çš„é”™è¯¯æ–‡ä»¶';


--
-- Name: COLUMN import_rate_status.start_epoch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_rate_status.start_epoch IS 'å¼€å§‹ä¸Šä¼ æ—¶é—´';


--
-- Name: COLUMN import_rate_status.end_epoch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_rate_status.end_epoch IS 'ç»“æŸä¸Šä¼ æ—¶é—´';


--
-- Name: COLUMN import_rate_status.sql_record; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_rate_status.sql_record IS 'è®°å½•ä¸Šä¼ æ“ä½œçš„cmd';


--
-- Name: COLUMN import_rate_status.default_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.import_rate_status.default_info IS 'example:Effective Date:yyyy-mm-dd hh:ii:ss<br />Min Time:1<br />Interval:2';


--
-- Name: import_rate_status_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.import_rate_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.import_rate_status_id_seq OWNER TO postgres;

--
-- Name: import_rate_status_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.import_rate_status_id_seq OWNED BY public.import_rate_status.id;


--
-- Name: import_target_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.import_target_log (
    id integer NOT NULL,
    status integer DEFAULT 1,
    client_id integer,
    create_time timestamp without time zone,
    file_name character varying(256),
    file_path character varying(256),
    error_message character varying(256)
);


ALTER TABLE public.import_target_log OWNER TO postgres;

--
-- Name: import_target_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.import_target_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.import_target_log_id_seq OWNER TO postgres;

--
-- Name: import_target_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.import_target_log_id_seq OWNED BY public.import_target_log.id;


--
-- Name: ingress_did_repository; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ingress_did_repository (
    number character varying(255) NOT NULL,
    ingress_id integer,
    egress_id integer,
    created_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    updated_time timestamp with time zone,
    state character varying(200),
    country character varying(200),
    city character varying(200),
    rate_center character varying(200),
    status smallint DEFAULT 0,
    type smallint,
    lata character varying(100)
);


ALTER TABLE public.ingress_did_repository OWNER TO postgres;

--
-- Name: COLUMN ingress_did_repository.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ingress_did_repository.type IS '(''Local'' => 1, ''TollFree'' => 2)';


--
-- Name: ingress_test; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ingress_test (
    id integer NOT NULL,
    ingress_id integer,
    code_name character varying(100),
    dnis character varying(1000),
    ani character varying(100),
    call_duration integer,
    start_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    status integer DEFAULT 0,
    ingress_ip character varying(100)
);


ALTER TABLE public.ingress_test OWNER TO postgres;

--
-- Name: COLUMN ingress_test.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ingress_test.status IS '0-wait
1-running
2-done
-1-open file error';


--
-- Name: ingress_test_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ingress_test_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ingress_test_id_seq OWNER TO postgres;

--
-- Name: ingress_test_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ingress_test_id_seq OWNED BY public.ingress_test.id;


--
-- Name: invalid_detection_block_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invalid_detection_block_log (
    id integer NOT NULL,
    created_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    number_type integer,
    ingress_id integer,
    number character varying,
    rule_id integer,
    block_type integer,
    blocked_on timestamp with time zone
);


ALTER TABLE public.invalid_detection_block_log OWNER TO postgres;

--
-- Name: COLUMN invalid_detection_block_log.block_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_detection_block_log.block_type IS '1 block;2unblock';


--
-- Name: invalid_detection_block_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invalid_detection_block_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invalid_detection_block_log_id_seq OWNER TO postgres;

--
-- Name: invalid_detection_block_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invalid_detection_block_log_id_seq OWNED BY public.invalid_detection_block_log.id;


--
-- Name: invalid_number_detection; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invalid_number_detection (
    id integer NOT NULL,
    rule_name character varying(100),
    update_by character varying(100),
    update_at timestamp with time zone,
    active boolean,
    ani_check_all boolean,
    ani_ingress character varying(500),
    ani_check_cycle integer,
    ani_threshold integer,
    ani_limit_percent integer,
    ani_return_codes character varying(100),
    dnis_check_all boolean,
    dnis_ingress character varying(500),
    dnis_check_cycle integer,
    dnis_threshold integer,
    dnis_limit_percent integer,
    dnis_return_codes character varying(100),
    block integer,
    unblock integer,
    unblock_min integer,
    send_email integer,
    email_to integer,
    subject text,
    content text,
    ani_last_run_time timestamp with time zone,
    dnis_last_run_time timestamp with time zone
);


ALTER TABLE public.invalid_number_detection OWNER TO postgres;

--
-- Name: COLUMN invalid_number_detection.ani_check_cycle; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection.ani_check_cycle IS 'å¾ªçŽ¯çš„åˆ†é’Ÿ';


--
-- Name: COLUMN invalid_number_detection.ani_threshold; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection.ani_threshold IS 'æœ€å°çš„æ¬¡æ•°';


--
-- Name: COLUMN invalid_number_detection.ani_limit_percent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection.ani_limit_percent IS 'é”™è¯¯codeçš„ç™¾åˆ†æ¯”';


--
-- Name: COLUMN invalid_number_detection.dnis_check_cycle; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection.dnis_check_cycle IS 'å¾ªçŽ¯æ—¶é—´';


--
-- Name: COLUMN invalid_number_detection.dnis_threshold; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection.dnis_threshold IS 'æœ€å°æ¬¡æ•°';


--
-- Name: COLUMN invalid_number_detection.dnis_limit_percent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection.dnis_limit_percent IS 'æœ€å°ç™¾åˆ†æ¯”';


--
-- Name: COLUMN invalid_number_detection.block; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection.block IS 'æ˜¯å¦block';


--
-- Name: COLUMN invalid_number_detection.unblock; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection.unblock IS 'æ˜¯å¦unblock';


--
-- Name: COLUMN invalid_number_detection.unblock_min; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection.unblock_min IS 'unblockçš„æ—¶é—´';


--
-- Name: COLUMN invalid_number_detection.send_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection.send_email IS 'æ˜¯å¦å‘é‚®ä»¶';


--
-- Name: invalid_number_detection_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invalid_number_detection_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invalid_number_detection_id_seq OWNER TO postgres;

--
-- Name: invalid_number_detection_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invalid_number_detection_id_seq OWNED BY public.invalid_number_detection.id;


--
-- Name: invalid_number_detection_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invalid_number_detection_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    finished_time timestamp with time zone,
    code_type integer,
    ingress_id integer,
    total_num integer,
    invalid_num integer,
    detection_id integer
);


ALTER TABLE public.invalid_number_detection_log OWNER TO postgres;

--
-- Name: COLUMN invalid_number_detection_log.code_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection_log.code_type IS '1:ANI
2:DNIS';


--
-- Name: invalid_number_detection_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invalid_number_detection_log_detail (
    id integer NOT NULL,
    log_id integer,
    ingress_id integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    total_call integer,
    count404 integer,
    count503 integer,
    count200 integer,
    others_call integer,
    code_type integer,
    number character varying(100)
);


ALTER TABLE public.invalid_number_detection_log_detail OWNER TO postgres;

--
-- Name: COLUMN invalid_number_detection_log_detail.code_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invalid_number_detection_log_detail.code_type IS '1:ANI
2:DNIS';


--
-- Name: invalid_number_detection_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invalid_number_detection_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invalid_number_detection_log_detail_id_seq OWNER TO postgres;

--
-- Name: invalid_number_detection_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invalid_number_detection_log_detail_id_seq OWNED BY public.invalid_number_detection_log_detail.id;


--
-- Name: invalid_number_detection_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invalid_number_detection_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invalid_number_detection_log_id_seq OWNER TO postgres;

--
-- Name: invalid_number_detection_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invalid_number_detection_log_id_seq OWNED BY public.invalid_number_detection_log.id;


--
-- Name: invocie_item_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invocie_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invocie_item_id_seq OWNER TO postgres;

--
-- Name: invoice; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice (
    invoice_id integer NOT NULL,
    invoice_number character varying(20) NOT NULL,
    state integer DEFAULT 0 NOT NULL,
    type integer,
    client_id integer,
    invoice_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    invoice_start timestamp with time zone NOT NULL,
    invoice_end timestamp with time zone NOT NULL,
    total_amount numeric(30,5) DEFAULT 0 NOT NULL,
    paid boolean DEFAULT false NOT NULL,
    due_date date,
    pay_amount numeric(30,5) DEFAULT 0 NOT NULL,
    current_balance numeric(30,10) NOT NULL,
    total_minutes real,
    disputed integer DEFAULT 0,
    send_time timestamp with time zone,
    create_type integer DEFAULT 0,
    buy_total numeric(30,10),
    sell_total numeric(30,10),
    buy_minutes real,
    sell_minutes real,
    buy_service_charge numeric(30,10),
    sell_service_charge numeric(30,10),
    link_cdr character varying(50),
    credit_amount numeric(30,5) DEFAULT 0,
    pdf_path character varying(300),
    cdr_path character varying(300),
    lrn_numbers integer,
    lrn_rate numeric(30,10),
    lrn_cost numeric(30,10),
    disputed_amount numeric(30,10),
    credit_note numeric(30,10),
    invoice_zone character varying(10),
    reconcile_file_path character varying,
    reconcile_state integer DEFAULT 0,
    output_type integer DEFAULT 0,
    status integer,
    include_detail boolean DEFAULT true,
    generate_start_time timestamp with time zone,
    generate_copy_time timestamp with time zone,
    generate_stats_time timestamp with time zone,
    generate_end_time timestamp with time zone,
    invoice_jurisdictional_detail boolean DEFAULT true,
    previous_balance numeric(30,10),
    payment_credit numeric(30,10),
    finance_charge numeric(30,10),
    decurring_charge numeric(30,10),
    non_recurring_charge numeric(30,10),
    tax numeric(30,10),
    decimal_place integer DEFAULT 5,
    rate_value integer DEFAULT 0,
    scc_cost numeric(30,5),
    is_invoice_account_summary boolean DEFAULT false,
    new_balance numeric(30,10),
    is_show_daily_usage boolean DEFAULT false,
    scc_calls integer,
    scc_per real,
    invoice_include_payment boolean,
    scc_sec integer,
    is_short_duration_call_surcharge_detail boolean DEFAULT false,
    usage_detail_fields text,
    ingress_cdr_file character varying(255),
    egress_cdr_file character varying(255),
    current_charge numeric(30,10),
    invoice_log_id integer,
    invoice_use_balance_type integer DEFAULT 0,
    invoice_balance_time timestamp with time zone,
    total_calls integer DEFAULT 0,
    decimals_num integer,
    please_pay numeric(20,5),
    credit_remaining numeric(20,5),
    unlimited_credit_unlimited boolean DEFAULT false,
    payment_term character varying,
    is_show_total_trunk boolean DEFAULT false,
    is_show_detail_trunk boolean DEFAULT false,
    is_show_code_100 boolean DEFAULT false,
    is_show_code_name boolean DEFAULT false,
    is_show_country boolean DEFAULT false,
    is_show_by_date boolean DEFAULT false,
    is_send_as_link boolean DEFAULT false,
    cdr_link text,
    cdr_token text,
    api_requests integer DEFAULT 0,
    api_params text
);


ALTER TABLE public.invoice OWNER TO postgres;

--
-- Name: TABLE invoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.invoice IS 'å‘ç¥¨';


--
-- Name: COLUMN invoice.invoice_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.invoice_id IS 'ä¸»é”®';


--
-- Name: COLUMN invoice.invoice_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.invoice_number IS 'å‘ç¥¨å·ç ';


--
-- Name: COLUMN invoice.state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.state IS '-1:void
0:normal
1:verify
9:send';


--
-- Name: COLUMN invoice.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.type IS '0:sent(out--buy)
1:received(in--sell)
2:sent(all)
3:incoming ';


--
-- Name: COLUMN invoice.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN invoice.invoice_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.invoice_time IS 'ç”Ÿæˆæ—¶é—´';


--
-- Name: COLUMN invoice.invoice_start; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.invoice_start IS 'å¼€å§‹æ—¥æœŸ';


--
-- Name: COLUMN invoice.invoice_end; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.invoice_end IS 'æˆªæ­¢æ—¥æœŸ';


--
-- Name: COLUMN invoice.total_amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.total_amount IS 'å‘ç¥¨é‡‘é¢';


--
-- Name: COLUMN invoice.paid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.paid IS 'æ˜¯å¦ä»˜æ¸…';


--
-- Name: COLUMN invoice.due_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.due_date IS 'ä»˜æ¬¾æ—¥æœŸ ---è¿‡æœŸæ—¶é—´';


--
-- Name: COLUMN invoice.pay_amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.pay_amount IS 'è·¯ç”±ä¼™ä¼´çš„ä»˜æ¬¾é‡‘é¢';


--
-- Name: COLUMN invoice.current_balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.current_balance IS 'å½“å‰ä½™é¢';


--
-- Name: COLUMN invoice.disputed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.disputed IS '0-Non-Disputed
1-Disputed
2-Dispute Resolved';


--
-- Name: COLUMN invoice.send_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.send_time IS 'å‘é€invoiceæ—¶é—´';


--
-- Name: COLUMN invoice.create_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.create_type IS '0-Auto-generated Invoice
1-Manual Invoice';


--
-- Name: COLUMN invoice.pdf_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.pdf_path IS 'pdfå­˜å‚¨è·¯å¾„';


--
-- Name: COLUMN invoice.cdr_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.cdr_path IS 'cdrå­˜å‚¨è·¯å¾„';


--
-- Name: COLUMN invoice.reconcile_state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.reconcile_state IS '0: æœ‰å¯æ¯”è¾ƒçš„æ–‡ä»¶
1: è¿›è¡Œä¸­
2: å·²ç»å®Œæˆ';


--
-- Name: COLUMN invoice.output_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.output_type IS '0 ------- pdf
1 ------- excel
2 ------- html';


--
-- Name: COLUMN invoice.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice.status IS '0--creating
1--zero cdr
2--done
-1--only support buy/sell';


--
-- Name: invoice_calls; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_calls (
    invoice_calls_id integer NOT NULL,
    calls_count integer,
    total_minutes real,
    avg_rate numeric(30,10),
    cost numeric(30,10),
    code_name character varying(100),
    invoice_no character varying(100),
    invoice_type integer,
    country character varying(100),
    effective_date character varying(100),
    contract_number character varying(20),
    inter_minutes real,
    intra_minutes real,
    inter_rate numeric(30,10),
    intra_rate numeric(30,10),
    inter_cost numeric(30,10),
    intra_cost numeric(30,10),
    trunk_name integer,
    prefix character varying(200)
);


ALTER TABLE public.invoice_calls OWNER TO postgres;

--
-- Name: invoice_calls_detail_by_trunk; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_calls_detail_by_trunk (
    resource_id integer,
    prefix character varying(50),
    calls integer,
    minutes real,
    amount numeric(30,10),
    invoice_no character varying(100)
);


ALTER TABLE public.invoice_calls_detail_by_trunk OWNER TO postgres;

--
-- Name: invoice_calls_invoice_calls_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_calls_invoice_calls_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_calls_invoice_calls_id_seq OWNER TO postgres;

--
-- Name: invoice_calls_invoice_calls_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_calls_invoice_calls_id_seq OWNED BY public.invoice_calls.invoice_calls_id;


--
-- Name: invoice_calls_total_by_trunk; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_calls_total_by_trunk (
    resource_id integer,
    prefix character varying(50),
    inter_calls integer,
    inter_minutes real,
    inter_acd real,
    inter_amount numeric(30,10),
    intra_calls integer,
    intra_minutes real,
    intra_acd real,
    intra_amount numeric(30,10),
    indeter_calls integer,
    indeter_minutes real,
    indeter_acd real,
    indeter_amount numeric(30,10),
    invoice_no character varying(100),
    amount numeric(30,10),
    no_call_6 integer
);


ALTER TABLE public.invoice_calls_total_by_trunk OWNER TO postgres;

--
-- Name: invoice_cdr_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_cdr_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    type integer,
    invoice_number character varying(255),
    carrier_name character varying(255)
);


ALTER TABLE public.invoice_cdr_log OWNER TO postgres;

--
-- Name: invoice_cdr_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_cdr_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_cdr_log_id_seq OWNER TO postgres;

--
-- Name: invoice_cdr_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_cdr_log_id_seq OWNED BY public.invoice_cdr_log.id;


--
-- Name: invoice_credit_note; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_credit_note (
    id integer NOT NULL,
    invoice_no character varying(20),
    credit_amount numeric(30,10),
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    note character varying(100)
);


ALTER TABLE public.invoice_credit_note OWNER TO postgres;

--
-- Name: invoice_credit_note_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_credit_note_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_credit_note_id_seq OWNER TO postgres;

--
-- Name: invoice_credit_note_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_credit_note_id_seq OWNED BY public.invoice_credit_note.id;


--
-- Name: invoice_daily_cost; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_daily_cost (
    id integer NOT NULL,
    invoice_no character varying(100),
    invoice_date timestamp with time zone,
    intra_mins real,
    inter_mins real,
    other_mins real,
    intra_cost numeric(30,10),
    inter_cost numeric(30,10),
    other_cost numeric(30,10)
);


ALTER TABLE public.invoice_daily_cost OWNER TO postgres;

--
-- Name: invoice_daily_cost_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_daily_cost_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_daily_cost_id_seq OWNER TO postgres;

--
-- Name: invoice_daily_cost_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_daily_cost_id_seq OWNED BY public.invoice_daily_cost.id;


--
-- Name: invoice_did; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_did (
    id integer NOT NULL,
    invoice_number character varying(50),
    did_rate real,
    did_total_count integer,
    did_total_cost real,
    did_plan character varying(100),
    channel_rate real,
    channel_total_count integer,
    channel_total_cost real
);


ALTER TABLE public.invoice_did OWNER TO postgres;

--
-- Name: invoice_did_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_did_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_did_id_seq OWNER TO postgres;

--
-- Name: invoice_did_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_did_id_seq OWNED BY public.invoice_did.id;


--
-- Name: invoice_email; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_email (
    id integer NOT NULL,
    invoice_no character varying(20),
    mail_content character varying(1000),
    send_time timestamp with time zone,
    pdf_file character varying(100),
    send_address character varying(100),
    mail_sub character varying(100)
);


ALTER TABLE public.invoice_email OWNER TO postgres;

--
-- Name: invoice_email_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_email_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_email_id_seq OWNER TO postgres;

--
-- Name: invoice_email_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_email_id_seq OWNED BY public.invoice_email.id;


--
-- Name: invoice_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_history (
    id integer NOT NULL,
    client_id integer NOT NULL,
    last_invoice_for date DEFAULT ('now'::text)::date,
    reminders_count integer DEFAULT 0,
    next_reminder_timestamp integer DEFAULT 0,
    invoice_filename character varying(500),
    start_time timestamp without time zone,
    end_time timestamp without time zone
);


ALTER TABLE public.invoice_history OWNER TO postgres;

--
-- Name: invoice_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_history_id_seq OWNER TO postgres;

--
-- Name: invoice_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_history_id_seq OWNED BY public.invoice_history.id;


--
-- Name: invoice_invoice_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_invoice_id_seq OWNER TO postgres;

--
-- Name: invoice_invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_invoice_id_seq OWNED BY public.invoice.invoice_id;


--
-- Name: invoice_item; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_item (
    id integer DEFAULT nextval('public.invocie_item_id_seq'::regclass) NOT NULL,
    invoice_id integer,
    item character varying(20),
    price numeric(20,10)
);


ALTER TABLE public.invoice_item OWNER TO postgres;

--
-- Name: invoice_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    status integer DEFAULT 0,
    cnt integer DEFAULT 1
);


ALTER TABLE public.invoice_log OWNER TO postgres;

--
-- Name: COLUMN invoice_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice_log.status IS '0 begin
1 progress
2 done
3 error';


--
-- Name: COLUMN invoice_log.cnt; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoice_log.cnt IS 'invoice æ€»æ•°
';


--
-- Name: invoice_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_log_id_seq OWNER TO postgres;

--
-- Name: invoice_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_log_id_seq OWNED BY public.invoice_log.id;


--
-- Name: invoice_payment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_payment (
    id integer NOT NULL,
    invoice_no character varying(50),
    payment_time timestamp with time zone,
    payment_amount numeric(30,10)
);


ALTER TABLE public.invoice_payment OWNER TO postgres;

--
-- Name: invoice_payment_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_payment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_payment_id_seq OWNER TO postgres;

--
-- Name: invoice_payment_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_payment_id_seq OWNED BY public.invoice_payment.id;


--
-- Name: invoice_reconcile; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_reconcile (
    id integer NOT NULL,
    code public.prefix_range,
    minute numeric,
    cost numeric,
    sys_minute numeric,
    sys_cost numeric,
    minute_diff_amt numeric,
    minute_diff_per numeric,
    cost_diff_amt numeric,
    cost_diff_per numeric,
    invoice_id bigint
);


ALTER TABLE public.invoice_reconcile OWNER TO postgres;

--
-- Name: invoice_reconcile_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_reconcile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_reconcile_id_seq OWNER TO postgres;

--
-- Name: invoice_reconcile_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_reconcile_id_seq OWNED BY public.invoice_reconcile.id;


--
-- Name: invoice_service_charge; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_service_charge (
    invoice_service_charge_id integer NOT NULL,
    invoice_no character varying(100),
    invoice_type integer,
    rate numeric(30,10),
    less_rate_minutes integer,
    greater_rate_minutes integer,
    less_rate_usage_fee numeric(30,10),
    less_rate_charges numeric(30,10),
    greater_rate_usage_fee numeric(30,10),
    greater_rate_charges numeric(30,10),
    greater_max_rate_minutes integer,
    greater_max_rate_usage_fee numeric(30,10),
    greater_max_rate_charges numeric(30,10),
    max_rate numeric(30,10)
);


ALTER TABLE public.invoice_service_charge OWNER TO postgres;

--
-- Name: invoice_service_charge_invoice_service_charge_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoice_service_charge_invoice_service_charge_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoice_service_charge_invoice_service_charge_id_seq OWNER TO postgres;

--
-- Name: invoice_service_charge_invoice_service_charge_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoice_service_charge_invoice_service_charge_id_seq OWNED BY public.invoice_service_charge.invoice_service_charge_id;


--
-- Name: invoice_show_code_100; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_show_code_100 (
    code character varying(100),
    calls integer,
    minutes real,
    amount numeric(30,10),
    invoice_no character varying(100)
);


ALTER TABLE public.invoice_show_code_100 OWNER TO postgres;

--
-- Name: invoice_show_code_name; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_show_code_name (
    code_name character varying(100),
    calls integer,
    minutes real,
    amount numeric(30,10),
    invoice_no character varying(100)
);


ALTER TABLE public.invoice_show_code_name OWNER TO postgres;

--
-- Name: invoice_show_country; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_show_country (
    country character varying(100),
    calls integer,
    minutes real,
    amount numeric(30,10),
    invoice_no character varying(100)
);


ALTER TABLE public.invoice_show_country OWNER TO postgres;

--
-- Name: invoice_show_date; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_show_date (
    time_day character varying(50),
    calls integer,
    minutes real,
    amount numeric(30,10),
    invoice_no character varying(100)
);


ALTER TABLE public.invoice_show_date OWNER TO postgres;

--
-- Name: ip_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ip_info (
    "time" character varying(100),
    ip_id character varying(100),
    value character varying(100),
    direction character varying(100),
    ip character varying(100)
);


ALTER TABLE public.ip_info OWNER TO postgres;

--
-- Name: TABLE ip_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ip_info IS 'ip monitor';


--
-- Name: COLUMN ip_info."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_info."time" IS 'æ—¶é—´';


--
-- Name: COLUMN ip_info.ip_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_info.ip_id IS 'ip';


--
-- Name: COLUMN ip_info.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_info.value IS 'é€šè¯æ•°';


--
-- Name: COLUMN ip_info.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_info.direction IS 'ingress,egress';


--
-- Name: COLUMN ip_info.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_info.ip IS 'æœåŠ¡å™¨åœ°å€';


--
-- Name: ip_modif_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ip_modif_log (
    modify integer,
    detail character(100),
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    trunk_id integer,
    id integer NOT NULL,
    email character varying(100),
    old character varying(100),
    new character varying(100)
);


ALTER TABLE public.ip_modif_log OWNER TO postgres;

--
-- Name: TABLE ip_modif_log; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.ip_modif_log IS 'ipçš„å¢žåˆ æ”¹çš„ è®°å½•';


--
-- Name: COLUMN ip_modif_log.modify; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_modif_log.modify IS '0-- ä¿®æ”¹
1-- add
2-- delete';


--
-- Name: COLUMN ip_modif_log.detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_modif_log.detail IS 'addã€deleteä¸ºæ‰€æ”¹ip
modify ä¸º oldip=ã€‹newip
';


--
-- Name: COLUMN ip_modif_log.update_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_modif_log.update_at IS 'ä¿®æ”¹æ—¶é—´';


--
-- Name: COLUMN ip_modif_log.update_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_modif_log.update_by IS 'æ“ä½œäºº';


--
-- Name: COLUMN ip_modif_log.old; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_modif_log.old IS 'old values';


--
-- Name: COLUMN ip_modif_log.new; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ip_modif_log.new IS 'new values';


--
-- Name: ip_modif_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ip_modif_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ip_modif_log_id_seq OWNER TO postgres;

--
-- Name: ip_modif_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ip_modif_log_id_seq OWNED BY public.ip_modif_log.id;


--
-- Name: jurisdiction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.jurisdiction_id_seq
    START WITH 40
    INCREMENT BY 1
    MINVALUE 40
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.jurisdiction_id_seq OWNER TO postgres;

--
-- Name: jurisdiction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.jurisdiction (
    id integer DEFAULT nextval('public.jurisdiction_id_seq'::regclass) NOT NULL,
    alias character varying(40),
    name character varying(100),
    jurisdiction_country_id integer
);


ALTER TABLE public.jurisdiction OWNER TO postgres;

--
-- Name: TABLE jurisdiction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.jurisdiction IS 'è®¡è´¹åŒºåŸŸç®¡ç†';


--
-- Name: COLUMN jurisdiction.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction.id IS 'ä¸»é”®';


--
-- Name: COLUMN jurisdiction.alias; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction.alias IS 'åˆ«å';


--
-- Name: COLUMN jurisdiction.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction.name IS 'åç§°';


--
-- Name: jurisdiction_country; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.jurisdiction_country (
    id integer NOT NULL,
    name character varying(100)
);


ALTER TABLE public.jurisdiction_country OWNER TO postgres;

--
-- Name: jurisdiction_country_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.jurisdiction_country_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.jurisdiction_country_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_country_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.jurisdiction_country_id_seq OWNED BY public.jurisdiction_country.id;


--
-- Name: jurisdiction_id_seq1; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.jurisdiction_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.jurisdiction_id_seq1 OWNER TO postgres;

--
-- Name: jurisdiction_id_seq1; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.jurisdiction_id_seq1 OWNED BY public.jurisdiction.id;


--
-- Name: jurisdiction_prefix_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.jurisdiction_prefix_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.jurisdiction_prefix_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_prefix; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.jurisdiction_prefix (
    id integer DEFAULT nextval('public.jurisdiction_prefix_id_seq'::regclass) NOT NULL,
    alias character varying(40),
    prefix public.prefix_range NOT NULL,
    jurisdiction_id integer,
    jurisdiction_country_id integer,
    jurisdiction_name character varying(100),
    jurisdiction_country_name character varying(100),
    ocn character varying(10),
    lata character varying(10),
    block_id character(1),
    effective_date timestamp with time zone
);


ALTER TABLE public.jurisdiction_prefix OWNER TO postgres;

--
-- Name: TABLE jurisdiction_prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.jurisdiction_prefix IS 'è®¡è´¹åŒºåŸŸå‰ç¼€';


--
-- Name: COLUMN jurisdiction_prefix.alias; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_prefix.alias IS 'åˆ«å';


--
-- Name: COLUMN jurisdiction_prefix.prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_prefix.prefix IS 'å‰ç¼€';


--
-- Name: COLUMN jurisdiction_prefix.jurisdiction_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_prefix.jurisdiction_id IS 'æ‰€å±žè®¡è´¹åŒºåŸŸ';


--
-- Name: COLUMN jurisdiction_prefix.jurisdiction_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_prefix.jurisdiction_name IS 'åŒºåŸŸ';


--
-- Name: COLUMN jurisdiction_prefix.jurisdiction_country_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_prefix.jurisdiction_country_name IS 'guojia ';


--
-- Name: jurisdiction_prefix_id_seq1; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.jurisdiction_prefix_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.jurisdiction_prefix_id_seq1 OWNER TO postgres;

--
-- Name: jurisdiction_prefix_id_seq1; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.jurisdiction_prefix_id_seq1 OWNED BY public.jurisdiction_prefix.id;


--
-- Name: jurisdiction_prefix_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.jurisdiction_prefix_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.jurisdiction_prefix_record_record_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_prefix_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.jurisdiction_prefix_record (
    id integer,
    alias character varying(40),
    prefix public.prefix_range,
    jurisdiction_id integer,
    jurisdiction_country_id integer,
    jurisdiction_name character varying(100),
    jurisdiction_country_name character varying(100),
    ocn character varying(10),
    lata character varying(10),
    block_id character(1),
    effective_date timestamp with time zone,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.jurisdiction_prefix_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.jurisdiction_prefix_record OWNER TO postgres;

--
-- Name: jurisdiction_prefix_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.jurisdiction_prefix_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.jurisdiction_prefix_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_prefix_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.jurisdiction_prefix_record_tmp (
    id integer,
    alias character varying(40),
    prefix public.prefix_range,
    jurisdiction_id integer,
    jurisdiction_country_id integer,
    jurisdiction_name character varying(100),
    jurisdiction_country_name character varying(100),
    ocn character varying(10),
    lata character varying(10),
    block_id character(1),
    effective_date timestamp with time zone,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.jurisdiction_prefix_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.jurisdiction_prefix_record_tmp OWNER TO postgres;

--
-- Name: jurisdiction_update_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.jurisdiction_update_history (
    id integer NOT NULL,
    task_id integer NOT NULL,
    prefix_count integer NOT NULL,
    status smallint DEFAULT 0 NOT NULL,
    create_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE public.jurisdiction_update_history OWNER TO postgres;

--
-- Name: COLUMN jurisdiction_update_history.task_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_update_history.task_id IS 'Jurisdiction upload task ID of the jurisdiction_upload_task table';


--
-- Name: COLUMN jurisdiction_update_history.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_update_history.status IS '0 - Successfully; 1 - Failed';


--
-- Name: jurisdiction_update_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.jurisdiction_update_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.jurisdiction_update_history_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_update_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.jurisdiction_update_history_id_seq OWNED BY public.jurisdiction_update_history.id;


--
-- Name: jurisdiction_update_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.jurisdiction_update_log (
    id integer NOT NULL,
    tigger_time timestamp with time zone,
    is_new_file boolean,
    import_log_id integer,
    file_update_time_flg character varying(10),
    status integer
);


ALTER TABLE public.jurisdiction_update_log OWNER TO postgres;

--
-- Name: COLUMN jurisdiction_update_log.tigger_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_update_log.tigger_time IS 'è„šæœ¬æ‰§è¡Œæ—¶é—´';


--
-- Name: COLUMN jurisdiction_update_log.import_log_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_update_log.import_log_id IS 'imports_export_log è¡¨çš„ID';


--
-- Name: COLUMN jurisdiction_update_log.file_update_time_flg; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_update_log.file_update_time_flg IS 'ftpæœåŠ¡å™¨ä¸Šçš„æ–‡ä»¶çš„ä¿®æ”¹æ—¶é—´æ ‡å¿—egï¼šApr1408:57';


--
-- Name: COLUMN jurisdiction_update_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.jurisdiction_update_log.status IS '1 succeed
-1 connect failed
-2 login failed
-3 Insufficient permissions
-4 file is not found
-5 import failed
-6 import log insert failed';


--
-- Name: jurisdiction_update_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.jurisdiction_update_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.jurisdiction_update_log_id_seq OWNER TO postgres;

--
-- Name: jurisdiction_update_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.jurisdiction_update_log_id_seq OWNED BY public.jurisdiction_update_log.id;


--
-- Name: jurisdiction_upload_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.jurisdiction_upload_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE public.jurisdiction_upload_id_seq OWNER TO postgres;

--
-- Name: kill_pg_sql_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.kill_pg_sql_log (
    id integer NOT NULL,
    query text,
    start_time timestamp with time zone,
    kill_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE public.kill_pg_sql_log OWNER TO postgres;

--
-- Name: COLUMN kill_pg_sql_log.query; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.kill_pg_sql_log.query IS 'killæŽ‰çš„sql';


--
-- Name: COLUMN kill_pg_sql_log.start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.kill_pg_sql_log.start_time IS 'query å¼€å§‹æ‰§è¡Œçš„æ—¶å€™';


--
-- Name: COLUMN kill_pg_sql_log.kill_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.kill_pg_sql_log.kill_time IS 'kill æŽ‰çš„æ—¶å€™';


--
-- Name: kill_pg_sql_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.kill_pg_sql_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.kill_pg_sql_log_id_seq OWNER TO postgres;

--
-- Name: kill_pg_sql_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.kill_pg_sql_log_id_seq OWNED BY public.kill_pg_sql_log.id;


--
-- Name: lcr_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lcr_record (
    id integer NOT NULL,
    type character varying(50) DEFAULT 0 NOT NULL,
    file character varying(300),
    rate_tables character varying,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status smallint DEFAULT 0
);


ALTER TABLE public.lcr_record OWNER TO postgres;

--
-- Name: lcr_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lcr_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lcr_record_id_seq OWNER TO postgres;

--
-- Name: lcr_record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.lcr_record_id_seq OWNED BY public.lcr_record.id;


--
-- Name: lcr_reports; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lcr_reports (
    id integer NOT NULL,
    start_time timestamp without time zone,
    end_time timestamp without time zone,
    status integer DEFAULT 0,
    file_path character varying(200)
);


ALTER TABLE public.lcr_reports OWNER TO postgres;

--
-- Name: lcr_reports_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lcr_reports_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lcr_reports_id_seq OWNER TO postgres;

--
-- Name: lcr_reports_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.lcr_reports_id_seq OWNED BY public.lcr_reports.id;


--
-- Name: license_modification_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.license_modification_log (
    id integer NOT NULL,
    modify_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    modify_by character(200),
    old_value integer,
    new_value integer,
    type integer,
    switch_name character(200)
);


ALTER TABLE public.license_modification_log OWNER TO postgres;

--
-- Name: COLUMN license_modification_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.license_modification_log.type IS '1 ä¸º call_limit
2 ä¸º cps_limit';


--
-- Name: COLUMN license_modification_log.switch_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.license_modification_log.switch_name IS 'ä¿®æ”¹çš„switch_name';


--
-- Name: license_modification_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.license_modification_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.license_modification_log_id_seq OWNER TO postgres;

--
-- Name: license_modification_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.license_modification_log_id_seq OWNED BY public.license_modification_log.id;


--
-- Name: lnp_request; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lnp_request (
    id integer NOT NULL,
    user_id integer,
    request_date timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    status integer DEFAULT 0,
    count integer DEFAULT 0 NOT NULL,
    type integer DEFAULT 0,
    file text
);


ALTER TABLE public.lnp_request OWNER TO postgres;

--
-- Name: lnp_request_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lnp_request_detail (
    id integer NOT NULL,
    request_id integer,
    number character varying(255) NOT NULL,
    status integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.lnp_request_detail OWNER TO postgres;

--
-- Name: lnp_request_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lnp_request_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lnp_request_detail_id_seq OWNER TO postgres;

--
-- Name: lnp_request_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.lnp_request_detail_id_seq OWNED BY public.lnp_request_detail.id;


--
-- Name: lnp_request_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lnp_request_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lnp_request_id_seq OWNER TO postgres;

--
-- Name: lnp_request_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.lnp_request_id_seq OWNED BY public.lnp_request.id;


--
-- Name: logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.logs (
    user_id integer NOT NULL,
    ip character varying(100),
    act_type character varying(100),
    act_info character varying(1000),
    "time" timestamp with time zone,
    model character varying(100)
);


ALTER TABLE public.logs OWNER TO postgres;

--
-- Name: loop_detection; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.loop_detection (
    id integer NOT NULL,
    rule_name character varying,
    number integer,
    counter_time integer,
    block_time integer
);


ALTER TABLE public.loop_detection OWNER TO postgres;

--
-- Name: loop_detection_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.loop_detection_detail (
    loop_detection_id integer,
    resource_id integer,
    id integer NOT NULL
);


ALTER TABLE public.loop_detection_detail OWNER TO postgres;

--
-- Name: loop_detection_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.loop_detection_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.loop_detection_detail_id_seq OWNER TO postgres;

--
-- Name: loop_detection_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.loop_detection_detail_id_seq OWNED BY public.loop_detection_detail.id;


--
-- Name: loop_detection_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.loop_detection_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.loop_detection_id_seq OWNER TO postgres;

--
-- Name: loop_detection_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.loop_detection_id_seq OWNED BY public.loop_detection.id;


--
-- Name: lrn; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lrn (
    lrn_id integer NOT NULL,
    ip1 public.ip4r,
    port1 integer,
    ip2 public.ip4r,
    port2 integer,
    timeout1 integer,
    timeout2 integer
);


ALTER TABLE public.lrn OWNER TO postgres;

--
-- Name: TABLE lrn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.lrn IS 'lrn';


--
-- Name: COLUMN lrn.lrn_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn.lrn_id IS 'ä¸»é”®';


--
-- Name: COLUMN lrn.ip1; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn.ip1 IS 'ip';


--
-- Name: COLUMN lrn.port1; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn.port1 IS 'port';


--
-- Name: COLUMN lrn.ip2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn.ip2 IS 'ip';


--
-- Name: COLUMN lrn.port2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn.port2 IS 'port';


--
-- Name: COLUMN lrn.timeout1; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn.timeout1 IS 'timeout';


--
-- Name: COLUMN lrn.timeout2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn.timeout2 IS 'timeout';


--
-- Name: lrn_groups; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lrn_groups (
    id integer NOT NULL,
    rule integer,
    name character varying(100),
    active integer DEFAULT 1
);


ALTER TABLE public.lrn_groups OWNER TO postgres;

--
-- Name: TABLE lrn_groups; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.lrn_groups IS 'ä¸€ä¸ªgroupå¯ä»¥æœ‰å¤šä¸ªitemï¼Œéƒ½åœ¨lrn_itemsè¡¨å±•å¼€ï¼Œä¸€å¯¹å¤šã€‚';


--
-- Name: COLUMN lrn_groups.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_groups.id IS 'group idé€’å¢ž';


--
-- Name: COLUMN lrn_groups.rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_groups.rule IS '0 -- tobdown
1 -- roundrobin
2 -- minpdd

ä¸€ä¸ªç»„å†…è®¿é—®lrnç­–ç•¥ï¼Œç»„ä¹‹é—´æ˜¯tobdownã€‚';


--
-- Name: COLUMN lrn_groups.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_groups.name IS 'ç»„çš„åå­—';


--
-- Name: COLUMN lrn_groups.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_groups.active IS '0 -- false
1 -- true

groupçš„æš‚æ—¶æ€§çš„å¼€å…³ã€‚';


--
-- Name: lrn_groups_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lrn_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lrn_groups_id_seq OWNER TO postgres;

--
-- Name: lrn_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.lrn_groups_id_seq OWNED BY public.lrn_groups.id;


--
-- Name: lrn_groups_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lrn_groups_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lrn_groups_record_record_id_seq OWNER TO postgres;

--
-- Name: lrn_groups_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lrn_groups_record (
    id integer,
    rule integer,
    name character varying(100),
    active integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.lrn_groups_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.lrn_groups_record OWNER TO postgres;

--
-- Name: lrn_groups_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lrn_groups_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lrn_groups_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: lrn_groups_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lrn_groups_record_tmp (
    id integer,
    rule integer,
    name character varying(100),
    active integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.lrn_groups_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.lrn_groups_record_tmp OWNER TO postgres;

--
-- Name: lrn_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lrn_items (
    id integer NOT NULL,
    group_id integer,
    ip public.ip4,
    port integer,
    timeout integer,
    retry integer,
    dynamic_timeout integer,
    filter_timeout integer,
    option integer,
    option_interval integer,
    domian_name character varying(100),
    active integer DEFAULT 1
);


ALTER TABLE public.lrn_items OWNER TO postgres;

--
-- Name: TABLE lrn_items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.lrn_items IS 'ä¸Žlrn_groupè¡¨å…³è”ï¼Œä¸€ä¸ªlrn_groupå¯ä»¥å¯¹åº”å¤šä¸ªlrn_itme';


--
-- Name: COLUMN lrn_items.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.id IS 'è‡ªå¢žçš„id';


--
-- Name: COLUMN lrn_items.group_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.group_id IS 'å…³è”lrn_groupsè¡¨id';


--
-- Name: COLUMN lrn_items.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.ip IS 'lrnæœåŠ¡å™¨ip';


--
-- Name: COLUMN lrn_items.port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.port IS 'lrnæœåŠ¡å™¨ç«¯å£';


--
-- Name: COLUMN lrn_items.timeout; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.timeout IS 'ç­‰å¾…lrnæœåŠ¡å™¨å›žåº”æ—¶é—´ï¼Œæ¯«ç§’ä¸ºå•ä½ï¼Œä¹Ÿå¯ä»¥æ ¹æ®æ­¤è®¾ç½®è¿‡æ»¤ç½‘ç»œå»¶è¿Ÿé«˜çš„lrnæœåŠ¡å™¨ã€‚';


--
-- Name: COLUMN lrn_items.retry; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.retry IS 'ç­‰å¾…lrnæœåŠ¡å™¨è¶…æ—¶ï¼Œæœ€å¤šé‡å‘æ¬¡æ•°ã€‚';


--
-- Name: COLUMN lrn_items.dynamic_timeout; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.dynamic_timeout IS '0 -- false
1 -- ture

æ ¹æ®å®žé™…çŽ¯å¢ƒè®¾ç½®ç­‰å¾…lrnæœåŠ¡å™¨è¶…æ—¶æ—¶é•¿ã€‚
ç½‘ç»œè¶…æ—¶ä»Žoptionå‘å‡ºåˆ°å¾—åˆ°200çš„æ—¶é—´å·®ã€‚';


--
-- Name: COLUMN lrn_items.filter_timeout; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.filter_timeout IS '0 -- false
1 -- true

å®žé™…ç½‘ç»œå»¶è¿Ÿå¤§äºŽtimeoutå€¼æ—¶å¿½ç•¥æ­¤lrnæœåŠ¡å™¨ï¼Œé¿å…è¶…æ—¶ï¼Œå¦‚æžœç½‘ç»œå»¶è¿Ÿå›žå¤åˆ°timeoutï¼Œå¯ä»¥è®¿é—®æ­¤lrnæœåŠ¡å™¨ã€‚';


--
-- Name: COLUMN lrn_items.option; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.option IS '0 -- false
1 -- true

æ˜¯å¦optionçš„å¼€å…³ã€‚';


--
-- Name: COLUMN lrn_items.option_interval; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.option_interval IS 'optionåˆ°lrnæœåŠ¡å™¨çš„é—´éš”ï¼Œç§’ä½å•ä½ã€‚æœ€å°å€¼ä¸º1ç§’ï¼Œ 0ç§’å½“åš3ç§’ã€‚';


--
-- Name: COLUMN lrn_items.domian_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.domian_name IS 'lrnæœåŠ¡å™¨åŸŸå';


--
-- Name: COLUMN lrn_items.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items.active IS '0 -- false
1 -- true

æ­¤itemæš‚æ—¶å…³é—­è¿˜æ˜¯å¼€å¯ã€‚';


--
-- Name: lrn_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lrn_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lrn_items_id_seq OWNER TO postgres;

--
-- Name: lrn_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.lrn_items_id_seq OWNED BY public.lrn_items.id;


--
-- Name: lrn_items_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lrn_items_logs (
    id integer NOT NULL,
    group_id integer,
    item_id integer,
    state integer,
    pdd integer,
    "time" character varying(100)
);


ALTER TABLE public.lrn_items_logs OWNER TO postgres;

--
-- Name: TABLE lrn_items_logs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.lrn_items_logs IS 'è®°å½•lrnæœåŠ¡å™¨çŠ¶æ€ï¼Œä¾‹å¦‚æ˜¯å¦åœ¨è¿è¡Œï¼Œç½‘ç»œå»¶è¿Ÿå¤šå°‘ç­‰';


--
-- Name: COLUMN lrn_items_logs.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items_logs.id IS 'è‡ªå¢žid';


--
-- Name: COLUMN lrn_items_logs.group_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items_logs.group_id IS 'ç»„id';


--
-- Name: COLUMN lrn_items_logs.state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items_logs.state IS 'lrnæœåŠ¡å™¨æ˜¯å¦å¯ç”¨çš„æ ‡å¿—

0 -- false (off line)
1 -- true (on line)';


--
-- Name: COLUMN lrn_items_logs.pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items_logs.pdd IS 'æŸä¸ªæ—¶é—´ç‚¹çš„pddï¼Œæ¯«ç§’å•ä½ã€‚';


--
-- Name: COLUMN lrn_items_logs."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.lrn_items_logs."time" IS 'å‘optionæ—¶é—´';


--
-- Name: lrn_items_logs_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lrn_items_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lrn_items_logs_id_seq OWNER TO postgres;

--
-- Name: lrn_items_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.lrn_items_logs_id_seq OWNED BY public.lrn_items_logs.id;


--
-- Name: lrn_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lrn_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lrn_items_record_record_id_seq OWNER TO postgres;

--
-- Name: lrn_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lrn_items_record (
    id integer,
    group_id integer,
    ip public.ip4,
    port integer,
    timeout integer,
    retry integer,
    dynamic_timeout integer,
    filter_timeout integer,
    option integer,
    option_interval integer,
    domian_name character varying(100),
    active integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.lrn_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.lrn_items_record OWNER TO postgres;

--
-- Name: lrn_items_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lrn_items_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lrn_items_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: lrn_items_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lrn_items_record_tmp (
    id integer,
    group_id integer,
    ip public.ip4,
    port integer,
    timeout integer,
    retry integer,
    dynamic_timeout integer,
    filter_timeout integer,
    option integer,
    option_interval integer,
    domian_name character varying(100),
    active integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.lrn_items_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.lrn_items_record_tmp OWNER TO postgres;

--
-- Name: lrn_lrn_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lrn_lrn_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lrn_lrn_id_seq OWNER TO postgres;

--
-- Name: lrn_lrn_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.lrn_lrn_id_seq OWNED BY public.lrn.lrn_id;


--
-- Name: lrn_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lrn_report (
    report_time timestamp with time zone,
    ingress_id integer,
    total_count integer,
    client_count integer,
    lrn_server_count integer,
    cache_count integer,
    lrn_same integer,
    lrn_no_response integer,
    lnp_charge real
);


ALTER TABLE public.lrn_report OWNER TO postgres;

--
-- Name: lrn_servers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lrn_servers (
    id integer NOT NULL,
    ip public.ip4r,
    port integer
);


ALTER TABLE public.lrn_servers OWNER TO postgres;

--
-- Name: lrn_servers_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.lrn_servers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lrn_servers_id_seq OWNER TO postgres;

--
-- Name: lrn_servers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.lrn_servers_id_seq OWNED BY public.lrn_servers.id;


--
-- Name: mail_cdr_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mail_cdr_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    cdr_counts integer,
    user_id integer,
    finish_time timestamp with time zone,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    file_counts integer,
    mail_content text,
    mail_subject character varying(500),
    status integer
);


ALTER TABLE public.mail_cdr_log OWNER TO postgres;

--
-- Name: COLUMN mail_cdr_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_cdr_log.status IS '1-success
-1-open file error
-2-copy cdr error
-3-send mail error';


--
-- Name: mail_cdr_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mail_cdr_log_detail (
    id integer NOT NULL,
    mail_cdr_log_id integer,
    "order" integer,
    cdr_start_time timestamp with time zone,
    cdr_end_time timestamp with time zone,
    file_size integer,
    filename character varying(255)
);


ALTER TABLE public.mail_cdr_log_detail OWNER TO postgres;

--
-- Name: mail_cdr_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.mail_cdr_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.mail_cdr_log_detail_id_seq OWNER TO postgres;

--
-- Name: mail_cdr_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.mail_cdr_log_detail_id_seq OWNED BY public.mail_cdr_log_detail.id;


--
-- Name: mail_cdr_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.mail_cdr_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.mail_cdr_log_id_seq OWNER TO postgres;

--
-- Name: mail_cdr_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.mail_cdr_log_id_seq OWNED BY public.mail_cdr_log.id;


--
-- Name: mail_tmplate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.mail_tmplate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.mail_tmplate_id_seq OWNER TO postgres;

--
-- Name: mail_tmplate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mail_tmplate (
    id integer DEFAULT nextval('public.mail_tmplate_id_seq'::regclass) NOT NULL,
    invoice_from text,
    invoice_to text,
    invoice_subject text,
    invoice_content text,
    payment_from text,
    payment_to text,
    payment_subject text,
    payment_content text,
    lowbalance_subject text,
    lowbalance_content text,
    noc_email_subject text,
    noc_email_content text,
    carrier_email_subject text,
    carrier_email_content text,
    alert_email_subject text,
    alert_email_content text,
    carrier_invoice_subject text DEFAULT 'Invoice form {start_Date} â€“ {end_date}'::text,
    carrier_invoice_content text DEFAULT 'Dear {carrier_name},
	  This is invoice {invoice_number} for {start_date} â€“ {end_date}.
	Please remit your due balance within the terms of your contractual
	agreement to avoid disconnection of service.
--
Autogenerated by billing system'::text,
    auto_summary_subject character varying,
    auto_summary_content text,
    auto_balance_subject character varying,
    auto_balance_content text,
    auto_delivery_subject character varying(200),
    auto_delivery_content text,
    auto_cdr_subject character varying(255),
    auto_cdr_content text,
    no_route_available_alert_email_subject character varying(225),
    no_route_available_alert_email_content text,
    target_match_alert_email_subject character varying(225),
    target_match_alert_email_content text,
    rate_watch_alert_email_subject character varying(225),
    rate_watch_alert_email_content text,
    route_update_alert_email_subject character varying(225),
    route_update_alert_email_content text,
    rate_update_alert_email_subject character varying(225),
    rate_update_alert_email_content text,
    low_balance_alert_email_subject character varying(225),
    low_balance_alert_email_content text,
    new_invoice_posted_mail_alert_email_subject character varying(225),
    new_invoice_posted_mail_alert_email_content text,
    payment_sent_subject character varying(255),
    payment_sent_content text,
    payment_received_subject character varying(255),
    payment_received_content text,
    trouble_ticket_subject character varying(255),
    trouble_ticket_content text,
    send_cdr_subject character varying(255),
    send_cdr_content text,
    select_route_up_email_subject text,
    select_route_up_email_content text,
    exchange_auto_summary_subject text,
    exchange_auto_summary_content text,
    finance_alert_subject text,
    finance_alert_content text,
    buy_qos_alert_subject text,
    buy_qos_alert_content text,
    sell_qos_alert_subject text,
    sell_qos_alert_content text,
    lowbalance_from character varying,
    noc_email_from character varying,
    carrier_email_from character varying,
    alert_email_from character varying,
    auto_summary_from character varying,
    auto_balance_from character varying,
    auto_cdr_from character varying,
    payment_sent_from character varying,
    payment_received_from character varying,
    trouble_ticket_from character varying,
    send_cdr_from character varying,
    no_route_available_alert_email_from character varying,
    target_match_alert_email_from character varying,
    rate_watch_alert_email_from character varying,
    route_update_alert_email_from character varying,
    rate_update_alert_email_from character varying,
    low_balance_alert_email_from character varying,
    select_route_up_email_from character varying,
    new_invoice_posted_mail_alert_email_from character varying,
    exchange_auto_summary_from character varying,
    finance_alert_from character varying,
    buy_qos_alert_from character varying,
    sell_qos_alert_from character varying,
    rate_mail_success_subject text,
    rate_mail_success_content text,
    rate_mail_success_from character varying,
    rate_mail_fail_subject text,
    rate_mail_fail_content text,
    rate_mail_fail_from character varying,
    invoice_cc text,
    payment_from_cc text,
    lowbalance_cc text,
    alert_email_cc text,
    auto_summary_cc text,
    auto_balance_cc text,
    auto_cdr_cc text,
    send_cdr_cc text,
    payment_sent_cc text,
    payment_received_cc text,
    rate_from character varying,
    rate_subject character varying,
    rate_content text,
    dialer_detection_subject character varying,
    dialer_detection_content text,
    retrieve_password_subject text,
    retrieve_password_content text,
    retrieve_password_from text,
    registration_subject text,
    registration_content text,
    registration_from text,
    registration_success text,
    registration_failure text,
    trunk_change_from character varying(50),
    trunk_change_subject character varying(200),
    trunk_change_content text,
    fraud_detection_from character varying(50),
    fraud_detection_subject text,
    fraud_detection_content text,
    welcom_from text,
    welcom_subject text,
    welcom_content text,
    download_rate_notice_from character varying(50),
    download_rate_notice_subject text,
    download_rate_notice_content text,
    no_download_rate_from text,
    no_download_rate_subject text,
    no_download_rate_content text,
    download_cdr_from text,
    download_cdr_subject text,
    download_cdr_content text,
    download_cdr_cc text,
    vendor_invoice_dispute_from text,
    vendor_invoice_dispute_subject text,
    vendor_invoice_dispute_content text,
    vendor_invoice_dispute_cc text,
    trunk_interop_from text,
    trunk_interop_subject text,
    trunk_interop_content text,
    trunk_interop_cc text,
    regletter_from text,
    regletter_subject text,
    regletter_content text,
    regletter_cc text,
    paymresvd_from text,
    paymresvd_subject text,
    paymresvd_content text,
    paymresvd_cc text,
    regconf_from text,
    regconf_subject text,
    regconf_content text,
    regconf_cc text,
    daily_payment_from character varying,
    daily_payment_subject character varying,
    daily_payment_content text,
    daily_payment_cc text,
    zerobalance_content text,
    zerobalance_from text,
    zerobalance_cc text,
    zerobalance_subject text,
    trunk_change_cc text,
    did_order_from character varying,
    did_order_cc character varying,
    did_order_subject text,
    did_order_content text,
    pending_trunk_content text,
    pending_trunk_cc text,
    pending_trunk_subject character varying,
    pending_trunk_from character varying,
    did_order_c character varying,
    welcom_cc text,
    retrieve_password_cc text,
    hour_from_48 text,
    hour_subject_48 text,
    hour_content_48 text,
    hour_cc_48 text,
    hour_from_24 text,
    hour_subject_24 text,
    hour_content_24 text,
    hour_cc_24 text,
    hour_from_3 text,
    hour_subject_3 text,
    hour_content_3 text,
    hour_cc_3 text,
    hour_from_1 text,
    hour_subject_1 text,
    hour_content_1 text,
    hour_cc_1 text
);


ALTER TABLE public.mail_tmplate OWNER TO postgres;

--
-- Name: TABLE mail_tmplate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.mail_tmplate IS 'é‚®ä»¶æ¨¡æ¿';


--
-- Name: COLUMN mail_tmplate.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.id IS 'ä¸»é”®';


--
-- Name: COLUMN mail_tmplate.invoice_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.invoice_from IS 'invoice_from';


--
-- Name: COLUMN mail_tmplate.invoice_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.invoice_to IS 'invoice_to';


--
-- Name: COLUMN mail_tmplate.invoice_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.invoice_subject IS 'invoice_subject';


--
-- Name: COLUMN mail_tmplate.invoice_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.invoice_content IS 'invoice_content';


--
-- Name: COLUMN mail_tmplate.payment_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.payment_from IS 'payment_from';


--
-- Name: COLUMN mail_tmplate.payment_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.payment_to IS 'payment_to';


--
-- Name: COLUMN mail_tmplate.payment_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.payment_subject IS 'payment_subject';


--
-- Name: COLUMN mail_tmplate.payment_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.payment_content IS 'payment_content';


--
-- Name: COLUMN mail_tmplate.lowbalance_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.lowbalance_subject IS 'lowbalance_subject';


--
-- Name: COLUMN mail_tmplate.lowbalance_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.lowbalance_content IS 'lowbalance_content';


--
-- Name: COLUMN mail_tmplate.rate_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.rate_from IS 'å‘é€rate tableçš„æ¨¡æ¿ å‘ä»¶äºº';


--
-- Name: COLUMN mail_tmplate.rate_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.rate_subject IS 'rate å‘é€æ¨¡æ¿ ä¸»é¢˜';


--
-- Name: COLUMN mail_tmplate.rate_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.rate_content IS 'rateå‘é€æ¨¡æ¿  å†…å®¹';


--
-- Name: COLUMN mail_tmplate.dialer_detection_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.dialer_detection_subject IS 'monitoring dialer_detection çš„é‚®ä»¶ä¸»é¢˜';


--
-- Name: COLUMN mail_tmplate.dialer_detection_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.dialer_detection_content IS 'monitoring dialer_detection çš„é‚®ä»¶å†…å®¹';


--
-- Name: COLUMN mail_tmplate.retrieve_password_subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.retrieve_password_subject IS 'retrieve_password_subject';


--
-- Name: COLUMN mail_tmplate.retrieve_password_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.retrieve_password_content IS 'retrieve_password_content';


--
-- Name: COLUMN mail_tmplate.retrieve_password_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.mail_tmplate.retrieve_password_from IS 'retrieve_password_from';


--
-- Name: modif_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.modif_log (
    id integer NOT NULL,
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    module character varying(100),
    type smallint,
    name character varying(100),
    detail text,
    rollback text,
    rollback_msg character varying(500),
    rollback_flg smallint,
    rollback_extra_info text
);


ALTER TABLE public.modif_log OWNER TO postgres;

--
-- Name: COLUMN modif_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.modif_log.type IS '0 -- creation
1-- deletion
2 -- modification';


--
-- Name: COLUMN modif_log.rollback; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.modif_log.rollback IS 'è®°å½•å›žæ»šçš„sql';


--
-- Name: COLUMN modif_log.rollback_msg; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.modif_log.rollback_msg IS 'è®°å½•å›žæ»šçš„æç¤ºä¿¡æ¯';


--
-- Name: COLUMN modif_log.rollback_flg; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.modif_log.rollback_flg IS '0ï¼šè¿˜æ²¡æœ‰å›žæ»š
1ï¼šæˆåŠŸå›žæ»š
2ï¼šå›žæ»šå¤±è´¥';


--
-- Name: COLUMN modif_log.rollback_extra_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.modif_log.rollback_extra_info IS 'å‚¨å­˜jsonæ ¼å¼
è®°å½•rollback_type:
1ï¼šç›´æŽ¥è¿è¡Œrollback_sql
2ï¼šDigit Mappingçš„åˆ é™¤å›žæ»š
3ï¼šStatic Routeçš„åˆ é™¤å›žæ»š';


--
-- Name: modif_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.modif_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.modif_log_id_seq OWNER TO postgres;

--
-- Name: modif_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.modif_log_id_seq OWNED BY public.modif_log.id;


--
-- Name: mutual_transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.mutual_transaction (
    "time" date,
    amount real,
    client_id character varying,
    type integer,
    id integer NOT NULL,
    balance real
);


ALTER TABLE public.mutual_transaction OWNER TO postgres;

--
-- Name: mutual_transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.mutual_transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.mutual_transaction_id_seq OWNER TO postgres;

--
-- Name: mutual_transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.mutual_transaction_id_seq OWNED BY public.mutual_transaction.id;


--
-- Name: myvar; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.myvar (
    date date
);


ALTER TABLE public.myvar OWNER TO postgres;

--
-- Name: no_dest_trunk; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.no_dest_trunk AS
 SELECT dynamic_route.name,
    ''::public.prefix_range AS digits,
    'Dynamic Route'::text AS type
   FROM public.dynamic_route
  WHERE ((NOT (EXISTS ( SELECT dynamic_route_items.id,
            dynamic_route_items.dynamic_route_id,
            dynamic_route_items.resource_id
           FROM public.dynamic_route_items
          WHERE (dynamic_route_items.dynamic_route_id = dynamic_route.dynamic_route_id)))) OR (EXISTS ( SELECT dynamic_route_items.id,
            dynamic_route_items.dynamic_route_id,
            dynamic_route_items.resource_id,
            resource.resource_id,
            resource.name,
            resource.ingress,
            resource.egress,
            resource.active,
            resource.rfc_2833,
            resource.t38,
            resource.alias,
            resource.res_strategy,
            resource.cps_limit,
            resource.capacity,
            resource.lnp,
            resource.lrn_block,
            resource.client_id,
            resource.tdm,
            resource.rate_table_id,
            resource.transnexus,
            resource.route_strategy_id,
            resource.media_type,
            resource.pass_through,
            resource.profit_margin,
            resource.enough_balance,
            resource.egress_bill_after_action,
            resource.proto,
            resource.dnis_only,
            resource.ring_timeout,
            resource.ignore_ring,
            resource.ignore_early_media,
            resource.disable_by_alert,
            resource.priority,
            resource.last_priority,
            resource.create_time,
            resource.update_time,
            resource.status,
            resource.wait_ringtime180,
            resource.profit_type,
            resource.lnp_dipping,
            resource.lnp_dipping_rate,
            resource.update_at,
            resource.update_by
           FROM (public.dynamic_route_items
             JOIN public.resource ON ((dynamic_route_items.resource_id = resource.resource_id)))
          WHERE ((dynamic_route_items.dynamic_route_id = dynamic_route.dynamic_route_id) AND (resource.active = false) AND (resource.egress = true)))))
UNION ALL
 SELECT product.name,
    product_items.digits,
    'Static Route'::text AS type
   FROM (public.product
     LEFT JOIN public.product_items ON ((product.product_id = product_items.product_id)))
  WHERE ((NOT (EXISTS ( SELECT product_items_resource.id,
            product_items_resource.item_id,
            product_items_resource.resource_id,
            product_items_resource.by_percentage,
            product_items_resource.order_id,
            product_items_resource.order_type
           FROM public.product_items_resource
          WHERE (product_items.item_id = product_items_resource.item_id)))) OR (EXISTS ( SELECT product_items_resource.id,
            product_items_resource.item_id,
            product_items_resource.resource_id,
            product_items_resource.by_percentage,
            product_items_resource.order_id,
            product_items_resource.order_type,
            resource.resource_id,
            resource.name,
            resource.ingress,
            resource.egress,
            resource.active,
            resource.rfc_2833,
            resource.t38,
            resource.alias,
            resource.res_strategy,
            resource.cps_limit,
            resource.capacity,
            resource.lnp,
            resource.lrn_block,
            resource.client_id,
            resource.tdm,
            resource.rate_table_id,
            resource.transnexus,
            resource.route_strategy_id,
            resource.media_type,
            resource.pass_through,
            resource.profit_margin,
            resource.enough_balance,
            resource.egress_bill_after_action,
            resource.proto,
            resource.dnis_only,
            resource.ring_timeout,
            resource.ignore_ring,
            resource.ignore_early_media,
            resource.disable_by_alert,
            resource.priority,
            resource.last_priority,
            resource.create_time,
            resource.update_time,
            resource.status,
            resource.wait_ringtime180,
            resource.profit_type,
            resource.lnp_dipping,
            resource.lnp_dipping_rate,
            resource.update_at,
            resource.update_by
           FROM (public.product_items_resource
             JOIN public.resource ON ((product_items_resource.resource_id = resource.resource_id)))
          WHERE ((product_items.item_id = product_items_resource.item_id) AND (resource.active = false) AND (resource.egress = true)))))
UNION ALL
 SELECT route_strategy.name,
    route.digits,
    'Route Plan'::text AS type
   FROM (public.route_strategy
     LEFT JOIN public.route ON ((route_strategy.route_strategy_id = route.route_strategy_id)))
  WHERE ((EXISTS ( SELECT dynamic_route_items.id,
            dynamic_route_items.dynamic_route_id,
            dynamic_route_items.resource_id,
            resource.resource_id,
            resource.name,
            resource.ingress,
            resource.egress,
            resource.active,
            resource.rfc_2833,
            resource.t38,
            resource.alias,
            resource.res_strategy,
            resource.cps_limit,
            resource.capacity,
            resource.lnp,
            resource.lrn_block,
            resource.client_id,
            resource.tdm,
            resource.rate_table_id,
            resource.transnexus,
            resource.route_strategy_id,
            resource.media_type,
            resource.pass_through,
            resource.profit_margin,
            resource.enough_balance,
            resource.egress_bill_after_action,
            resource.proto,
            resource.dnis_only,
            resource.ring_timeout,
            resource.ignore_ring,
            resource.ignore_early_media,
            resource.disable_by_alert,
            resource.priority,
            resource.last_priority,
            resource.create_time,
            resource.update_time,
            resource.status,
            resource.wait_ringtime180,
            resource.profit_type,
            resource.lnp_dipping,
            resource.lnp_dipping_rate,
            resource.update_at,
            resource.update_by
           FROM (public.dynamic_route_items
             JOIN public.resource ON ((dynamic_route_items.resource_id = resource.resource_id)))
          WHERE ((dynamic_route_items.dynamic_route_id = route.dynamic_route_id) AND (resource.active = false) AND (resource.egress = true)))) OR (EXISTS ( SELECT product_items.item_id,
            product_items.product_id,
            product_items.alias,
            product_items.digits,
            product_items.strategy,
            product_items.time_profile_id,
            product_items.min_len,
            product_items.max_len,
            product_items_resource.id,
            product_items_resource.item_id,
            product_items_resource.resource_id,
            product_items_resource.by_percentage,
            product_items_resource.order_id,
            product_items_resource.order_type,
            resource.resource_id,
            resource.name,
            resource.ingress,
            resource.egress,
            resource.active,
            resource.rfc_2833,
            resource.t38,
            resource.alias,
            resource.res_strategy,
            resource.cps_limit,
            resource.capacity,
            resource.lnp,
            resource.lrn_block,
            resource.client_id,
            resource.tdm,
            resource.rate_table_id,
            resource.transnexus,
            resource.route_strategy_id,
            resource.media_type,
            resource.pass_through,
            resource.profit_margin,
            resource.enough_balance,
            resource.egress_bill_after_action,
            resource.proto,
            resource.dnis_only,
            resource.ring_timeout,
            resource.ignore_ring,
            resource.ignore_early_media,
            resource.disable_by_alert,
            resource.priority,
            resource.last_priority,
            resource.create_time,
            resource.update_time,
            resource.status,
            resource.wait_ringtime180,
            resource.profit_type,
            resource.lnp_dipping,
            resource.lnp_dipping_rate,
            resource.update_at,
            resource.update_by
           FROM ((public.product_items
             LEFT JOIN public.product_items_resource ON ((product_items.item_id = product_items_resource.item_id)))
             LEFT JOIN public.resource ON ((product_items_resource.resource_id = resource.resource_id)))
          WHERE ((product_items.product_id = route.static_route_id) AND (resource.active = false) AND (resource.egress = true)))));


ALTER TABLE public.no_dest_trunk OWNER TO postgres;

--
-- Name: ocn_lata; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ocn_lata (
    id integer NOT NULL,
    ocn character varying(20),
    lata character varying(20),
    intra_rate numeric(30,10),
    inter_rate numeric(30,10),
    rate numeric(30,10),
    effective_date timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    "interval" integer DEFAULT 1,
    min_time integer DEFAULT 0,
    rate_table_id integer
);


ALTER TABLE public.ocn_lata OWNER TO postgres;

--
-- Name: ocn_lata_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ocn_lata_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ocn_lata_id_seq OWNER TO postgres;

--
-- Name: ocn_lata_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ocn_lata_id_seq OWNED BY public.ocn_lata.id;


--
-- Name: online_users_online_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.online_users_online_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.online_users_online_id_seq OWNER TO postgres;

--
-- Name: online_users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.online_users (
    user_id integer,
    reseller_id integer,
    login_time timestamp with time zone DEFAULT now(),
    online_id integer DEFAULT nextval('public.online_users_online_id_seq'::regclass) NOT NULL,
    card_id integer,
    client_id integer,
    user_type integer,
    user_name character varying(40)
);


ALTER TABLE public.online_users OWNER TO postgres;

--
-- Name: TABLE online_users; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.online_users IS 'åœ¨çº¿ç”¨æˆ·è¡¨';


--
-- Name: COLUMN online_users.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.online_users.user_id IS 'ç”¨æˆ·';


--
-- Name: COLUMN online_users.reseller_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.online_users.reseller_id IS 'ä»£ç†å•†';


--
-- Name: COLUMN online_users.login_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.online_users.login_time IS 'ç™»å½•æ—¶é—´';


--
-- Name: COLUMN online_users.online_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.online_users.online_id IS 'ä¸»é”®';


--
-- Name: COLUMN online_users.card_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.online_users.card_id IS 'è´¦å·å¡';


--
-- Name: COLUMN online_users.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.online_users.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN online_users.user_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.online_users.user_type IS '1--ç®¡ç†å‘˜
2--ä»£ç†å•†
3--å®¢æˆ·(æ‰¹å‘)
4--å¸å·å¡(account)
5--æ™®é€šç”¨æˆ·
6--ä½“éªŒç”¨æˆ·
';


--
-- Name: COLUMN online_users.user_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.online_users.user_name IS 'ç™»å½•ç”¨æˆ·å';


--
-- Name: opentact_balance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.opentact_balance (
    id integer NOT NULL,
    ingress_id integer NOT NULL,
    balance numeric(30,10) DEFAULT 0
);


ALTER TABLE public.opentact_balance OWNER TO postgres;

--
-- Name: opentact_balance_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.opentact_balance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.opentact_balance_id_seq OWNER TO postgres;

--
-- Name: opentact_balance_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.opentact_balance_id_seq OWNED BY public.opentact_balance.id;


--
-- Name: options_of_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.options_of_record (
    id integer NOT NULL,
    "time" bigint,
    state integer,
    sip_code integer,
    resource_id integer,
    resource_ip_id integer,
    pdd integer
);


ALTER TABLE public.options_of_record OWNER TO postgres;

--
-- Name: TABLE options_of_record; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.options_of_record IS 'è®°å½•optionsçŠ¶æ€æ”¹å˜æƒ…å†µ

baohq20140419';


--
-- Name: COLUMN options_of_record.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.options_of_record.id IS 'é€’å¢žçš„åºåˆ—';


--
-- Name: COLUMN options_of_record."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.options_of_record."time" IS 'æ’å…¥æ—¶é—´ï¼Œé•¿æ•´åž‹ï¼Œç§’å•ä½

baohq20140419';


--
-- Name: COLUMN options_of_record.state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.options_of_record.state IS 'çŠ¶æ€æ”¹å˜æ—¶è¢«æ’å…¥ä¸€æ¡ï¼Œåˆ†ç»„åŽidæœ€å¤§çš„æ˜¯æœ€æ–°çš„çŠ¶æ€
0 -- false ä¸åœ¨çº¿
1 -- true åœ¨çº¿

baohq20140419';


--
-- Name: COLUMN options_of_record.sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.options_of_record.sip_code IS 'æœ€åŽä¸€æ¬¡æ”¶åˆ°çš„sipç ï¼Œ 0ä¸ºè¡¨ç¤ºæ²¡æ”¶åˆ°ã€‚

baohq20140419';


--
-- Name: COLUMN options_of_record.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.options_of_record.resource_id IS 'å¯¹åº”resourceå’Œresource_ipè¡¨çš„resource_id

baohq20140419';


--
-- Name: COLUMN options_of_record.resource_ip_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.options_of_record.resource_ip_id IS 'å¯¹åº”resource_ipè¡¨resource_ip_id

baohq20140419';


--
-- Name: COLUMN options_of_record.pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.options_of_record.pdd IS 'æœ€è¿‘10æ¬¡optionçš„å¹³å‡pdd

baohq20140419';


--
-- Name: options_of_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.options_of_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.options_of_record_id_seq OWNER TO postgres;

--
-- Name: options_of_record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.options_of_record_id_seq OWNED BY public.options_of_record.id;


--
-- Name: order_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_code (
    order_id integer NOT NULL,
    code public.prefix_range NOT NULL,
    order_type integer NOT NULL,
    id integer NOT NULL,
    code_name character varying(100) NOT NULL,
    code_id integer,
    country character varying(100) NOT NULL,
    client_id integer
);


ALTER TABLE public.order_code OWNER TO postgres;

--
-- Name: COLUMN order_code.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_code.code IS 'code  è¡¨ä¸­çš„code';


--
-- Name: COLUMN order_code.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_code.order_type IS '1ï¼ï¼buy
2ï¼ï¼sell';


--
-- Name: order_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.order_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.order_code_id_seq OWNER TO postgres;

--
-- Name: order_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.order_code_id_seq OWNED BY public.order_code.id;


--
-- Name: order_partern; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_partern (
    id integer NOT NULL,
    order_id integer,
    order_type integer,
    partern_id integer,
    status integer DEFAULT 1
);


ALTER TABLE public.order_partern OWNER TO postgres;

--
-- Name: COLUMN order_partern.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_partern.order_type IS '1-buy
2-sell';


--
-- Name: COLUMN order_partern.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_partern.status IS '1-default
2-accept
3-reject';


--
-- Name: order_partern_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.order_partern_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.order_partern_id_seq OWNER TO postgres;

--
-- Name: order_partern_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.order_partern_id_seq OWNED BY public.order_partern.id;


--
-- Name: order_user; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_user (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    password character varying(100) NOT NULL,
    question character varying(1000) NOT NULL,
    answer character varying(1000) NOT NULL,
    company_name character varying NOT NULL,
    addr1 character varying(100) NOT NULL,
    addr2 character varying(100),
    city character varying(100) NOT NULL,
    province character varying(100),
    post_code character varying(40) NOT NULL,
    country character varying(100) NOT NULL,
    corporate_contact_name character varying(100) NOT NULL,
    corporate_contact_phone character varying(100) NOT NULL,
    corporate_contact_cell character varying(100),
    corporate_contact_email character varying(100) NOT NULL,
    alternate_emails character varying(1000),
    corporate_contact_fax character varying(100),
    corporate_registration_id character varying(100),
    corporate_registration_country character varying(100) NOT NULL,
    billing_contact_name character varying(100),
    billing_contact_phone character varying(100),
    billing_contact_email character varying(100),
    billing_contact_fax character varying(100),
    bank_name character varying(100) NOT NULL,
    bank_address character varying(100),
    bank_city character varying(100),
    bank_province character varying(100),
    bank_country character varying(100),
    bank_post_code character varying DEFAULT 100,
    bank_account_name character varying(100) NOT NULL,
    bank_routing_number character varying(100) NOT NULL,
    bank_account_number character varying(100) NOT NULL,
    bank_swift character varying(100) NOT NULL,
    bank_notes character varying(1000),
    status integer DEFAULT 1 NOT NULL,
    client_id integer,
    noc_contract_phone character varying(100),
    noc_contract_email character varying(100),
    noc_contract_im character varying(1000),
    mail_validate_code character varying(32),
    paypal character varying(100),
    currency_preference character varying(100),
    noc_contract_type integer,
    intermediately_bank character varying(100),
    ach character varying(100),
    primary_contact_name character varying(100),
    primary_job_tite character varying(100),
    primary_email character varying(100),
    primary_fax character varying(100),
    primary_phone character varying(100),
    primary_mobile character varying(100),
    primary_yahoo character varying(100),
    primary_msn character varying(100),
    primary_skype character varying(100),
    primary_aql character varying(100),
    primary_icq character varying(100),
    primary_qq character varying(100),
    technical_contact_name character varying(100),
    technical_job_tite character varying(100),
    technical_email character varying(100),
    technical_fax character varying(100),
    technical_phone character varying(100),
    technical_mobile character varying(100),
    technical_yahoo character varying(100),
    technical_msn character varying(100),
    technical_skype character varying(100),
    technical_aql character varying(100),
    technical_icq character varying(100),
    technical_qq character varying(100),
    billing_job_tite character varying(100),
    billing_email character varying(100),
    billing_fax character varying(100),
    billing_phone character varying(100),
    billing_mobile character varying(100),
    billing_yahoo character varying(100),
    billing_msn character varying(100),
    billing_skype character varying(100),
    billing_aql character varying(100),
    billing_icq character varying(100),
    billing_qq character varying(100),
    pwd_code character varying(2000),
    last_login_time timestamp with time zone,
    admin_login_key character varying(100),
    create_time timestamp with time zone,
    email_key character varying(100),
    agent_email text,
    rate_send_from text,
    rate_contact_name character varying,
    rate_contact_phone character varying,
    role_id integer,
    client_type integer DEFAULT 1 NOT NULL,
    edit_trunk integer DEFAULT 1 NOT NULL,
    is_reg boolean DEFAULT false,
    app_time timestamp with time zone,
    app_status integer,
    app_key character varying
);


ALTER TABLE public.order_user OWNER TO postgres;

--
-- Name: COLUMN order_user.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user.status IS '1:New
2:Hold
3:Accepted
4:mail validated';


--
-- Name: COLUMN order_user.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user.client_id IS 'æ³¨å†ŒæˆåŠŸåŽçš„carrirçš„ç›¸å…³client_idå­—æ®µ';


--
-- Name: COLUMN order_user.noc_contract_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user.noc_contract_type IS '1-msn
2-skype
3-other';


--
-- Name: COLUMN order_user.client_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user.client_type IS '1:exchange user
2:class4 user';


--
-- Name: COLUMN order_user.edit_trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user.edit_trunk IS '1:can edit
2:can not edit';


--
-- Name: COLUMN order_user.app_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user.app_status IS '1:watiing email
2:wating for app
3:complete';


--
-- Name: order_user_alert; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_user_alert (
    id integer NOT NULL,
    user_id integer,
    order_type integer,
    alert_type integer,
    freq_type integer,
    freq_value character varying(100),
    email character varying(100),
    last_email_time timestamp with time zone,
    last_run_time timestamp with time zone,
    client_id integer,
    agent_id integer,
    allow_sent integer DEFAULT 0
);


ALTER TABLE public.order_user_alert OWNER TO postgres;

--
-- Name: TABLE order_user_alert; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.order_user_alert IS 'exchange_alert';


--
-- Name: COLUMN order_user_alert.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user_alert.order_type IS '1--buy
2--sell';


--
-- Name: COLUMN order_user_alert.alert_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user_alert.alert_type IS '1-rate update
2-route update
3-request route match
4-select route update
5-no route available
6-invoice post
7-rate watch
8-auto summary
9-buy qos
10-sell qos
11-finance';


--
-- Name: COLUMN order_user_alert.freq_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user_alert.freq_type IS '0-never
1-real time
2-30 m
3-1 h
4-3 h
5-6 h
6-12 h
7-24 h';


--
-- Name: order_user_alert_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.order_user_alert_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.order_user_alert_id_seq OWNER TO postgres;

--
-- Name: order_user_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.order_user_alert_id_seq OWNED BY public.order_user_alert.id;


--
-- Name: order_user_finance; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_user_finance (
    id integer NOT NULL,
    order_user_alert_id integer,
    finance_type integer,
    finance_value real,
    finance_condition integer,
    client_id integer,
    name character varying(100)
);


ALTER TABLE public.order_user_finance OWNER TO postgres;

--
-- Name: COLUMN order_user_finance.finance_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user_finance.finance_type IS '0-remaining balance
1-daily buy
2-daily sell';


--
-- Name: COLUMN order_user_finance.finance_condition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user_finance.finance_condition IS '1-<
2->=';


--
-- Name: order_user_finance_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.order_user_finance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.order_user_finance_id_seq OWNER TO postgres;

--
-- Name: order_user_finance_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.order_user_finance_id_seq OWNED BY public.order_user_finance.id;


--
-- Name: order_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.order_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.order_user_id_seq OWNER TO postgres;

--
-- Name: order_user_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.order_user_id_seq OWNED BY public.order_user.id;


--
-- Name: order_user_qos; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_user_qos (
    id integer NOT NULL,
    order_user_alert_id integer,
    asr_condition integer,
    acd_condition integer,
    pdd_condition integer,
    asr_value real,
    acd_value real,
    pdd_value real,
    resource_id integer,
    client_id integer,
    name character varying(100)
);


ALTER TABLE public.order_user_qos OWNER TO postgres;

--
-- Name: COLUMN order_user_qos.asr_condition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user_qos.asr_condition IS '0-don''t care
1->=
2-<';


--
-- Name: order_user_qos_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.order_user_qos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.order_user_qos_id_seq OWNER TO postgres;

--
-- Name: order_user_qos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.order_user_qos_id_seq OWNED BY public.order_user_qos.id;


--
-- Name: order_user_rate_watch; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_user_rate_watch (
    id integer NOT NULL,
    order_user_alert_id integer,
    code_name character varying(100),
    rate_type integer,
    rate_less real,
    rate_more real,
    code text,
    new_route_available boolean,
    rate_increases boolean,
    rate_decreases boolean,
    no_route_available boolean,
    rate_greater_than numeric,
    rate_less_than numeric,
    new_target_available boolean,
    client_id integer
);


ALTER TABLE public.order_user_rate_watch OWNER TO postgres;

--
-- Name: COLUMN order_user_rate_watch.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.order_user_rate_watch.rate_type IS '1-white
2-grey';


--
-- Name: order_user_rate_watch_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.order_user_rate_watch_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.order_user_rate_watch_id_seq OWNER TO postgres;

--
-- Name: order_user_rate_watch_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.order_user_rate_watch_id_seq OWNED BY public.order_user_rate_watch.id;


--
-- Name: orig_invoice; Type: TABLE; Schema: public; Owner: class4_user
--

CREATE TABLE public.orig_invoice (
    invoice_id integer NOT NULL,
    invoice_number text NOT NULL,
    state integer DEFAULT 1 NOT NULL,
    client_id integer NOT NULL,
    invoice_time timestamp without time zone NOT NULL,
    invoice_start timestamp without time zone NOT NULL,
    invoice_end timestamp without time zone NOT NULL,
    total_amount numeric(15,2) NOT NULL,
    pdf_path text NOT NULL,
    create_type integer DEFAULT 0
);


ALTER TABLE public.orig_invoice OWNER TO class4_user;

--
-- Name: orig_invoice_invoice_id_seq; Type: SEQUENCE; Schema: public; Owner: class4_user
--

CREATE SEQUENCE public.orig_invoice_invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.orig_invoice_invoice_id_seq OWNER TO class4_user;

--
-- Name: orig_invoice_invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: class4_user
--

ALTER SEQUENCE public.orig_invoice_invoice_id_seq OWNED BY public.orig_invoice.invoice_id;


--
-- Name: orig_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.orig_log (
    log_id integer NOT NULL,
    update_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying(100),
    module character varying(100),
    type smallint,
    detail character varying(500)
);


ALTER TABLE public.orig_log OWNER TO postgres;

--
-- Name: COLUMN orig_log.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.orig_log.type IS '0 -- creation
1-- deletion
2 -- modification';


--
-- Name: orig_log_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.orig_log_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.orig_log_log_id_seq OWNER TO postgres;

--
-- Name: orig_log_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.orig_log_log_id_seq OWNED BY public.orig_log.log_id;


--
-- Name: origination_global_failover; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.origination_global_failover (
    id integer NOT NULL,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100)
);


ALTER TABLE public.origination_global_failover OWNER TO postgres;

--
-- Name: TABLE origination_global_failover; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.origination_global_failover IS 'ä¸»å«æ–¹è·³è½¬ç­–ç•¥

baohq20140422';


--
-- Name: COLUMN origination_global_failover.failover_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.origination_global_failover.failover_strategy IS 'è·³è½¬ç­–ç•¥ç±»åž‹

baohq20140422';


--
-- Name: COLUMN origination_global_failover.from_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.origination_global_failover.from_sip_code IS 'ä»Žè¢«å«æ”¶åˆ°çš„sipç 

baohq20140422';


--
-- Name: COLUMN origination_global_failover.to_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.origination_global_failover.to_sip_code IS 'è¿”å›žç»™ä¸»å«çš„sipç 

baohq20140422';


--
-- Name: COLUMN origination_global_failover.to_sip_string; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.origination_global_failover.to_sip_string IS 'è¿”å›žç»™ä¸»å«çš„sipæè¿°å­—ç¬¦ä¸²

baohq20140422';


--
-- Name: origination_global_failover_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.origination_global_failover_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.origination_global_failover_id_seq OWNER TO postgres;

--
-- Name: origination_global_failover_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.origination_global_failover_id_seq OWNED BY public.origination_global_failover.id;


--
-- Name: origination_global_failover_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.origination_global_failover_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.origination_global_failover_record_record_id_seq OWNER TO postgres;

--
-- Name: origination_global_failover_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.origination_global_failover_record (
    id integer,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.origination_global_failover_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.origination_global_failover_record OWNER TO postgres;

--
-- Name: origination_global_failover_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.origination_global_failover_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.origination_global_failover_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: origination_global_failover_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.origination_global_failover_record_tmp (
    id integer,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.origination_global_failover_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.origination_global_failover_record_tmp OWNER TO postgres;

--
-- Name: par_user; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.par_user (
    name character varying(100),
    password character varying(100),
    question character varying(1000),
    answer character varying(1000),
    company_name character varying,
    addr1 character varying(100),
    addr2 character varying(100),
    city character varying(100),
    province character varying(100),
    post_code character varying(40),
    country character varying(100),
    corporate_contact_name character varying(100),
    corporate_contact_phone character varying(100),
    corporate_contact_cell character varying(100),
    corporate_contact_email character varying(100),
    alternate_emails character varying(1000),
    corporate_contact_fax character varying(100),
    corporate_registration_id character varying(100),
    corporate_registration_country character varying(100),
    billing_contact_name character varying(100),
    billing_contact_phone character varying(100),
    billing_contact_email character varying(100),
    billing_contact_fax character varying(100),
    bank_name character varying(100),
    bank_address character varying(100),
    bank_city character varying(100),
    bank_province character varying(100),
    bank_country character varying(100),
    bank_post_code character varying,
    bank_account_name character varying(100),
    bank_routing_number character varying(100),
    bank_account_number character varying(100),
    bank_swift character varying(100),
    bank_notes character varying(1000),
    status integer DEFAULT 1 NOT NULL,
    client_id integer,
    noc_contract_phone character varying(100),
    noc_contract_email character varying(100),
    noc_contract_im character varying(1000),
    mail_validate_code character varying(32),
    paypal character varying(100),
    currency_preference character varying(100),
    noc_contract_type integer,
    intermediately_bank character varying(100),
    ach character varying(100),
    primary_contact_name character varying(100),
    primary_job_tite character varying(100),
    primary_email character varying(100),
    primary_fax character varying(100),
    primary_phone character varying(100),
    primary_mobile character varying(100),
    primary_yahoo character varying(100),
    primary_msn character varying(100),
    primary_skype character varying(100),
    primary_aql character varying(100),
    primary_icq character varying(100),
    primary_qq character varying(100),
    technical_contact_name character varying(100),
    technical_job_tite character varying(100),
    technical_email character varying(100),
    technical_fax character varying(100),
    technical_phone character varying(100),
    technical_mobile character varying(100),
    technical_yahoo character varying(100),
    technical_msn character varying(100),
    technical_skype character varying(100),
    technical_aql character varying(100),
    technical_icq character varying(100),
    technical_qq character varying(100),
    billing_job_tite character varying(100),
    billing_email character varying(100),
    billing_fax character varying(100),
    billing_phone character varying(100),
    billing_mobile character varying(100),
    billing_yahoo character varying(100),
    billing_msn character varying(100),
    billing_skype character varying(100),
    billing_aql character varying(100),
    billing_icq character varying(100),
    billing_qq character varying(100),
    pwd_code character varying(2000),
    last_login_time timestamp with time zone,
    admin_login_key character varying(100),
    create_time timestamp with time zone,
    email_key character varying(100),
    agent_email text,
    id integer NOT NULL,
    rate_send_from text,
    rate_contact_name character varying,
    rate_contact_phone character varying,
    client_type integer
);


ALTER TABLE public.par_user OWNER TO postgres;

--
-- Name: COLUMN par_user.client_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.par_user.client_type IS '1: Client  (buy)
2:Vendor (sell)
';


--
-- Name: par_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.par_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.par_user_id_seq OWNER TO postgres;

--
-- Name: par_user_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.par_user_id_seq OWNED BY public.par_user.id;


--
-- Name: partition_gateway_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.partition_gateway_ref (
    id integer NOT NULL,
    partition_id integer,
    gateway_ip public.ip4,
    gateway_port integer
);


ALTER TABLE public.partition_gateway_ref OWNER TO postgres;

--
-- Name: TABLE partition_gateway_ref; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.partition_gateway_ref IS 'partitionå’Œswitch_profileè¡¨çš„æ˜ å°„å…³ç³»';


--
-- Name: COLUMN partition_gateway_ref.gateway_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.partition_gateway_ref.gateway_ip IS 'è·Ÿswitch_profileè¡¨sip_ipå¯¹åº”';


--
-- Name: COLUMN partition_gateway_ref.gateway_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.partition_gateway_ref.gateway_port IS 'è·Ÿswitch_profileè¡¨sip_portå¯¹åº”';


--
-- Name: partition_gateway_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.partition_gateway_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.partition_gateway_ref_id_seq OWNER TO postgres;

--
-- Name: partition_gateway_ref_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.partition_gateway_ref_id_seq OWNED BY public.partition_gateway_ref.id;


--
-- Name: partition_gateway_ref_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.partition_gateway_ref_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.partition_gateway_ref_record_record_id_seq OWNER TO postgres;

--
-- Name: partition_gateway_ref_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.partition_gateway_ref_record (
    id integer,
    partition_id integer,
    gateway_ip public.ip4,
    gateway_port integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.partition_gateway_ref_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.partition_gateway_ref_record OWNER TO postgres;

--
-- Name: partition_gateway_ref_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.partition_gateway_ref_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.partition_gateway_ref_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: partition_gateway_ref_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.partition_gateway_ref_record_tmp (
    id integer,
    partition_id integer,
    gateway_ip public.ip4,
    gateway_port integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.partition_gateway_ref_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.partition_gateway_ref_record_tmp OWNER TO postgres;

--
-- Name: partition_invoice; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.partition_invoice (
    id integer NOT NULL,
    invoice_no character varying(20),
    total_calls integer,
    total_minutes integer,
    rate numeric(30,10),
    total_cost numeric(30,10),
    invoice_start timestamp with time zone,
    invoice_end timestamp with time zone,
    invoice_time timestamp with time zone,
    customer_name character varying(100),
    due_date timestamp with time zone
);


ALTER TABLE public.partition_invoice OWNER TO postgres;

--
-- Name: partition_invoice_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.partition_invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.partition_invoice_id_seq OWNER TO postgres;

--
-- Name: partition_invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.partition_invoice_id_seq OWNED BY public.partition_invoice.id;


--
-- Name: partner; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.partner (
    id integer NOT NULL,
    client_id integer,
    partner_id integer
);


ALTER TABLE public.partner OWNER TO postgres;

--
-- Name: TABLE partner; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.partner IS 'è¿è¥å•†çš„partner';


--
-- Name: partner_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.partner_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.partner_id_seq OWNER TO postgres;

--
-- Name: partner_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.partner_id_seq OWNED BY public.partner.id;


--
-- Name: payline_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.payline_history (
    chargetotal numeric,
    method smallint,
    cardnumber character varying,
    cardexpmonth character varying,
    cardexpyear character varying,
    created_time timestamp without time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    modified_time timestamp without time zone,
    error character varying,
    confirmed boolean DEFAULT false,
    client_id integer,
    fee numeric,
    status smallint DEFAULT 0,
    id integer NOT NULL,
    invoice_id character varying(255),
    par_id integer,
    address1 character varying(255),
    address2 character varying(255),
    city character varying(255),
    state_province character varying(255),
    zip_code character varying(255),
    country character varying(255),
    credit_card_type integer,
    paypal_id character varying(100),
    transaction_id character varying(100),
    return_code character varying(100),
    charge_type numeric DEFAULT 0,
    charge_amount numeric DEFAULT 0,
    response text
);


ALTER TABLE public.payline_history OWNER TO postgres;

--
-- Name: COLUMN payline_history.method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payline_history.method IS '0 - paypal

1- yourpay';


--
-- Name: COLUMN payline_history.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payline_history.status IS '0 initial

1 error

2 success';


--
-- Name: payline_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.payline_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.payline_history_id_seq OWNER TO postgres;

--
-- Name: payline_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.payline_history_id_seq OWNED BY public.payline_history.id;


--
-- Name: payment_invoice; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.payment_invoice (
    id integer NOT NULL,
    payment_id integer,
    invoice_id integer,
    amount numeric(20,5)
);


ALTER TABLE public.payment_invoice OWNER TO postgres;

--
-- Name: payment_invoice_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.payment_invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.payment_invoice_id_seq OWNER TO postgres;

--
-- Name: payment_invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.payment_invoice_id_seq OWNED BY public.payment_invoice.id;


--
-- Name: payment_term_payment_term_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.payment_term_payment_term_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999
    CACHE 1;


ALTER TABLE public.payment_term_payment_term_id_seq OWNER TO postgres;

--
-- Name: payment_term; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.payment_term (
    payment_term_id integer DEFAULT nextval('public.payment_term_payment_term_id_seq'::regclass) NOT NULL,
    name character varying(100) NOT NULL,
    type integer NOT NULL,
    days integer NOT NULL,
    grace_days integer,
    notify_days integer,
    more_days character varying(100),
    finance_rate real
);


ALTER TABLE public.payment_term OWNER TO postgres;

--
-- Name: TABLE payment_term; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.payment_term IS 'ç¼´è´¹è®¾ç½®';


--
-- Name: COLUMN payment_term.payment_term_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_term.payment_term_id IS 'ä¸»é”®';


--
-- Name: COLUMN payment_term.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_term.name IS 'åå­—';


--
-- Name: COLUMN payment_term.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_term.type IS 'ä»˜æ¬¾æ—¶é—´ï¼š1ï¼æ¯éš”å¤šå°‘å¤©ï¼Œ2ï¼æ¯æœˆå“ªä¸€å¤©
3ï¼æ¯å‘¨å‡ ï¼Œ4ï¼æ¯æœˆå“ªå‡ å¤©';


--
-- Name: COLUMN payment_term.days; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_term.days IS 'å¤©æ•°æˆ–æ—¥æœŸ';


--
-- Name: COLUMN payment_term.grace_days; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_term.grace_days IS 'ç¼´æ¬¾çš„å®½é™å¤©æ•°';


--
-- Name: COLUMN payment_term.notify_days; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.payment_term.notify_days IS 'å®½é™æœŸç»“æŸå‰ï¼Œå¤šå°å¤©å‰é€šçŸ¥';


--
-- Name: payment_term_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.payment_term_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.payment_term_record_record_id_seq OWNER TO postgres;

--
-- Name: payment_term_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.payment_term_record (
    payment_term_id integer,
    name character varying(100),
    type integer,
    days integer,
    grace_days integer,
    notify_days integer,
    more_days character varying(100),
    finance_rate real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.payment_term_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.payment_term_record OWNER TO postgres;

--
-- Name: payment_term_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.payment_term_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.payment_term_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: payment_term_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.payment_term_record_tmp (
    payment_term_id integer,
    name character varying(100),
    type integer,
    days integer,
    grace_days integer,
    notify_days integer,
    more_days character varying(100),
    finance_rate real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.payment_term_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.payment_term_record_tmp OWNER TO postgres;

--
-- Name: pex_offer_pending_rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.pex_offer_pending_rate (
    id integer NOT NULL,
    offer_id integer,
    rate_id integer,
    new_rate numeric(30,10),
    new_inteval integer,
    new_min_period integer,
    created_date timestamp with time zone,
    status integer DEFAULT 1 NOT NULL,
    effective_date timestamp with time zone,
    closed_date timestamp with time zone
);


ALTER TABLE public.pex_offer_pending_rate OWNER TO postgres;

--
-- Name: COLUMN pex_offer_pending_rate.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.pex_offer_pending_rate.status IS '1:pending
2:rejected';


--
-- Name: pex_offer_pending_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.pex_offer_pending_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.pex_offer_pending_rate_id_seq OWNER TO postgres;

--
-- Name: pex_offer_pending_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.pex_offer_pending_rate_id_seq OWNED BY public.pex_offer_pending_rate.id;


--
-- Name: pex_offers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.pex_offers (
    id integer NOT NULL,
    client_id integer,
    type integer NOT NULL,
    trunk_id integer NOT NULL,
    rate_table_id integer,
    created_date timestamp with time zone,
    close_date timestamp with time zone,
    accepted_date timestamp with time zone,
    rejected_date timestamp with time zone,
    status integer DEFAULT 1 NOT NULL,
    exchange_escrow boolean,
    allowed_credit numeric(30,10),
    partner_client_id integer,
    partner_trunk_id integer,
    closed_by integer
);


ALTER TABLE public.pex_offers OWNER TO postgres;

--
-- Name: COLUMN pex_offers.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.pex_offers.status IS '1:pending
2:active
3:rejectd
4:closed';


--
-- Name: COLUMN pex_offers.closed_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.pex_offers.closed_by IS '1:owner
2:partner';


--
-- Name: pex_offers_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.pex_offers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.pex_offers_id_seq OWNER TO postgres;

--
-- Name: pex_offers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.pex_offers_id_seq OWNED BY public.pex_offers.id;


--
-- Name: prefix_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.prefix_info (
    "time" character varying(100),
    pro_id character varying(100),
    prefix_id character varying(100),
    acd character varying(100),
    asr character varying(100),
    ca character varying(100),
    call_count character varying(100),
    direction character varying(100),
    call_count_asr character varying(100),
    pdd character varying(100),
    ip character varying(100)
);


ALTER TABLE public.prefix_info OWNER TO postgres;

--
-- Name: TABLE prefix_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.prefix_info IS 'prefix monitor';


--
-- Name: COLUMN prefix_info."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info."time" IS 'æ—¶é—´';


--
-- Name: COLUMN prefix_info.pro_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info.pro_id IS 'é™æ€è·¯ç”±è¡¨';


--
-- Name: COLUMN prefix_info.prefix_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info.prefix_id IS 'prefix';


--
-- Name: COLUMN prefix_info.acd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info.acd IS 'å¹³å‡é€šè¯æ—¶é—´';


--
-- Name: COLUMN prefix_info.asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info.asr IS 'å‘¼å«æˆåŠŸçŽ‡';


--
-- Name: COLUMN prefix_info.ca; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info.ca IS 'ca';


--
-- Name: COLUMN prefix_info.call_count; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info.call_count IS 'call_count';


--
-- Name: COLUMN prefix_info.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info.direction IS 'ingress,egress';


--
-- Name: COLUMN prefix_info.call_count_asr; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info.call_count_asr IS 'call_count_asr';


--
-- Name: COLUMN prefix_info.pdd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info.pdd IS 'å‘¼å«å»¶è¿Ÿ';


--
-- Name: COLUMN prefix_info.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.prefix_info.ip IS 'æœåŠ¡å™¨åœ°å€';


--
-- Name: priority_view; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.priority_view AS
 SELECT ( SELECT alert_rule.name
           FROM public.alert_rule
          WHERE (alert_rule.id = alert_event.alert_rule_id)) AS rule_name,
    ( SELECT resource.alias
           FROM public.resource
          WHERE (resource.resource_id = alert_event.res_id)) AS resource,
    alert_event.disable_code AS code,
    alert_event.event_time,
    (alert_event.event_time + ((alert_event.disable_duration)::double precision * '00:01:00'::interval)) AS enabled_time,
    alert_event.old_priority,
    alert_event.new_priority
   FROM public.alert_event
  WHERE (alert_event.event_type = 7);


ALTER TABLE public.priority_view OWNER TO postgres;

--
-- Name: private_invite; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.private_invite (
    id integer NOT NULL,
    sender_user_id integer,
    sender_first_name character varying(100),
    sender_last_name character varying(100),
    sender_phone character varying(100),
    sender_email character varying(100),
    invite_content character varying(1000),
    receiver_first_name character varying(100),
    receiver_last_name character varying(100),
    receiver_company character varying(100),
    receiver_email character varying(100),
    receiver_user_id integer,
    send_time timestamp with time zone,
    accept_time timestamp with time zone,
    status integer DEFAULT 0,
    invite_no character varying(100)
);


ALTER TABLE public.private_invite OWNER TO postgres;

--
-- Name: COLUMN private_invite.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.private_invite.status IS '0ï¼šå‘å‡ºé‚€è¯·
1ï¼šå‘é€é‚®ä»¶
2ï¼šæŽ¥å—é‚€è¯·
3ï¼šå–æ¶ˆé‚€è¯·
4ï¼šæ‹’ç»é‚€è¯·';


--
-- Name: private_invite_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.private_invite_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.private_invite_id_seq OWNER TO postgres;

--
-- Name: private_invite_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.private_invite_id_seq OWNED BY public.private_invite.id;


--
-- Name: product_agents_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_agents_ref (
    id integer NOT NULL,
    product_id integer,
    agent_id integer
);


ALTER TABLE public.product_agents_ref OWNER TO postgres;

--
-- Name: product_agents_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_agents_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_agents_ref_id_seq OWNER TO postgres;

--
-- Name: product_agents_ref_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.product_agents_ref_id_seq OWNED BY public.product_agents_ref.id;


--
-- Name: product_clients_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_clients_ref (
    id integer NOT NULL,
    product_id integer,
    client_id integer
);


ALTER TABLE public.product_clients_ref OWNER TO postgres;

--
-- Name: product_clients_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_clients_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_clients_ref_id_seq OWNER TO postgres;

--
-- Name: product_clients_ref_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.product_clients_ref_id_seq OWNED BY public.product_clients_ref.id;


--
-- Name: product_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_info (
    "time" character varying(100),
    product_id character varying(100),
    value character varying(100),
    ip character varying(100)
);


ALTER TABLE public.product_info OWNER TO postgres;

--
-- Name: TABLE product_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.product_info IS 'product monitor';


--
-- Name: COLUMN product_info."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product_info."time" IS 'æ—¶é—´';


--
-- Name: COLUMN product_info.product_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product_info.product_id IS 'product';


--
-- Name: COLUMN product_info.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product_info.value IS 'é€šè¯æ•°';


--
-- Name: COLUMN product_info.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product_info.ip IS 'æœåŠ¡å™¨åœ°å€';


--
-- Name: product_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_items_record_record_id_seq OWNER TO postgres;

--
-- Name: product_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_items_record (
    item_id integer,
    product_id integer,
    alias character varying(100),
    digits public.prefix_range,
    strategy integer,
    time_profile_id integer,
    min_len integer,
    max_len integer,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real,
    update_at timestamp with time zone,
    update_by character varying,
    code_name character(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.product_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.product_items_record OWNER TO postgres;

--
-- Name: product_items_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_items_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_items_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: product_items_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_items_record_tmp (
    item_id integer,
    product_id integer,
    alias character varying(100),
    digits public.prefix_range,
    strategy integer,
    time_profile_id integer,
    min_len integer,
    max_len integer,
    min_asr real,
    max_asr real,
    min_abr real,
    max_abr real,
    min_acd real,
    max_acd real,
    min_pdd integer,
    max_pdd integer,
    min_aloc real,
    max_aloc real,
    limit_price real,
    update_at timestamp with time zone,
    update_by character varying,
    code_name character(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.product_items_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.product_items_record_tmp OWNER TO postgres;

--
-- Name: product_items_resource_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_items_resource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_items_resource_id_seq OWNER TO postgres;

--
-- Name: product_items_resource_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.product_items_resource_id_seq OWNED BY public.product_items_resource.id;


--
-- Name: product_items_resource_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_items_resource_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_items_resource_record_record_id_seq OWNER TO postgres;

--
-- Name: product_items_resource_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_items_resource_record (
    id integer,
    item_id integer,
    resource_id integer,
    by_percentage integer,
    order_id integer,
    order_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.product_items_resource_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.product_items_resource_record OWNER TO postgres;

--
-- Name: product_items_resource_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_items_resource_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_items_resource_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: product_items_resource_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_items_resource_record_tmp (
    id integer,
    item_id integer,
    resource_id integer,
    by_percentage integer,
    order_id integer,
    order_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.product_items_resource_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.product_items_resource_record_tmp OWNER TO postgres;

--
-- Name: product_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_record_record_id_seq OWNER TO postgres;

--
-- Name: product_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_record (
    product_id integer,
    name character varying(100),
    modify_time timestamp with time zone,
    introduction character varying(80),
    dynamic_route_id integer,
    update_by character varying,
    code_type integer,
    code_deck_id integer,
    route_lrn integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.product_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.product_record OWNER TO postgres;

--
-- Name: product_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: product_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_record_tmp (
    product_id integer,
    name character varying(100),
    modify_time timestamp with time zone,
    introduction character varying(80),
    dynamic_route_id integer,
    update_by character varying,
    code_type integer,
    code_deck_id integer,
    route_lrn integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.product_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.product_record_tmp OWNER TO postgres;

--
-- Name: product_rout_rate_table; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_rout_rate_table (
    id integer NOT NULL,
    rout_id integer NOT NULL,
    rate_table_id integer NOT NULL,
    product_name character varying(256) NOT NULL,
    agent_id integer,
    status integer DEFAULT 1,
    type integer DEFAULT 0,
    marketplace integer DEFAULT 0,
    par_id integer,
    prefix character varying
);


ALTER TABLE public.product_rout_rate_table OWNER TO postgres;

--
-- Name: TABLE product_rout_rate_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.product_rout_rate_table IS 'product';


--
-- Name: COLUMN product_rout_rate_table.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product_rout_rate_table.status IS '0:Inactive
1:Active';


--
-- Name: COLUMN product_rout_rate_table.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product_rout_rate_table.type IS '0:Public
1:Private';


--
-- Name: COLUMN product_rout_rate_table.marketplace; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.product_rout_rate_table.marketplace IS '0:A-Z
1:US';


--
-- Name: product_rout_rate_table_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_rout_rate_table_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_rout_rate_table_id_seq OWNER TO postgres;

--
-- Name: product_rout_rate_table_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.product_rout_rate_table_id_seq OWNED BY public.product_rout_rate_table.id;


--
-- Name: product_rout_rate_table_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_rout_rate_table_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_rout_rate_table_record_record_id_seq OWNER TO postgres;

--
-- Name: product_rout_rate_table_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_rout_rate_table_record (
    id integer,
    rout_id integer,
    rate_table_id integer,
    product_name character varying(256),
    agent_id integer,
    status integer,
    type integer,
    marketplace integer,
    par_id integer,
    prefix character varying,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.product_rout_rate_table_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.product_rout_rate_table_record OWNER TO postgres;

--
-- Name: product_route_rate_table; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_route_rate_table (
    id integer NOT NULL,
    product_name character varying(100),
    route_strategy_id integer,
    rate_table_id integer,
    update_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_by character varying(100),
    tech_prefix public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    is_private boolean DEFAULT false NOT NULL,
    description character varying(255)
);


ALTER TABLE public.product_route_rate_table OWNER TO postgres;

--
-- Name: product_route_rate_table_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_route_rate_table_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_route_rate_table_id_seq OWNER TO postgres;

--
-- Name: product_route_rate_table_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.product_route_rate_table_id_seq OWNED BY public.product_route_rate_table.id;


--
-- Name: qos_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.qos_ip (
    report_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    ip_id integer,
    call integer,
    cps integer,
    direction integer,
    server_ip character varying(50),
    server_port integer,
    channels integer
);


ALTER TABLE public.qos_ip OWNER TO postgres;

--
-- Name: qos_resource; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.qos_resource (
    report_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    res_id integer,
    call integer,
    cps integer,
    direction integer,
    server_ip character varying(50),
    server_port integer,
    channels integer
);


ALTER TABLE public.qos_resource OWNER TO postgres;

--
-- Name: qos_route_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.qos_route_report (
    report_time timestamp with time zone NOT NULL,
    resource_id integer,
    code character varying(32),
    not_zero_calls integer,
    total_calls integer,
    bill_time integer,
    cancel_calls integer,
    busy_calls integer,
    direction integer,
    server_ip character varying(36),
    pdd integer,
    cost numeric(12,6),
    call_duration integer,
    total_pdd integer
);


ALTER TABLE public.qos_route_report OWNER TO postgres;

--
-- Name: TABLE qos_route_report; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.qos_route_report IS 'ç»Ÿè®¡resource + codeçš„asr, acdç­‰ï¼Œä¿å­˜æ—¶é—´å¯ä»¥é™åˆ¶åœ¨ä¸€ä¸ªå°æ—¶ï¼Œä¸€ä¸ªå°æ—¶ä»¥å‰çš„åœ¨æŠ¥è¡¨æœåŠ¡å™¨å¯ä»¥æŸ¥è¯¢ã€‚';


--
-- Name: COLUMN qos_route_report.report_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.qos_route_report.report_time IS 'äº§ç”ŸæŠ¥è¡¨æ•°æ®çš„æ—¶é—´';


--
-- Name: COLUMN qos_route_report.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.qos_route_report.code IS 'ä¾‹å¦‚ï¼š86ï¼Œ86755ç­‰';


--
-- Name: COLUMN qos_route_report.bill_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.qos_route_report.bill_time IS 'ç§’å•ä½';


--
-- Name: COLUMN qos_route_report.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.qos_route_report.direction IS '0 --- ingress
1 --- egress';


--
-- Name: COLUMN qos_route_report.server_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.qos_route_report.server_ip IS 'switchçš„sip profile IP';


--
-- Name: qos_route_report_unlogged; Type: TABLE; Schema: public; Owner: postgres
--

CREATE UNLOGGED TABLE public.qos_route_report_unlogged (
    report_time timestamp with time zone NOT NULL,
    resource_id integer,
    code character varying(32),
    not_zero_calls integer,
    total_calls integer,
    bill_time integer,
    cancel_calls integer,
    busy_calls integer,
    direction integer,
    server_ip character varying(36),
    pdd integer,
    cost numeric(12,6)
);


ALTER TABLE public.qos_route_report_unlogged OWNER TO postgres;

--
-- Name: qos_total; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.qos_total (
    report_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    call integer,
    cps integer,
    server_ip character varying(50),
    server_port integer,
    channels integer,
    ingress_channels integer,
    egress_channels integer,
    ingress_cps integer,
    egress_cps integer
);


ALTER TABLE public.qos_total OWNER TO postgres;

--
-- Name: quick_cdr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.quick_cdr (
    id integer NOT NULL,
    status integer DEFAULT 0,
    start_date date,
    end_date date,
    file_path character varying(200),
    user_id integer,
    type integer,
    client_id integer
);


ALTER TABLE public.quick_cdr OWNER TO postgres;

--
-- Name: quick_cdr_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.quick_cdr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.quick_cdr_id_seq OWNER TO postgres;

--
-- Name: quick_cdr_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.quick_cdr_id_seq OWNED BY public.quick_cdr.id;


--
-- Name: random_ani_generation; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.random_ani_generation (
    id integer NOT NULL,
    ani_number character varying(32),
    random_table_id integer
);


ALTER TABLE public.random_ani_generation OWNER TO postgres;

--
-- Name: TABLE random_ani_generation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.random_ani_generation IS 'éšæœºæ›¿æ¢å‘¼å‡ºä¸»è§’å·ç ï¼Œé’ˆå¯¹ä¸åŒä¾›åº”å•†ä½¿ç”¨ä¸åŒå·ç ã€‚';


--
-- Name: COLUMN random_ani_generation.ani_number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.random_ani_generation.ani_number IS 'éšæœºæ›¿æ¢çš„å·ç ã€‚';


--
-- Name: random_ani_generation_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.random_ani_generation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.random_ani_generation_id_seq OWNER TO postgres;

--
-- Name: random_ani_generation_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.random_ani_generation_id_seq OWNED BY public.random_ani_generation.id;


--
-- Name: random_ani_generation_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.random_ani_generation_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.random_ani_generation_record_record_id_seq OWNER TO postgres;

--
-- Name: random_ani_generation_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.random_ani_generation_record (
    id integer,
    ani_number character varying(32),
    random_table_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.random_ani_generation_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.random_ani_generation_record OWNER TO postgres;

--
-- Name: random_ani_populated_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.random_ani_populated_log (
    id integer NOT NULL,
    start_time timestamp without time zone,
    finsh_time timestamp without time zone,
    prefix character varying(32),
    number_of_digits integer,
    total_num integer,
    success_num integer,
    duplicate_num integer,
    pid integer,
    status integer,
    random_table_id integer
);


ALTER TABLE public.random_ani_populated_log OWNER TO postgres;

--
-- Name: COLUMN random_ani_populated_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.random_ani_populated_log.status IS '"Waiting", "In Progress", "Done",''Killed''';


--
-- Name: random_ani_populated_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.random_ani_populated_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.random_ani_populated_log_id_seq OWNER TO postgres;

--
-- Name: random_ani_populated_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.random_ani_populated_log_id_seq OWNED BY public.random_ani_populated_log.id;


--
-- Name: random_ani_table; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.random_ani_table (
    id integer NOT NULL,
    name character varying(100),
    create_time timestamp with time zone
);


ALTER TABLE public.random_ani_table OWNER TO postgres;

--
-- Name: COLUMN random_ani_table.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.random_ani_table.name IS 'ä¸»å«éšæœºæ›¿æ¢è¡¨åå­—';


--
-- Name: random_ani_table_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.random_ani_table_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.random_ani_table_id_seq OWNER TO postgres;

--
-- Name: random_ani_table_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.random_ani_table_id_seq OWNED BY public.random_ani_table.id;


--
-- Name: rate_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_rate_id_seq OWNER TO postgres;

--
-- Name: rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate (
    rate_id integer DEFAULT nextval('public.rate_rate_id_seq'::regclass) NOT NULL,
    rate_table_id integer NOT NULL,
    code public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    rate numeric(30,10),
    setup_fee numeric(30,10) DEFAULT 0 NOT NULL,
    effective_date timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    end_date timestamp with time zone,
    min_time integer DEFAULT 1 NOT NULL,
    grace_time integer DEFAULT 0 NOT NULL,
    "interval" integer DEFAULT 1 NOT NULL,
    time_profile_id integer,
    seconds integer DEFAULT 60 NOT NULL,
    code_name character varying(100),
    basic_percentages real DEFAULT 0,
    gift_percentages real DEFAULT 0,
    rate_type integer DEFAULT 3 NOT NULL,
    intra_rate numeric(30,10),
    inter_rate numeric(30,10),
    local_rate numeric(30,10),
    country character varying(1000),
    zone character varying(10) DEFAULT 0,
    ocn character varying(10),
    lata character varying(10),
    create_time timestamp with time zone,
    did_type integer
);


ALTER TABLE public.rate OWNER TO postgres;

--
-- Name: TABLE rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.rate IS 'è¯¦ç»†è´¹çŽ‡';


--
-- Name: COLUMN rate.rate_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.rate_id IS 'ä¸»é”®';


--
-- Name: COLUMN rate.rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.rate_table_id IS 'rate_table';


--
-- Name: COLUMN rate.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.code IS 'å‰ç¼€å·ç 
å’Œcdrè¡¨çš„è¢«å«å·åŒ¹é… ';


--
-- Name: COLUMN rate.rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.rate IS 'æ¯åˆ†é’Ÿè´¹ç”¨';


--
-- Name: COLUMN rate.setup_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.setup_fee IS 'å›ºå®šè´¹ç”¨';


--
-- Name: COLUMN rate.effective_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.effective_date IS 'å¼€å§‹æ—¶é—´

';


--
-- Name: COLUMN rate.end_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.end_date IS 'ç»“æŸæ—¶é—´';


--
-- Name: COLUMN rate.min_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.min_time IS 'é¦–æ¬¡æ—¶é•¿(ç§’)';


--
-- Name: COLUMN rate.grace_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.grace_time IS 'å…è´¹æ—¶é•¿(ç§’)';


--
-- Name: COLUMN rate."interval"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate."interval" IS 'è®¡è´¹å‘¨æœŸ
6ç§’è®¡è´¹
ä¸è¶³6ç§’çš„è¦è¡¥
8ç§’ç®—2ä¸ª6ç§’

';


--
-- Name: COLUMN rate.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.time_profile_id IS 'æ—¶é—´æ®µè®¾ç½®';


--
-- Name: COLUMN rate.seconds; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.seconds IS 'æ¯åˆ†é’Ÿå¤šå°‘ç§’';


--
-- Name: COLUMN rate.code_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.code_name IS 'å·ç åç§°';


--
-- Name: COLUMN rate.basic_percentages; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.basic_percentages IS 'åŸºç¡€é‡‘æ¯”ä¾‹';


--
-- Name: COLUMN rate.gift_percentages; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.gift_percentages IS 'èµ é€é‡‘æ¯”ä¾‹';


--
-- Name: COLUMN rate.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.rate_type IS '1ï¼ï¼interstateï¼Œä¸åŒçš„åœ°åŒº
2ï¼ï¼intrastateï¼ŒåŒä¸€ä¸ªåœ°åŒº
3ï¼ï¼othersï¼Œå…¶ä»–';


--
-- Name: COLUMN rate.intra_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.intra_rate IS '2ï¼ï¼intrastateï¼ŒåŒä¸€ä¸ªåœ°åŒº';


--
-- Name: COLUMN rate.inter_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.inter_rate IS '1ï¼ï¼interstateï¼Œä¸åŒçš„åœ°åŒº';


--
-- Name: COLUMN rate.did_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate.did_type IS '1:æœªåˆ†é…;2:å·²åˆ†é…';


--
-- Name: rate_auto_create; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_auto_create (
    id integer NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    ingress_id integer,
    status integer DEFAULT 0,
    rate_order integer,
    result_file character varying,
    client_id integer,
    rate_effective_date timestamp with time zone,
    product_id integer,
    code_name text,
    decrease_days integer,
    increase_days integer,
    keep_old_rate integer,
    rate_min_time integer,
    rate_interval integer,
    mass_edit_log_id integer,
    new_days integer,
    remove_code integer,
    us_trunks character varying,
    rate_from integer DEFAULT 1 NOT NULL,
    us_type integer DEFAULT 1 NOT NULL
);


ALTER TABLE public.rate_auto_create OWNER TO postgres;

--
-- Name: TABLE rate_auto_create; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.rate_auto_create IS 'agent è‡ªåŠ¨ç”Ÿæˆè´¹çŽ‡';


--
-- Name: COLUMN rate_auto_create.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_auto_create.status IS '0-waiting
1-running
2-done
-1-open file error
-2-args not set';


--
-- Name: COLUMN rate_auto_create.rate_order; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_auto_create.rate_order IS '0-max';


--
-- Name: COLUMN rate_auto_create.keep_old_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_auto_create.keep_old_rate IS '1-old rate no change';


--
-- Name: COLUMN rate_auto_create.us_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_auto_create.us_type IS '1;us jd (has intre,intra)
2:us no jd(no intre,intra)';


--
-- Name: rate_auto_create_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_auto_create_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_auto_create_id_seq OWNER TO postgres;

--
-- Name: rate_auto_create_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_auto_create_id_seq OWNED BY public.rate_auto_create.id;


--
-- Name: rate_auto_create_interval; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_auto_create_interval (
    id integer NOT NULL,
    rate_auto_create_id integer,
    rate_min_time integer,
    rate_interval integer,
    rate_country character varying(256)
);


ALTER TABLE public.rate_auto_create_interval OWNER TO postgres;

--
-- Name: rate_auto_create_interval_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_auto_create_interval_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_auto_create_interval_id_seq OWNER TO postgres;

--
-- Name: rate_auto_create_interval_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_auto_create_interval_id_seq OWNED BY public.rate_auto_create_interval.id;


--
-- Name: rate_auto_create_profit; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_auto_create_profit (
    id integer NOT NULL,
    rate_auto_create_id integer,
    profit_type integer,
    profit_amount real,
    min_rate real,
    max_rate real,
    rate_type integer,
    is_default boolean DEFAULT false NOT NULL
);


ALTER TABLE public.rate_auto_create_profit OWNER TO postgres;

--
-- Name: COLUMN rate_auto_create_profit.profit_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_auto_create_profit.profit_type IS '0-percent
1-amout';


--
-- Name: COLUMN rate_auto_create_profit.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_auto_create_profit.rate_type IS '0 : percenage
1  :  fixed profit ç›´æŽ¥ç›¸åŠ ';


--
-- Name: rate_auto_create_profit_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_auto_create_profit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_auto_create_profit_id_seq OWNER TO postgres;

--
-- Name: rate_auto_create_profit_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_auto_create_profit_id_seq OWNED BY public.rate_auto_create_profit.id;


--
-- Name: rate_auto_diff; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_auto_diff (
    id integer NOT NULL,
    source_file character varying(100),
    diff_file character varying(100),
    result_file character varying(100),
    effective_date timestamp with time zone,
    decrease_days integer,
    increase_days integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    end_time timestamp with time zone,
    status integer DEFAULT 0,
    client_id integer
);


ALTER TABLE public.rate_auto_diff OWNER TO postgres;

--
-- Name: COLUMN rate_auto_diff.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_auto_diff.status IS '0-waiting
1-running
2-done
-1-open file error
-2-csv file error';


--
-- Name: rate_auto_diff_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_auto_diff_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_auto_diff_id_seq OWNER TO postgres;

--
-- Name: rate_auto_diff_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_auto_diff_id_seq OWNED BY public.rate_auto_diff.id;


--
-- Name: rate_bot_import_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_bot_import_logs (
    id integer NOT NULL,
    status integer DEFAULT 0,
    email_subject character varying(100),
    email_from character varying(100),
    email_time character varying(100),
    start_time timestamp with time zone DEFAULT now(),
    finish_time timestamp with time zone,
    rule_name character varying(100),
    error_msg character varying(200),
    mail_vendor character varying(128)
);


ALTER TABLE public.rate_bot_import_logs OWNER TO postgres;

--
-- Name: rate_bot_import_logs_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_bot_import_logs_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_bot_import_logs_seq OWNER TO postgres;

--
-- Name: rate_bot_import_logs_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_bot_import_logs_seq OWNED BY public.rate_bot_import_logs.id;


--
-- Name: rate_download_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_download_log (
    id integer NOT NULL,
    resource_id integer,
    file_path character varying,
    download_time timestamp with time zone,
    download_ip character varying,
    log_detail_id integer
);


ALTER TABLE public.rate_download_log OWNER TO postgres;

--
-- Name: rate_download_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_download_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_download_log_id_seq OWNER TO postgres;

--
-- Name: rate_download_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_download_log_id_seq OWNED BY public.rate_download_log.id;


--
-- Name: rate_email_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_email_template (
    id integer NOT NULL,
    email_cc character varying(200),
    subject text,
    content text,
    email_from character varying(20),
    name character varying(50),
    headers character varying(500),
    download_method integer
);


ALTER TABLE public.rate_email_template OWNER TO postgres;

--
-- Name: COLUMN rate_email_template.download_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_email_template.download_method IS '1:Send as attachment;2:Send as link';


--
-- Name: rate_email_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_email_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_email_template_id_seq OWNER TO postgres;

--
-- Name: rate_email_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_email_template_id_seq OWNED BY public.rate_email_template.id;


--
-- Name: rate_generate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_generate (
    id integer NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    rate_type integer NOT NULL,
    max_selected integer NOT NULL,
    result_file character varying(256),
    client_id integer,
    rate_deck_file character varying(100),
    status integer DEFAULT 0 NOT NULL,
    finish_time timestamp with time zone,
    rate_deck_csv_heads character varying,
    rate_deck_csv_line integer,
    active integer DEFAULT 1 NOT NULL,
    analysis_file character varying
);


ALTER TABLE public.rate_generate OWNER TO postgres;

--
-- Name: COLUMN rate_generate.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_generate.status IS '0-waiting
1-processing
2-complete
-1-open file error
-2-csv file head error';


--
-- Name: rate_generate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_generate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_generate_id_seq OWNER TO postgres;

--
-- Name: rate_generate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_generate_id_seq OWNED BY public.rate_generate.id;


--
-- Name: rate_generation_code_deck; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_generation_code_deck (
    rate_generation_template_id integer,
    code character varying(30),
    code_name character varying(100),
    country character varying(100)
);


ALTER TABLE public.rate_generation_code_deck OWNER TO postgres;

--
-- Name: rate_generation_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_generation_history (
    id integer NOT NULL,
    is_applied boolean DEFAULT false,
    rate_generation_template_id integer,
    status smallint DEFAULT 0 NOT NULL,
    finished_time timestamp with time zone,
    rate_count integer DEFAULT 0 NOT NULL,
    processing_time integer DEFAULT 0 NOT NULL,
    progress character varying(200),
    create_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    create_by character varying(100),
    rate_table_type integer
);


ALTER TABLE public.rate_generation_history OWNER TO postgres;

--
-- Name: COLUMN rate_generation_history.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_generation_history.status IS '0 for initial; 1 for in process, 2 for finished; 3 for error';


--
-- Name: rate_generation_history_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_generation_history_detail (
    id integer NOT NULL,
    rate_table_id integer,
    effective_date_new timestamp with time zone,
    effective_date_increase timestamp with time zone,
    effective_date_decrease timestamp with time zone,
    is_send_mail boolean,
    end_date date,
    email_template_id integer,
    rate_generation_history_id integer,
    create_on timestamp with time zone,
    create_by character varying(100),
    finished_time timestamp with time zone,
    end_date_method integer DEFAULT 1,
    rand_flg character varying(100),
    new_rate_end_date date
);


ALTER TABLE public.rate_generation_history_detail OWNER TO postgres;

--
-- Name: COLUMN rate_generation_history_detail.end_date_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_generation_history_detail.end_date_method IS '1   => ''Duplicated Codes Only'',
2   =>  ''Code with Rate Changed Only'',
3   =>  ''All Codes''';


--
-- Name: rate_generation_history_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_generation_history_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_generation_history_detail_id_seq OWNER TO postgres;

--
-- Name: rate_generation_history_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_generation_history_detail_id_seq OWNED BY public.rate_generation_history_detail.id;


--
-- Name: rate_generation_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_generation_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_generation_history_id_seq OWNER TO postgres;

--
-- Name: rate_generation_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_generation_history_id_seq OWNED BY public.rate_generation_history.id;


--
-- Name: rate_generation_rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_generation_rate (
    rate_generation_history_id integer NOT NULL,
    code public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    rate numeric(30,10),
    setup_fee numeric(30,10) DEFAULT 0 NOT NULL,
    effective_date timestamp with time zone,
    end_date timestamp with time zone,
    min_time integer DEFAULT 0 NOT NULL,
    grace_time integer DEFAULT 0 NOT NULL,
    "interval" integer DEFAULT 1 NOT NULL,
    time_profile_id integer,
    seconds integer DEFAULT 60 NOT NULL,
    code_name character varying(100),
    rate_type integer DEFAULT 3 NOT NULL,
    intra_rate numeric(30,10),
    inter_rate numeric(30,10),
    local_rate numeric(30,10),
    country character varying(1000),
    zone character varying(10) DEFAULT 0,
    ocn character varying(10),
    lata character varying(10),
    generation_rate_id integer NOT NULL,
    lcr_rate character varying(100),
    lcr_intra_rate character varying(100),
    lcr_inter_rate character varying(100),
    lcr_local_rate character varying(100)
);


ALTER TABLE public.rate_generation_rate OWNER TO postgres;

--
-- Name: rate_generation_rate_generation_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_generation_rate_generation_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_generation_rate_generation_rate_id_seq OWNER TO postgres;

--
-- Name: rate_generation_rate_generation_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_generation_rate_generation_rate_id_seq OWNED BY public.rate_generation_rate.generation_rate_id;


--
-- Name: rate_generation_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_generation_template (
    id integer NOT NULL,
    name character varying(50),
    include_blocked_route boolean DEFAULT false,
    rate_table_type integer DEFAULT 1 NOT NULL,
    lcr_digit integer,
    default_rate numeric(30,10),
    margin_default_type integer,
    margin_default_value character varying(30),
    default_interval integer,
    default_min_time integer,
    create_by character varying(100),
    create_on timestamp with time zone,
    last_generated timestamp with time zone,
    code_deck_id integer,
    egress_str character varying(500),
    include_local_rate boolean DEFAULT false,
    effective_days integer DEFAULT 0,
    decimal_places integer DEFAULT 0,
    user_defined_code_deck boolean DEFAULT false
);


ALTER TABLE public.rate_generation_template OWNER TO postgres;

--
-- Name: COLUMN rate_generation_template.rate_table_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_generation_template.rate_table_type IS '0 for A-Z; 1 for US Jurisdictional; 2 for US Non Jurisdictional, 3 for OCN-LATA, 4 for IJ - Inter, 5 for IJ - Intra, 6 for IJ - Max(Inter,Intra), 7 for IJ - True Math';


--
-- Name: COLUMN rate_generation_template.lcr_digit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_generation_template.lcr_digit IS 'Which LCR selection';


--
-- Name: COLUMN rate_generation_template.default_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_generation_template.default_rate IS 'Default rate if no egress is available';


--
-- Name: COLUMN rate_generation_template.margin_default_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_generation_template.margin_default_type IS '1 for Percentage; 2 for Fix Value';


--
-- Name: COLUMN rate_generation_template.egress_str; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_generation_template.egress_str IS 'Egress trunk list, format: trunk_1_id,trunk_1_rate_table_id;trunk_2_id,trunk_2_rate_table_id;...';


--
-- Name: COLUMN rate_generation_template.decimal_places; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_generation_template.decimal_places IS '0 for use system default, other is rate decimal places';


--
-- Name: rate_generation_template_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_generation_template_detail (
    id integer NOT NULL,
    rate_generation_template_id integer,
    rate_interval integer,
    min_time integer,
    code character varying(50)
);


ALTER TABLE public.rate_generation_template_detail OWNER TO postgres;

--
-- Name: rate_generation_template_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_generation_template_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_generation_template_detail_id_seq OWNER TO postgres;

--
-- Name: rate_generation_template_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_generation_template_detail_id_seq OWNED BY public.rate_generation_template_detail.id;


--
-- Name: rate_generation_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_generation_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_generation_template_id_seq OWNER TO postgres;

--
-- Name: rate_generation_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_generation_template_id_seq OWNED BY public.rate_generation_template.id;


--
-- Name: rate_generation_template_margin; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_generation_template_margin (
    id integer NOT NULL,
    rate_generation_template_id integer,
    min_rate numeric(30,10),
    max_rate numeric(30,10),
    markup_type integer,
    markup_value numeric(30,10)
);


ALTER TABLE public.rate_generation_template_margin OWNER TO postgres;

--
-- Name: COLUMN rate_generation_template_margin.markup_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_generation_template_margin.markup_type IS '1 for Percentage; 2 for Fix Value';


--
-- Name: rate_generation_template_margin_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_generation_template_margin_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_generation_template_margin_id_seq OWNER TO postgres;

--
-- Name: rate_generation_template_margin_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_generation_template_margin_id_seq OWNED BY public.rate_generation_template_margin.id;


--
-- Name: rate_handler; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_handler (
    id integer NOT NULL,
    rate_delivery_to character varying(255) NOT NULL,
    mail_password character varying(255),
    imap_host character varying(255),
    imap_port integer,
    mail_ssl smallint DEFAULT 0,
    smtp_port integer,
    mail_tls smallint DEFAULT 0,
    smtp_host character varying(255)
);


ALTER TABLE public.rate_handler OWNER TO postgres;

--
-- Name: rate_handler_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_handler_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_handler_id_seq OWNER TO postgres;

--
-- Name: rate_handler_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_handler_id_seq OWNED BY public.rate_handler.id;


--
-- Name: rate_import_error_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_import_error_log (
    id integer NOT NULL,
    import_log_id integer,
    error_line integer,
    rate numeric(30,10),
    effective_date timestamp with time zone,
    error_info character varying(500)
);


ALTER TABLE public.rate_import_error_log OWNER TO postgres;

--
-- Name: rate_import_error_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_import_error_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_import_error_log_id_seq OWNER TO postgres;

--
-- Name: rate_import_error_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_import_error_log_id_seq OWNED BY public.rate_import_error_log.id;


--
-- Name: rate_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_info (
    "time" character varying(100),
    asr character varying(100),
    asr_count character varying(100),
    acd character varying(100),
    acd_count character varying(100),
    code character varying(100),
    rate_table_id character varying(100),
    call_count character varying(100)
);


ALTER TABLE public.rate_info OWNER TO postgres;

--
-- Name: rate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_log (
    user_id integer NOT NULL,
    old_rateinfo character varying(500),
    "time" timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    rate_id integer,
    rate numeric(30,10),
    setup_fee numeric(30,10),
    effective_date timestamp without time zone,
    end_date timestamp without time zone
);


ALTER TABLE public.rate_log OWNER TO postgres;

--
-- Name: rate_mail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_mail (
    id integer NOT NULL,
    from_address character varying(100) NOT NULL,
    from_name character varying(100) NOT NULL,
    subject character varying(100) NOT NULL,
    content text NOT NULL,
    mail_password character varying(100),
    name character varying
);


ALTER TABLE public.rate_mail OWNER TO postgres;

--
-- Name: rate_mail_decks; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_mail_decks (
    id integer NOT NULL,
    type integer,
    received_time timestamp with time zone,
    client_id integer,
    from_address character varying(255),
    num_of_attachment integer,
    success integer,
    fail integer,
    mail_content text,
    mail_subject character varying(255),
    "to" character varying(255)
);


ALTER TABLE public.rate_mail_decks OWNER TO postgres;

--
-- Name: COLUMN rate_mail_decks.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_mail_decks.type IS '0 --- process&unproccess
1 -- unrecognized';


--
-- Name: rate_mail_decks_files; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_mail_decks_files (
    id integer NOT NULL,
    file_name character varying(255),
    upload_time timestamp with time zone,
    rate_mail_decks_id integer,
    rate_upload_id integer,
    original_filename character varying(255),
    file_type integer DEFAULT 0,
    file_size integer
);


ALTER TABLE public.rate_mail_decks_files OWNER TO postgres;

--
-- Name: COLUMN rate_mail_decks_files.file_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_mail_decks_files.file_type IS '0 - csv
1 - xls';


--
-- Name: rate_mail_decks_files_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_mail_decks_files_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_mail_decks_files_id_seq OWNER TO postgres;

--
-- Name: rate_mail_decks_files_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_mail_decks_files_id_seq OWNED BY public.rate_mail_decks_files.id;


--
-- Name: rate_mail_decks_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_mail_decks_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_mail_decks_id_seq OWNER TO postgres;

--
-- Name: rate_mail_decks_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_mail_decks_id_seq OWNED BY public.rate_mail_decks.id;


--
-- Name: rate_mail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_mail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_mail_id_seq OWNER TO postgres;

--
-- Name: rate_mail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_mail_id_seq OWNED BY public.rate_mail.id;


--
-- Name: rate_management; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_management (
    id integer NOT NULL,
    received_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    from_address character varying(255),
    to_address character varying(255),
    mail_subject character varying,
    mail_content character varying,
    success integer DEFAULT 0,
    failed integer DEFAULT 0
);


ALTER TABLE public.rate_management OWNER TO postgres;

--
-- Name: rate_management_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_management_detail (
    id integer NOT NULL,
    rate_management_id integer,
    status integer DEFAULT 0,
    upload_time timestamp with time zone,
    file_path character varying,
    log_id integer,
    email_when_done integer DEFAULT 0,
    file_type smallint DEFAULT 0,
    orig_file_name character varying,
    server_id integer,
    rate_table_id integer,
    rate_table_name character varying(255),
    rate_handler_id integer
);


ALTER TABLE public.rate_management_detail OWNER TO postgres;

--
-- Name: rate_management_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_management_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_management_detail_id_seq OWNER TO postgres;

--
-- Name: rate_management_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_management_detail_id_seq OWNED BY public.rate_management_detail.id;


--
-- Name: rate_management_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_management_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_management_id_seq OWNER TO postgres;

--
-- Name: rate_management_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_management_id_seq OWNED BY public.rate_management.id;


--
-- Name: rate_management_option; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_management_option (
    id integer NOT NULL,
    rate_table_id integer,
    email_received_from character varying(100),
    subject_keyword character varying(100),
    filename_keyword character varying(100),
    start_from_line integer,
    headers character varying(200),
    effective_date_default timestamp without time zone,
    end_date_default timestamp without time zone,
    min_time_default integer,
    interval_default integer,
    increase_handle_type integer,
    increase_rule_time integer,
    newcode_handle_type integer,
    newcode_rule_time integer,
    success_notification_to integer,
    failure_notification_to integer,
    effective_date_format character varying(50),
    dup_method integer,
    dup_end_date timestamp without time zone,
    dup_end_date_tz character(5),
    dup_end_date_all timestamp without time zone,
    dup_end_date_all_tz character(5),
    with_header boolean DEFAULT false,
    code_name_match integer
);


ALTER TABLE public.rate_management_option OWNER TO postgres;

--
-- Name: COLUMN rate_management_option.increase_handle_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.increase_handle_type IS '1:Reject Specific Rate Record
2:Entire Rate Notice';


--
-- Name: COLUMN rate_management_option.increase_rule_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.increase_rule_time IS 'days';


--
-- Name: COLUMN rate_management_option.newcode_handle_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.newcode_handle_type IS '1:Reject Specific Rate Record
2:Entire Rate Notice';


--
-- Name: COLUMN rate_management_option.newcode_rule_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.newcode_rule_time IS 'days';


--
-- Name: COLUMN rate_management_option.success_notification_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.success_notification_to IS '1:Vendor
2:Owner Email
3:both';


--
-- Name: COLUMN rate_management_option.failure_notification_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.failure_notification_to IS '1:Vendor
2:Owner Email
3:both';


--
-- Name: COLUMN rate_management_option.effective_date_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.effective_date_format IS '''mm/dd/yyyy'',
''yyyy-mm-dd'',
''mm/dd/yyyy'',
''dd/mm/yyyy'',
''yyyy/mm/dd''';


--
-- Name: COLUMN rate_management_option.dup_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.dup_method IS '1:Delete Existing Records
2:End-Date Existing Records
0:End-Date All Records';


--
-- Name: COLUMN rate_management_option.dup_end_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.dup_end_date IS 'when dup_method =2(End-Date Existing Records)';


--
-- Name: COLUMN rate_management_option.dup_end_date_tz; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.dup_end_date_tz IS 'when dup_method =2(End-Date Existing Records)';


--
-- Name: COLUMN rate_management_option.dup_end_date_all; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.dup_end_date_all IS 'when dup_method =0(End-Date All Records)';


--
-- Name: COLUMN rate_management_option.dup_end_date_all_tz; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.dup_end_date_all_tz IS 'when dup_method =0(End-Date All Records)';


--
-- Name: COLUMN rate_management_option.code_name_match; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_management_option.code_name_match IS '1:Re-populate Country and Code Name with Selected Code Deck
2:Re-populate Country and Code Name with Selected Code Deck if not available';


--
-- Name: rate_management_option_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_management_option_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_management_option_id_seq OWNER TO postgres;

--
-- Name: rate_management_option_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_management_option_id_seq OWNED BY public.rate_management_option.id;


--
-- Name: rate_mass_edit_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_mass_edit_log (
    id integer NOT NULL,
    action_time timestamp with time zone,
    client_id integer,
    action_type smallint,
    down_file_path text,
    rate_table_id integer,
    action_rate_rows integer
);


ALTER TABLE public.rate_mass_edit_log OWNER TO postgres;

--
-- Name: COLUMN rate_mass_edit_log.action_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_mass_edit_log.action_type IS '0 => ''delete found rates'',
1 => ''insert as new rates'',
2 => ''update current rates'',
3 => ''update all rates'',';


--
-- Name: rate_mass_edit_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_mass_edit_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_mass_edit_log_id_seq OWNER TO postgres;

--
-- Name: rate_mass_edit_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_mass_edit_log_id_seq OWNED BY public.rate_mass_edit_log.id;


--
-- Name: rate_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_record_record_id_seq OWNER TO postgres;

--
-- Name: rate_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_record (
    rate_id integer,
    rate_table_id integer,
    code public.prefix_range,
    rate numeric(30,10),
    setup_fee numeric(30,10),
    effective_date timestamp with time zone,
    end_date timestamp with time zone,
    min_time integer,
    grace_time integer,
    "interval" integer,
    time_profile_id integer,
    seconds integer,
    code_name character varying(100),
    basic_percentages real,
    gift_percentages real,
    rate_type integer,
    intra_rate numeric(30,10),
    inter_rate numeric(30,10),
    local_rate numeric(30,10),
    country character varying(1000),
    zone character varying(10),
    ocn character varying(10),
    lata character varying(10),
    create_time timestamp with time zone,
    did_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.rate_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.rate_record OWNER TO postgres;

--
-- Name: rate_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: rate_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_record_tmp (
    rate_id integer,
    rate_table_id integer,
    code public.prefix_range,
    rate numeric(30,10),
    setup_fee numeric(30,10),
    effective_date timestamp with time zone,
    end_date timestamp with time zone,
    min_time integer,
    grace_time integer,
    "interval" integer,
    time_profile_id integer,
    seconds integer,
    code_name character varying(100),
    basic_percentages real,
    gift_percentages real,
    rate_type integer,
    intra_rate numeric(30,10),
    inter_rate numeric(30,10),
    local_rate numeric(30,10),
    country character varying(1000),
    zone character varying(10),
    ocn character varying(10),
    lata character varying(10),
    create_time timestamp with time zone,
    did_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.rate_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.rate_record_tmp OWNER TO postgres;

--
-- Name: rate_send_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_send_log (
    rate_table_id integer NOT NULL,
    status smallint NOT NULL,
    zip smallint,
    file character varying(500),
    error character varying(500),
    format smallint NOT NULL,
    id integer NOT NULL,
    email_template_id integer NOT NULL,
    create_time timestamp with time zone,
    effective_date character varying(50),
    start_effective_date character varying(50),
    download_deadline date,
    is_email_alert boolean DEFAULT false NOT NULL,
    is_disable boolean DEFAULT false NOT NULL,
    is_temp boolean DEFAULT false,
    headers character varying(500),
    send_type integer DEFAULT 0,
    send_specify_email character varying,
    resource_ids character varying(500),
    download_method integer DEFAULT 1,
    total_records integer,
    completed_records integer,
    sent_area integer DEFAULT 1
);


ALTER TABLE public.rate_send_log OWNER TO postgres;

--
-- Name: COLUMN rate_send_log.rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_send_log.rate_table_id IS 'å‘é€è´¹çŽ‡çš„ rate table id ';


--
-- Name: COLUMN rate_send_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_send_log.status IS '1:æ­£åœ¨æ‰§è¡Œ
2:å‘é€æˆåŠŸ
3:å‘é€å¤±è´¥';


--
-- Name: COLUMN rate_send_log.zip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_send_log.zip IS '1ï¼šæ‰“åŒ…
2ï¼šæ²¡æœ‰æ‰“åŒ…';


--
-- Name: COLUMN rate_send_log.file; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_send_log.file IS 'å‘é€çš„rateæ–‡ä»¶';


--
-- Name: COLUMN rate_send_log.error; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_send_log.error IS 'é”™è¯¯çš„æç¤º';


--
-- Name: COLUMN rate_send_log.format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_send_log.format IS '1:csv
2:xls';


--
-- Name: COLUMN rate_send_log.effective_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_send_log.effective_date IS 'å‘å‡ºåŽ»è´¹çŽ‡çš„ç”Ÿæ•ˆæ—¥æœŸèŒƒå›´';


--
-- Name: COLUMN rate_send_log.download_deadline; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_send_log.download_deadline IS 'ä¸‹è½½æˆªè‡³æ—¥æœŸ';


--
-- Name: rate_send_log_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_send_log_detail (
    id integer NOT NULL,
    log_id integer,
    resource_id integer,
    send_to character varying(100),
    status integer,
    error text,
    salt character varying,
    download_date date,
    sent_on timestamp with time zone
);


ALTER TABLE public.rate_send_log_detail OWNER TO postgres;

--
-- Name: rate_send_log_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_send_log_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_send_log_detail_id_seq OWNER TO postgres;

--
-- Name: rate_send_log_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_send_log_detail_id_seq OWNED BY public.rate_send_log_detail.id;


--
-- Name: rate_send_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_send_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_send_log_id_seq OWNER TO postgres;

--
-- Name: rate_send_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_send_log_id_seq OWNED BY public.rate_send_log.id;


--
-- Name: rate_send_logging; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_send_logging (
    id integer NOT NULL,
    log_datetime timestamp with time zone,
    data text,
    file character varying(500),
    status integer
);


ALTER TABLE public.rate_send_logging OWNER TO postgres;

--
-- Name: COLUMN rate_send_logging.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_send_logging.status IS '0 - succeed
1- db error
2- smtp error
3- other error';


--
-- Name: rate_send_logging_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_send_logging_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_send_logging_id_seq OWNER TO postgres;

--
-- Name: rate_send_logging_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_send_logging_id_seq OWNED BY public.rate_send_logging.id;


--
-- Name: rate_send_rules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_send_rules (
    from_email text,
    subject_keyword text,
    mail_server_ip character varying,
    file_type smallint DEFAULT 0,
    start_from_row smallint DEFAULT 0,
    effect_rate_keyword character varying,
    rate_col smallint,
    code_col smallint,
    code_name_col smallint,
    country_code text,
    effective_date_col smallint,
    end_date_col smallint,
    inter_rate_col smallint,
    intra_rate_col smallint,
    local_rate_col smallint,
    rate_status_col smallint,
    id integer NOT NULL,
    resource_id integer DEFAULT 0 NOT NULL,
    date_pattern character varying,
    violation_action smallint DEFAULT 0,
    min_lead_time smallint DEFAULT 7,
    special_rule_case character varying,
    special boolean DEFAULT false,
    rule_name character varying,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    min_time integer DEFAULT 1,
    "interval" integer DEFAULT 1,
    country_col smallint,
    multiple_codes boolean DEFAULT false,
    code_delimiter character varying,
    min_lead_time_del_code integer,
    min_lead_time_new_code integer,
    min_lead_time_inc_rate integer,
    active boolean,
    read_effective_rate_from_subject smallint DEFAULT 0,
    blocked boolean DEFAULT false
);


ALTER TABLE public.rate_send_rules OWNER TO postgres;

--
-- Name: COLUMN rate_send_rules.file_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_send_rules.file_type IS '0: xls, 1: xlsx,2: csv';


--
-- Name: rate_send_rules_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_send_rules_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_send_rules_id_seq OWNER TO postgres;

--
-- Name: rate_send_rules_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_send_rules_id_seq OWNED BY public.rate_send_rules.id;


--
-- Name: rate_table_rate_table_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_table_rate_table_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE public.rate_table_rate_table_id_seq OWNER TO postgres;

--
-- Name: rate_table; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_table (
    rate_table_id integer DEFAULT nextval('public.rate_table_rate_table_id_seq'::regclass) NOT NULL,
    name character varying(100) NOT NULL,
    modify_time timestamp with time zone,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    code_deck_id integer,
    currency_id integer NOT NULL,
    rate_type integer DEFAULT 0,
    jurisdiction_country_id integer,
    update_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    update_by character varying,
    lnp_dipping_rate real,
    jurisdiction_prefix public.prefix_range,
    noprefix_min_length integer,
    noprefix_max_length integer,
    prefix_min_length integer,
    prefix_max_length integer,
    jur_type smallint DEFAULT 0,
    origination boolean DEFAULT false,
    is_virtual boolean,
    define_by integer DEFAULT 0
);


ALTER TABLE public.rate_table OWNER TO postgres;

--
-- Name: TABLE rate_table; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.rate_table IS 'è´¹çŽ‡æ¨¡æ¿';


--
-- Name: COLUMN rate_table.rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table.rate_table_id IS 'ä¸»é”®';


--
-- Name: COLUMN rate_table.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table.name IS 'åç§°';


--
-- Name: COLUMN rate_table.modify_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table.modify_time IS 'ä¸Šæ¬¡ä¿®æ”¹æ—¶é—´';


--
-- Name: COLUMN rate_table.create_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table.create_time IS 'ç”Ÿæˆæ—¶é—´';


--
-- Name: COLUMN rate_table.code_deck_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table.code_deck_id IS 'å‰ç¼€å·ç ç»„';


--
-- Name: COLUMN rate_table.currency_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table.currency_id IS 'è´§å¸';


--
-- Name: COLUMN rate_table.rate_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table.rate_type IS '0-dnis
1-lrn
2-lrn block';


--
-- Name: COLUMN rate_table.jurisdiction_country_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table.jurisdiction_country_id IS 'è®¡è´¹åŒºåŸŸå›½å®¶ï¼Œæœ‰å€¼è¡¨ç¤ºè´¹çŽ‡æ˜¯æŒ‰ç…§intra/interæ¥è®¡ç®—ï¼Œæ²¡æœ‰å€¼è¡¨ç¤ºdnisè®¡è´¹ã€‚';


--
-- Name: rate_table_code_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_table_code_ref (
    "time" bigint,
    rate_table_id integer,
    code character varying(100),
    rate numeric,
    code_name character varying(100)
);


ALTER TABLE public.rate_table_code_ref OWNER TO postgres;

--
-- Name: TABLE rate_table_code_ref; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.rate_table_code_ref IS 'exchangeä½¿ç”¨ï¼Œrate tableå’Œcodeï¼Œrateå¯¹åº”è¡¨';


--
-- Name: COLUMN rate_table_code_ref."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table_code_ref."time" IS 'è®°å½•äº§ç”Ÿæ—¶é—´';


--
-- Name: COLUMN rate_table_code_ref.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table_code_ref.code IS 'å¯¹åº”è´¹çŽ‡è¡¨é‡Œçš„codeï¼Œè€Œä¸æ˜¯code_decké‡Œçš„code';


--
-- Name: COLUMN rate_table_code_ref.rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_table_code_ref.rate IS 'codeçš„è´¹çŽ‡';


--
-- Name: rate_table_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_table_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_table_record_record_id_seq OWNER TO postgres;

--
-- Name: rate_table_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_table_record (
    rate_table_id integer,
    name character varying(100),
    modify_time timestamp with time zone,
    create_time timestamp with time zone,
    code_deck_id integer,
    currency_id integer,
    rate_type integer,
    jurisdiction_country_id integer,
    update_at timestamp with time zone,
    update_by character varying,
    lnp_dipping_rate real,
    jurisdiction_prefix public.prefix_range,
    noprefix_min_length integer,
    noprefix_max_length integer,
    prefix_min_length integer,
    prefix_max_length integer,
    jur_type smallint,
    origination boolean,
    is_virtual boolean,
    define_by integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.rate_table_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.rate_table_record OWNER TO postgres;

--
-- Name: rate_table_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_table_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_table_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: rate_table_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_table_record_tmp (
    rate_table_id integer,
    name character varying(100),
    modify_time timestamp with time zone,
    create_time timestamp with time zone,
    code_deck_id integer,
    currency_id integer,
    rate_type integer,
    jurisdiction_country_id integer,
    update_at timestamp with time zone,
    update_by character varying,
    lnp_dipping_rate real,
    jurisdiction_prefix public.prefix_range,
    noprefix_min_length integer,
    noprefix_max_length integer,
    prefix_min_length integer,
    prefix_max_length integer,
    jur_type smallint,
    origination boolean,
    is_virtual boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.rate_table_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.rate_table_record_tmp OWNER TO postgres;

--
-- Name: rate_upload_fail_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_upload_fail_log (
    id integer NOT NULL,
    file_name character varying(255),
    received_time timestamp with time zone,
    processed_time timestamp with time zone,
    error_cause integer
);


ALTER TABLE public.rate_upload_fail_log OWNER TO postgres;

--
-- Name: rate_upload_fail_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_upload_fail_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_upload_fail_log_id_seq OWNER TO postgres;

--
-- Name: rate_upload_fail_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_upload_fail_log_id_seq OWNED BY public.rate_upload_fail_log.id;


--
-- Name: rate_upload_queue; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_upload_queue (
    id integer NOT NULL,
    cmd text,
    rate_table_id integer,
    status integer DEFAULT 0,
    end_date timestamp with time zone,
    log_id integer,
    is_ocn_lata smallint DEFAULT 0,
    date_format character varying(255),
    rates_file_cmd character varying(500),
    rates_file character varying(500),
    code_name_match character(2)
);


ALTER TABLE public.rate_upload_queue OWNER TO postgres;

--
-- Name: rate_upload_queue_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_upload_queue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_upload_queue_id_seq OWNER TO postgres;

--
-- Name: rate_upload_queue_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_upload_queue_id_seq OWNED BY public.rate_upload_queue.id;


--
-- Name: rate_upload_success_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_upload_success_log (
    id integer NOT NULL,
    file_name character varying(255),
    received_time timestamp with time zone,
    imported_time timestamp with time zone,
    record_loaded integer
);


ALTER TABLE public.rate_upload_success_log OWNER TO postgres;

--
-- Name: rate_upload_success_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_upload_success_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_upload_success_log_id_seq OWNER TO postgres;

--
-- Name: rate_upload_success_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_upload_success_log_id_seq OWNED BY public.rate_upload_success_log.id;


--
-- Name: rate_upload_task; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_upload_task (
    id integer NOT NULL,
    operator_user character varying(40),
    upload_file_path character varying(256),
    upload_orig_file character varying(100),
    upload_format_file character varying(100),
    result_file_path character varying(256),
    rate_table_id integer NOT NULL,
    rate_table_code_deck_id integer,
    rate_date_format character varying(40),
    rate_end_date character varying(40),
    reduplicate_rate_action smallint DEFAULT 0 NOT NULL,
    code_deck_flag smallint DEFAULT 0 NOT NULL,
    use_ocn_lata_code smallint DEFAULT 0 NOT NULL,
    status smallint DEFAULT 0 NOT NULL,
    progress character varying(200),
    expense_detail character varying(100),
    create_time bigint,
    start_time bigint,
    end_time bigint,
    default_info character varying(200),
    all_rate_end_date timestamp with time zone,
    start_from integer DEFAULT 1,
    code_name_match integer
);


ALTER TABLE public.rate_upload_task OWNER TO postgres;

--
-- Name: COLUMN rate_upload_task.rate_date_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_task.rate_date_format IS 'Upload rate date format';


--
-- Name: COLUMN rate_upload_task.rate_end_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_task.rate_end_date IS 'Rate end date, a specified date or NULL(use current time)';


--
-- Name: COLUMN rate_upload_task.reduplicate_rate_action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_task.reduplicate_rate_action IS 'reduplicate rate action: 0 for Ingore, 1 for Delete, 2 for Update';


--
-- Name: COLUMN rate_upload_task.code_deck_flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_task.code_deck_flag IS 'Use system code deck, 0 for use rate code, 1 for use system global code deck';


--
-- Name: COLUMN rate_upload_task.use_ocn_lata_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_task.use_ocn_lata_code IS 'Use OCN code deck, 0 for No, 1 for Yes';


--
-- Name: COLUMN rate_upload_task.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_task.status IS '0 for initial; 1 for download rate; 2 for process rate, 3 for commit rate to db; 4 for finished; 5 for error';


--
-- Name: COLUMN rate_upload_task.expense_detail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_task.expense_detail IS 'Detailed processing time: download, process, delete, update, copy action elapsed time';


--
-- Name: rate_upload_task_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_upload_task_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_upload_task_id_seq OWNER TO postgres;

--
-- Name: rate_upload_task_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_upload_task_id_seq OWNED BY public.rate_upload_task.id;


--
-- Name: rate_upload_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rate_upload_template (
    id integer NOT NULL,
    dup_method integer,
    end_date timestamp without time zone,
    end_date_gmt character(5) DEFAULT (+ 0),
    end_date_all timestamp without time zone,
    end_date_all_gmt character(5) DEFAULT (+ 0),
    effective_date_format character varying(50),
    has_code_deck boolean,
    code_name_match integer,
    with_header boolean,
    header_fields character varying(200),
    effective_date_default timestamp with time zone,
    min_time_default integer,
    interval_default integer,
    name character varying(100),
    create_by character varying(100),
    update_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    create_on timestamp with time zone,
    rate_increase_days integer,
    new_code_days integer,
    check_effective boolean DEFAULT false,
    reject_rate integer,
    send_error_email_to integer DEFAULT 0,
    append_prefix boolean,
    append_prefix_value character varying(20)
);


ALTER TABLE public.rate_upload_template OWNER TO postgres;

--
-- Name: COLUMN rate_upload_template.dup_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_template.dup_method IS '1 => ''Delete Existing Records''
2 => ''End-Date Existing Records'',
0 => ''End-Date All Records'',';


--
-- Name: COLUMN rate_upload_template.effective_date_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_template.effective_date_format IS '''mm/dd/yyyy'' => ''mm/dd/yyyy'',
''yyyy-mm-dd'' => ''yyyy-mm-dd'',
''dd-mm-yyyy'' => ''dd-mm-yyyy'',
''dd/mm/yyyy'' => ''dd/mm/yyyy'',
''yyyy/mm/dd'' => ''yyyy/mm/dd''';


--
-- Name: COLUMN rate_upload_template.code_name_match; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_template.code_name_match IS '1 => ''Re-populate Country and Code Name with Selected Code Deck'',
2 => ''Re-populate Country and Code Name with Selected Code Deck if not available''';


--
-- Name: COLUMN rate_upload_template.reject_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_template.reject_rate IS '0 no 1 yes';


--
-- Name: COLUMN rate_upload_template.send_error_email_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rate_upload_template.send_error_email_to IS '0 none;1 Carrier Rate Contact;2 Switchâ€™s Rate Contact';


--
-- Name: rate_upload_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rate_upload_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rate_upload_template_id_seq OWNER TO postgres;

--
-- Name: rate_upload_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rate_upload_template_id_seq OWNED BY public.rate_upload_template.id;


--
-- Name: ratemail_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ratemail_history (
    id integer NOT NULL,
    send_date timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    send_to text NOT NULL,
    mail_content text,
    files text,
    client_id integer
);


ALTER TABLE public.ratemail_history OWNER TO postgres;

--
-- Name: ratemail_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ratemail_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ratemail_history_id_seq OWNER TO postgres;

--
-- Name: ratemail_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ratemail_history_id_seq OWNED BY public.ratemail_history.id;


--
-- Name: rawlerg6; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rawlerg6 (
    line character varying
);


ALTER TABLE public.rawlerg6 OWNER TO postgres;

--
-- Name: real_cdr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.real_cdr (
    real_cdr_id integer NOT NULL,
    uuid_a character varying(100),
    uuid_b character varying(100),
    ans_time_a character varying(100),
    ans_time_b character varying(100),
    ani character varying(100),
    dnis character varying(100),
    call_type character varying(100),
    egress_id character varying(100),
    client_id character varying(100),
    codec_id character varying(100),
    ingress_id character varying(100),
    caller_ip_address character varying(100),
    callee_ip_address character varying(100),
    callee_ani character varying(100),
    callee_dnis character varying(100),
    caller_media_port character varying(100),
    caller_media_ip character varying(100),
    callee_media_port character varying(100),
    callee_media_ip character varying(100),
    server_orig_port character varying(100),
    server_term_port character varying(100),
    orig_caller_packets character varying(100),
    orig_caller_bytes character varying(100),
    orig_callee_packets character varying(100),
    orig_callee_bytes character varying(100),
    term_caller_packets character varying(100),
    term_caller_bytes character varying(100),
    term_callee_packets character varying(100),
    term_callee_bytes character varying(100),
    ingress_codec character varying(100),
    egress_codec character varying(100),
    server_ip character varying(100),
    ani_code_id integer,
    dnis_code_id integer,
    signaling_server_ip character varying(100),
    signaling_server_port character varying(100),
    media_server_ip character varying(100),
    media_server_port character varying(100),
    application_server_ip character varying(100),
    application_server_port character varying(100),
    a_seconds character varying(100),
    a_interval character varying(100),
    a_min_time character varying(100),
    a_grace_time character varying(100),
    a_rate character varying(100),
    a_setup_fee character varying(100),
    b_seconds character varying(100),
    b_interval character varying(100),
    b_min_time character varying(100),
    b_grace_time character varying(100),
    b_rate character varying(100),
    b_setup_fee character varying(100),
    orig_code character varying(100),
    orig_code_name character varying(100),
    orig_country character varying(100),
    term_code character varying(100),
    term_code_name character varying(100),
    term_country character varying(100),
    ingress_currency_id character varying(10),
    egress_currency_id character varying(10)
);


ALTER TABLE public.real_cdr OWNER TO postgres;

--
-- Name: COLUMN real_cdr.server_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.real_cdr.server_ip IS 'æœåŠ¡å™¨ip';


--
-- Name: real_cdr_real_cdr_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.real_cdr_real_cdr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.real_cdr_real_cdr_id_seq OWNER TO postgres;

--
-- Name: real_cdr_real_cdr_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.real_cdr_real_cdr_id_seq OWNED BY public.real_cdr.real_cdr_id;


--
-- Name: redirect_carrier; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.redirect_carrier (
    id integer NOT NULL,
    ip public.ip4,
    active integer DEFAULT 1 NOT NULL,
    max_cps integer,
    type integer
);


ALTER TABLE public.redirect_carrier OWNER TO postgres;

--
-- Name: TABLE redirect_carrier; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.redirect_carrier IS 'è¢«dnl_redirect_serverç¨‹åºæ‰€ä½¿ç”¨';


--
-- Name: COLUMN redirect_carrier.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.redirect_carrier.id IS 'é€’å¢žçš„åºåˆ—å·';


--
-- Name: COLUMN redirect_carrier.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.redirect_carrier.ip IS 'å‘¼å…¥å®¢æˆ·ipï¼Œæ ¹æ®æ­¤ipå†³å®šè¦ä¸è¦æŽ¥å—å¤„ç†æ­¤INVITEã€‚';


--
-- Name: COLUMN redirect_carrier.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.redirect_carrier.active IS 'å¼€å…³ï¼Œ 0 â€”â€” falseå…³é—­ï¼Œ 1 â€”â€” trueæ‰“å¼€ï¼Œå…³é—­çŠ¶æ€ä¸‹æ‹’ç»æ­¤ipæ¥çš„INVITE';


--
-- Name: COLUMN redirect_carrier.max_cps; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.redirect_carrier.max_cps IS 'æ²¡ç§’é’Ÿå¤„ç†å‘¼å«æ•°ï¼Œè¶…è¿‡æ­¤é™åˆ¶ï¼Œåˆ™æ‹’ç»æ­¤ipæ¥çš„å‘¼å«ã€‚';


--
-- Name: COLUMN redirect_carrier.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.redirect_carrier.type IS 'åˆ¤æ–­å·ç çš„ç±»åž‹ï¼Œ0 â€”â€” è¢«å«å·ï¼Œ 1 â€”â€” ä¸»å«å·ï¼ŒæŸ¥è¯¢å‰ç¼€codeçš„æ—¶å€™ç”¨ã€‚';


--
-- Name: redirect_carrier_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.redirect_carrier_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.redirect_carrier_id_seq OWNER TO postgres;

--
-- Name: redirect_carrier_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.redirect_carrier_id_seq OWNED BY public.redirect_carrier.id;


--
-- Name: redirect_host; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.redirect_host (
    id integer NOT NULL,
    ip public.ip4,
    port integer,
    code public.prefix_range
);


ALTER TABLE public.redirect_host OWNER TO postgres;

--
-- Name: TABLE redirect_host; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.redirect_host IS 'è¢«dnl_redirect_serverç¨‹åºæ‰€ä½¿ç”¨';


--
-- Name: COLUMN redirect_host.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.redirect_host.id IS 'é€’å¢žçš„åºåˆ—';


--
-- Name: COLUMN redirect_host.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.redirect_host.ip IS 'æ ¹ç»å‰ç¼€codeé‡å®šå‘çš„æœåŠ¡å™¨ip';


--
-- Name: COLUMN redirect_host.port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.redirect_host.port IS 'æ ¹ç»å‰ç¼€codeé‡å®šå‘çš„æœåŠ¡å™¨ç«¯å£';


--
-- Name: COLUMN redirect_host.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.redirect_host.code IS 'æ ¹æ®æ¬¡å‰ç¼€é‡å®šå‘å‘¼å«åˆ°ipæŒ‡å®šçš„æœåŠ¡å™¨ä¸Šã€‚';


--
-- Name: redirect_host_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.redirect_host_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.redirect_host_id_seq OWNER TO postgres;

--
-- Name: redirect_host_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.redirect_host_id_seq OWNED BY public.redirect_host.id;


--
-- Name: register_of_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.register_of_record (
    id integer NOT NULL,
    "time" bigint,
    state smallint,
    username character varying(100),
    direction integer,
    ip public.ip4,
    port integer,
    expires_time bigint
);


ALTER TABLE public.register_of_record OWNER TO postgres;

--
-- Name: TABLE register_of_record; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.register_of_record IS 'æ³¨å†Œä¿¡æ¯è¡¨';


--
-- Name: COLUMN register_of_record."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.register_of_record."time" IS 'äº§ç”Ÿè®°å½•æ—¶é—´ï¼Œç§’å•ä½ï¼Œé•¿æ•´åž‹æ—¶é—´ã€‚';


--
-- Name: COLUMN register_of_record.state; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.register_of_record.state IS 'æ³¨å†ŒçŠ¶æ€ï¼Œ0 æœªæ³¨å†Œï¼Œ1 å·²æ³¨å†Œ';


--
-- Name: COLUMN register_of_record.username; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.register_of_record.username IS 'æ³¨å†Œç”¨æˆ·åï¼Œingressé‡Œå”¯ä¸€ï¼Œå¯ä»¥è·Ÿegressé‡å¤';


--
-- Name: COLUMN register_of_record.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.register_of_record.direction IS '0 ingress 1 egress';


--
-- Name: COLUMN register_of_record.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.register_of_record.ip IS 'å¯¹ä¸»å«ï¼šæ˜¯æ³¨å†Œè¿‡æ¥çš„IP
å¯¹è¢«å«ï¼šæ˜¯æ³¨å†Œç›®æ ‡æœåŠ¡å™¨IP';


--
-- Name: COLUMN register_of_record.port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.register_of_record.port IS 'å¯¹ä¸»å«ï¼šæ˜¯æ³¨å†Œè¿‡æ¥çš„ç«¯å£
å¯¹è¢«å«ï¼šæ˜¯æ³¨å†Œç›®æ ‡æœåŠ¡å™¨ç«¯å£';


--
-- Name: register_of_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.register_of_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.register_of_record_id_seq OWNER TO postgres;

--
-- Name: register_of_record_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.register_of_record_id_seq OWNED BY public.register_of_record.id;


--
-- Name: report_delivery_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.report_delivery_history (
    id integer NOT NULL,
    report_delivery_id integer,
    sent_time timestamp without time zone,
    email_to character(150),
    content character(200)
);


ALTER TABLE public.report_delivery_history OWNER TO postgres;

--
-- Name: COLUMN report_delivery_history.content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.report_delivery_history.content IS 'ä¿å­˜è·¯å¾„åœ°å€';


--
-- Name: rerate_cdr_download_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rerate_cdr_download_log (
    id integer NOT NULL,
    task_id integer,
    create_by character varying(100),
    create_on timestamp with time zone,
    download_file character varying(200),
    finished_time timestamp with time zone,
    status integer DEFAULT 0
);


ALTER TABLE public.rerate_cdr_download_log OWNER TO postgres;

--
-- Name: rerate_cdr_download_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rerate_cdr_download_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rerate_cdr_download_log_id_seq OWNER TO postgres;

--
-- Name: rerate_cdr_download_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rerate_cdr_download_log_id_seq OWNED BY public.rerate_cdr_download_log.id;


--
-- Name: rerate_cdr_task; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rerate_cdr_task (
    id integer NOT NULL,
    from_time bigint,
    to_time bigint,
    timezone integer DEFAULT 0 NOT NULL,
    update_lrn smallint DEFAULT 0 NOT NULL,
    update_us_jurisdiction smallint DEFAULT 0 NOT NULL,
    ingress_trunk character varying(1024),
    egress_trunk character varying(1024),
    lrn_server_ip character varying(16),
    lrn_server_port integer DEFAULT 5060 NOT NULL,
    cdr_file character varying(4096),
    err_code integer DEFAULT 0 NOT NULL,
    include_q850 smallint DEFAULT 0 NOT NULL,
    progress character varying(200),
    status smallint DEFAULT 0 NOT NULL,
    load_cdr_elapsed_sec integer DEFAULT 0 NOT NULL,
    load_rate_elapsed_sec integer DEFAULT 0 NOT NULL,
    rerate_elapsed_sec integer DEFAULT 0 NOT NULL,
    create_time bigint,
    start_time bigint,
    end_time bigint,
    cdr_file_path character varying(100),
    download_file character varying(200),
    client_ids character varying(1024),
    update_local_rate smallint DEFAULT 1 NOT NULL
);


ALTER TABLE public.rerate_cdr_task OWNER TO postgres;

--
-- Name: COLUMN rerate_cdr_task.from_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rerate_cdr_task.from_time IS 'rerate cdr start time';


--
-- Name: COLUMN rerate_cdr_task.to_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rerate_cdr_task.to_time IS 'rerate cdr end time';


--
-- Name: COLUMN rerate_cdr_task.ingress_trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rerate_cdr_task.ingress_trunk IS 'ingress trunk info, format: trunk_id,update_rate,rate_table_id,rate_effective_date;trunk_id_1,...';


--
-- Name: COLUMN rerate_cdr_task.egress_trunk; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rerate_cdr_task.egress_trunk IS 'egress trunk info, format: trunk_id,update_rate,rate_table_id,rate_effective_date;trunk_id_1,...  (update_rate: 0 for No, 1 for Yes; rate_effective_date:a specified date or 0(same as CDR time) )';


--
-- Name: COLUMN rerate_cdr_task.include_q850; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rerate_cdr_task.include_q850 IS 'Rerate CDR MUST include Q.850 column, 0 for none; 1 for include';


--
-- Name: COLUMN rerate_cdr_task.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rerate_cdr_task.status IS '0 for initial; 1 for download cdr; 2 for load rate, 3 for rerate cdr; 4 for finished; 5 for error';


--
-- Name: rerate_cdr_task_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rerate_cdr_task_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rerate_cdr_task_id_seq OWNER TO postgres;

--
-- Name: rerate_cdr_task_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rerate_cdr_task_id_seq OWNED BY public.rerate_cdr_task.id;


--
-- Name: rerate_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rerate_log (
    rerate_log_id integer NOT NULL,
    start_datetime timestamp with time zone,
    end_datetime timestamp with time zone,
    update_lrn integer,
    update_us_jurisdiction integer,
    update_ingress_rate integer,
    ingress_rate integer,
    ingress_rate_effective_date_type integer,
    ingress_rate_effective_date date,
    update_egress_rate integer,
    egress_rate integer,
    egress_rate_effective_date_type integer,
    egress_rate_effective_date integer,
    ingress_trunks character varying(200),
    egress_trunks character varying(200),
    pid integer,
    process_start timestamp without time zone,
    process_end timestamp without time zone,
    status integer
);


ALTER TABLE public.rerate_log OWNER TO postgres;

--
-- Name: rerate_log_rerate_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rerate_log_rerate_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rerate_log_rerate_log_id_seq OWNER TO postgres;

--
-- Name: rerate_log_rerate_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rerate_log_rerate_log_id_seq OWNED BY public.rerate_log.rerate_log_id;


--
-- Name: rerate_report_exec_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.rerate_report_exec_log (
    id integer NOT NULL,
    start_time timestamp with time zone,
    finish_time timestamp with time zone,
    create_by character varying(100),
    status integer,
    exec_type integer,
    task_id integer,
    total_files_count integer,
    success_files_count integer,
    create_on timestamp with time zone
);


ALTER TABLE public.rerate_report_exec_log OWNER TO postgres;

--
-- Name: COLUMN rerate_report_exec_log.exec_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.rerate_report_exec_log.exec_type IS '1:report;2:balance';


--
-- Name: rerate_report_exec_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rerate_report_exec_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rerate_report_exec_log_id_seq OWNER TO postgres;

--
-- Name: rerate_report_exec_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.rerate_report_exec_log_id_seq OWNED BY public.rerate_report_exec_log.id;


--
-- Name: reseller; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.reseller (
    id integer NOT NULL,
    name character varying(255),
    password character varying(32),
    email character varying(255),
    login_id character varying(255)
);


ALTER TABLE public.reseller OWNER TO postgres;

--
-- Name: reseller_client; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.reseller_client (
    id integer NOT NULL,
    login_id character varying(255),
    password character varying(32),
    email character varying(255),
    reseller_id integer,
    client_id integer,
    prefix character varying(255)
);


ALTER TABLE public.reseller_client OWNER TO postgres;

--
-- Name: reseller_client_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.reseller_client_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.reseller_client_id_seq OWNER TO postgres;

--
-- Name: reseller_client_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.reseller_client_id_seq OWNED BY public.reseller_client.id;


--
-- Name: reseller_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.reseller_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.reseller_id_seq OWNER TO postgres;

--
-- Name: reseller_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.reseller_id_seq OWNED BY public.reseller.id;


--
-- Name: resoruce_block_itmes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resoruce_block_itmes (
);


ALTER TABLE public.resoruce_block_itmes OWNER TO postgres;

--
-- Name: TABLE resoruce_block_itmes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resoruce_block_itmes IS 'åªæœ‰ingress trunkæ‰æœ‰æ­¤è¡¨ï¼Œä¸€ä¸ªingresså¯ä»¥è®¾ç½®å¤šä¸ªä¸èƒ½åŽ»çš„egressã€‚';


--
-- Name: resource_auth; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_auth (
    id integer NOT NULL,
    resource_id integer,
    client_id integer
);


ALTER TABLE public.resource_auth OWNER TO postgres;

--
-- Name: TABLE resource_auth; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource_auth IS 'resource æƒé™';


--
-- Name: resource_auth_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_auth_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_auth_id_seq OWNER TO postgres;

--
-- Name: resource_auth_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_auth_id_seq OWNED BY public.resource_auth.id;


--
-- Name: resource_block_res_block_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_block_res_block_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_block_res_block_id_seq OWNER TO postgres;

--
-- Name: resource_block; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_block (
    ingress_res_id integer,
    engress_res_id integer,
    digit public.prefix_range DEFAULT ''::public.prefix_range,
    res_block_id integer DEFAULT nextval('public.resource_block_res_block_id_seq'::regclass) NOT NULL,
    time_profile_id integer,
    ingress_client_id integer,
    egress_client_id integer,
    disable_by_alert boolean DEFAULT false,
    ani_prefix public.prefix_range,
    ani_length integer,
    dnis_length integer,
    ani_method integer,
    dnis_method integer,
    ani_empty boolean DEFAULT false,
    action_type integer DEFAULT 0,
    block_log_id integer,
    loop_block_id integer,
    ticket_log_id integer,
    code_name character varying,
    country character varying,
    create_by character varying,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_by character varying,
    dialer_detection_id integer,
    ani_max_length integer DEFAULT 32,
    dnis_max_length integer DEFAULT 32,
    ingress_group_id integer,
    egress_group_id integer,
    full_match integer DEFAULT 0,
    unblock_at numeric,
    type integer,
    block_at numeric,
    unblock_after numeric
);


ALTER TABLE public.resource_block OWNER TO postgres;

--
-- Name: TABLE resource_block; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource_block IS 'æ‹’ç»å·ç ç®¡ç†';


--
-- Name: COLUMN resource_block.ingress_res_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block.ingress_res_id IS 'æŽ¥å…¥ç½‘å…³';


--
-- Name: COLUMN resource_block.engress_res_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block.engress_res_id IS 'è½åœ°ç½‘å…³';


--
-- Name: COLUMN resource_block.digit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block.digit IS 'åŒ¹é…çš„å‰ç¼€';


--
-- Name: COLUMN resource_block.res_block_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block.res_block_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_block.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block.time_profile_id IS 'æ—¶é—´æ®µ';


--
-- Name: COLUMN resource_block.ani_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block.ani_method IS '0:<
1:=
2:>';


--
-- Name: COLUMN resource_block.dnis_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block.dnis_method IS '0:<
1:=
2:>';


--
-- Name: COLUMN resource_block.action_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block.action_type IS '
0 - manual

1 - automatic';


--
-- Name: COLUMN resource_block.ani_max_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block.ani_max_length IS 'è·Ÿani_prefix, ani_lengthï¼ˆæœ€å°é•¿åº¦ï¼‰ä¸€èµ·ä½¿ç”¨ï¼Œå¼€åˆã€‚';


--
-- Name: COLUMN resource_block.dnis_max_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block.dnis_max_length IS 'è·Ÿdigit, dnis_lengthï¼ˆæœ€å°é•¿åº¦ï¼‰ä¸€èµ·ä½¿ç”¨ï¼Œå¼€åˆã€‚';


--
-- Name: resource_block_group; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_block_group (
    id integer NOT NULL,
    name character varying(100),
    trunk_type smallint DEFAULT 0 NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL
);


ALTER TABLE public.resource_block_group OWNER TO postgres;

--
-- Name: COLUMN resource_block_group.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block_group.trunk_type IS '0 for ingress trunk; 1 for egress trunk';


--
-- Name: resource_block_group_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_block_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_block_group_id_seq OWNER TO postgres;

--
-- Name: resource_block_group_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_block_group_id_seq OWNED BY public.resource_block_group.id;


--
-- Name: resource_block_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_block_items (
    id integer NOT NULL,
    resource_id integer,
    block_resource_id integer,
    active smallint DEFAULT 1
);


ALTER TABLE public.resource_block_items OWNER TO postgres;

--
-- Name: TABLE resource_block_items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource_block_items IS 'åªæœ‰ingressæ—¶æœ‰æ•ˆï¼Œä¸€ä¸ªingresså¯ä»¥è®¾ç½®å¤šä¸ªä¸èƒ½åŽ»çš„egress';


--
-- Name: COLUMN resource_block_items.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block_items.resource_id IS 'ingress id';


--
-- Name: COLUMN resource_block_items.block_resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block_items.block_resource_id IS 'è¢«è¿‡æ»¤çš„resource_idï¼Œä¹Ÿå°±æ˜¯egress_id';


--
-- Name: COLUMN resource_block_items.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_block_items.active IS '0 -- false, 1 -- true';


--
-- Name: resource_block_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_block_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_block_items_id_seq OWNER TO postgres;

--
-- Name: resource_block_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_block_items_id_seq OWNED BY public.resource_block_items.id;


--
-- Name: resource_block_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_block_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_block_items_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_block_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_block_items_record (
    id integer,
    resource_id integer,
    block_resource_id integer,
    active smallint,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_block_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_block_items_record OWNER TO postgres;

--
-- Name: resource_block_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_block_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_block_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_block_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_block_record (
    ingress_res_id integer,
    engress_res_id integer,
    digit public.prefix_range,
    res_block_id integer,
    time_profile_id integer,
    ingress_client_id integer,
    egress_client_id integer,
    disable_by_alert boolean,
    ani_prefix public.prefix_range,
    ani_length integer,
    dnis_length integer,
    ani_method integer,
    dnis_method integer,
    ani_empty boolean,
    action_type integer,
    block_log_id integer,
    loop_block_id integer,
    ticket_log_id integer,
    code_name character varying,
    country character varying,
    create_by character varying,
    create_time timestamp with time zone,
    update_by character varying,
    dialer_detection_id integer,
    ani_max_length integer,
    dnis_max_length integer,
    ingress_group_id integer,
    egress_group_id integer,
    full_match integer,
    unblock_at numeric,
    type integer,
    block_at numeric,
    unblock_after numeric,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_block_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_block_record OWNER TO postgres;

--
-- Name: resource_block_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_block_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_block_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_block_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_block_record_tmp (
    ingress_res_id integer,
    engress_res_id integer,
    digit public.prefix_range,
    res_block_id integer,
    time_profile_id integer,
    ingress_client_id integer,
    egress_client_id integer,
    disable_by_alert boolean,
    ani_prefix public.prefix_range,
    ani_length integer,
    dnis_length integer,
    ani_method integer,
    dnis_method integer,
    ani_empty boolean,
    action_type integer,
    block_log_id integer,
    loop_block_id integer,
    ticket_log_id integer,
    code_name character varying,
    country character varying,
    create_by character varying,
    create_time timestamp with time zone,
    update_by character varying,
    dialer_detection_id integer,
    ani_max_length integer,
    dnis_max_length integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_block_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_block_record_tmp OWNER TO postgres;

--
-- Name: resource_capacity; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_capacity (
    id bigint NOT NULL,
    egress_id integer,
    ingress_id integer,
    max_cps integer,
    max_cap integer
);


ALTER TABLE public.resource_capacity OWNER TO postgres;

--
-- Name: resource_capacity_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_capacity_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_capacity_id_seq OWNER TO postgres;

--
-- Name: resource_capacity_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_capacity_id_seq OWNED BY public.resource_capacity.id;


--
-- Name: resource_capacity_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_capacity_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_capacity_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_capacity_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_capacity_record (
    id bigint,
    egress_id integer,
    ingress_id integer,
    max_cps integer,
    max_cap integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_capacity_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_capacity_record OWNER TO postgres;

--
-- Name: resource_codecs_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_codecs_ref (
    id integer NOT NULL,
    resource_id integer NOT NULL,
    codec_id integer
);


ALTER TABLE public.resource_codecs_ref OWNER TO postgres;

--
-- Name: TABLE resource_codecs_ref; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource_codecs_ref IS 'codes';


--
-- Name: COLUMN resource_codecs_ref.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_codecs_ref.id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_codecs_ref.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_codecs_ref.resource_id IS 'ç½‘å…³ç»„';


--
-- Name: resource_codecs_ref_codec_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_codecs_ref_codec_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE public.resource_codecs_ref_codec_id_seq OWNER TO postgres;

--
-- Name: resource_codecs_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_codecs_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_codecs_ref_id_seq OWNER TO postgres;

--
-- Name: resource_codecs_ref_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_codecs_ref_id_seq OWNED BY public.resource_codecs_ref.id;


--
-- Name: resource_codecs_ref_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_codecs_ref_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_codecs_ref_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_codecs_ref_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_codecs_ref_record (
    id integer,
    resource_id integer,
    codec_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_codecs_ref_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_codecs_ref_record OWNER TO postgres;

--
-- Name: resource_codecs_ref_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_codecs_ref_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_codecs_ref_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_codecs_ref_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_codecs_ref_record_tmp (
    id integer,
    resource_id integer,
    codec_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_codecs_ref_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_codecs_ref_record_tmp OWNER TO postgres;

--
-- Name: resource_direction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_direction (
    direction smallint NOT NULL,
    action smallint NOT NULL,
    digits character varying(10) NOT NULL,
    direction_id integer NOT NULL,
    dnis public.prefix_range DEFAULT ''::public.prefix_range,
    resource_id integer NOT NULL,
    time_profile_id integer,
    type integer NOT NULL,
    number_length integer,
    number_type integer
);


ALTER TABLE public.resource_direction OWNER TO postgres;

--
-- Name: TABLE resource_direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource_direction IS 'action(å·ç è½¬æ¢)';


--
-- Name: COLUMN resource_direction.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction.direction IS '0ï¼ï¼ALL
1ï¼ï¼æ‰“è¿›  ingress
2ï¼ï¼æ‰“å‡ºegress';


--
-- Name: COLUMN resource_direction.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction.action IS '1ï¼ï¼åŠ å‰ç¼€
2ï¼ï¼åŠ åŽç¼€
3ï¼ï¼å‡å‰ç¼€
4ï¼ï¼å‡åŽç¼€';


--
-- Name: COLUMN resource_direction.digits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction.digits IS 'è¦æ·»åŠ çš„å­—ç¬¦æˆ–åˆ é™¤çš„ä½æ•°';


--
-- Name: COLUMN resource_direction.direction_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction.direction_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_direction.dnis; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction.dnis IS 'ä¸»å«æˆ–è€…è¢«å«å‰ç¼€';


--
-- Name: COLUMN resource_direction.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction.resource_id IS 'ç½‘å…³ç»„';


--
-- Name: COLUMN resource_direction.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction.time_profile_id IS 'æ—¶é—´æ®µ';


--
-- Name: COLUMN resource_direction.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction.type IS '0ï¼ï¼ä¿®æ”¹ä¸»å«
1ï¼ï¼ä¿®æ”¹è¢«å«';


--
-- Name: COLUMN resource_direction.number_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction.number_length IS 'å·ç çš„é•¿åº¦';


--
-- Name: COLUMN resource_direction.number_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction.number_type IS '0ï¼ï¼æ‰€æœ‰
1ï¼ï¼å¤§äºŽ
2ï¼ï¼ç­‰äºŽ
3ï¼ï¼å°äºŽ';


--
-- Name: resource_direction_direction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_direction_direction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_direction_direction_id_seq OWNER TO postgres;

--
-- Name: resource_direction_direction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_direction_direction_id_seq OWNED BY public.resource_direction.direction_id;


--
-- Name: resource_direction_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_direction_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_direction_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_direction_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_direction_record (
    direction smallint,
    action smallint,
    digits character varying(10),
    direction_id integer,
    dnis public.prefix_range,
    resource_id integer,
    time_profile_id integer,
    type integer,
    number_length integer,
    number_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_direction_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_direction_record OWNER TO postgres;

--
-- Name: resource_direction_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_direction_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_direction_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_direction_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_direction_record_tmp (
    direction smallint,
    action smallint,
    digits character varying(10),
    direction_id integer,
    dnis public.prefix_range,
    resource_id integer,
    time_profile_id integer,
    type integer,
    number_length integer,
    number_type integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_direction_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_direction_record_tmp OWNER TO postgres;

--
-- Name: resource_direction_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_direction_template (
    direction_id integer NOT NULL,
    direction smallint,
    action smallint NOT NULL,
    digits character varying(10) NOT NULL,
    dnis public.prefix_range DEFAULT ''::public.prefix_range,
    resource_template_id integer NOT NULL,
    time_profile_id integer,
    type integer NOT NULL,
    number_length integer,
    number_type integer
);


ALTER TABLE public.resource_direction_template OWNER TO postgres;

--
-- Name: COLUMN resource_direction_template.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction_template.time_profile_id IS 'æ—¶é—´æ®µ';


--
-- Name: COLUMN resource_direction_template.number_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_direction_template.number_length IS 'å·ç çš„é•¿åº¦';


--
-- Name: resource_direction_template_direction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_direction_template_direction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_direction_template_direction_id_seq OWNER TO postgres;

--
-- Name: resource_direction_template_direction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_direction_template_direction_id_seq OWNED BY public.resource_direction_template.direction_id;


--
-- Name: resource_info; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_info (
    "time" character varying(100),
    resource_id character varying(100),
    value character varying(100),
    direction character varying(100),
    ip character varying(100)
);


ALTER TABLE public.resource_info OWNER TO postgres;

--
-- Name: TABLE resource_info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource_info IS 'resource monitor';


--
-- Name: COLUMN resource_info."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_info."time" IS 'æ—¶é—´';


--
-- Name: COLUMN resource_info.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_info.resource_id IS 'ç½‘å…³';


--
-- Name: COLUMN resource_info.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_info.value IS 'é€šè¯æ•°';


--
-- Name: COLUMN resource_info.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_info.direction IS 'ingress,egress';


--
-- Name: COLUMN resource_info.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_info.ip IS 'æœåŠ¡å™¨åœ°å€';


--
-- Name: resource_ip_resource_ip_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_ip_resource_ip_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_ip_resource_ip_id_seq OWNER TO postgres;

--
-- Name: resource_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_ip (
    resource_id integer NOT NULL,
    resource_ip_id integer DEFAULT nextval('public.resource_ip_resource_ip_id_seq'::regclass) NOT NULL,
    ip character varying(50),
    port integer DEFAULT 5060,
    fqdn character varying(100),
    sip_rpid character varying(64),
    disable_by_alert boolean DEFAULT false,
    priority integer DEFAULT 0,
    last_priority integer DEFAULT 0,
    addr_type integer DEFAULT 0,
    direction integer,
    username character varying(50),
    password character varying(50),
    reg_type smallint DEFAULT 0 NOT NULL,
    reg_status smallint DEFAULT 0 NOT NULL,
    reg_srv_ip character varying(100),
    reg_srv_port integer DEFAULT 5060 NOT NULL,
    expires integer DEFAULT 3600 NOT NULL,
    profile_id integer DEFAULT 0 NOT NULL,
    need_register boolean,
    masked_from integer,
    mask integer,
    options_ping_inv integer
);


ALTER TABLE public.resource_ip OWNER TO postgres;

--
-- Name: TABLE resource_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource_ip IS 'ç½‘å…³';


--
-- Name: COLUMN resource_ip.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip.resource_id IS 'ç½‘å…³ç»„';


--
-- Name: COLUMN resource_ip.resource_ip_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip.resource_ip_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_ip.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip.ip IS 'ipåœ°å€';


--
-- Name: COLUMN resource_ip.port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip.port IS 'ç«¯å£';


--
-- Name: COLUMN resource_ip.fqdn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip.fqdn IS 'åŸŸå';


--
-- Name: COLUMN resource_ip.sip_rpid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip.sip_rpid IS 'opensips';


--
-- Name: COLUMN resource_ip.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip.direction IS 'æ ‡æ³¨æ­¤ipæ˜¯incomingè¿˜æ˜¯outgoing

0 -- incoming
1 -- outgoing';


--
-- Name: COLUMN resource_ip.reg_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip.reg_type IS 'register user type, 0 for none; 1 for register user; 2 for register gateway account';


--
-- Name: COLUMN resource_ip.reg_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip.reg_status IS '0 for un-register; 1 for registered; 2 for register failed';


--
-- Name: COLUMN resource_ip.need_register; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip.need_register IS '0:Authorized by IP Only;1:Authorized by SIP Registration';


--
-- Name: resource_ip_limit; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_ip_limit (
    limit_id integer NOT NULL,
    ip_id integer NOT NULL,
    cps integer,
    capacity integer,
    time_profile_id integer
);


ALTER TABLE public.resource_ip_limit OWNER TO postgres;

--
-- Name: TABLE resource_ip_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource_ip_limit IS 'ä¸åŒæ—¶é—´æ®µï¼Œä¸åŒçš„limitå€¼';


--
-- Name: COLUMN resource_ip_limit.limit_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip_limit.limit_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_ip_limit.ip_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip_limit.ip_id IS 'ipåœ°å€ï¼ï¼å¤–é”®';


--
-- Name: COLUMN resource_ip_limit.cps; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip_limit.cps IS 'æ¯ç§’å‘¼å«æ•°';


--
-- Name: COLUMN resource_ip_limit.capacity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip_limit.capacity IS 'åŒæ—¶åœ¨çº¿é€šè¯æ•°';


--
-- Name: COLUMN resource_ip_limit.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_ip_limit.time_profile_id IS 'æ—¶é—´æ®µï¼ï¼å¤–é”®';


--
-- Name: resource_ip_limit_limit_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_ip_limit_limit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_ip_limit_limit_id_seq OWNER TO postgres;

--
-- Name: resource_ip_limit_limit_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_ip_limit_limit_id_seq OWNED BY public.resource_ip_limit.limit_id;


--
-- Name: resource_ip_limit_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_ip_limit_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_ip_limit_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_ip_limit_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_ip_limit_record (
    limit_id integer,
    ip_id integer,
    cps integer,
    capacity integer,
    time_profile_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_ip_limit_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_ip_limit_record OWNER TO postgres;

--
-- Name: resource_ip_limit_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_ip_limit_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_ip_limit_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_ip_limit_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_ip_limit_record_tmp (
    limit_id integer,
    ip_id integer,
    cps integer,
    capacity integer,
    time_profile_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_ip_limit_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_ip_limit_record_tmp OWNER TO postgres;

--
-- Name: resource_ip_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_ip_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_ip_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_ip_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_ip_record (
    resource_id integer,
    resource_ip_id integer,
    ip character varying(50),
    port integer,
    fqdn character varying(100),
    sip_rpid character varying(64),
    disable_by_alert boolean,
    priority integer,
    last_priority integer,
    addr_type integer,
    direction integer,
    username character varying(50),
    password character varying(50),
    reg_type smallint,
    reg_status smallint,
    reg_srv_ip character varying(100),
    reg_srv_port integer,
    expires integer,
    profile_id integer,
    need_register boolean,
    masked_from integer,
    mask integer,
    options_ping_inv integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_ip_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_ip_record OWNER TO postgres;

--
-- Name: resource_ip_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_ip_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_ip_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_ip_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_ip_record_tmp (
    resource_id integer,
    resource_ip_id integer,
    ip character varying(50),
    port integer,
    fqdn character varying(100),
    sip_rpid character varying(64),
    disable_by_alert boolean,
    priority integer,
    last_priority integer,
    addr_type integer,
    direction integer,
    username character varying(50),
    password character varying(50),
    reg_type smallint,
    reg_status smallint,
    reg_srv_ip character varying(100),
    reg_srv_port integer,
    expires integer,
    profile_id integer,
    need_register boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_ip_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_ip_record_tmp OWNER TO postgres;

--
-- Name: resource_lrn_action; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_lrn_action (
    id integer NOT NULL,
    direction smallint NOT NULL,
    action smallint NOT NULL,
    digits character varying(10) NOT NULL,
    dnis public.prefix_range DEFAULT ''::public.prefix_range,
    resource_id integer NOT NULL
);


ALTER TABLE public.resource_lrn_action OWNER TO postgres;

--
-- Name: COLUMN resource_lrn_action.direction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_lrn_action.direction IS '1ï¼lrnä¹‹å‰
2ï¼lrnä¹‹åŽ';


--
-- Name: COLUMN resource_lrn_action.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_lrn_action.action IS '1ï¼ï¼åŠ å‰ç¼€
2ï¼ï¼åŠ åŽç¼€
3ï¼ï¼å‡å‰ç¼€
4ï¼ï¼å‡åŽç¼€';


--
-- Name: resource_lrn_action_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_lrn_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_lrn_action_id_seq OWNER TO postgres;

--
-- Name: resource_lrn_action_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_lrn_action_id_seq OWNED BY public.resource_lrn_action.id;


--
-- Name: resource_lrn_action_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_lrn_action_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_lrn_action_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_lrn_action_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_lrn_action_record (
    id integer,
    direction smallint,
    action smallint,
    digits character varying(10),
    dnis public.prefix_range,
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_lrn_action_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_lrn_action_record OWNER TO postgres;

--
-- Name: resource_lrn_action_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_lrn_action_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_lrn_action_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_lrn_action_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_lrn_action_record_tmp (
    id integer,
    direction smallint,
    action smallint,
    digits character varying(10),
    dnis public.prefix_range,
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_lrn_action_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_lrn_action_record_tmp OWNER TO postgres;

--
-- Name: resource_next_route_rule; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_next_route_rule (
    id integer NOT NULL,
    route_type integer,
    reponse_code character varying(100),
    resource_id integer,
    return_code character varying(100),
    return_string character varying(100)
);


ALTER TABLE public.resource_next_route_rule OWNER TO postgres;

--
-- Name: TABLE resource_next_route_rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource_next_route_rule IS 'next_rule';


--
-- Name: COLUMN resource_next_route_rule.route_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_next_route_rule.route_type IS '1--next host
2--next route
3--stop';


--
-- Name: COLUMN resource_next_route_rule.reponse_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_next_route_rule.reponse_code IS '200,486,404,487';


--
-- Name: resource_next_route_rule_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_next_route_rule_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_next_route_rule_id_seq OWNER TO postgres;

--
-- Name: resource_next_route_rule_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_next_route_rule_id_seq OWNED BY public.resource_next_route_rule.id;


--
-- Name: resource_next_route_rule_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_next_route_rule_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_next_route_rule_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_next_route_rule_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_next_route_rule_record (
    id integer,
    route_type integer,
    reponse_code character varying(100),
    resource_id integer,
    return_code character varying(100),
    return_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_next_route_rule_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_next_route_rule_record OWNER TO postgres;

--
-- Name: resource_next_route_rule_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_next_route_rule_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_next_route_rule_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_next_route_rule_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_next_route_rule_record_tmp (
    id integer,
    route_type integer,
    reponse_code character varying(100),
    resource_id integer,
    return_code character varying(100),
    return_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_next_route_rule_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_next_route_rule_record_tmp OWNER TO postgres;

--
-- Name: resource_next_route_rule_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_next_route_rule_template (
    id integer NOT NULL,
    route_type integer,
    reponse_code character varying(100),
    resource_template_id integer,
    return_code character varying(100),
    return_string character varying(100)
);


ALTER TABLE public.resource_next_route_rule_template OWNER TO postgres;

--
-- Name: resource_next_route_rule_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_next_route_rule_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_next_route_rule_template_id_seq OWNER TO postgres;

--
-- Name: resource_next_route_rule_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_next_route_rule_template_id_seq OWNED BY public.resource_next_route_rule_template.id;


--
-- Name: resource_prefix; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_prefix (
    id integer NOT NULL,
    resource_id integer,
    tech_prefix public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    route_strategy_id integer,
    rate_table_id integer,
    code public.prefix_range,
    code_cps integer,
    code_cap integer,
    product_id integer
);


ALTER TABLE public.resource_prefix OWNER TO postgres;

--
-- Name: COLUMN resource_prefix.tech_prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_prefix.tech_prefix IS 'åŒ¹é…å·ç çš„å‰ç¼€';


--
-- Name: COLUMN resource_prefix.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_prefix.code IS 'è¢«å«å·ç å‰ç¼€ï¼Œè·Ÿtech_prefixä¸ä¸€æ ·çš„ï¼Œä¸éœ€è¦åˆ é™¤å‰ç¼€ï¼Œé€‰routing_palanå’Œrate_tableçš„ä½œç”¨ã€‚
åŒä¸€ä¸ªingress+tech_prefixå†…codeå¿…é¡»æ˜¯å”¯ä¸€çš„ã€‚';


--
-- Name: COLUMN resource_prefix.code_cps; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_prefix.code_cps IS 'codeä¸ºåˆ†ç±»çš„cps';


--
-- Name: COLUMN resource_prefix.code_cap; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_prefix.code_cap IS 'codeä¸ºåˆ†ç±»çš„cap';


--
-- Name: resource_prefix_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_prefix_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_prefix_id_seq OWNER TO postgres;

--
-- Name: resource_prefix_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_prefix_id_seq OWNED BY public.resource_prefix.id;


--
-- Name: resource_prefix_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_prefix_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_prefix_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_prefix_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_prefix_record (
    id integer,
    resource_id integer,
    tech_prefix public.prefix_range,
    route_strategy_id integer,
    rate_table_id integer,
    code public.prefix_range,
    code_cps integer,
    code_cap integer,
    product_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_prefix_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_prefix_record OWNER TO postgres;

--
-- Name: resource_prefix_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_prefix_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_prefix_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_prefix_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_prefix_record_tmp (
    id integer,
    resource_id integer,
    tech_prefix public.prefix_range,
    route_strategy_id integer,
    rate_table_id integer,
    code public.prefix_range,
    code_cps integer,
    code_cap integer,
    product_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_prefix_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_prefix_record_tmp OWNER TO postgres;

--
-- Name: resource_rate; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_rate (
    id integer NOT NULL,
    code public.prefix_range,
    rate numeric(30,10),
    service_rate real,
    finance_rate real,
    resource_id integer,
    order_type integer,
    min_time integer DEFAULT 0 NOT NULL,
    "interval" integer DEFAULT 1 NOT NULL,
    code_name character varying(100),
    country character varying(1000),
    ingress_id integer,
    egress_id integer
);


ALTER TABLE public.resource_rate OWNER TO postgres;

--
-- Name: COLUMN resource_rate.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_rate.order_type IS '1-buy order
2-sell order';


--
-- Name: resource_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_rate_id_seq OWNER TO postgres;

--
-- Name: resource_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_rate_id_seq OWNED BY public.resource_rate.id;


--
-- Name: resource_rate_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_rate_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_rate_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_rate_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_rate_record (
    id integer,
    code public.prefix_range,
    rate numeric(30,10),
    service_rate real,
    finance_rate real,
    resource_id integer,
    order_type integer,
    min_time integer,
    "interval" integer,
    code_name character varying(100),
    country character varying(1000),
    ingress_id integer,
    egress_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_rate_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_rate_record OWNER TO postgres;

--
-- Name: resource_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_record (
    resource_id integer,
    name character varying(100),
    ingress boolean,
    egress boolean,
    active boolean,
    rfc_2833 boolean,
    t38 boolean,
    alias character varying(100),
    res_strategy smallint,
    cps_limit integer,
    capacity integer,
    lnp boolean,
    lrn_block boolean,
    client_id integer,
    tdm boolean,
    rate_table_id integer,
    transnexus integer,
    route_strategy_id integer,
    media_type integer,
    pass_through integer,
    profit_margin double precision,
    enough_balance boolean,
    egress_bill_after_action boolean,
    proto integer,
    dnis_only boolean,
    ring_timeout integer,
    ignore_ring boolean,
    ignore_early_media boolean,
    disable_by_alert boolean,
    priority integer,
    last_priority integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    status integer,
    wait_ringtime180 integer,
    profit_type integer,
    lnp_dipping boolean,
    lnp_dipping_rate real,
    update_at timestamp with time zone,
    update_by character varying,
    cli_type integer,
    auth_type integer,
    delay_bye_second integer,
    delay_bye_limit integer,
    max_duration integer,
    marketplace integer,
    rating_type integer,
    billing_type integer,
    trunk_type integer,
    switch_profile_id integer,
    transaction_fee_id integer,
    service_type integer,
    product_id integer,
    rpid smallint,
    paid smallint,
    oli smallint,
    pci smallint,
    priv smallint,
    div smallint,
    trunk_type2 smallint,
    account_id character(32),
    billing_method smallint,
    amount_per_port numeric,
    billing_rule integer,
    ignore_early_nosdp integer,
    media_timeout integer,
    private integer,
    agent_type integer,
    bill_by integer,
    rate_profile integer,
    us_route integer,
    intl_route integer,
    canada_route integer,
    rate_decimal integer,
    rate_rounding integer,
    us_other integer,
    canada_other integer,
    redirect integer,
    lrn_prefix integer,
    pass_response_code integer,
    is_del integer,
    dtmf_type integer,
    dtmf_detect integer,
    rpid_screen integer,
    rpid_party integer,
    display_name integer,
    rpid_id_type integer,
    rpid_privacy integer,
    counter_time integer,
    number integer,
    block_time integer,
    re_invite integer,
    re_invite_interval integer,
    info integer,
    rfc2833 integer,
    inband integer,
    dummy_trunk boolean,
    random_table_id integer,
    is_virtual boolean,
    rfc_r833_payload integer,
    resource_template_id integer,
    rate_use_rpid boolean,
    group_id integer,
    resource_block_group_id integer,
    block_404_number_time integer,
    billing_port_type integer,
    cost_per_port numeric,
    price_per_actual_channel double precision,
    price_per_max_channel double precision,
    enfource_cid boolean,
    ani_cps_limit integer,
    ani_cap_limit integer,
    dnis_cps_limit integer,
    dnis_cap_limit integer,
    jurisdiction_use_dnis boolean,
    cid_min_asr integer,
    cid_min_acd integer,
    cid_max_sdp integer,
    tech_prefix character varying(255),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_record OWNER TO postgres;

--
-- Name: resource_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_record_tmp (
    resource_id integer,
    name character varying(100),
    ingress boolean,
    egress boolean,
    active boolean,
    rfc_2833 boolean,
    t38 boolean,
    alias character varying(100),
    res_strategy smallint,
    cps_limit integer,
    capacity integer,
    lnp boolean,
    lrn_block boolean,
    client_id integer,
    tdm boolean,
    rate_table_id integer,
    transnexus integer,
    route_strategy_id integer,
    media_type integer,
    pass_through integer,
    profit_margin double precision,
    enough_balance boolean,
    egress_bill_after_action boolean,
    proto integer,
    dnis_only boolean,
    ring_timeout integer,
    ignore_ring boolean,
    ignore_early_media boolean,
    disable_by_alert boolean,
    priority integer,
    last_priority integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    status integer,
    wait_ringtime180 integer,
    profit_type integer,
    lnp_dipping boolean,
    lnp_dipping_rate real,
    update_at timestamp with time zone,
    update_by character varying,
    cli_type integer,
    auth_type integer,
    delay_bye_second integer,
    delay_bye_limit integer,
    max_duration integer,
    marketplace integer,
    rating_type integer,
    billing_type integer,
    trunk_type integer,
    switch_profile_id integer,
    transaction_fee_id integer,
    service_type integer,
    product_id integer,
    rpid smallint,
    paid smallint,
    oli smallint,
    pci smallint,
    priv smallint,
    div smallint,
    trunk_type2 smallint,
    account_id character(32),
    billing_method smallint,
    amount_per_port numeric,
    billing_rule integer,
    ignore_early_nosdp integer,
    media_timeout integer,
    private integer,
    agent_type integer,
    bill_by integer,
    rate_profile integer,
    us_route integer,
    intl_route integer,
    canada_route integer,
    rate_decimal integer,
    rate_rounding integer,
    us_other integer,
    canada_other integer,
    redirect integer,
    lrn_prefix integer,
    pass_response_code integer,
    is_del integer,
    dtmf_type integer,
    dtmf_detect integer,
    rpid_screen integer,
    rpid_party integer,
    display_name integer,
    rpid_id_type integer,
    rpid_privacy integer,
    counter_time integer,
    number integer,
    block_time integer,
    re_invite integer,
    re_invite_interval integer,
    info integer,
    rfc2833 integer,
    inband integer,
    dummy_trunk boolean,
    random_table_id integer,
    is_virtual boolean,
    rfc_r833_payload integer,
    resource_template_id integer,
    rate_use_rpid boolean,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_record_tmp OWNER TO postgres;

--
-- Name: resource_replace_action; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_replace_action (
    id integer NOT NULL,
    resource_id integer,
    ani_prefix character varying(50),
    ani character varying(30),
    ani_min_length integer DEFAULT 1,
    ani_max_length integer,
    type integer,
    dnis_prefix character varying(30),
    dnis character varying(30),
    dnis_min_length integer,
    dnis_max_length integer
);


ALTER TABLE public.resource_replace_action OWNER TO postgres;

--
-- Name: COLUMN resource_replace_action.ani_min_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_replace_action.ani_min_length IS 'åŒ¹é…çš„ä¸»å«å·æœ€å°é•¿åº¦ï¼Œè·Ÿæœ€å¤§é•¿åº¦å¹¶ä¸”å…³ç³»ï¼Œå¤§äºŽç­‰äºŽã€‚';


--
-- Name: COLUMN resource_replace_action.ani_max_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_replace_action.ani_max_length IS 'åŒ¹é…çš„ä¸»å«å·æœ€å¤§é•¿åº¦ï¼Œè·Ÿæœ€å°é•¿åº¦å¹¶ä¸”å…³ç³»ï¼Œå°äºŽã€‚';


--
-- Name: COLUMN resource_replace_action.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_replace_action.type IS '0 -- ani åªæ›¿æ¢ä¸»å«
1 -- dnis åªæ›¿æ¢è¢«å«
2 -- both æ›¿æ¢ä¸»å«å’Œè¢«å«';


--
-- Name: COLUMN resource_replace_action.dnis_prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_replace_action.dnis_prefix IS 'åŒ¹é…è¢«å«çš„å‰ç¼€';


--
-- Name: COLUMN resource_replace_action.dnis; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_replace_action.dnis IS 'åŒ¹é…æˆåŠŸåŽæ›¿æ¢çš„è¢«å«å·ç ';


--
-- Name: COLUMN resource_replace_action.dnis_min_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_replace_action.dnis_min_length IS 'åŒ¹é…çš„è¢«å«å·æœ€å°é•¿åº¦ï¼Œè·Ÿæœ€å¤§é•¿åº¦å¹¶ä¸”å…³ç³»ï¼Œå¤§äºŽç­‰äºŽã€‚';


--
-- Name: COLUMN resource_replace_action.dnis_max_length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_replace_action.dnis_max_length IS 'åŒ¹é…çš„è¢«å«å·æœ€å¤§é•¿åº¦ï¼Œè·Ÿæœ€å°é•¿åº¦å¹¶ä¸”å…³ç³»ï¼Œå°äºŽã€‚';


--
-- Name: resource_replace_action_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_replace_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_replace_action_id_seq OWNER TO postgres;

--
-- Name: resource_replace_action_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_replace_action_id_seq OWNED BY public.resource_replace_action.id;


--
-- Name: resource_replace_action_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_replace_action_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_replace_action_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_replace_action_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_replace_action_record (
    id integer,
    resource_id integer,
    ani_prefix character varying(50),
    ani character varying(30),
    ani_min_length integer,
    ani_max_length integer,
    type integer,
    dnis_prefix character varying(30),
    dnis character varying(30),
    dnis_min_length integer,
    dnis_max_length integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_replace_action_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_replace_action_record OWNER TO postgres;

--
-- Name: resource_replace_action_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_replace_action_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_replace_action_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_replace_action_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_replace_action_record_tmp (
    id integer,
    resource_id integer,
    ani_prefix character varying(50),
    ani character varying(30),
    ani_min_length integer,
    ani_max_length integer,
    type integer,
    dnis_prefix character varying(30),
    dnis character varying(30),
    dnis_min_length integer,
    dnis_max_length integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_replace_action_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_replace_action_record_tmp OWNER TO postgres;

--
-- Name: resource_replace_action_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_replace_action_template (
    id integer NOT NULL,
    resource_template_id integer,
    ani_prefix character varying(50),
    ani character varying(30),
    ani_min_length integer,
    ani_max_length integer,
    type integer,
    dnis_prefix character varying(30),
    dnis character varying(30),
    dnis_min_length integer,
    dnis_max_length integer
);


ALTER TABLE public.resource_replace_action_template OWNER TO postgres;

--
-- Name: resource_replace_action_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_replace_action_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_replace_action_template_id_seq OWNER TO postgres;

--
-- Name: resource_replace_action_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_replace_action_template_id_seq OWNED BY public.resource_replace_action_template.id;


--
-- Name: resource_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_template (
    name character varying(100),
    resource_template_id integer NOT NULL,
    create_by character varying(100),
    update_on timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    create_on timestamp with time zone,
    trunk_type integer DEFAULT 0 NOT NULL,
    media_type integer,
    profit_margin double precision DEFAULT 0 NOT NULL,
    profit_type integer DEFAULT 1 NOT NULL,
    wait_ringtime180 integer,
    lnp_dipping_rate real,
    lnp_dipping boolean DEFAULT false,
    delay_bye_second integer,
    ignore_early_media boolean DEFAULT false,
    re_invite integer,
    re_invite_interval integer,
    media_timeout integer,
    res_strategy smallint,
    max_duration integer,
    trunk_type2 smallint DEFAULT 0 NOT NULL,
    billing_rule integer,
    billing_method smallint,
    rate_table_id integer,
    random_table_id integer,
    amount_per_port numeric,
    info integer,
    rfc2833 integer,
    inband integer,
    ring_timeout integer DEFAULT 60 NOT NULL,
    codecs_str character varying(200),
    paid smallint,
    oli smallint,
    pci smallint,
    priv smallint,
    div smallint,
    display_name smallint,
    rpid_screen integer DEFAULT 0,
    rpid_party integer DEFAULT 0,
    rpid_id_type integer DEFAULT 0,
    rpid_privacy integer DEFAULT 0,
    rate_rounding integer DEFAULT 0,
    rate_decimal integer DEFAULT 6,
    rate_profile integer DEFAULT 0,
    us_route integer DEFAULT 0,
    us_other integer DEFAULT 0,
    canada_route integer DEFAULT 0,
    canada_other integer DEFAULT 0,
    intl_route integer DEFAULT 0,
    ignore_early_nosdp integer,
    bill_by integer DEFAULT 4,
    ignore_ring boolean DEFAULT false,
    t38 boolean DEFAULT false NOT NULL
);


ALTER TABLE public.resource_template OWNER TO postgres;

--
-- Name: COLUMN resource_template.trunk_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.trunk_type IS '0 ingress
1 egress';


--
-- Name: COLUMN resource_template.re_invite; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.re_invite IS '0 -- false
1 -- true

å‘é€re-INVITEæ£€æµ‹å¯¹æ–¹æ˜¯å¦æ´»è·ƒ';


--
-- Name: COLUMN resource_template.re_invite_interval; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.re_invite_interval IS 'ç§’å•ä½ï¼Œå»ºè®®ä¸å°äºŽ60ç§’';


--
-- Name: COLUMN resource_template.res_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.res_strategy IS 'è½åœ°ç½‘å…³é€‰æ‹©ç­–ç•¥
1ï¼ï¼top-down
2ï¼ï¼round-robin';


--
-- Name: COLUMN resource_template.billing_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.billing_method IS '0 - by minutes

1- by port';


--
-- Name: COLUMN resource_template.rate_table_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.rate_table_id IS 'è´¹çŽ‡æ¨¡æ¿';


--
-- Name: COLUMN resource_template.amount_per_port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.amount_per_port IS 'money per port';


--
-- Name: COLUMN resource_template.info; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.info IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource_template.rfc2833; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.rfc2833 IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource_template.inband; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.inband IS '0 Does Not Support/Does Not Require
1 Support/Require';


--
-- Name: COLUMN resource_template.bill_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_template.bill_by IS '0 -- DNISï¼ŒDNISè®¡è´¹ï¼Œä¸éœ€è¦æŸ¥è¯¢LRN
1 -- LRNï¼ŒLRNè®¡è´¹ï¼Œå¿½ç•¥è¿è¥å•†å˜åŒ–
2 -- LRN Blockï¼ŒLRNè®¡è´¹å·ç è¿è¥å•†æœ‰æ”¹å˜ï¼Œåˆ™æ‹’ç»
3 -- LRN Block Higher Rateï¼ŒLRNè´¹çŽ‡é«˜äºŽDNISè´¹çŽ‡
4 -- Follow Rate Deckï¼Œä½¿ç”¨è´¹çŽ‡è¡¨çš„ä»¥ä¸Šé…ç½®';


--
-- Name: resource_template_resource_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_template_resource_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_template_resource_template_id_seq OWNER TO postgres;

--
-- Name: resource_template_resource_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_template_resource_template_id_seq OWNED BY public.resource_template.resource_template_id;


--
-- Name: resource_translation_ref; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_translation_ref (
    ref_id integer NOT NULL,
    resource_id integer NOT NULL,
    translation_id integer NOT NULL,
    time_profile_id integer
);


ALTER TABLE public.resource_translation_ref OWNER TO postgres;

--
-- Name: TABLE resource_translation_ref; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.resource_translation_ref IS 'ä¸åŒæ—¶é—´æ®µï¼Œä¸åŒçš„ä¸»è¢«å«è½¬æ¢';


--
-- Name: COLUMN resource_translation_ref.ref_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_translation_ref.ref_id IS 'ä¸»é”®';


--
-- Name: COLUMN resource_translation_ref.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_translation_ref.resource_id IS 'ç½‘å…³ç»„ï¼ï¼å¤–é”®
å¯¹æŽ¥ç½‘å…³';


--
-- Name: COLUMN resource_translation_ref.translation_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_translation_ref.translation_id IS 'è½¬æ¢è§„åˆ™ï¼ï¼å¤–é”®';


--
-- Name: COLUMN resource_translation_ref.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.resource_translation_ref.time_profile_id IS 'æ—¶é—´æ®µï¼ï¼å¤–é”®';


--
-- Name: resource_translation_ref_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_translation_ref_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_translation_ref_record_record_id_seq OWNER TO postgres;

--
-- Name: resource_translation_ref_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_translation_ref_record (
    ref_id integer,
    resource_id integer,
    translation_id integer,
    time_profile_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_translation_ref_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_translation_ref_record OWNER TO postgres;

--
-- Name: resource_translation_ref_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_translation_ref_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_translation_ref_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: resource_translation_ref_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.resource_translation_ref_record_tmp (
    ref_id integer,
    resource_id integer,
    translation_id integer,
    time_profile_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.resource_translation_ref_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.resource_translation_ref_record_tmp OWNER TO postgres;

--
-- Name: resource_translation_ref_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.resource_translation_ref_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.resource_translation_ref_ref_id_seq OWNER TO postgres;

--
-- Name: resource_translation_ref_ref_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.resource_translation_ref_ref_id_seq OWNED BY public.resource_translation_ref.ref_id;


--
-- Name: retrieve_password_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.retrieve_password_log (
    id integer NOT NULL,
    username character varying(500),
    operation_time timestamp with time zone,
    email_addresses character varying(500),
    modify_time timestamp with time zone,
    status smallint
);


ALTER TABLE public.retrieve_password_log OWNER TO postgres;

--
-- Name: COLUMN retrieve_password_log.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.retrieve_password_log.status IS '1,failure

2,E-mail has been sent

3,Modified successfully
';


--
-- Name: retrieve_password_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.retrieve_password_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.retrieve_password_log_id_seq OWNER TO postgres;

--
-- Name: retrieve_password_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.retrieve_password_log_id_seq OWNED BY public.retrieve_password_log.id;


--
-- Name: role; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.role (
    role_id integer NOT NULL,
    role_name character varying(100) NOT NULL,
    view_pw boolean DEFAULT false,
    default_sysfunc_id integer,
    del_able boolean DEFAULT true,
    edit_able boolean DEFAULT true,
    client_id integer,
    is_carriers boolean DEFAULT true,
    is_transaction boolean DEFAULT true,
    is_mutual_settlements boolean DEFAULT true,
    is_invoices boolean DEFAULT true,
    is_payment boolean DEFAULT true,
    is_spam_report boolean DEFAULT true,
    is_location_report boolean DEFAULT true,
    is_origterm boolean DEFAULT true,
    is_summary_report boolean DEFAULT true,
    is_usage_report boolean DEFAULT true,
    is_cdr_list boolean DEFAULT true,
    is_qos_report boolean DEFAULT true,
    is_disconnect_cause boolean DEFAULT true,
    is_billing_mismatch boolean DEFAULT true,
    is_active_call boolean DEFAULT true,
    is_termination_report boolean DEFAULT true,
    is_rates_analysis boolean DEFAULT true,
    is_call_simulation boolean DEFAULT true,
    is_ingress_trunk_simulation boolean DEFAULT true,
    is_egress_trunk_simulation boolean DEFAULT true,
    is_sip_capture boolean DEFAULT true,
    is_digit_mapping boolean DEFAULT true,
    is_trunk boolean DEFAULT true,
    is_dynamic_routing boolean DEFAULT true,
    is_static_route_table boolean DEFAULT true,
    is_block_list boolean DEFAULT true,
    is_routing_plan boolean DEFAULT true,
    is_active_web_session boolean DEFAULT true,
    is_payment_term boolean DEFAULT true,
    is_jurisdiction boolean DEFAULT true,
    is_capicity boolean DEFAULT true,
    is_rate_table boolean DEFAULT true,
    is_code_deck boolean DEFAULT true,
    is_time_profile boolean DEFAULT true,
    is_currency boolean DEFAULT true,
    is_task_schedulers boolean DEFAULT true,
    is_mail_template boolean DEFAULT true,
    is_role boolean DEFAULT true,
    is_user boolean DEFAULT true,
    is_change_password boolean DEFAULT true,
    is_setting boolean DEFAULT true,
    is_import_log boolean DEFAULT true,
    is_export_log boolean DEFAULT true,
    is_cdr_backup boolean DEFAULT true,
    is_lrn_setting boolean DEFAULT true,
    active boolean DEFAULT true,
    is_unpaid_bills boolean DEFAULT true,
    is_service_charge boolean DEFAULT true,
    is_voip_gateway boolean DEFAULT true,
    is_trouble_shoot boolean DEFAULT true,
    is_event boolean DEFAULT true,
    is_ticket boolean DEFAULT true,
    is_buy_select_country boolean DEFAULT true,
    is_search_private_buy boolean DEFAULT true,
    is_buy_confirm_order boolean DEFAULT true,
    is_sell_select_country boolean DEFAULT true,
    is_search_private_sell boolean DEFAULT true,
    is_sell_confirm_order boolean DEFAULT true,
    role_type integer DEFAULT 1
);


ALTER TABLE public.role OWNER TO postgres;

--
-- Name: TABLE role; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.role IS 'è§’è‰²';


--
-- Name: COLUMN role.role_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role.role_id IS 'ä¸»é”®';


--
-- Name: COLUMN role.role_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role.role_name IS 'åç§°';


--
-- Name: COLUMN role.view_pw; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role.view_pw IS 'æ˜¯å¦æœ‰æŸ¥çœ‹å¯†ç çš„æƒé™';


--
-- Name: COLUMN role.default_sysfunc_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role.default_sysfunc_id IS 'æƒé™åŠŸèƒ½';


--
-- Name: COLUMN role.del_able; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role.del_able IS 'æ‹¥æœ‰è¿™ä¸ªè§’è‰²çš„ç”¨æˆ·æ˜¯å¦èƒ½è¢«åˆ é™¤';


--
-- Name: COLUMN role.edit_able; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role.edit_able IS 'æ‹¥æœ‰è¿™ä¸ªè§’è‰²çš„ç”¨æˆ·ä¿¡æ¯æ˜¯å¦èƒ½è¢«ä¿®æ”¹';


--
-- Name: COLUMN role.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN role.role_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role.role_type IS '1--adminä½¿ç”¨çš„è§’è‰²
2--carrierä½¿ç”¨çš„è§’è‰²';


--
-- Name: role_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.role_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.role_role_id_seq OWNER TO postgres;

--
-- Name: role_role_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.role_role_id_seq OWNED BY public.role.role_id;


--
-- Name: role_privilege; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.role_privilege (
    role_id integer DEFAULT nextval('public.role_role_id_seq'::regclass) NOT NULL,
    system_function_id integer NOT NULL,
    writable boolean DEFAULT false NOT NULL,
    readable boolean DEFAULT false NOT NULL,
    executable boolean DEFAULT false NOT NULL,
    reseller_id integer,
    role_privilege_id integer NOT NULL
);


ALTER TABLE public.role_privilege OWNER TO postgres;

--
-- Name: TABLE role_privilege; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.role_privilege IS 'è§’è‰²æƒé™';


--
-- Name: COLUMN role_privilege.role_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role_privilege.role_id IS 'role';


--
-- Name: COLUMN role_privilege.system_function_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role_privilege.system_function_id IS 'ç³»ç»ŸåŠŸèƒ½æˆ–é¡µé¢';


--
-- Name: COLUMN role_privilege.writable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role_privilege.writable IS 'å¯å†™æƒé™';


--
-- Name: COLUMN role_privilege.readable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role_privilege.readable IS 'å¯è¯»æƒé™';


--
-- Name: COLUMN role_privilege.executable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role_privilege.executable IS 'å¯æ‰§è¡Œæƒé™';


--
-- Name: COLUMN role_privilege.reseller_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role_privilege.reseller_id IS 'ä»£ç†å•†';


--
-- Name: COLUMN role_privilege.role_privilege_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.role_privilege.role_privilege_id IS 'ä¸»é”®';


--
-- Name: role_privilege_role_privilege_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.role_privilege_role_privilege_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.role_privilege_role_privilege_id_seq OWNER TO postgres;

--
-- Name: role_privilege_role_privilege_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.role_privilege_role_privilege_id_seq OWNED BY public.role_privilege.role_privilege_id;


--
-- Name: route_block; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.route_block (
    egress_trunk_id integer,
    code_name character varying(256),
    id integer NOT NULL,
    create_by character varying(256),
    create_on timestamp without time zone
);


ALTER TABLE public.route_block OWNER TO postgres;

--
-- Name: route_block_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.route_block_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.route_block_id_seq OWNER TO postgres;

--
-- Name: route_block_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.route_block_id_seq OWNED BY public.route_block.id;


--
-- Name: route_qos_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.route_qos_report (
);


ALTER TABLE public.route_qos_report OWNER TO postgres;

--
-- Name: TABLE route_qos_report; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.route_qos_report IS 'ç»Ÿè®¡resource_id + code çš„asr, acdç­‰ã€‚';


--
-- Name: route_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.route_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.route_record_record_id_seq OWNER TO postgres;

--
-- Name: route_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.route_record (
    route_id integer,
    digits public.prefix_range,
    dynamic_route_id integer,
    static_route_id integer,
    route_type integer,
    route_strategy_id integer,
    lnp boolean,
    lrn_block boolean,
    dnis_only boolean,
    code_deck_type integer,
    update_at timestamp with time zone,
    update_by character varying,
    intra_static_route_id integer,
    inter_static_route_id integer,
    jurisdiction_country_id integer,
    ani_prefix public.prefix_range,
    ani_min_length integer,
    ani_max_length integer,
    digits_min_length integer,
    digits_max_length integer,
    code_name character varying,
    country character varying(50),
    route_type_flg integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.route_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.route_record OWNER TO postgres;

--
-- Name: route_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.route_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.route_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: route_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.route_record_tmp (
    route_id integer,
    digits public.prefix_range,
    dynamic_route_id integer,
    static_route_id integer,
    route_type integer,
    route_strategy_id integer,
    lnp boolean,
    lrn_block boolean,
    dnis_only boolean,
    code_deck_type integer,
    update_at timestamp with time zone,
    update_by character varying,
    intra_static_route_id integer,
    inter_static_route_id integer,
    jurisdiction_country_id integer,
    ani_prefix public.prefix_range,
    ani_min_length integer,
    ani_max_length integer,
    digits_min_length integer,
    digits_max_length integer,
    code_name character varying,
    country character varying(50),
    route_type_flg integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.route_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.route_record_tmp OWNER TO postgres;

--
-- Name: route_route_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.route_route_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.route_route_id_seq OWNER TO postgres;

--
-- Name: route_route_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.route_route_id_seq OWNED BY public.route.route_id;


--
-- Name: route_strategy_route_strategy_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.route_strategy_route_strategy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.route_strategy_route_strategy_id_seq OWNER TO postgres;

--
-- Name: route_strategy_route_strategy_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.route_strategy_route_strategy_id_seq OWNED BY public.route_strategy.route_strategy_id;


--
-- Name: routing_wizard_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.routing_wizard_list (
    id integer NOT NULL,
    client_id integer,
    resource_id integer,
    rate_generation_template_id integer,
    send_rate_on timestamp with time zone,
    create_time timestamp with time zone,
    create_by character varying(50),
    rate_generation_history_id integer,
    virtual_dynamic_route_id integer,
    virtual_route_plan_id integer,
    virtual_route_id integer,
    virtual_rate_table_id integer,
    rollback_sql text,
    rate_generation_history_detail_id integer
);


ALTER TABLE public.routing_wizard_list OWNER TO postgres;

--
-- Name: routing_wizard_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.routing_wizard_list_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.routing_wizard_list_id_seq OWNER TO postgres;

--
-- Name: routing_wizard_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.routing_wizard_list_id_seq OWNED BY public.routing_wizard_list.id;


--
-- Name: scheduled_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.scheduled_report (
    id integer NOT NULL,
    report_name character varying(100),
    email_to character varying(500),
    subject text,
    frequency_type integer,
    time_of_day integer,
    day_of_week integer,
    day_of_months integer,
    action boolean,
    query text,
    query2 text,
    query3 text,
    report_type integer,
    "interval" integer
);


ALTER TABLE public.scheduled_report OWNER TO postgres;

--
-- Name: TABLE scheduled_report; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.scheduled_report IS 'å‘é€æŠ¥è¡¨';


--
-- Name: COLUMN scheduled_report.email_to; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report.email_to IS 'å¤šä¸ªä»¥ï¼›åˆ†éš”';


--
-- Name: COLUMN scheduled_report.subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report.subject IS ' å‘é€é‚®ä»¶çš„ä¸»é¢˜';


--
-- Name: COLUMN scheduled_report.frequency_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report.frequency_type IS '1:Daily
2:Weekly
3:Monthly';


--
-- Name: COLUMN scheduled_report.time_of_day; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report.time_of_day IS '0-23 hour';


--
-- Name: COLUMN scheduled_report.day_of_week; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report.day_of_week IS 'Mon, Tue, Wed, Thu, Fri, Sat, Sun
1,2,3,4,5,6,7';


--
-- Name: COLUMN scheduled_report.day_of_months; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report.day_of_months IS 'æ¯æœˆçš„å‡ å·';


--
-- Name: COLUMN scheduled_report.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report.action IS 'æ˜¯å¦å¯ç”¨';


--
-- Name: COLUMN scheduled_report.query; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report.query IS 'æ‰§è¡Œçš„sql';


--
-- Name: COLUMN scheduled_report.query2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report.query2 IS 'åœ¨æŠ¥è¡¨æœ‰ä¸‰ä¸­æƒ…å†µæ—¶è®°å½•';


--
-- Name: COLUMN scheduled_report.report_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report.report_type IS 'ä¸åŒçš„æŠ¥è¡¨';


--
-- Name: COLUMN scheduled_report."interval"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report."interval" IS 'æŠ¥è¡¨æŸ¥è¯¢çš„æ—¶é—´åŒºé—´ï¼Œå•ä½ä¸ºå°æ—¶h';


--
-- Name: scheduled_report_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.scheduled_report_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.scheduled_report_id_seq OWNER TO postgres;

--
-- Name: scheduled_report_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.scheduled_report_id_seq OWNED BY public.scheduled_report.id;


--
-- Name: scheduled_report_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.scheduled_report_log (
    id integer NOT NULL,
    email_to character varying(500),
    report_name character(50),
    attachment_path character varying(500),
    execute_time timestamp with time zone
);


ALTER TABLE public.scheduled_report_log OWNER TO postgres;

--
-- Name: COLUMN scheduled_report_log.attachment_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduled_report_log.attachment_path IS 'å‘é€çš„é™„ä»¶è·¯å¾„';


--
-- Name: scheduled_report_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.scheduled_report_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.scheduled_report_log_id_seq OWNER TO postgres;

--
-- Name: scheduled_report_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.scheduled_report_log_id_seq OWNED BY public.scheduled_report_log.id;


--
-- Name: scheduler; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.scheduler (
    id integer NOT NULL,
    name character varying(255),
    active boolean,
    minute_type integer,
    minute integer,
    hour_type integer,
    hour integer,
    day_type integer,
    day integer,
    week integer,
    last_run timestamp with time zone,
    script_name character varying(255)
);


ALTER TABLE public.scheduler OWNER TO postgres;

--
-- Name: scheduler_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.scheduler_log (
    id integer NOT NULL,
    script_name character varying(200),
    start_time timestamp without time zone,
    end_time timestamp without time zone
);


ALTER TABLE public.scheduler_log OWNER TO postgres;

--
-- Name: COLUMN scheduler_log.script_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduler_log.script_name IS 'è„šæœ¬åå­—';


--
-- Name: COLUMN scheduler_log.start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduler_log.start_time IS 'è„šæœ¬å¼€å§‹æ‰§è¡Œæ—¶é—´';


--
-- Name: COLUMN scheduler_log.end_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.scheduler_log.end_time IS 'æ‰§è¡Œç»“æŸæ—¶é—´';


--
-- Name: scheduler_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.scheduler_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.scheduler_log_id_seq OWNER TO postgres;

--
-- Name: scheduler_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.scheduler_log_id_seq OWNED BY public.scheduler_log.id;


--
-- Name: search_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.search_logs (
    id integer NOT NULL,
    type character varying(100) NOT NULL,
    search_val character varying(100),
    search_time timestamp without time zone,
    client_id integer,
    module character varying(100)
);


ALTER TABLE public.search_logs OWNER TO postgres;

--
-- Name: COLUMN search_logs.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.search_logs.type IS '--code
--code_name
--country
--order_id';


--
-- Name: COLUMN search_logs.search_val; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.search_logs.search_val IS 'æŸ¥è¯¢çš„å†…å®¹';


--
-- Name: search_logs_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.search_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.search_logs_id_seq OWNER TO postgres;

--
-- Name: search_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.search_logs_id_seq OWNED BY public.search_logs.id;


--
-- Name: sell_order; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sell_order (
    id integer NOT NULL,
    name character varying(40),
    client_id integer NOT NULL,
    resource_id integer NOT NULL,
    code_deck_id integer DEFAULT 1,
    rate numeric(30,10),
    is_private boolean DEFAULT false NOT NULL,
    is_commit boolean DEFAULT false NOT NULL,
    commit_minutes integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    update_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    cli boolean DEFAULT false NOT NULL,
    g729 boolean DEFAULT false NOT NULL,
    fax boolean DEFAULT false NOT NULL,
    active boolean DEFAULT true NOT NULL,
    status integer DEFAULT 0 NOT NULL,
    expire_time timestamp with time zone,
    country character varying(100),
    acd real,
    asr real,
    user_id integer NOT NULL,
    dtmf boolean DEFAULT false NOT NULL,
    state_date timestamp with time zone NOT NULL,
    end_date timestamp with time zone,
    limit_price numeric(30,10),
    g723 boolean DEFAULT false NOT NULL,
    g711 boolean DEFAULT false NOT NULL,
    time_of_date boolean DEFAULT false NOT NULL,
    peak boolean DEFAULT false NOT NULL,
    offpeak boolean DEFAULT false NOT NULL,
    weekend boolean DEFAULT false NOT NULL,
    invite_id integer,
    partner_id integer,
    resource_prefix public.prefix_range DEFAULT ''::public.prefix_range NOT NULL,
    route_type integer DEFAULT 1 NOT NULL,
    asr_var real,
    acd_var real,
    rate_only boolean DEFAULT false NOT NULL,
    match_type integer DEFAULT 2 NOT NULL,
    route_priority integer DEFAULT 1 NOT NULL,
    auto_match boolean DEFAULT false NOT NULL,
    auto_match_result integer,
    dialer boolean DEFAULT false NOT NULL,
    "interval" integer DEFAULT 1 NOT NULL,
    "limit" integer,
    is_select integer DEFAULT 0 NOT NULL,
    purged boolean DEFAULT false NOT NULL,
    cli_type integer DEFAULT 0 NOT NULL,
    minimal_duration integer DEFAULT 1 NOT NULL,
    pdd_timeout integer,
    auto_match_time timestamp with time zone,
    is_first integer
);


ALTER TABLE public.sell_order OWNER TO postgres;

--
-- Name: COLUMN sell_order.route_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sell_order.route_type IS '1: Prime,2:Select,2: Direct
';


--
-- Name: COLUMN sell_order.match_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sell_order.match_type IS '1:var2:soft3:hard';


--
-- Name: COLUMN sell_order.route_priority; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sell_order.route_priority IS '1--quality
2--price';


--
-- Name: COLUMN sell_order.auto_match_result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sell_order.auto_match_result IS '0-fail
1-success';


--
-- Name: COLUMN sell_order.is_select; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sell_order.is_select IS '0--æ²¡æœ‰é€‰å®š
1--å–æ¶ˆé€‰å®š
2--é€‰å®š
3--ç¡®è®¤é€‰å®š';


--
-- Name: COLUMN sell_order.cli_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sell_order.cli_type IS '0-white
1-white non cli
2-grey';


--
-- Name: COLUMN sell_order.is_first; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sell_order.is_first IS '1-æŽ’åœ¨ç¬¬ä¸€ä½
2-å¤±åŽ»ç¬¬ä¸€ä½
3-æŽ’åœ¨ç¬¬ä¸€ä½å·²å‘é€é‚®ä»¶
4-å¤±åŽ»ç¬¬ä¸€ä½å·²å‘é€é‚®ä»¶';


--
-- Name: sell_order_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sell_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sell_order_id_seq OWNER TO postgres;

--
-- Name: sell_order_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.sell_order_id_seq OWNED BY public.sell_order.id;


--
-- Name: sell_order_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sell_order_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sell_order_record_record_id_seq OWNER TO postgres;

--
-- Name: sell_order_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sell_order_record (
    id integer,
    name character varying(40),
    client_id integer,
    resource_id integer,
    code_deck_id integer,
    rate numeric(30,10),
    is_private boolean,
    is_commit boolean,
    commit_minutes integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    cli boolean,
    g729 boolean,
    fax boolean,
    active boolean,
    status integer,
    expire_time timestamp with time zone,
    country character varying(100),
    acd real,
    asr real,
    user_id integer,
    dtmf boolean,
    state_date timestamp with time zone,
    end_date timestamp with time zone,
    limit_price numeric(30,10),
    g723 boolean,
    g711 boolean,
    time_of_date boolean,
    peak boolean,
    offpeak boolean,
    weekend boolean,
    invite_id integer,
    partner_id integer,
    resource_prefix public.prefix_range,
    route_type integer,
    asr_var real,
    acd_var real,
    rate_only boolean,
    match_type integer,
    route_priority integer,
    auto_match boolean,
    auto_match_result integer,
    dialer boolean,
    "interval" integer,
    "limit" integer,
    is_select integer,
    purged boolean,
    cli_type integer,
    minimal_duration integer,
    pdd_timeout integer,
    auto_match_time timestamp with time zone,
    is_first integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.sell_order_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.sell_order_record OWNER TO postgres;

--
-- Name: sell_order_response; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sell_order_response (
    id integer NOT NULL,
    sell_order_id integer,
    client_id integer,
    is_commit boolean DEFAULT true NOT NULL,
    commit_minutes integer,
    create_time timestamp with time zone,
    update_time timestamp with time zone,
    status integer DEFAULT 0 NOT NULL,
    expire_time timestamp with time zone,
    resource_id integer
);


ALTER TABLE public.sell_order_response OWNER TO postgres;

--
-- Name: COLUMN sell_order_response.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sell_order_response.client_id IS 'ä¹°è€…çš„client_id';


--
-- Name: sell_order_response_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sell_order_response_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sell_order_response_id_seq OWNER TO postgres;

--
-- Name: sell_order_response_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.sell_order_response_id_seq OWNED BY public.sell_order_response.id;


--
-- Name: send_mails; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.send_mails (
    id integer NOT NULL,
    client_id integer,
    mail_subject character varying(200),
    mail_content text,
    mail_to character varying(200),
    mail_cc character varying(200),
    files character varying(200)[],
    status integer DEFAULT 0,
    send_time time with time zone
);


ALTER TABLE public.send_mails OWNER TO postgres;

--
-- Name: COLUMN send_mails.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.send_mails.status IS '0 - waiting
1 - done
-1 - error

';


--
-- Name: send_mails_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.send_mails_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.send_mails_id_seq OWNER TO postgres;

--
-- Name: send_mails_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.send_mails_id_seq OWNED BY public.send_mails.id;


--
-- Name: send_rate_preserved_data; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.send_rate_preserved_data (
    id integer NOT NULL,
    rate_id integer NOT NULL,
    email_cc character varying(255) NOT NULL,
    subject character varying(255) NOT NULL,
    content character varying(255) NOT NULL,
    format integer,
    zipped boolean,
    start_effective_date text,
    email_template integer
);


ALTER TABLE public.send_rate_preserved_data OWNER TO postgres;

--
-- Name: send_rate_preserved_data_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.send_rate_preserved_data_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.send_rate_preserved_data_id_seq OWNER TO postgres;

--
-- Name: send_rate_preserved_data_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.send_rate_preserved_data_id_seq OWNED BY public.send_rate_preserved_data.id;


--
-- Name: send_rate_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.send_rate_template (
    id integer NOT NULL,
    name character varying(200),
    subject character varying(200),
    content text
);


ALTER TABLE public.send_rate_template OWNER TO postgres;

--
-- Name: send_rate_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.send_rate_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.send_rate_template_id_seq OWNER TO postgres;

--
-- Name: send_rate_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.send_rate_template_id_seq OWNED BY public.send_rate_template.id;


--
-- Name: server_platform_server_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.server_platform_server_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.server_platform_server_id_seq OWNER TO postgres;

--
-- Name: server_platform; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.server_platform (
    server_id integer DEFAULT nextval('public.server_platform_server_id_seq'::regclass) NOT NULL,
    server_type integer,
    ip public.ip4r NOT NULL,
    enable_register boolean DEFAULT false,
    port integer,
    project_type integer,
    info_ip public.ip4r,
    info_port integer,
    name character varying(200),
    sip_ip public.ip4r,
    sip_port integer,
    sip_path character varying(500)
);


ALTER TABLE public.server_platform OWNER TO postgres;

--
-- Name: TABLE server_platform; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.server_platform IS 'ç³»ç»Ÿå¹³å°åœ°å€';


--
-- Name: COLUMN server_platform.server_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.server_platform.server_id IS 'ä¸»é”®';


--
-- Name: COLUMN server_platform.server_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.server_platform.server_type IS '0ï¼ï¼class4
1ï¼ï¼sip proxy
2---sipcapture server
è´Ÿè´£æ³¨å†Œçš„';


--
-- Name: COLUMN server_platform.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.server_platform.ip IS 'ip';


--
-- Name: COLUMN server_platform.enable_register; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.server_platform.enable_register IS 'å‘é€æ³¨å†Œè¯·æ±‚çš„class4';


--
-- Name: COLUMN server_platform.project_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.server_platform.project_type IS 'é¡¹ç›®é…ç½®
1--exchange
2--wholesales
3--partition


';


--
-- Name: service_charge; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.service_charge (
    service_charge_id integer NOT NULL,
    name character varying(40) NOT NULL,
    buy_rate numeric(30,10) DEFAULT 0 NOT NULL,
    less_buy_rate_fee numeric(30,10),
    greater_buy_rate_fee numeric(30,10),
    sell_rate numeric(30,10),
    less_sell_rate_fee numeric(30,10),
    greater_sell_rate_fee numeric(30,10),
    buy_max_rate numeric(30,10),
    greater_buy_max_rate_fee numeric(30,10),
    sell_max_rate numeric(30,10),
    greater_sell_max_rate_fee numeric(30,10)
);


ALTER TABLE public.service_charge OWNER TO postgres;

--
-- Name: COLUMN service_charge.buy_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.service_charge.buy_rate IS 'æ‰“è¿›è´¹çŽ‡';


--
-- Name: COLUMN service_charge.less_buy_rate_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.service_charge.less_buy_rate_fee IS 'å°äºŽæ‰“è¿›rateçš„æ—¶å€™ï¼Œæ¯åˆ†é’Ÿå¤šå°‘è´¹ç”¨';


--
-- Name: COLUMN service_charge.greater_buy_rate_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.service_charge.greater_buy_rate_fee IS 'å¤§äºŽæˆ–ç­‰äºŽæ‰“è¿›rate
å¹¶ä¸”
å°äºŽæ‰“è¿›max rateçš„æ—¶å€™ï¼Œæ¯åˆ†é’Ÿå¤šå°‘è´¹ç”¨';


--
-- Name: COLUMN service_charge.sell_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.service_charge.sell_rate IS 'æ‰“å‡ºè´¹çŽ‡';


--
-- Name: COLUMN service_charge.buy_max_rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.service_charge.buy_max_rate IS 'æ‰“è¿›æœ€å¤§è´¹çŽ‡';


--
-- Name: COLUMN service_charge.greater_buy_max_rate_fee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.service_charge.greater_buy_max_rate_fee IS 'å¤§äºŽæˆ–ç­‰äºŽæ‰“è¿›max rateçš„æ—¶å€™ï¼Œæ¯åˆ†é’Ÿå¤šå°‘è´¹ç”¨';


--
-- Name: service_charge_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.service_charge_items (
    id integer NOT NULL,
    min_rate numeric(30,10),
    max_rate numeric(30,10),
    charge_value real,
    service_charge_id integer
);


ALTER TABLE public.service_charge_items OWNER TO postgres;

--
-- Name: TABLE service_charge_items; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.service_charge_items IS 'exchangeçš„æœåŠ¡è´¹è¡¨';


--
-- Name: service_charge_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.service_charge_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.service_charge_items_id_seq OWNER TO postgres;

--
-- Name: service_charge_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.service_charge_items_id_seq OWNED BY public.service_charge_items.id;


--
-- Name: service_charge_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.service_charge_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.service_charge_items_record_record_id_seq OWNER TO postgres;

--
-- Name: service_charge_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.service_charge_items_record (
    id integer,
    min_rate numeric(30,10),
    max_rate numeric(30,10),
    charge_value real,
    service_charge_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.service_charge_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.service_charge_items_record OWNER TO postgres;

--
-- Name: service_charge_items_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.service_charge_items_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.service_charge_items_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: service_charge_items_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.service_charge_items_record_tmp (
    id integer,
    min_rate numeric(30,10),
    max_rate numeric(30,10),
    charge_value real,
    service_charge_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.service_charge_items_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.service_charge_items_record_tmp OWNER TO postgres;

--
-- Name: service_charge_service_charge_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.service_charge_service_charge_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.service_charge_service_charge_id_seq OWNER TO postgres;

--
-- Name: service_charge_service_charge_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.service_charge_service_charge_id_seq OWNED BY public.service_charge.service_charge_id;


--
-- Name: shceduler_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.shceduler_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.shceduler_id_seq OWNER TO postgres;

--
-- Name: shceduler_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.shceduler_id_seq OWNED BY public.scheduler.id;


--
-- Name: signup; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.signup (
    id integer NOT NULL,
    company character varying(100),
    login character varying(40),
    password character varying(50),
    address character varying(500),
    email character varying(100),
    noc_email character varying(100),
    billing_email character varying(100),
    rate_email character varying(100),
    rate_delivery_email character varying(100),
    tax_id character varying(100),
    details character varying(1000),
    phone character varying(32),
    status smallint DEFAULT 0,
    modify_time timestamp with time zone,
    signup_time timestamp with time zone,
    send_email smallint DEFAULT 0,
    contact_name character varying(100),
    city character varying(40),
    state character varying(40),
    zip character varying(40),
    country character varying(40),
    billing_address character varying(1000),
    billing_city character varying(40),
    billing_state character varying(40),
    billing_zip character varying(40),
    billing_country character varying(40),
    billing_contact_name character varying(40),
    billing_phone character varying(40),
    product_id character varying(100),
    agent_assoc_id integer
);


ALTER TABLE public.signup OWNER TO postgres;

--
-- Name: COLUMN signup.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.signup.status IS '0-Unconfirmed;1-Approve; 2- Reject';


--
-- Name: COLUMN signup.send_email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.signup.send_email IS '0-not;1-success;2-fail';


--
-- Name: signup_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.signup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.signup_id_seq OWNER TO postgres;

--
-- Name: signup_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.signup_id_seq OWNED BY public.signup.id;


--
-- Name: signup_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.signup_ip (
    id integer NOT NULL,
    signup_id integer NOT NULL,
    ip public.ip4r,
    port integer DEFAULT 5060,
    netmark integer DEFAULT 32
);


ALTER TABLE public.signup_ip OWNER TO postgres;

--
-- Name: signup_ip_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.signup_ip_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.signup_ip_id_seq OWNER TO postgres;

--
-- Name: signup_ip_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.signup_ip_id_seq OWNED BY public.signup_ip.id;


--
-- Name: sip_error_code_sip_error_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sip_error_code_sip_error_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sip_error_code_sip_error_code_id_seq OWNER TO postgres;

--
-- Name: sip_error_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sip_error_code (
    sip_error_code_id integer DEFAULT nextval('public.sip_error_code_sip_error_code_id_seq'::regclass) NOT NULL,
    return_code integer NOT NULL,
    return_code_str character varying(100),
    switch_error_code integer,
    switch_error_code_str character varying(100),
    resource_id integer
);


ALTER TABLE public.sip_error_code OWNER TO postgres;

--
-- Name: TABLE sip_error_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.sip_error_code IS 'é”™è¯¯ç ';


--
-- Name: COLUMN sip_error_code.sip_error_code_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sip_error_code.sip_error_code_id IS 'ä¸»é”®';


--
-- Name: COLUMN sip_error_code.return_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sip_error_code.return_code IS 'è¿”å›žçŠ¶æ€å€¼';


--
-- Name: COLUMN sip_error_code.switch_error_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sip_error_code.switch_error_code IS '0-19';


--
-- Name: sip_error_code_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sip_error_code_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sip_error_code_record_record_id_seq OWNER TO postgres;

--
-- Name: sip_error_code_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sip_error_code_record (
    sip_error_code_id integer,
    return_code integer,
    return_code_str character varying(100),
    switch_error_code integer,
    switch_error_code_str character varying(100),
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.sip_error_code_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.sip_error_code_record OWNER TO postgres;

--
-- Name: sip_error_code_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sip_error_code_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sip_error_code_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: sip_error_code_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sip_error_code_record_tmp (
    sip_error_code_id integer,
    return_code integer,
    return_code_str character varying(100),
    switch_error_code integer,
    switch_error_code_str character varying(100),
    resource_id integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.sip_error_code_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.sip_error_code_record_tmp OWNER TO postgres;

--
-- Name: sip_registrations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sip_registrations (
    id integer NOT NULL,
    username character varying(40) NOT NULL,
    network_ip public.ip4,
    network_port integer,
    status smallint DEFAULT 0 NOT NULL,
    expires integer,
    contact character varying(256),
    uptime bigint
);


ALTER TABLE public.sip_registrations OWNER TO postgres;

--
-- Name: COLUMN sip_registrations.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sip_registrations.status IS '0 for un-register; 1 for registered; 2 for register failed';


--
-- Name: sip_registrations_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sip_registrations_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sip_registrations_id_seq OWNER TO postgres;

--
-- Name: sip_registrations_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.sip_registrations_id_seq OWNED BY public.sip_registrations.id;


--
-- Name: sip_requests; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sip_requests (
    id integer NOT NULL,
    username character varying(255),
    query_key character varying(255),
    switch_ip character varying(255),
    date timestamp without time zone DEFAULT now() NOT NULL,
    start_time bigint,
    duration integer,
    call_id character varying(255),
    client_id integer
);


ALTER TABLE public.sip_requests OWNER TO postgres;

--
-- Name: sip_requests_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sip_requests_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sip_requests_id_seq OWNER TO postgres;

--
-- Name: sip_requests_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.sip_requests_id_seq OWNED BY public.sip_requests.id;


--
-- Name: softroute_settings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.softroute_settings (
    p_server_ip public.ip4r,
    p_server_port integer,
    s_server_ip public.ip4r,
    s_server_port integer,
    timeout integer,
    retry integer
);


ALTER TABLE public.softroute_settings OWNER TO postgres;

--
-- Name: spam_traffic_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.spam_traffic_ip (
    ip character varying(30) NOT NULL,
    brief character varying(100),
    created_by character varying,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    netmask integer,
    auto_block boolean DEFAULT false
);


ALTER TABLE public.spam_traffic_ip OWNER TO postgres;

--
-- Name: spam_traffic_ip_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.spam_traffic_ip_record (
    ip character varying(30),
    brief character varying(100),
    created_by character varying,
    create_time timestamp with time zone,
    netmask integer,
    auto_block boolean,
    "time" numeric,
    flag character(1),
    record_id integer NOT NULL
);


ALTER TABLE public.spam_traffic_ip_record OWNER TO postgres;

--
-- Name: spam_traffic_ip_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.spam_traffic_ip_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.spam_traffic_ip_record_record_id_seq OWNER TO postgres;

--
-- Name: spam_traffic_ip_record_record_id_seq1; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.spam_traffic_ip_record_record_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.spam_traffic_ip_record_record_id_seq1 OWNER TO postgres;

--
-- Name: spam_traffic_ip_record_record_id_seq1; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.spam_traffic_ip_record_record_id_seq1 OWNED BY public.spam_traffic_ip_record.record_id;


--
-- Name: sqlmapfile; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sqlmapfile (
    data character(10000)
);


ALTER TABLE public.sqlmapfile OWNER TO postgres;

--
-- Name: stats_buy_order; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stats_buy_order (
    id integer NOT NULL,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    call_duration real,
    asr real,
    acd real,
    ca integer,
    success_calls integer,
    failed_calls integer,
    avg_buy_rate numeric(30,10),
    avg_sell_rate numeric(30,10),
    total_buy_volume integer,
    total_sell_volume integer,
    stat_time timestamp with time zone
);


ALTER TABLE public.stats_buy_order OWNER TO postgres;

--
-- Name: stats_buy_order_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stats_buy_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stats_buy_order_id_seq OWNER TO postgres;

--
-- Name: stats_buy_order_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.stats_buy_order_id_seq OWNED BY public.stats_buy_order.id;


--
-- Name: stats_buy_order_summary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stats_buy_order_summary (
    id integer,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    ca integer,
    ok_calls integer,
    minutes real,
    week_ca integer,
    week_ok_calls integer,
    week_minutes real,
    mtd_ca integer,
    mtd_ok_calls integer,
    mtd_minutes real,
    cost numeric(30,10),
    mtd_cost numeric(30,10),
    pdd integer,
    week_pdd integer,
    mtd_pdd integer,
    week_cost numeric(30,10)
);


ALTER TABLE public.stats_buy_order_summary OWNER TO postgres;

--
-- Name: stats_sell_order; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stats_sell_order (
    id integer NOT NULL,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    call_duration real,
    asr real,
    acd real,
    ca integer,
    success_calls integer,
    failed_calls integer,
    avg_buy_rate numeric(30,10),
    avg_sell_rate numeric(30,10),
    total_buy_volume integer,
    total_sell_volume integer,
    stat_time timestamp with time zone
);


ALTER TABLE public.stats_sell_order OWNER TO postgres;

--
-- Name: stats_sell_order_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stats_sell_order_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stats_sell_order_id_seq OWNER TO postgres;

--
-- Name: stats_sell_order_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.stats_sell_order_id_seq OWNED BY public.stats_sell_order.id;


--
-- Name: stats_sell_order_summary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stats_sell_order_summary (
    id integer,
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    ca integer,
    ok_calls integer,
    minutes real,
    week_ca integer,
    week_ok_calls integer,
    week_minutes real,
    mtd_ca integer,
    mtd_ok_calls integer,
    mtd_minutes real,
    cost numeric(30,10),
    mtd_cost numeric(30,10),
    pdd integer,
    week_pdd integer,
    mtd_pdd integer,
    week_cost numeric(30,10)
);


ALTER TABLE public.stats_sell_order_summary OWNER TO postgres;

--
-- Name: stats_trunk_origination; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stats_trunk_origination (
    client_id integer,
    resource_id integer,
    trunk_id_origination character varying(100),
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    ca bigint,
    ok_calls bigint,
    minutes real,
    yesday_ca bigint,
    yesday_ok_calls bigint,
    yesday_minutes real,
    week_ca integer,
    week_ok_calls bigint,
    week_minutes real,
    mtd_ca integer,
    mtd_ok_calls bigint,
    mtd_minutes real,
    cost numeric(30,10),
    pdd integer,
    yesday_pdd integer,
    mtd_pdd integer,
    yesday_cost numeric(30,10),
    mtd_cost numeric(30,10),
    week_pdd integer,
    week_cost numeric(30,10)
);


ALTER TABLE public.stats_trunk_origination OWNER TO postgres;

--
-- Name: stats_trunk_termination; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stats_trunk_termination (
    client_id integer,
    resource_id integer,
    trunk_id_termination character varying(100),
    country character varying(100),
    code_name character varying(100),
    code character varying(100),
    ca bigint,
    ok_calls bigint,
    minutes real,
    yesday_ca bigint,
    yesday_ok_calls bigint,
    yesday_minutes real,
    week_ca integer,
    week_ok_calls bigint,
    week_minutes real,
    mtd_ca integer,
    mtd_ok_calls bigint,
    mtd_minutes real,
    cost numeric(30,10),
    pdd integer,
    yesday_pdd integer,
    mtd_pdd integer,
    yesday_cost numeric(30,10),
    mtd_cost numeric(30,10),
    week_pdd integer,
    week_cost numeric(30,10)
);


ALTER TABLE public.stats_trunk_termination OWNER TO postgres;

--
-- Name: storage_config; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.storage_config (
    storage text NOT NULL,
    conf_type text,
    remote_server_port integer,
    ftp_port integer,
    storage_days integer DEFAULT 60,
    storage_days_local integer DEFAULT 60,
    remote_server_ip text,
    storage_path text,
    username text,
    password text,
    ftp_ip text,
    google_drive_key text,
    google_drive_name text
);


ALTER TABLE public.storage_config OWNER TO postgres;

--
-- Name: switch_profile; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.switch_profile (
    id integer NOT NULL,
    switch_name character varying(100),
    profile_name character varying(100),
    sip_ip character varying(64),
    sip_port integer,
    sip_debug integer DEFAULT 0,
    sip_trace boolean DEFAULT false NOT NULL,
    proxy_ip character varying(64),
    proxy_port integer,
    voip_gateway_id integer,
    support_rpid integer DEFAULT 0 NOT NULL,
    support_oli integer DEFAULT 0 NOT NULL,
    support_priv integer DEFAULT 0 NOT NULL,
    support_div integer DEFAULT 0 NOT NULL,
    support_paid integer DEFAULT 0 NOT NULL,
    support_pci integer DEFAULT 0 NOT NULL,
    support_x_lrn integer DEFAULT 1 NOT NULL,
    support_x_header integer DEFAULT 1 NOT NULL,
    sip_capture_ip character varying(255),
    sip_capture_port integer,
    sip_capture_path character varying(255),
    lan_ip character varying(255),
    lan_port integer,
    profile_status smallint,
    paid_replace_ip integer DEFAULT 0,
    auth_register integer,
    default_register integer,
    report_ip character varying(100),
    report_port integer DEFAULT 3300,
    active_call_ip character(64),
    active_call_port integer,
    cps integer,
    cap integer,
    pcap_token character varying(255)
);


ALTER TABLE public.switch_profile OWNER TO postgres;

--
-- Name: COLUMN switch_profile.paid_replace_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.switch_profile.paid_replace_ip IS 'PAIDå‘¼å‡ºIPç”¨switch profile sip ipæ›¿æ¢
0 -- false
1 -- true';


--
-- Name: COLUMN switch_profile.auth_register; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.switch_profile.auth_register IS 'æ˜¯å¦æ£€æµ‹æ³¨å†ŒçŠ¶æ€ 0 false 1 true';


--
-- Name: COLUMN switch_profile.default_register; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.switch_profile.default_register IS 'æ³¨å†Œä½¿ç”¨çš„é»˜è®¤profileï¼Œä¸€ä¸ªswitch_nameé‡Œè‡³å°‘æœ‰ä¸ªä¸€ä¸ªè®¾ç½®ä¸ºé»˜è®¤';


--
-- Name: COLUMN switch_profile.report_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.switch_profile.report_ip IS 'æŠ¥è¡¨æœåŠ¡å™¨çš„IP ç«¯å£å…±ç”¨info_port(lan_port)';


--
-- Name: switch_profile_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.switch_profile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.switch_profile_id_seq OWNER TO postgres;

--
-- Name: switch_profile_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.switch_profile_id_seq OWNED BY public.switch_profile.id;


--
-- Name: switch_profile_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.switch_profile_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.switch_profile_record_record_id_seq OWNER TO postgres;

--
-- Name: switch_profile_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.switch_profile_record (
    id integer,
    switch_name character varying(100),
    profile_name character varying(100),
    sip_ip character varying(64),
    sip_port integer,
    sip_debug integer,
    sip_trace boolean,
    proxy_ip character varying(64),
    proxy_port integer,
    voip_gateway_id integer,
    support_rpid integer,
    support_oli integer,
    support_priv integer,
    support_div integer,
    support_paid integer,
    support_pci integer,
    support_x_lrn integer,
    support_x_header integer,
    sip_capture_ip character varying(255),
    sip_capture_port integer,
    sip_capture_path character varying(255),
    lan_ip character varying(255),
    lan_port integer,
    profile_status smallint,
    paid_replace_ip integer,
    auth_register integer,
    default_register integer,
    report_ip character varying(100),
    report_port integer,
    active_call_ip character(64),
    active_call_port integer,
    cps integer,
    cap integer,
    pcap_token character varying(255),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.switch_profile_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.switch_profile_record OWNER TO postgres;

--
-- Name: switch_profile_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.switch_profile_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.switch_profile_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: switch_profile_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.switch_profile_record_tmp (
    id integer,
    switch_name character varying(100),
    profile_name character varying(100),
    sip_ip character varying(64),
    sip_port integer,
    sip_debug integer,
    sip_trace boolean,
    proxy_ip character varying(64),
    proxy_port integer,
    voip_gateway_id integer,
    support_rpid integer,
    support_oli integer,
    support_priv integer,
    support_div integer,
    support_paid integer,
    support_pci integer,
    support_x_lrn integer,
    support_x_header integer,
    sip_capture_ip character varying(255),
    sip_capture_port integer,
    sip_capture_path character varying(255),
    lan_ip character varying(255),
    lan_port integer,
    profile_status smallint,
    paid_replace_ip integer,
    auth_register integer,
    default_register integer,
    report_ip character varying(100),
    report_port integer,
    active_call_ip character(64),
    active_call_port integer,
    cps integer,
    cap integer,
    pcap_token character varying(255),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.switch_profile_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.switch_profile_record_tmp OWNER TO postgres;

--
-- Name: sys_action_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sys_action_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sys_action_id_seq OWNER TO postgres;

--
-- Name: sys_client_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sys_client_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sys_client_role_id_seq OWNER TO postgres;

--
-- Name: sys_group_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sys_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sys_group_id_seq OWNER TO postgres;

--
-- Name: sys_module; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sys_module (
    id integer NOT NULL,
    module_name character varying(100),
    order_num integer DEFAULT 10,
    status integer DEFAULT 1
);


ALTER TABLE public.sys_module OWNER TO postgres;

--
-- Name: TABLE sys_module; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.sys_module IS 'ç³»ç»Ÿæ¨¡å—è¡¨';


--
-- Name: sys_module_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sys_module_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sys_module_id_seq OWNER TO postgres;

--
-- Name: sys_module_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.sys_module_id_seq OWNED BY public.sys_module.id;


--
-- Name: sys_pri; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sys_pri (
    id integer NOT NULL,
    pri_name character varying(100) NOT NULL,
    module_id integer,
    pri_val character varying(100) NOT NULL,
    flag boolean DEFAULT true NOT NULL,
    pri_url character varying(200)
);


ALTER TABLE public.sys_pri OWNER TO postgres;

--
-- Name: TABLE sys_pri; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.sys_pri IS 'ç³»ç»ŸåŠ¨ä½œï¼Œæœ¬ç³»ç»Ÿè®¤ä¸ºæ˜¯å„æ ç›®';


--
-- Name: COLUMN sys_pri.pri_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sys_pri.pri_name IS 'æ¨¡å—åï¼Œå†…éƒ¨ä½¿ç”¨';


--
-- Name: COLUMN sys_pri.pri_val; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sys_pri.pri_val IS 'æ¨¡å—æ˜¾ç¤ºå';


--
-- Name: COLUMN sys_pri.pri_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.sys_pri.pri_url IS 'æ¨¡å—çš„urlæŒ‡å‘';


--
-- Name: sys_pri_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sys_pri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sys_pri_id_seq OWNER TO postgres;

--
-- Name: sys_pri_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.sys_pri_id_seq OWNED BY public.sys_pri.id;


--
-- Name: sys_role_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sys_role_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sys_role_role_id_seq OWNER TO postgres;

--
-- Name: sys_role; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sys_role (
    role_id integer DEFAULT nextval('public.sys_role_role_id_seq'::regclass) NOT NULL,
    role_name character varying(100),
    role_info character varying(1000),
    view_all boolean DEFAULT false,
    delete_invoice smallint DEFAULT 0,
    delete_payment smallint DEFAULT 0,
    delete_credit_note smallint DEFAULT 0,
    delete_debit_note smallint DEFAULT 0,
    reset_balance smallint DEFAULT 0,
    modify_credit_limit smallint DEFAULT 0,
    modify_min_profit smallint DEFAULT 0,
    view_cost_and_rate smallint DEFAULT 1
);


ALTER TABLE public.sys_role OWNER TO postgres;

--
-- Name: sys_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sys_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sys_role_id_seq OWNER TO postgres;

--
-- Name: sys_role_pri; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sys_role_pri (
    id integer NOT NULL,
    role_id integer,
    pri_name character varying(100) NOT NULL,
    model_r boolean DEFAULT false NOT NULL,
    model_w boolean DEFAULT false NOT NULL,
    model_x boolean DEFAULT false NOT NULL
);


ALTER TABLE public.sys_role_pri OWNER TO postgres;

--
-- Name: sys_role_pri_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sys_role_pri_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sys_role_pri_id_seq OWNER TO postgres;

--
-- Name: sys_role_pri_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.sys_role_pri_id_seq OWNED BY public.sys_role_pri.id;


--
-- Name: sys_user_role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.sys_user_role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sys_user_role_id_seq OWNER TO postgres;

--
-- Name: sys_user_role; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.sys_user_role (
    id integer DEFAULT nextval('public.sys_user_role_id_seq'::regclass) NOT NULL,
    user_id integer NOT NULL,
    role_id integer
);


ALTER TABLE public.sys_user_role OWNER TO postgres;

--
-- Name: TABLE sys_user_role; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.sys_user_role IS 'ç”¨æˆ·è§’è‰²è¡¨';


--
-- Name: system_configure; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.system_configure (
    limit_cps integer DEFAULT 0 NOT NULL,
    limit_cap integer DEFAULT 0 NOT NULL,
    switch_name character varying(100) NOT NULL,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE public.system_configure OWNER TO postgres;

--
-- Name: system_function; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.system_function (
    system_function_id integer NOT NULL,
    description character varying(40),
    func_name character varying(50),
    is_read boolean DEFAULT true,
    is_write boolean DEFAULT true,
    is_exe boolean DEFAULT false,
    func_url character varying(50),
    func_type integer,
    key_118n character varying(50),
    parent_id integer,
    image_name character varying(50),
    develop_status integer NOT NULL
);


ALTER TABLE public.system_function OWNER TO postgres;

--
-- Name: TABLE system_function; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.system_function IS 'ç³»ç»ŸåŠŸèƒ½æˆ–é¡µé¢åˆ—è¡¨
ç³»ç»ŸåŠŸèƒ½è¡¨';


--
-- Name: COLUMN system_function.system_function_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.system_function_id IS 'ä¸»é”®
ç³»ç»ŸåŠŸèƒ½ç¼–å·';


--
-- Name: COLUMN system_function.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.description IS 'ç³»ç»ŸåŠŸèƒ½æˆ–é¡µé¢æè¿°';


--
-- Name: COLUMN system_function.func_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.func_name IS 'ç³»ç»ŸåŠŸèƒ½åç§°
è¿™ä¸ªåç§°è¦å’Œå›½é™…åŒ–æ–‡ä»¶ä¸­çš„ç³»ç»ŸåŠŸèƒ½keyå¯¹åº”';


--
-- Name: COLUMN system_function.is_read; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.is_read IS 'å¯¹æ‰€æœ‰è§’è‰²é€‚ç”¨ï¼Œä¸€ç»è®¾å®šå°†å¯¹æ‰€æœ‰è§’è‰²ç”Ÿæ•ˆï¼Œå¦‚æžœè¿™é‡Œè®¾ç½®ä¸å¯è¯»ï¼Œæ‰€æœ‰è§’è‰²å°†ä¸å¯è¯»æ­¤æ¨¡å—';


--
-- Name: COLUMN system_function.is_write; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.is_write IS 'å¯¹æ‰€æœ‰è§’è‰²é€‚ç”¨ï¼Œä¸€ç»è®¾å®šå°†å¯¹æ‰€æœ‰è§’è‰²ç”Ÿæ•ˆï¼Œå¦‚æžœè¿™é‡Œè®¾ç½®ä¸å¯å†™ï¼Œæ‰€æœ‰è§’è‰²å°†ä¸å¯å†™æ­¤æ¨¡å—';


--
-- Name: COLUMN system_function.is_exe; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.is_exe IS 'å¯¹æ‰€æœ‰è§’è‰²é€‚ç”¨ï¼Œä¸€ç»è®¾å®šå°†å¯¹æ‰€æœ‰è§’è‰²ç”Ÿæ•ˆï¼Œå¦‚æžœè¿™é‡Œè®¾ç½®ä¸å¯æ‰§è¡Œï¼Œæ‰€æœ‰è§’è‰²å°†ä¸å¯æ‰§è¡Œæ­¤æ¨¡å—ï¼ˆå¯¹æ‰§è¡Œå‘½ä»¤çš„é™å®šï¼‰';


--
-- Name: COLUMN system_function.func_url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.func_url IS 'åŠŸèƒ½æ¨¡å—æ‰€å¯¹åº”çš„url';


--
-- Name: COLUMN system_function.func_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.func_type IS 'æ¨¡å—ç±»åž‹
1.--è·¯ç”±ä¼™ä¼´
2.--ä»£ç†å•†
3--é›¶å”®å¸æˆ·
4--ç»Ÿè®¡
5-å·¥å…·
6--è·¯ç”±é…ç½®
7.--ç³»ç»Ÿé…ç½®
8--ç³»ç»Ÿç®¡ç†
9--ç­–è™ç®¡ç†
11--å……å€¼ç®¡ç†';


--
-- Name: COLUMN system_function.key_118n; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.key_118n IS 'èœå•å›½é™…åŒ–ç”¨åˆ°çš„key';


--
-- Name: COLUMN system_function.parent_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.parent_id IS 'èœå•';


--
-- Name: COLUMN system_function.image_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.image_name IS 'å›¾ç‰‡åå­—';


--
-- Name: COLUMN system_function.develop_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_function.develop_status IS 'æ¨¡å—å¼€å‘çŠ¶æ€
1--å‡†å¤‡å¼€å‘
2--å¼€å‘ä¸­
3--å¼€å‘å®Œæˆ
4ï¼ï¼ä¿®æ”¹BUG
5ï¼ï¼æµ‹è¯•ä¸­
6ï¼ï¼æ²¡æœ‰BUG
';


--
-- Name: system_function_system_function_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.system_function_system_function_id_seq
    START WITH 18
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.system_function_system_function_id_seq OWNER TO postgres;

--
-- Name: system_function_system_function_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.system_function_system_function_id_seq OWNED BY public.system_function.system_function_id;


--
-- Name: system_limit; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.system_limit (
    ingress_call_limit integer DEFAULT 1 NOT NULL,
    ingress_cps_limit integer DEFAULT 1 NOT NULL,
    egress_call_limit integer DEFAULT 1 NOT NULL,
    egress_cps_limit integer DEFAULT 1 NOT NULL
);


ALTER TABLE public.system_limit OWNER TO postgres;

--
-- Name: TABLE system_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.system_limit IS 'ç³»ç»Ÿå‘¼å«é™åˆ¶';


--
-- Name: COLUMN system_limit.ingress_call_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_limit.ingress_call_limit IS 'call limit';


--
-- Name: COLUMN system_limit.ingress_cps_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_limit.ingress_cps_limit IS 'cps limit ';


--
-- Name: COLUMN system_limit.egress_call_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_limit.egress_call_limit IS 'call limit ';


--
-- Name: COLUMN system_limit.egress_cps_limit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_limit.egress_cps_limit IS 'cps limit ';


--
-- Name: system_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.system_log (
    user_id integer,
    log_time timestamp without time zone,
    log character varying(100),
    menu character varying(50),
    id integer NOT NULL
);


ALTER TABLE public.system_log OWNER TO postgres;

--
-- Name: system_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.system_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.system_log_id_seq OWNER TO postgres;

--
-- Name: system_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.system_log_id_seq OWNED BY public.system_log.id;


--
-- Name: system_mail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.system_mail (
    smtp_type character varying(50),
    smtphost character varying(50),
    smtpport character varying(50),
    emailusername character varying(50),
    emailpassword character varying(50),
    fromemail character varying(50),
    emailname character varying(50),
    id integer NOT NULL
);


ALTER TABLE public.system_mail OWNER TO postgres;

--
-- Name: system_mail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.system_mail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.system_mail_id_seq OWNER TO postgres;

--
-- Name: system_mail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.system_mail_id_seq OWNED BY public.system_mail.id;


--
-- Name: system_parameter; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.system_parameter (
    sys_timezone character varying(20),
    sys_area character varying(50),
    mailserver_host character varying(20),
    mail_server_from character varying(50),
    de_pin_len integer,
    ftp_username character varying(50),
    ftp_pass character varying(20),
    date_format character varying(20),
    datetime_format character varying(20),
    sys_currency character varying(20),
    sys_id integer NOT NULL,
    invoices_tplno character varying(20),
    invoices_lastno character varying(20),
    invoices_fields character varying(50),
    invoices_delay character varying(10),
    invoices_separate character varying(10),
    invoices_cdr_fields character varying(80),
    dr_period character varying(10),
    radius_log_routes character varying(10),
    events_notfoundaccount boolean,
    events_notfoundtariff boolean,
    events_unprofitable boolean,
    events_alertszerotime boolean,
    "lowBalance_period" integer,
    events_deleteafterdays character varying(10),
    stats_rotate_delay character varying(10),
    rates_deleteafterdays character varying(10),
    cdrs_deleteafterdays character varying(20),
    logs_deleteafterdays character varying(10),
    backup_period character varying(10),
    backup_leave_last character varying(10),
    csv_delimiter character varying(5),
    sys_ani public.prefix_range,
    conf_number character varying(10),
    msgmonthlyfee numeric(20,3),
    fail_calls integer,
    forbidden_times integer,
    conf_max_duration integer,
    smtphost character varying(50),
    smtpport character varying(50),
    emailusername character varying(50),
    emailpassword character varying(50),
    fromemail character varying(50),
    emailname character varying(50),
    loginemail character varying(12),
    system_admin_email character varying(1000),
    switch_ip character varying(20),
    switch_port character varying(20),
    noc_email character varying(1000),
    finance_email character varying(1000),
    pdf_tpl text,
    tpl_number integer DEFAULT 0,
    rate_clean_days integer,
    smtp_secure integer DEFAULT 0,
    default_code_deck integer,
    qos_sample_period integer,
    minimal_call_attempt_required integer,
    low_call_attempt_handling integer,
    welcome_message character varying,
    report_count integer DEFAULT 0,
    realm character varying,
    workstation character varying,
    landing_page smallint DEFAULT 0,
    invoice_name character varying(200),
    auto_delivery_timezone character varying(20) DEFAULT '+00'::character varying,
    auto_delivery_address character varying(200),
    allow_cdr_fields text,
    company_info character varying(500),
    bar_color character varying(20) DEFAULT '6B9B20'::character varying,
    auto_delivery_group_by smallint DEFAULT 0,
    inactivity_timeout integer DEFAULT 30,
    is_preload boolean DEFAULT true,
    yourpay_store_number character varying(255),
    paypal_account character varying(255),
    withdraw_email character varying(1000),
    switch_alias character varying(255),
    overlap_invoice_protection boolean DEFAULT true,
    send_cdr_fields text,
    system_rate_mail character varying(255),
    ingress_pdd_timeout integer DEFAULT 60000 NOT NULL,
    egress_pdd_timeout integer DEFAULT 6000 NOT NULL,
    ring_timeout integer DEFAULT 60 NOT NULL,
    call_timeout integer DEFAULT 3600,
    invoice_send_mode integer DEFAULT 0,
    company_info_location smallint DEFAULT 0,
    daily_payment_confirmation boolean,
    daily_payment_email text,
    notify_carrier boolean,
    notify_carrier_cc text,
    payment_setting_subject character(100),
    payment_content text,
    is_show_mutual_balance smallint DEFAULT 1,
    ftp_email character varying(50),
    is_hide_unauthorized_ip smallint DEFAULT 0,
    stripe_account character varying(255),
    require_comment integer,
    auto_rate_smtp character varying(50),
    auto_rate_username character varying(100),
    auto_rate_pwd character varying(100),
    auto_rate_smtp_port integer,
    auto_rate_mail_ssl integer DEFAULT 1,
    themer integer DEFAULT 0,
    default_us_ij_rule integer,
    report_hourly_save_days integer DEFAULT 30,
    report_daily_save_days integer DEFAULT 180,
    report_code_save_days integer DEFAULT 60,
    full_cdr_save_days integer DEFAULT 30,
    simple_cdr_save_days integer DEFAULT 180,
    non_zero_cdr_save_days integer DEFAULT 60,
    invoice_decimal_digits integer DEFAULT 2,
    stripe_public_account character varying(255),
    default_billing_decimal integer DEFAULT 6 NOT NULL,
    auto_carrier_notification boolean,
    login_page_content text,
    payment_received_confirmation boolean,
    paypal_service_charge integer DEFAULT 0,
    stripe_service_charge integer DEFAULT 0,
    payment_from text,
    payment_subject text,
    payment_from_cc text,
    login_fit_image boolean,
    cdr_token character varying(255),
    cdr_token_alias character varying(255),
    cmd_debug character varying(200),
    signup_content text,
    charge_type integer DEFAULT 0,
    login_captcha character varying,
    paypal_test_mode boolean,
    base_url character varying,
    allow_registration character varying DEFAULT true,
    enable_client_download_rate character varying DEFAULT false,
    enable_client_delete_trunk character varying DEFAULT false,
    enable_client_disable_trunk character varying DEFAULT false
);


ALTER TABLE public.system_parameter OWNER TO postgres;

--
-- Name: TABLE system_parameter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.system_parameter IS 'ç³»ç»Ÿå‚æ•°';


--
-- Name: COLUMN system_parameter.sys_timezone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.sys_timezone IS 'é»˜è®¤æ—¶åŒº';


--
-- Name: COLUMN system_parameter.sys_area; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.sys_area IS 'é»˜è®¤åœ°åŒº';


--
-- Name: COLUMN system_parameter.mailserver_host; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.mailserver_host IS 'é‚®ä»¶æœåŠ¡å™¨åœ°å€:';


--
-- Name: COLUMN system_parameter.mail_server_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.mail_server_from IS 'é‚®ç®±åœ°å€';


--
-- Name: COLUMN system_parameter.de_pin_len; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.de_pin_len IS 'é»˜è®¤å¡çš„å¯†ç é•¿åº¦';


--
-- Name: COLUMN system_parameter.ftp_pass; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.ftp_pass IS 'ftpå¯†ç ';


--
-- Name: COLUMN system_parameter.datetime_format; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.datetime_format IS 'æ—¥æœŸå’Œæ—¶é—´æ ¼å¼';


--
-- Name: COLUMN system_parameter.sys_currency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.sys_currency IS 'é»˜è®¤è´§å¸:  	';


--
-- Name: COLUMN system_parameter.invoices_tplno; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.invoices_tplno IS 'å‘ç¥¨åºåˆ—å·æ¨¡æ¿';


--
-- Name: COLUMN system_parameter.invoices_lastno; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.invoices_lastno IS 'åºåˆ—å·å¼€å§‹:';


--
-- Name: COLUMN system_parameter.invoices_fields; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.invoices_fields IS 'é»˜è®¤é‡ä½æ˜¾ç¤º';


--
-- Name: COLUMN system_parameter.invoices_delay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.invoices_delay IS 'è‡ªåŠ¨å‘ç¥¨ç”Ÿæˆå»¶æœŸ';


--
-- Name: COLUMN system_parameter.invoices_separate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.invoices_separate IS 'è‡ªåŠ¨å‘ç¥¨ç”Ÿæˆæ–¹å¼:  	 ';


--
-- Name: COLUMN system_parameter.invoices_cdr_fields; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.invoices_cdr_fields IS 'å‘ç¥¨é‡Œé¢çš„cdré‡ä½';


--
-- Name: COLUMN system_parameter.dr_period; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.dr_period IS 'åˆ†æžæ—¶é•¿';


--
-- Name: COLUMN system_parameter.radius_log_routes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.radius_log_routes IS 'æ—¥å¿—';


--
-- Name: COLUMN system_parameter.events_notfoundaccount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.events_notfoundaccount IS 'æ˜¯å¦è®°å½•æ‰¾ä¸åˆ°å¸æˆ·çš„è¯å•';


--
-- Name: COLUMN system_parameter.events_notfoundtariff; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.events_notfoundtariff IS ' 	æ˜¯å¦è®°å½•æ‰¾ä¸åˆ°è´¹çŽ‡çš„è¯å•';


--
-- Name: COLUMN system_parameter.events_unprofitable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.events_unprofitable IS 'æ˜¯å¦è®°å½•äºé’±çš„è¯å•';


--
-- Name: COLUMN system_parameter.events_alertszerotime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.events_alertszerotime IS 'æ˜¯å¦è®°å½•é›¶æ—¶é•¿çš„è¯å•';


--
-- Name: COLUMN system_parameter."lowBalance_period"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter."lowBalance_period" IS 'æ¯éš”å¤šä¹…è®°å½•å®¢æˆ·ä½™é¢ä¸è¶³(å°æ—¶):';


--
-- Name: COLUMN system_parameter.events_deleteafterdays; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.events_deleteafterdays IS 'åˆ é™¤ç³»ç»Ÿæ—¥å¿—:';


--
-- Name: COLUMN system_parameter.stats_rotate_delay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.stats_rotate_delay IS 'åˆ é™¤ç³»ç»Ÿç»Ÿè®¡æ•°æ®';


--
-- Name: COLUMN system_parameter.rates_deleteafterdays; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.rates_deleteafterdays IS 'åˆ é™¤è¿‡æœŸè´¹çŽ‡æ•°æ®:';


--
-- Name: COLUMN system_parameter.cdrs_deleteafterdays; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.cdrs_deleteafterdays IS 'åˆ é™¤CDRæ¡£æ¡ˆ';


--
-- Name: COLUMN system_parameter.logs_deleteafterdays; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.logs_deleteafterdays IS 'åˆ é™¤æ—¥å¿—æ–‡ä»¶';


--
-- Name: COLUMN system_parameter.backup_period; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.backup_period IS 'backup_period';


--
-- Name: COLUMN system_parameter.backup_leave_last; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.backup_leave_last IS 'åªä¿ç•™çš„å¤‡ä»½æ¡£æ¡ˆæ•°';


--
-- Name: COLUMN system_parameter.sys_ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.sys_ani IS 'ç³»ç»Ÿä¸»å«';


--
-- Name: COLUMN system_parameter.fail_calls; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.fail_calls IS 'è¿žç»­å¤±è´¥æ¬¡æ•°';


--
-- Name: COLUMN system_parameter.forbidden_times; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.forbidden_times IS 'ç¦æ­¢å‘¼å«é—´éš”æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰';


--
-- Name: COLUMN system_parameter.conf_max_duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.conf_max_duration IS 'ä¼šè®®æœ€é•¿å¤šå°‘åˆ†é’Ÿ';


--
-- Name: COLUMN system_parameter.pdf_tpl; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.pdf_tpl IS 'ç”Ÿæˆpdfæ—¶åœ¨pdfé‡Œé™„åŠ çš„ä¿¡æ¯å†…å®¹';


--
-- Name: COLUMN system_parameter.smtp_secure; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.smtp_secure IS '0-no
1-tls
2-ssl';


--
-- Name: COLUMN system_parameter.auto_delivery_group_by; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.auto_delivery_group_by IS '0 - Country
1 - Code Name
2 - Code
3 - Trunk';


--
-- Name: COLUMN system_parameter.notify_carrier; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.notify_carrier IS 'æ˜¯å¦æ¯æ¬¡Payment äº§ç”Ÿï¼Œå°±å‘é‚®ä»¶';


--
-- Name: COLUMN system_parameter.notify_carrier_cc; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.notify_carrier_cc IS 'Payment äº§ç”Ÿï¼Œå°±å‘é‚®ä»¶çš„æŠ„é€åœ°å€';


--
-- Name: COLUMN system_parameter.require_comment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.require_comment IS 'ä¿®æ”¹logæ—¶å¦‚æžœNo ï¼Œå°±ä¸éœ€è¦æ¯æ¬¡ä¿®æ”¹æˆ–æ·»åŠ ï¼Œæˆ–åˆ åŽ»éƒ½éœ€è¦å¡«å†™Comment.';


--
-- Name: COLUMN system_parameter.auto_rate_mail_ssl; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.auto_rate_mail_ssl IS '1:ssl else:tls';


--
-- Name: COLUMN system_parameter.themer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.themer IS 'ä¸»é¢˜é…è‰²';


--
-- Name: COLUMN system_parameter.default_us_ij_rule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.system_parameter.default_us_ij_rule IS '0:A-Z
1:US Non-JD
2:US JD
3:OCN-LATA-JD
4:OCN-LATA-NON-JD';


--
-- Name: system_parameter_sys_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.system_parameter_sys_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.system_parameter_sys_id_seq OWNER TO postgres;

--
-- Name: system_parameter_sys_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.system_parameter_sys_id_seq OWNED BY public.system_parameter.sys_id;


--
-- Name: task_manage; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.task_manage (
    name character varying(40) NOT NULL,
    active boolean DEFAULT true NOT NULL,
    id integer NOT NULL,
    run_type integer NOT NULL,
    run_interval integer NOT NULL,
    last_runtime timestamp with time zone,
    once_or_every integer NOT NULL,
    function_name character varying(100)
);


ALTER TABLE public.task_manage OWNER TO postgres;

--
-- Name: TABLE task_manage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.task_manage IS 'å®šæ—¶ä»»åŠ¡è®¾ç½®';


--
-- Name: COLUMN task_manage.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_manage.name IS 'åç§°';


--
-- Name: COLUMN task_manage.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_manage.active IS 'å¯ç”¨ï¼ç¦ç”¨';


--
-- Name: COLUMN task_manage.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_manage.id IS 'ä¸»é”®';


--
-- Name: COLUMN task_manage.run_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_manage.run_type IS '0ï¼ï¼æŒ‰åˆ†é’Ÿ
1ï¼ï¼æŒ‰å°æ—¶
2ï¼ï¼æŒ‰å¤©æ•°';


--
-- Name: COLUMN task_manage.run_interval; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_manage.run_interval IS 'å¤šé•¿æ—¶é—´è¿è¡Œä¸€æ¬¡';


--
-- Name: COLUMN task_manage.last_runtime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_manage.last_runtime IS 'ä¸Šæ¬¡è¿è¡Œæ—¶é—´';


--
-- Name: COLUMN task_manage.once_or_every; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_manage.once_or_every IS '1--æ‰§è¡Œä¸€æ¬¡
2--æ¯æ¬¡';


--
-- Name: task_manage_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.task_manage_id_seq
    START WITH 2
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.task_manage_id_seq OWNER TO postgres;

--
-- Name: task_manage_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.task_manage_id_seq OWNED BY public.task_manage.id;


--
-- Name: task_schedule; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.task_schedule (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    cmd_path character varying(1000) NOT NULL,
    log_path character varying(1000),
    cron_minute character varying(100),
    cron_hour character varying(100),
    cron_day character varying(100),
    cron_month character varying(100),
    cron_week character varying(100),
    flag boolean DEFAULT true NOT NULL
);


ALTER TABLE public.task_schedule OWNER TO postgres;

--
-- Name: TABLE task_schedule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.task_schedule IS 'å®šæ—¶å™¨æ•°æ®è¡¨';


--
-- Name: COLUMN task_schedule.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_schedule.name IS 'åŽå°å®šæ—¶æ‰§è¡Œçš„ç¨‹åºå';


--
-- Name: COLUMN task_schedule.cmd_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_schedule.cmd_path IS 'ç¨‹åºæ‰§è¡Œè·¯å¾„';


--
-- Name: COLUMN task_schedule.log_path; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_schedule.log_path IS 'logæ—¥å¿—è·¯å¾„ï¼Œä¸ºç©ºå†™åˆ°/dev/null
';


--
-- Name: COLUMN task_schedule.cron_minute; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_schedule.cron_minute IS 'cronçš„åˆ†é’Ÿæ ';


--
-- Name: COLUMN task_schedule.cron_hour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_schedule.cron_hour IS 'cronçš„å°æ—¶æ ';


--
-- Name: COLUMN task_schedule.cron_day; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_schedule.cron_day IS 'cronçš„æœˆä»½çš„æ—¥æœŸ';


--
-- Name: COLUMN task_schedule.cron_month; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_schedule.cron_month IS 'cronçš„æœˆä»½';


--
-- Name: COLUMN task_schedule.cron_week; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_schedule.cron_week IS 'cronçš„æ˜ŸæœŸå‡ ';


--
-- Name: COLUMN task_schedule.flag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.task_schedule.flag IS 'æ­¤ç¨‹åºæ˜¯å¦æœ‰æ•ˆ';


--
-- Name: temp_tb; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.temp_tb (
    report_time timestamp without time zone
);


ALTER TABLE public.temp_tb OWNER TO postgres;

--
-- Name: termination_global_failover; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.termination_global_failover (
    id integer NOT NULL,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100)
);


ALTER TABLE public.termination_global_failover OWNER TO postgres;

--
-- Name: TABLE termination_global_failover; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.termination_global_failover IS 'è¢«å«æ–¹è·³è½¬ç­–ç•¥

baohq20140422';


--
-- Name: COLUMN termination_global_failover.failover_strategy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.termination_global_failover.failover_strategy IS 'è·³è½¬ç­–ç•¥ç±»åž‹

baohq20140422';


--
-- Name: COLUMN termination_global_failover.from_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.termination_global_failover.from_sip_code IS 'ä»Žè¢«å«æ”¶åˆ°çš„sipç 

baohq20140422';


--
-- Name: COLUMN termination_global_failover.to_sip_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.termination_global_failover.to_sip_code IS 'è¿”å›žç»™ä¸»å«çš„sipç 

baohq20140422';


--
-- Name: COLUMN termination_global_failover.to_sip_string; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.termination_global_failover.to_sip_string IS 'è¿”å›žç»™ä¸»å«çš„sipæè¿°å­—ç¬¦ä¸²

baohq20140422';


--
-- Name: termination_global_failover_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.termination_global_failover_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.termination_global_failover_id_seq OWNER TO postgres;

--
-- Name: termination_global_failover_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.termination_global_failover_id_seq OWNED BY public.termination_global_failover.id;


--
-- Name: termination_global_failover_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.termination_global_failover_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.termination_global_failover_record_record_id_seq OWNER TO postgres;

--
-- Name: termination_global_failover_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.termination_global_failover_record (
    id integer,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.termination_global_failover_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.termination_global_failover_record OWNER TO postgres;

--
-- Name: termination_global_failover_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.termination_global_failover_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.termination_global_failover_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: termination_global_failover_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.termination_global_failover_record_tmp (
    id integer,
    failover_strategy integer,
    from_sip_code integer,
    to_sip_code integer,
    to_sip_string character varying(100),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.termination_global_failover_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.termination_global_failover_record_tmp OWNER TO postgres;

--
-- Name: test; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.test (
    dup_end_date timestamp without time zone
);


ALTER TABLE public.test OWNER TO postgres;

--
-- Name: test_device; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.test_device (
    user_name character varying(40) NOT NULL,
    pw integer NOT NULL,
    resource_id integer NOT NULL,
    test_device_id integer NOT NULL
);


ALTER TABLE public.test_device OWNER TO postgres;

--
-- Name: TABLE test_device; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.test_device IS 'æ¨¡æ‹Ÿå¯¹æŽ¥ç½‘å…³';


--
-- Name: COLUMN test_device.user_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.test_device.user_name IS 'ç”¨æˆ·åç§°';


--
-- Name: COLUMN test_device.pw; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.test_device.pw IS 'å¯†ç ';


--
-- Name: COLUMN test_device.resource_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.test_device.resource_id IS 'ç½‘å…³';


--
-- Name: COLUMN test_device.test_device_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.test_device.test_device_id IS 'ä¸»é”®';


--
-- Name: test_device_test_device_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.test_device_test_device_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.test_device_test_device_id_seq OWNER TO postgres;

--
-- Name: test_device_test_device_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.test_device_test_device_id_seq OWNED BY public.test_device.test_device_id;


--
-- Name: time_profile_time_profile_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.time_profile_time_profile_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.time_profile_time_profile_id_seq OWNER TO postgres;

--
-- Name: time_profile; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.time_profile (
    time_profile_id integer DEFAULT nextval('public.time_profile_time_profile_id_seq'::regclass) NOT NULL,
    name character varying(100) NOT NULL,
    start_time time without time zone,
    end_time time without time zone,
    start_week integer,
    end_week integer,
    type integer NOT NULL,
    time_zone character varying(10)
);


ALTER TABLE public.time_profile OWNER TO postgres;

--
-- Name: TABLE time_profile; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.time_profile IS 'æ—¶é—´æ®µç®¡ç†';


--
-- Name: COLUMN time_profile.time_profile_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.time_profile.time_profile_id IS 'ä¸»é”®';


--
-- Name: COLUMN time_profile.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.time_profile.name IS 'åç§°';


--
-- Name: COLUMN time_profile.start_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.time_profile.start_time IS ' å¼€å§‹æ—¶é—´';


--
-- Name: COLUMN time_profile.end_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.time_profile.end_time IS 'ç»“æŸæ—¶é—´';


--
-- Name: COLUMN time_profile.start_week; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.time_profile.start_week IS '0ï¼šæ˜ŸæœŸå¤©
1ï¼6ï¼šæ˜ŸæœŸ1ï¼æ˜ŸæœŸ6';


--
-- Name: COLUMN time_profile.end_week; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.time_profile.end_week IS '0ï¼šæ˜ŸæœŸå¤©
1ï¼6ï¼šæ˜ŸæœŸ1ï¼æ˜ŸæœŸ6';


--
-- Name: COLUMN time_profile.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.time_profile.type IS '0ï¼šall time
1ï¼šweekly
2ï¼šdaily';


--
-- Name: time_profile_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.time_profile_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.time_profile_record_record_id_seq OWNER TO postgres;

--
-- Name: time_profile_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.time_profile_record (
    time_profile_id integer,
    name character varying(100),
    start_time time without time zone,
    end_time time without time zone,
    start_week integer,
    end_week integer,
    type integer,
    time_zone character varying(10),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.time_profile_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.time_profile_record OWNER TO postgres;

--
-- Name: time_profile_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.time_profile_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.time_profile_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: time_profile_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.time_profile_record_tmp (
    time_profile_id integer,
    name character varying(100),
    start_time time without time zone,
    end_time time without time zone,
    start_week integer,
    end_week integer,
    type integer,
    time_zone character varying(10),
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.time_profile_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.time_profile_record_tmp OWNER TO postgres;

--
-- Name: traffic_alert; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.traffic_alert (
    id integer NOT NULL,
    less_hour integer,
    greater_hour integer,
    email character(255),
    carriers character varying(500),
    code_name character varying(1000),
    mail_from text,
    mail_content text,
    mail_subject text,
    active boolean
);


ALTER TABLE public.traffic_alert OWNER TO postgres;

--
-- Name: COLUMN traffic_alert.less_hour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.traffic_alert.less_hour IS 'Previous Hour Attempt Less Than';


--
-- Name: COLUMN traffic_alert.greater_hour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.traffic_alert.greater_hour IS 'Current Hour Attempt Greater Than';


--
-- Name: COLUMN traffic_alert.carriers; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.traffic_alert.carriers IS 'æ‰€é€‰çš„carrierçš„id
ä»¥é€—å·åˆ†éš”';


--
-- Name: COLUMN traffic_alert.code_name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.traffic_alert.code_name IS 'A-Z çš„Destination ä»¥é€—å·åˆ†éš”';


--
-- Name: COLUMN traffic_alert.mail_from; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.traffic_alert.mail_from IS 'å‘ä»¶äººid or defalut';


--
-- Name: COLUMN traffic_alert.mail_content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.traffic_alert.mail_content IS 'é‚®ä»¶å†…å®¹';


--
-- Name: traffic_alert_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.traffic_alert_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.traffic_alert_id_seq OWNER TO postgres;

--
-- Name: traffic_alert_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.traffic_alert_id_seq OWNED BY public.traffic_alert.id;


--
-- Name: transaction; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.transaction (
    id integer NOT NULL,
    client_id integer NOT NULL,
    buy numeric(30,10) DEFAULT 0,
    sell numeric(30,10) DEFAULT 0,
    wire_in numeric(30,10) DEFAULT 0,
    wire_out numeric(30,10) DEFAULT 0,
    bod_balance numeric(30,10) DEFAULT 0,
    date timestamp with time zone
);


ALTER TABLE public.transaction OWNER TO postgres;

--
-- Name: transaction_fee; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.transaction_fee (
    id integer NOT NULL,
    name character varying(50),
    is_default boolean
);


ALTER TABLE public.transaction_fee OWNER TO postgres;

--
-- Name: transaction_fee_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.transaction_fee_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.transaction_fee_id_seq OWNER TO postgres;

--
-- Name: transaction_fee_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.transaction_fee_id_seq OWNED BY public.transaction_fee.id;


--
-- Name: transaction_fee_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.transaction_fee_items (
    id integer NOT NULL,
    trans_type integer,
    transaction_fee_id integer,
    trans_id integer,
    use_fee real
);


ALTER TABLE public.transaction_fee_items OWNER TO postgres;

--
-- Name: COLUMN transaction_fee_items.trans_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transaction_fee_items.trans_type IS '1-payment
2-service charge';


--
-- Name: COLUMN transaction_fee_items.trans_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transaction_fee_items.trans_id IS 'payment_term_id
server_charge_items_id';


--
-- Name: transaction_fee_items_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.transaction_fee_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.transaction_fee_items_id_seq OWNER TO postgres;

--
-- Name: transaction_fee_items_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.transaction_fee_items_id_seq OWNED BY public.transaction_fee_items.id;


--
-- Name: transaction_fee_items_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.transaction_fee_items_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.transaction_fee_items_record_record_id_seq OWNER TO postgres;

--
-- Name: transaction_fee_items_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.transaction_fee_items_record (
    id integer,
    trans_type integer,
    transaction_fee_id integer,
    trans_id integer,
    use_fee real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.transaction_fee_items_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.transaction_fee_items_record OWNER TO postgres;

--
-- Name: transaction_fee_items_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.transaction_fee_items_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.transaction_fee_items_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: transaction_fee_items_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.transaction_fee_items_record_tmp (
    id integer,
    trans_type integer,
    transaction_fee_id integer,
    trans_id integer,
    use_fee real,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.transaction_fee_items_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.transaction_fee_items_record_tmp OWNER TO postgres;

--
-- Name: transaction_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.transaction_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.transaction_id_seq OWNER TO postgres;

--
-- Name: transaction_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.transaction_id_seq OWNED BY public.transaction.id;


--
-- Name: translation_item_ref_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.translation_item_ref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999
    CACHE 1;


ALTER TABLE public.translation_item_ref_id_seq OWNER TO postgres;

--
-- Name: translation_item; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.translation_item (
    ref_id integer DEFAULT nextval('public.translation_item_ref_id_seq'::regclass) NOT NULL,
    translation_id integer NOT NULL,
    ani public.prefix_range,
    dnis public.prefix_range,
    action_ani character varying(30) NOT NULL,
    action_dnis character varying(30) NOT NULL,
    ani_method integer NOT NULL,
    dnis_method integer NOT NULL
);


ALTER TABLE public.translation_item OWNER TO postgres;

--
-- Name: TABLE translation_item; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.translation_item IS 'ä¸»è¢«å«è½¬æ¢';


--
-- Name: COLUMN translation_item.ref_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.translation_item.ref_id IS 'ä¸»é”®';


--
-- Name: COLUMN translation_item.translation_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.translation_item.translation_id IS 'å·ç è½¬æ¢';


--
-- Name: COLUMN translation_item.ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.translation_item.ani IS 'ä¸»å«';


--
-- Name: COLUMN translation_item.dnis; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.translation_item.dnis IS 'è¢«å«';


--
-- Name: COLUMN translation_item.action_ani; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.translation_item.action_ani IS 'è½¬æ¢åŽçš„ä¸»å«';


--
-- Name: COLUMN translation_item.action_dnis; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.translation_item.action_dnis IS 'è½¬æ¢åŽçš„è¢«å«';


--
-- Name: COLUMN translation_item.ani_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.translation_item.ani_method IS '0ï¼ï¼å¿½ç•¥
1ï¼ï¼éƒ¨åˆ†æ›¿æ¢
2ï¼ï¼å…¨éƒ¨æ›¿æ¢';


--
-- Name: COLUMN translation_item.dnis_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.translation_item.dnis_method IS '0ï¼ï¼å¿½ç•¥
1ï¼ï¼éƒ¨åˆ†æ›¿æ¢
2ï¼ï¼å…¨éƒ¨æ›¿æ¢';


--
-- Name: translation_item_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.translation_item_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.translation_item_record_record_id_seq OWNER TO postgres;

--
-- Name: translation_item_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.translation_item_record (
    ref_id integer,
    translation_id integer,
    ani public.prefix_range,
    dnis public.prefix_range,
    action_ani character varying(30),
    action_dnis character varying(30),
    ani_method integer,
    dnis_method integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.translation_item_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.translation_item_record OWNER TO postgres;

--
-- Name: translation_item_record_tmp_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.translation_item_record_tmp_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.translation_item_record_tmp_record_id_seq OWNER TO postgres;

--
-- Name: translation_item_record_tmp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.translation_item_record_tmp (
    ref_id integer,
    translation_id integer,
    ani public.prefix_range,
    dnis public.prefix_range,
    action_ani character varying(30),
    action_dnis character varying(30),
    ani_method integer,
    dnis_method integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.translation_item_record_tmp_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.translation_item_record_tmp OWNER TO postgres;

--
-- Name: trouble_tickets_template; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.trouble_tickets_template (
    id integer NOT NULL,
    name character varying(255),
    title character varying(255),
    content text,
    created_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    updated_at timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    updated_by character varying(255)
);


ALTER TABLE public.trouble_tickets_template OWNER TO postgres;

--
-- Name: trouble_tickets_template_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.trouble_tickets_template_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.trouble_tickets_template_id_seq OWNER TO postgres;

--
-- Name: trouble_tickets_template_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.trouble_tickets_template_id_seq OWNED BY public.trouble_tickets_template.id;


--
-- Name: trunk_group; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.trunk_group (
    group_id integer NOT NULL,
    group_name character varying,
    trunk_type integer
);


ALTER TABLE public.trunk_group OWNER TO postgres;

--
-- Name: trunk_group_group_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.trunk_group_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.trunk_group_group_id_seq OWNER TO postgres;

--
-- Name: trunk_group_group_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.trunk_group_group_id_seq OWNED BY public.trunk_group.group_id;


--
-- Name: trunk_pstn_header; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.trunk_pstn_header (
    id integer NOT NULL,
    ingress_id integer,
    egress_id integer,
    rpid integer DEFAULT 0 NOT NULL,
    paid integer DEFAULT 0 NOT NULL,
    oli integer DEFAULT 0 NOT NULL,
    priv integer DEFAULT 0 NOT NULL,
    div integer DEFAULT 0 NOT NULL,
    pci integer DEFAULT 0 NOT NULL,
    rpid_id_type integer DEFAULT 1 NOT NULL,
    rpid_party integer DEFAULT 1 NOT NULL,
    rpid_privacy integer DEFAULT 1 NOT NULL,
    rpid_screen integer DEFAULT 1 NOT NULL,
    paid_privacy integer DEFAULT 1 NOT NULL
);


ALTER TABLE public.trunk_pstn_header OWNER TO postgres;

--
-- Name: COLUMN trunk_pstn_header.rpid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.rpid IS 'Remote-Party-ID: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.paid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.paid IS 'P-Asserted-Identity: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.oli; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.oli IS 'isup-oli: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.priv; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.priv IS 'Privacy: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.div; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.div IS 'Diversion: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.pci; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.pci IS 'P-Charge-Info: 0-Nerver; 1-Pass; 2-Always';


--
-- Name: COLUMN trunk_pstn_header.rpid_id_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.rpid_id_type IS '1-Subscriber; 2-User; 3-Term; 4-Proxy';


--
-- Name: COLUMN trunk_pstn_header.rpid_party; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.rpid_party IS '1-Caller; 2-Callee; 3-Proxy';


--
-- Name: COLUMN trunk_pstn_header.rpid_privacy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.rpid_privacy IS '1-Full; 2-Name; 3-Url; 4-Off; 5-Ipaddr; 6-Proxy';


--
-- Name: COLUMN trunk_pstn_header.rpid_screen; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.rpid_screen IS '1-No; 2-Yes; 3-Proxy';


--
-- Name: COLUMN trunk_pstn_header.paid_privacy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.trunk_pstn_header.paid_privacy IS '1-ID; 1-Proxy';


--
-- Name: trunk_pstn_header_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.trunk_pstn_header_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.trunk_pstn_header_id_seq OWNER TO postgres;

--
-- Name: trunk_pstn_header_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.trunk_pstn_header_id_seq OWNED BY public.trunk_pstn_header.id;


--
-- Name: trunk_pstn_header_record_record_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.trunk_pstn_header_record_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.trunk_pstn_header_record_record_id_seq OWNER TO postgres;

--
-- Name: trunk_pstn_header_record; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.trunk_pstn_header_record (
    id integer,
    ingress_id integer,
    egress_id integer,
    rpid integer,
    paid integer,
    oli integer,
    priv integer,
    div integer,
    pci integer,
    rpid_id_type integer,
    rpid_party integer,
    rpid_privacy integer,
    rpid_screen integer,
    paid_privacy integer,
    "time" numeric,
    flag character(1),
    record_id integer DEFAULT nextval('public.trunk_pstn_header_record_record_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.trunk_pstn_header_record OWNER TO postgres;

--
-- Name: trunk_relation_route; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.trunk_relation_route (
    id integer NOT NULL,
    type integer DEFAULT 2 NOT NULL,
    dynamic integer,
    static integer,
    prefix character varying,
    resource_id integer
);


ALTER TABLE public.trunk_relation_route OWNER TO postgres;

--
-- Name: trunk_relation_route_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.trunk_relation_route_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.trunk_relation_route_id_seq OWNER TO postgres;

--
-- Name: trunk_relation_route_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.trunk_relation_route_id_seq OWNED BY public.trunk_relation_route.id;


--
-- Name: trunk_stat; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.trunk_stat (
    resource_id integer,
    calls_3hr integer,
    call_24hr integer,
    duration_3hr integer,
    total_calls_3hr integer,
    term_code_name character varying(100),
    calls_1hr integer,
    duration_1hr integer,
    total_calls_1hr integer,
    total_calls_24hr integer,
    duration_24hr integer,
    total_calls_7hr integer
);


ALTER TABLE public.trunk_stat OWNER TO postgres;

--
-- Name: TABLE trunk_stat; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.trunk_stat IS 'search route çš„ calls asr acd å­˜å‚¨å€¼çš„ä½ç½® ';


--
-- Name: upload_ani_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.upload_ani_log (
    id integer NOT NULL,
    file_path character varying(255),
    upload_by character varying(200),
    upload_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone
);


ALTER TABLE public.upload_ani_log OWNER TO postgres;

--
-- Name: upload_ani_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.upload_ani_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.upload_ani_log_id_seq OWNER TO postgres;

--
-- Name: upload_ani_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.upload_ani_log_id_seq OWNED BY public.upload_ani_log.id;


--
-- Name: upload_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.upload_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.upload_log_id_seq OWNER TO postgres;

--
-- Name: us_export_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.us_export_log (
    id integer NOT NULL,
    report_type integer,
    route_plan_id integer,
    rate_table_id integer,
    start_time timestamp with time zone,
    end_time timestamp with time zone,
    status integer,
    num_of_row integer,
    create_time timestamp with time zone,
    file_name character varying(200),
    pid integer,
    error_msg text,
    trunk_id integer,
    bill_method integer
);


ALTER TABLE public.us_export_log OWNER TO postgres;

--
-- Name: COLUMN us_export_log.report_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.us_export_log.report_type IS '1:retrun_code_report';


--
-- Name: COLUMN us_export_log.bill_method; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.us_export_log.bill_method IS '0:DNIS;1:LRN';


--
-- Name: us_export_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.us_export_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.us_export_log_id_seq OWNER TO postgres;

--
-- Name: us_export_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.us_export_log_id_seq OWNED BY public.us_export_log.id;


--
-- Name: us_frequent_number_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.us_frequent_number_report (
    report_time timestamp with time zone NOT NULL,
    route_plan integer,
    ingress_id integer,
    number_type integer,
    number_code character varying(100),
    total_calls integer,
    not_zero_calls integer,
    busy_calls integer,
    cancel_calls integer,
    duration integer
);


ALTER TABLE public.us_frequent_number_report OWNER TO postgres;

--
-- Name: us_lcr_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.us_lcr_report (
    report_time timestamp with time zone NOT NULL,
    rate_table_id integer,
    route_plan integer,
    orig_jur_type integer,
    ingress_dnis_type integer,
    npanxx character varying(100),
    ingress_client_rate double precision,
    lcr1_rate double precision,
    lcr1_total_calls integer,
    lcr1_not_zero_calls integer,
    lcr2_rate double precision,
    lcr2_total_calls integer,
    lcr2_not_zero_calls integer,
    lcr3_rate double precision,
    lcr3_not_zero_calls integer,
    lcr4_rate double precision,
    lcr4_total_calls integer,
    lcr4_not_zero_calls integer,
    inter_lcr1_rate double precision,
    inter_lcr1_total_calls integer,
    inter_lcr1_not_zero_calls integer,
    inter_lcr2_rate double precision,
    inter_lcr2_total_calls integer,
    inter_lcr2_not_zero_calls integer,
    inter_lcr3_rate double precision,
    inter_lcr3_total_calls integer,
    inter_lcr3_not_zero_calls integer,
    inter_lcr4_rate double precision,
    inter_lcr4_total_calls integer,
    inter_lcr4_not_zero_calls integer,
    intra_lcr1_rate double precision,
    intra_lcr1_total_calls integer,
    intra_lcr1_not_zero_calls integer,
    intra_lcr2_rate double precision,
    intra_lcr2_total_calls integer,
    intra_lcr2_not_zero_calls integer,
    intra_lcr3_rate double precision,
    intra_lcr3_total_calls integer,
    intra_lcr3_not_zero_calls integer,
    intra_lcr4_rate double precision,
    intra_lcr4_total_calls integer,
    intra_lcr4_not_zero_calls integer,
    ij_lcr1_rate double precision,
    ij_lcr1_total_calls integer,
    ij_lcr1_not_zero_calls integer,
    ij_lcr2_rate double precision,
    ij_lcr2_total_calls integer,
    ij_lcr2_not_zero_calls integer,
    ij_lcr3_rate double precision,
    ij_lcr3_total_calls integer,
    ij_lcr3_not_zero_calls integer,
    ij_lcr4_rate double precision,
    ij_lcr4_total_calls integer,
    ij_lcr4_not_zero_calls integer,
    lcr3_total_calls integer
);


ALTER TABLE public.us_lcr_report OWNER TO postgres;

--
-- Name: us_lcr_vendor_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.us_lcr_vendor_report (
    report_time timestamp with time zone NOT NULL,
    rate_table_id integer,
    route_plan integer,
    orig_jur_type integer,
    ingress_dnis_type integer,
    npanxx character varying(100),
    of_routes integer,
    of_working integer,
    of_blocked integer,
    inter_of_routes integer,
    inter_of_working integer,
    inter_of_blocked integer,
    intra_of_routes integer,
    intra_of_working integer,
    intra_of_blocked integer,
    local_of_routes integer,
    local_of_working integer,
    local_of_blocked integer,
    ij_of_routes integer,
    ij_of_working integer,
    ij_of_blocked integer
);


ALTER TABLE public.us_lcr_vendor_report OWNER TO postgres;

--
-- Name: us_ocn_lata; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.us_ocn_lata (
    id integer NOT NULL,
    ocn character varying(10),
    lata character varying(10),
    npa character varying(100),
    nxx character varying(100),
    a_block character(1),
    effective_time timestamp with time zone
);


ALTER TABLE public.us_ocn_lata OWNER TO postgres;

--
-- Name: us_ocn_lata_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.us_ocn_lata_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.us_ocn_lata_id_seq OWNER TO postgres;

--
-- Name: us_ocn_lata_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.us_ocn_lata_id_seq OWNED BY public.us_ocn_lata.id;


--
-- Name: us_return_code_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.us_return_code_report (
    report_time timestamp with time zone NOT NULL,
    rate_table_id integer,
    route_plan integer,
    orig_jur_type integer,
    ingress_dnis_type integer,
    ingress_rate_type integer,
    cause400 integer,
    cause200 integer,
    cause503 integer,
    cause487 integer,
    cause482 integer,
    cause_other integer,
    npanxx character varying(100)
);


ALTER TABLE public.us_return_code_report OWNER TO postgres;

--
-- Name: us_termination_vendor_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.us_termination_vendor_report (
    report_time timestamp with time zone NOT NULL,
    rate_table_id integer,
    route_plan integer,
    orig_jur_type integer,
    ingress_dnis_type integer,
    egress_id integer,
    lcr1_num integer,
    lcr2_num integer,
    lcr3_num integer,
    lcr1_200_num integer,
    lcr2_200_num integer,
    lcr3_200_num integer,
    inter_lcr1_num integer,
    inter_lcr2_num integer,
    inter_lcr3_num integer,
    inter_lcr1_200_num integer,
    inter_lcr2_200_num integer,
    inter_lcr3_200_num integer,
    intra_lcr1_num integer,
    intra_lcr2_num integer,
    intra_lcr3_num integer,
    intra_lcr1_200_num integer,
    intra_lcr2_200_num integer,
    intra_lcr3_200_num integer,
    ij_lcr1_num integer,
    ij_lcr2_num integer,
    ij_lcr3_num integer,
    ij_lcr1_200_num integer,
    ij_lcr2_200_num integer,
    ij_lcr3_200_num integer
);


ALTER TABLE public.us_termination_vendor_report OWNER TO postgres;

--
-- Name: usage_report_delivery; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.usage_report_delivery (
    type smallint,
    week character(2),
    month smallint,
    hour smallint,
    carrierid character varying(500),
    ingressid character varying(500),
    egressid character varying(500),
    is_all_carrier boolean,
    time_bucket smallint,
    code_bucket smallint,
    skip_empty boolean,
    email character(100),
    id integer NOT NULL,
    all_ingress boolean,
    all_egress boolean,
    action boolean
);


ALTER TABLE public.usage_report_delivery OWNER TO postgres;

--
-- Name: COLUMN usage_report_delivery.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.type IS '1.ä¸ºdaily
2.ä¸ºweekly
3.ä¸ºmonthly';


--
-- Name: COLUMN usage_report_delivery.week; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.week IS 'M, T, W, Th, F, Sa, Su';


--
-- Name: COLUMN usage_report_delivery.month; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.month IS '1åˆ°31';


--
-- Name: COLUMN usage_report_delivery.hour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.hour IS '0åˆ°23ç‚¹';


--
-- Name: COLUMN usage_report_delivery.carrierid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.carrierid IS 'ä¿å­˜carrierID ç”¨é€—å·éš”å¼€';


--
-- Name: COLUMN usage_report_delivery.ingressid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.ingressid IS 'ingress id';


--
-- Name: COLUMN usage_report_delivery.egressid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.egressid IS 'egressid é€—å·éš”å¼€';


--
-- Name: COLUMN usage_report_delivery.is_all_carrier; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.is_all_carrier IS 'tureä¸ºå…¨é€‰';


--
-- Name: COLUMN usage_report_delivery.time_bucket; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.time_bucket IS '1ä¸ºhourly
2ä¸ºdaily';


--
-- Name: COLUMN usage_report_delivery.code_bucket; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.code_bucket IS '1.ä¸ºby code
2 ä¸º by code name';


--
-- Name: COLUMN usage_report_delivery.skip_empty; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.skip_empty IS 'ture ä¸ºè·³è¿‡
';


--
-- Name: COLUMN usage_report_delivery.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.email IS 'æŽ¥æ”¶åœ°å€';


--
-- Name: COLUMN usage_report_delivery.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.usage_report_delivery.action IS 'æ˜¯å¦åœ¨ä½¿ç”¨';


--
-- Name: usage_report_delivery_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.usage_report_delivery_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.usage_report_delivery_id_seq OWNER TO postgres;

--
-- Name: usage_report_delivery_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.usage_report_delivery_id_seq OWNED BY public.usage_report_delivery.id;


--
-- Name: user_auth_ip; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_auth_ip (
    user_id integer,
    ip public.ip4r,
    id integer NOT NULL
);


ALTER TABLE public.user_auth_ip OWNER TO postgres;

--
-- Name: TABLE user_auth_ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.user_auth_ip IS 'ç”¨æˆ·IPè®¤è¯è¡¨';


--
-- Name: user_auth_ip_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.user_auth_ip_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.user_auth_ip_id_seq OWNER TO postgres;

--
-- Name: user_auth_ip_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.user_auth_ip_id_seq OWNED BY public.user_auth_ip.id;


--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    user_id integer NOT NULL,
    name character varying(40) NOT NULL,
    password character varying(40) NOT NULL,
    role_id integer,
    reseller_id integer,
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone NOT NULL,
    active boolean DEFAULT true NOT NULL,
    client_id integer,
    email character varying(100),
    fullname character varying(100),
    user_type integer NOT NULL,
    create_user_id integer,
    last_login_time timestamp with time zone,
    card_id integer,
    is_online integer DEFAULT 2 NOT NULL,
    login_ip public.ip4r,
    default_mod integer DEFAULT 0,
    default_mod2 integer DEFAULT 0,
    last_seen timestamp with time zone,
    report_group boolean DEFAULT true NOT NULL,
    outbound_report boolean DEFAULT true NOT NULL,
    all_termination boolean DEFAULT true NOT NULL,
    show_carrier_trunk_drop_only boolean DEFAULT false NOT NULL,
    report_fields text
);


ALTER TABLE public.users OWNER TO postgres;

--
-- Name: TABLE users; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.users IS 'ç”¨æˆ·';


--
-- Name: COLUMN users.user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.user_id IS 'ä¸»é”®';


--
-- Name: COLUMN users.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.name IS 'åå­—';


--
-- Name: COLUMN users.password; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.password IS 'å¯†ç ';


--
-- Name: COLUMN users.role_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.role_id IS 'è§’è‰²';


--
-- Name: COLUMN users.reseller_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.reseller_id IS 'ä»£ç†å•†';


--
-- Name: COLUMN users.create_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.create_time IS 'å»ºç«‹æ—¶é—´';


--
-- Name: COLUMN users.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.active IS 'ç¦ç”¨ï¼Œæ¿€æ´»';


--
-- Name: COLUMN users.client_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.client_id IS 'æ‰¹å‘';


--
-- Name: COLUMN users.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.email IS 'ç”µå­é‚®ä»¶';


--
-- Name: COLUMN users.fullname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.fullname IS 'å…¨å';


--
-- Name: COLUMN users.user_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.user_type IS 'ç”¨æˆ·ç±»åž‹(éžå¸¸é‡è¦è¿™ä¸ªå­—æ®µ
æ˜¯ç”¨æˆ·ç™»å½•ç³»ç»Ÿçš„æ ‡å¿—ä½œä¸ºä¸å¯ä»¥åˆ é™¤)
1--ç®¡ç†å‘˜
2--ä»£ç†å•†
3--å®¢æˆ·(è·¯ç”±ä¼™ä¼´)
4--å¸å·å¡(account)
5--æ™®é€šç”¨æˆ·
6--ä½“éªŒç”¨æˆ·';


--
-- Name: COLUMN users.create_user_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.create_user_id IS 'åˆ›å»ºäºº';


--
-- Name: COLUMN users.last_login_time; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.last_login_time IS 'æœ€åŽç™»å½•çš„æ—¶é—´';


--
-- Name: COLUMN users.card_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.card_id IS 'è´¦å·å¡';


--
-- Name: COLUMN users.is_online; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.users.is_online IS 'æ˜¯å¦åœ¨çº¿
1ï¼ï¼åœ¨çº¿
2ï¼ï¼ç¦»çº¿
3ï¼ï¼ç¦»å¼€
ï¼ï¼ä¸å†ä½¿ç”¨ï¼Œå‡†å¤‡åˆ é™¤';


--
-- Name: users_limit; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users_limit (
    id integer NOT NULL,
    user_id integer,
    client_id integer
);


ALTER TABLE public.users_limit OWNER TO postgres;

--
-- Name: users_limit_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.users_limit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.users_limit_id_seq OWNER TO postgres;

--
-- Name: users_limit_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.users_limit_id_seq OWNED BY public.users_limit.id;


--
-- Name: users_user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.users_user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.users_user_id_seq OWNER TO postgres;

--
-- Name: users_user_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.users_user_id_seq OWNED BY public.users.user_id;


--
-- Name: vendor_invoice; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.vendor_invoice (
    vendor_invoice_id integer NOT NULL,
    client_id integer,
    invoice_time timestamp with time zone,
    billing_start timestamp with time zone,
    billing_end timestamp with time zone,
    system_mins numeric(6,2),
    billing_total numeric(7,2),
    status integer DEFAULT 0,
    system_total numeric(7,2),
    billing_mins numeric(6,2),
    file_path text,
    file_name text
);


ALTER TABLE public.vendor_invoice OWNER TO postgres;

--
-- Name: COLUMN vendor_invoice.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vendor_invoice.status IS '0:Not Billed, 1:Disputed, 2:Accepted, 3:Dispute Resolved, 4:Billed';


--
-- Name: vendor_invoice_detail; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.vendor_invoice_detail (
    id integer NOT NULL,
    vendor_invoice_id integer,
    code_name character varying(100),
    mins numeric(6,2),
    non_zero_calls integer,
    rate numeric(30,10),
    report_date date,
    total_cost numeric(8,2)
);


ALTER TABLE public.vendor_invoice_detail OWNER TO postgres;

--
-- Name: vendor_invoice_detail_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.vendor_invoice_detail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vendor_invoice_detail_id_seq OWNER TO postgres;

--
-- Name: vendor_invoice_detail_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.vendor_invoice_detail_id_seq OWNED BY public.vendor_invoice_detail.id;


--
-- Name: vendor_invoice_dispute; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.vendor_invoice_dispute (
    id integer NOT NULL,
    vendor_invoice_id integer,
    create_on timestamp with time zone,
    create_by character varying(100),
    dispute numeric(6,2),
    credit numeric(6,2),
    credit_note text
);


ALTER TABLE public.vendor_invoice_dispute OWNER TO postgres;

--
-- Name: vendor_invoice_dispute_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.vendor_invoice_dispute_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vendor_invoice_dispute_id_seq OWNER TO postgres;

--
-- Name: vendor_invoice_dispute_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.vendor_invoice_dispute_id_seq OWNED BY public.vendor_invoice_dispute.id;


--
-- Name: vendor_invoice_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.vendor_invoice_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vendor_invoice_id_seq OWNER TO postgres;

--
-- Name: vendor_invoice_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.vendor_invoice_id_seq OWNED BY public.vendor_invoice.vendor_invoice_id;


--
-- Name: vendor_test_number_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.vendor_test_number_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vendor_test_number_id_seq OWNER TO postgres;

--
-- Name: vendor_test_number_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.vendor_test_number_id_seq OWNED BY public.exchange_vendor_test_number.id;


--
-- Name: vendortest_code; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.vendortest_code (
    id integer NOT NULL,
    vendortest_project_id integer NOT NULL,
    code_name character varying(50),
    active smallint DEFAULT 0 NOT NULL
);


ALTER TABLE public.vendortest_code OWNER TO postgres;

--
-- Name: vendortest_code_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.vendortest_code_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vendortest_code_id_seq OWNER TO postgres;

--
-- Name: vendortest_code_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.vendortest_code_id_seq OWNED BY public.vendortest_code.id;


--
-- Name: vendortest_number; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.vendortest_number (
    id integer NOT NULL,
    vendortest_code_id integer NOT NULL,
    test_number character varying(100) NOT NULL,
    source_number character varying(100) NOT NULL,
    call_time integer DEFAULT 5 NOT NULL,
    sip_capture_path character varying
);


ALTER TABLE public.vendortest_number OWNER TO postgres;

--
-- Name: vendortest_number_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.vendortest_number_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vendortest_number_id_seq OWNER TO postgres;

--
-- Name: vendortest_number_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.vendortest_number_id_seq OWNED BY public.vendortest_number.id;


--
-- Name: vendortest_number_summary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.vendortest_number_summary (
    id integer NOT NULL,
    pdd integer DEFAULT 0,
    start_epoch bigint DEFAULT 0,
    ring_epoch bigint DEFAULT 0,
    answer_epoch bigint DEFAULT 0,
    end_epoch bigint DEFAULT 0,
    duration integer DEFAULT 0,
    rbt_bytes integer DEFAULT 0,
    media_bytes integer DEFAULT 0,
    packet_loss integer DEFAULT 0,
    media_path character varying(64),
    pcap_path character varying(64),
    release_cause character varying(64),
    vendortest_code_id integer,
    ani character varying(64),
    dnis character varying(64),
    bill_status integer DEFAULT 0 NOT NULL,
    bill_type integer,
    currency_id integer,
    country_id integer,
    rate_id integer,
    rate_table_id integer,
    bill_time integer DEFAULT 0 NOT NULL,
    six_seconds integer DEFAULT 0 NOT NULL,
    cost numeric(12,6) DEFAULT 0 NOT NULL,
    rate numeric(12,6),
    bill_minutes numeric(12,6) DEFAULT 0 NOT NULL,
    early_sdp integer,
    early_nosdp integer,
    answer_nosdp integer,
    result_code integer
);


ALTER TABLE public.vendortest_number_summary OWNER TO postgres;

--
-- Name: COLUMN vendortest_number_summary.bill_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vendortest_number_summary.bill_status IS '0 - æˆåŠŸ
1 - ç©ºè´¹çŽ‡
2 - è´¹çŽ‡æ‰¾ä¸åˆ°';


--
-- Name: COLUMN vendortest_number_summary.bill_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vendortest_number_summary.bill_type IS '0 - dnis
1 - lrn';


--
-- Name: COLUMN vendortest_number_summary.country_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vendortest_number_summary.country_id IS 'å¦‚æžœéžç©ºï¼Œåˆ™ä¼šåˆ¤æ–­æ˜¯å¦jurisdictionè®¡è´¹';


--
-- Name: COLUMN vendortest_number_summary.result_code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vendortest_number_summary.result_code IS '0 -- Normal Connected
1 -- FAS
2 -- Connected w/o Ring Tone
3 -- Dead Air
4 -- Normal Caller Hangup';


--
-- Name: vendortest_number_summary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.vendortest_number_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vendortest_number_summary_id_seq OWNER TO postgres;

--
-- Name: vendortest_number_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.vendortest_number_summary_id_seq OWNED BY public.vendortest_number_summary.id;


--
-- Name: vendortest_project; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.vendortest_project (
    id integer NOT NULL,
    project_name character varying(50),
    status smallint DEFAULT 0 NOT NULL,
    trunk integer NOT NULL,
    order_type integer,
    order_id integer,
    public_link_key character varying(100),
    test_trunk_id integer,
    send_email integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.vendortest_project OWNER TO postgres;

--
-- Name: COLUMN vendortest_project.order_type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.vendortest_project.order_type IS '1:buy_order
2:sell_order';


--
-- Name: vendortest_project_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.vendortest_project_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vendortest_project_id_seq OWNER TO postgres;

--
-- Name: vendortest_project_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.vendortest_project_id_seq OWNED BY public.vendortest_project.id;


--
-- Name: vendortest_project_summary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.vendortest_project_summary (
    id integer NOT NULL,
    start_epoch bigint DEFAULT 0,
    end_epoch bigint DEFAULT 0,
    pdd integer DEFAULT 0,
    pdd_count integer DEFAULT 0,
    asr real DEFAULT 0,
    asr_count integer DEFAULT 0,
    acd integer DEFAULT 0,
    acd_count integer DEFAULT 0,
    fas_count integer DEFAULT 0,
    vendortest_project_id integer
);


ALTER TABLE public.vendortest_project_summary OWNER TO postgres;

--
-- Name: vendortest_project_summary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.vendortest_project_summary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vendortest_project_summary_id_seq OWNER TO postgres;

--
-- Name: vendortest_project_summary_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.vendortest_project_summary_id_seq OWNED BY public.vendortest_project_summary.id;


--
-- Name: version_information; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.version_information (
    id integer NOT NULL,
    program_name character varying(50),
    major_ver character varying(100),
    minor_ver character varying(100),
    build_date character varying(11),
    start_time timestamp with time zone,
    licensed_cps integer,
    licensed_channel integer,
    expires timestamp with time zone,
    switch_name character varying(100),
    serial_number character varying(100)
);


ALTER TABLE public.version_information OWNER TO postgres;

--
-- Name: version_information_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.version_information_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.version_information_id_seq OWNER TO postgres;

--
-- Name: version_information_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.version_information_id_seq OWNED BY public.version_information.id;


--
-- Name: voip_gateway; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.voip_gateway (
    id integer NOT NULL,
    name character varying(200),
    paid_replace_ip integer DEFAULT 0,
    lan_ip character varying(255),
    lan_port integer,
    active_call_ip character varying(64),
    active_call_port integer,
    sip_capture_ip character varying(255),
    sip_capture_port integer,
    sip_capture_path character varying(255)
);


ALTER TABLE public.voip_gateway OWNER TO postgres;

--
-- Name: voip_gateway_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.voip_gateway_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.voip_gateway_id_seq OWNER TO postgres;

--
-- Name: voip_gateway_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.voip_gateway_id_seq OWNED BY public.voip_gateway.id;


--
-- Name: web_session; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.web_session (
    create_time timestamp with time zone DEFAULT ('now'::text)::timestamp(0) with time zone,
    user_id integer,
    host character varying(1000),
    agent character varying(1000),
    id integer NOT NULL,
    msg character varying
);


ALTER TABLE public.web_session OWNER TO postgres;

--
-- Name: web_session_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.web_session_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.web_session_id_seq OWNER TO postgres;

--
-- Name: web_session_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.web_session_id_seq OWNED BY public.web_session.id;


--
-- Name: pga_exception jexid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_exception ALTER COLUMN jexid SET DEFAULT nextval('pgagent.pga_exception_jexid_seq'::regclass);


--
-- Name: pga_job jobid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_job ALTER COLUMN jobid SET DEFAULT nextval('pgagent.pga_job_jobid_seq'::regclass);


--
-- Name: pga_jobclass jclid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_jobclass ALTER COLUMN jclid SET DEFAULT nextval('pgagent.pga_jobclass_jclid_seq'::regclass);


--
-- Name: pga_joblog jlgid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_joblog ALTER COLUMN jlgid SET DEFAULT nextval('pgagent.pga_joblog_jlgid_seq'::regclass);


--
-- Name: pga_jobstep jstid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_jobstep ALTER COLUMN jstid SET DEFAULT nextval('pgagent.pga_jobstep_jstid_seq'::regclass);


--
-- Name: pga_jobsteplog jslid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_jobsteplog ALTER COLUMN jslid SET DEFAULT nextval('pgagent.pga_jobsteplog_jslid_seq'::regclass);


--
-- Name: pga_schedule jscid; Type: DEFAULT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_schedule ALTER COLUMN jscid SET DEFAULT nextval('pgagent.pga_schedule_jscid_seq'::regclass);


--
-- Name: actual_transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.actual_transaction ALTER COLUMN id SET DEFAULT nextval('public.actual_transaction_id_seq'::regclass);


--
-- Name: admin_alert id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.admin_alert ALTER COLUMN id SET DEFAULT nextval('public.admin_alert_id_seq'::regclass);


--
-- Name: agent agent_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent ALTER COLUMN agent_id SET DEFAULT nextval('public.agent_agent_id_seq'::regclass);


--
-- Name: agent_client id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_client ALTER COLUMN id SET DEFAULT nextval('public.agent_client_id_seq'::regclass);


--
-- Name: agent_clients id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_clients ALTER COLUMN id SET DEFAULT nextval('public.agent_clients_id_seq'::regclass);


--
-- Name: agent_commission_history history_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_commission_history ALTER COLUMN history_id SET DEFAULT nextval('public.agent_commission_history_history_id_seq'::regclass);


--
-- Name: agent_commission_history_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_commission_history_detail ALTER COLUMN id SET DEFAULT nextval('public.agent_commission_history_detail_id_seq'::regclass);


--
-- Name: agent_commission_payment id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_commission_payment ALTER COLUMN id SET DEFAULT nextval('public.agent_commission_payment_id_seq'::regclass);


--
-- Name: alert_action id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_action ALTER COLUMN id SET DEFAULT nextval('public.alert_action_id_seq'::regclass);


--
-- Name: alert_condition id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_condition ALTER COLUMN id SET DEFAULT nextval('public.alert_condition_id_seq'::regclass);


--
-- Name: alert_event id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_event ALTER COLUMN id SET DEFAULT nextval('public.alert_event_id_seq'::regclass);


--
-- Name: alert_mail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_mail ALTER COLUMN id SET DEFAULT nextval('public.alert_mail_id_seq'::regclass);


--
-- Name: alert_rule id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_rule ALTER COLUMN id SET DEFAULT nextval('public.alert_rule_id_seq'::regclass);


--
-- Name: alert_rules id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_rules ALTER COLUMN id SET DEFAULT nextval('public.alert_rules_id_seq'::regclass);


--
-- Name: alert_rules_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_rules_log ALTER COLUMN id SET DEFAULT nextval('public.alert_rules_log_id_seq'::regclass);


--
-- Name: alert_rules_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_rules_log_detail ALTER COLUMN id SET DEFAULT nextval('public.alert_rules_log_detail_id_seq'::regclass);


--
-- Name: allowed_sendto_ip id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.allowed_sendto_ip ALTER COLUMN id SET DEFAULT nextval('public.allowed_sendto_ip_id_seq'::regclass);


--
-- Name: ani_blocking_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ani_blocking_log ALTER COLUMN id SET DEFAULT nextval('public.ani_blocking_log_id_seq'::regclass);


--
-- Name: api_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_log ALTER COLUMN id SET DEFAULT nextval('public.api_log_id_seq'::regclass);


--
-- Name: automatic_rate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.automatic_rate ALTER COLUMN id SET DEFAULT nextval('public.automatic_rate_id_seq'::regclass);


--
-- Name: backup_clean id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.backup_clean ALTER COLUMN id SET DEFAULT nextval('public.backup_clean_id_seq'::regclass);


--
-- Name: balance_daily_reset_task id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.balance_daily_reset_task ALTER COLUMN id SET DEFAULT nextval('public.balance_daily_reset_task_id_seq'::regclass);


--
-- Name: balance_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.balance_history ALTER COLUMN id SET DEFAULT nextval('public.balance_history_id_seq'::regclass);


--
-- Name: balance_history_actual id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.balance_history_actual ALTER COLUMN id SET DEFAULT nextval('public.balance_history_actual_id_seq'::regclass);


--
-- Name: balance_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.balance_log ALTER COLUMN id SET DEFAULT nextval('public.balance_log_id_seq'::regclass);


--
-- Name: block_ani id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_ani ALTER COLUMN id SET DEFAULT nextval('public.block_ani_id_seq'::regclass);


--
-- Name: block_log log_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_log ALTER COLUMN log_id SET DEFAULT nextval('public.block_log_log_id_seq'::regclass);


--
-- Name: block_loop id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_loop ALTER COLUMN id SET DEFAULT nextval('public.block_loop_id_seq'::regclass);


--
-- Name: block_loop_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_loop_log ALTER COLUMN id SET DEFAULT nextval('public.block_loop_log_id_seq'::regclass);


--
-- Name: block_loop_log_calls id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_loop_log_calls ALTER COLUMN id SET DEFAULT nextval('public.block_loop_log_calls_id_seq'::regclass);


--
-- Name: block_ticket id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_ticket ALTER COLUMN id SET DEFAULT nextval('public.block_ticket_id_seq'::regclass);


--
-- Name: block_trouble_ticket id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_trouble_ticket ALTER COLUMN id SET DEFAULT nextval('public.block_trouble_ticket_id_seq'::regclass);


--
-- Name: buy_order id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.buy_order ALTER COLUMN id SET DEFAULT nextval('public.buy_order_id_seq'::regclass);


--
-- Name: buy_order_response id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.buy_order_response ALTER COLUMN id SET DEFAULT nextval('public.buy_order_response_id_seq'::regclass);


--
-- Name: c4_client_balance id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.c4_client_balance ALTER COLUMN id SET DEFAULT nextval('public.c4_client_balance_id_seq'::regclass);


--
-- Name: c4_livecall_user id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.c4_livecall_user ALTER COLUMN id SET DEFAULT nextval('public.c4_livecall_user_id_seq'::regclass);


--
-- Name: c4_lrn id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.c4_lrn ALTER COLUMN id SET DEFAULT nextval('public.c4_lrn_id_seq'::regclass);


--
-- Name: call_monitor id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.call_monitor ALTER COLUMN id SET DEFAULT nextval('public.call_monitor_id_seq'::regclass);


--
-- Name: captcha captcha_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.captcha ALTER COLUMN captcha_id SET DEFAULT nextval('public.captcha_captcha_id_seq'::regclass);


--
-- Name: carrier_group group_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carrier_group ALTER COLUMN group_id SET DEFAULT nextval('public.carrier_group_group_id_seq'::regclass);


--
-- Name: carrier_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carrier_template ALTER COLUMN id SET DEFAULT nextval('public.carrier_template_id_seq'::regclass);


--
-- Name: cdr_api_export_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_api_export_log ALTER COLUMN id SET DEFAULT nextval('public.cdr_api_export_log_id_seq'::regclass);


--
-- Name: cdr_compare id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_compare ALTER COLUMN id SET DEFAULT nextval('public.cdr_compare_id_seq'::regclass);


--
-- Name: cdr_compare_cloud id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_compare_cloud ALTER COLUMN id SET DEFAULT nextval('public.cdr_compare_cloud_id_seq'::regclass);


--
-- Name: cdr_export_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_export_log ALTER COLUMN id SET DEFAULT nextval('public.cdr_export_log_id_seq'::regclass);


--
-- Name: cdr_list_export_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_list_export_log ALTER COLUMN id SET DEFAULT nextval('public.cdr_list_export_log_id_seq'::regclass);


--
-- Name: cdr_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_log ALTER COLUMN id SET DEFAULT nextval('public.cdr_log_id_seq'::regclass);


--
-- Name: cdr_report_regenerate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_report_regenerate_log ALTER COLUMN id SET DEFAULT nextval('public.cdr_report_regenerate_log_id_seq'::regclass);


--
-- Name: cdr_rerate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_rerate ALTER COLUMN id SET DEFAULT nextval('public.cdr_rerate_id_seq'::regclass);


--
-- Name: cdr_transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_transaction ALTER COLUMN id SET DEFAULT nextval('public.cdr_transaction_id_seq'::regclass);


--
-- Name: class4_call_id_cloud_shark_id_map id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.class4_call_id_cloud_shark_id_map ALTER COLUMN id SET DEFAULT nextval('public.class4_call_id_cloud_shark_id_map_id_seq'::regclass);


--
-- Name: class4_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.class4_log ALTER COLUMN id SET DEFAULT nextval('public.class4_log_id_seq'::regclass);


--
-- Name: cleanup id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cleanup ALTER COLUMN id SET DEFAULT nextval('public.cleanup_id_seq'::regclass);


--
-- Name: client_balance_operation_action id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_balance_operation_action ALTER COLUMN id SET DEFAULT nextval('public.client_balance_operation_action_id_seq'::regclass);


--
-- Name: client_commit_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_commit_code ALTER COLUMN id SET DEFAULT nextval('public.client_commit_code_id_seq'::regclass);


--
-- Name: client_commit_minutes id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_commit_minutes ALTER COLUMN id SET DEFAULT nextval('public.client_commit_minutes_id_seq'::regclass);


--
-- Name: client_finance_transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_finance_transaction ALTER COLUMN id SET DEFAULT nextval('public.client_finance_transaction_id_seq'::regclass);


--
-- Name: client_payment client_payment_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_payment ALTER COLUMN client_payment_id SET DEFAULT nextval('public.client_payment_client_payment_id_seq'::regclass);


--
-- Name: client_route_request id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_route_request ALTER COLUMN id SET DEFAULT nextval('public.client_route_request_id_seq'::regclass);


--
-- Name: client_route_request_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_route_request_code ALTER COLUMN id SET DEFAULT nextval('public.client_route_request_code_id_seq'::regclass);


--
-- Name: client_route_strategy id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_route_strategy ALTER COLUMN id SET DEFAULT nextval('public.client_route_strategy_id_seq'::regclass);


--
-- Name: client_taxes id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_taxes ALTER COLUMN id SET DEFAULT nextval('public.client_taxes_id_seq'::regclass);


--
-- Name: client_transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_transaction ALTER COLUMN id SET DEFAULT nextval('public.client_transaction_id_seq'::regclass);


--
-- Name: code_based_report_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_based_report_log ALTER COLUMN id SET DEFAULT nextval('public.code_based_report_log_id_seq'::regclass);


--
-- Name: code_based_report_log_status id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_based_report_log_status ALTER COLUMN id SET DEFAULT nextval('public.code_based_report_log_status_id_seq'::regclass);


--
-- Name: code_deck code_deck_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_deck ALTER COLUMN code_deck_id SET DEFAULT nextval('public.code_deck_code_deck_id_seq'::regclass);


--
-- Name: code_stats id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_stats ALTER COLUMN id SET DEFAULT nextval('public.code_stats_id_seq'::regclass);


--
-- Name: contract id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contract ALTER COLUMN id SET DEFAULT nextval('public.contract_id_seq'::regclass);


--
-- Name: contract confirm_order_number; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contract ALTER COLUMN confirm_order_number SET DEFAULT nextval('public.contract_confirm_order_number_seq'::regclass);


--
-- Name: contract_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contract_code ALTER COLUMN id SET DEFAULT nextval('public.contract_code_id_seq'::regclass);


--
-- Name: credit_application id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.credit_application ALTER COLUMN id SET DEFAULT nextval('public.credit_application_id_seq'::regclass);


--
-- Name: credit_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.credit_log ALTER COLUMN id SET DEFAULT nextval('public.credit_log_id_seq'::regclass);


--
-- Name: current_dashboard_data id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.current_dashboard_data ALTER COLUMN id SET DEFAULT nextval('public.current_dashboard_data_id_seq'::regclass);


--
-- Name: daily_cdr_fields id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.daily_cdr_fields ALTER COLUMN id SET DEFAULT nextval('public.daily_cdr_fields_id_seq'::regclass);


--
-- Name: dashboard_time_option id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dashboard_time_option ALTER COLUMN id SET DEFAULT nextval('public.dashboard_time_option_id_seq'::regclass);


--
-- Name: dex id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dex ALTER COLUMN id SET DEFAULT nextval('public.dex_id_seq'::regclass);


--
-- Name: dex_resource id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dex_resource ALTER COLUMN id SET DEFAULT nextval('public.dex_resource_id_seq'::regclass);


--
-- Name: dialer_detection id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dialer_detection ALTER COLUMN id SET DEFAULT nextval('public.dialer_detection_id_seq'::regclass);


--
-- Name: did_billing_brief id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_billing_brief ALTER COLUMN id SET DEFAULT nextval('public.did_billing_brief_id_seq'::regclass);


--
-- Name: did_billing_plan id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_billing_plan ALTER COLUMN id SET DEFAULT nextval('public.did_billing_plan_id_seq'::regclass);


--
-- Name: did_billing_rel id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_billing_rel ALTER COLUMN id SET DEFAULT nextval('public.did_billing_rel_id_seq'::regclass);


--
-- Name: did_number_upload_task id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_number_upload_task ALTER COLUMN id SET DEFAULT nextval('public.did_number_upload_task_id_seq'::regclass);


--
-- Name: did_request id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_request ALTER COLUMN id SET DEFAULT nextval('public.did_request_id_seq'::regclass);


--
-- Name: did_request_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_request_detail ALTER COLUMN id SET DEFAULT nextval('public.did_request_detail_id_seq'::regclass);


--
-- Name: did_special_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_special_code ALTER COLUMN id SET DEFAULT nextval('public.did_special_code_id_seq'::regclass);


--
-- Name: direct_seller_enrollment id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.direct_seller_enrollment ALTER COLUMN id SET DEFAULT nextval('public.direct_seller_enrollment_id_seq'::regclass);


--
-- Name: dynamic_route_items id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_items ALTER COLUMN id SET DEFAULT nextval('public.dynamic_route_items_id_seq'::regclass);


--
-- Name: dynamic_route_override id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_override ALTER COLUMN id SET DEFAULT nextval('public.dynamic_route_override_id_seq'::regclass);


--
-- Name: dynamic_route_pri id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_pri ALTER COLUMN id SET DEFAULT nextval('public.dynamic_route_pri_id_seq'::regclass);


--
-- Name: dynamic_route_qos id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_qos ALTER COLUMN id SET DEFAULT nextval('public.dynamic_route_qos_id_seq'::regclass);


--
-- Name: egress_profile id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.egress_profile ALTER COLUMN id SET DEFAULT nextval('public.egress_profile_id_seq'::regclass);


--
-- Name: egress_test id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.egress_test ALTER COLUMN id SET DEFAULT nextval('public.egress_test_id_seq'::regclass);


--
-- Name: egress_test_result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.egress_test_result ALTER COLUMN id SET DEFAULT nextval('public.egress_test_result_id_seq'::regclass);


--
-- Name: email_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.email_log ALTER COLUMN id SET DEFAULT nextval('public.daily_email_log_id_seq'::regclass);


--
-- Name: email_record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.email_record ALTER COLUMN id SET DEFAULT nextval('public.email_record_id_seq'::regclass);


--
-- Name: error_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.error_log ALTER COLUMN id SET DEFAULT nextval('public.error_log_id_seq'::regclass);


--
-- Name: event_log event_log_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_log ALTER COLUMN event_log_id SET DEFAULT nextval('public.event_log_event_log_id_seq'::regclass);


--
-- Name: exchange_agent_email_type id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_email_type ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_email_type_id_seq'::regclass);


--
-- Name: exchange_agent_exchange_push_list_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_exchange_push_list_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_exchange_push_list_log_id_seq'::regclass);


--
-- Name: exchange_agent_exchange_push_list_result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_exchange_push_list_result ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_exchange_push_list_result_id_seq'::regclass);


--
-- Name: exchange_agent_exchange_push_list_send_member id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_exchange_push_list_send_member ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_exchange_push_list_send_member_id_seq'::regclass);


--
-- Name: exchange_agent_generate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_generate ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_generate_id_seq'::regclass);


--
-- Name: exchange_agent_generate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_generate_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_generate_insert_send_log_id_seq'::regclass);


--
-- Name: exchange_agent_import_target_push id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_import_target_push ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_import_target_push_id_seq'::regclass);


--
-- Name: exchange_agent_import_target_push_job id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_import_target_push_job ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_import_target_push_job_id_seq'::regclass);


--
-- Name: exchange_agent_mail_tmplate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_mail_tmplate ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_mail_tmplate_id_seq'::regclass);


--
-- Name: exchange_agent_partition_login_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_partition_login_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_partition_login_log_id_seq'::regclass);


--
-- Name: exchange_agent_product_agent_mapping id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_product_agent_mapping ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_product_agent_mapping_id_seq'::regclass);


--
-- Name: exchange_agent_product_client_mapping id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_product_client_mapping ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_product_client_mapping_id_seq'::regclass);


--
-- Name: exchange_agent_product_no_route id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_product_no_route ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_product_no_route_id_seq'::regclass);


--
-- Name: exchange_agent_product_no_route_now id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_product_no_route_now ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_product_no_route_now_id_seq'::regclass);


--
-- Name: exchange_agent_product_push_list_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_product_push_list_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_product_push_list_log_id_seq'::regclass);


--
-- Name: exchange_agent_product_push_list_result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_product_push_list_result ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_product_push_list_result_id_seq'::regclass);


--
-- Name: exchange_agent_product_push_list_send_member id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_product_push_list_send_member ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_product_push_list_send_member_id_seq'::regclass);


--
-- Name: exchange_agent_send_mail_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_send_mail_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_send_mail_log_id_seq'::regclass);


--
-- Name: exchange_agent_send_mail_log_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_send_mail_log_list ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_send_mail_log_list_id_seq'::regclass);


--
-- Name: exchange_agent_send_rate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_send_rate_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_send_rate_log_id_seq'::regclass);


--
-- Name: exchange_agent_target_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_target_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_target_log_id_seq'::regclass);


--
-- Name: exchange_agent_target_result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_target_result ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_target_result_id_seq'::regclass);


--
-- Name: exchange_agent_target_send_member id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_target_send_member ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_target_send_member_id_seq'::regclass);


--
-- Name: exchange_agent_user id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_user ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_user_id_seq'::regclass);


--
-- Name: exchange_agent_vendor_test_result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_vendor_test_result ALTER COLUMN id SET DEFAULT nextval('public.exchange_agent_vendor_test_result_id_seq'::regclass);


--
-- Name: exchange_block_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_block_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_block_log_id_seq'::regclass);


--
-- Name: exchange_client_user_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_client_user_list ALTER COLUMN id SET DEFAULT nextval('public.exchange_client_user_list_id_seq'::regclass);


--
-- Name: exchange_code_name_mapping id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_code_name_mapping ALTER COLUMN id SET DEFAULT nextval('public.exchange_code_name_mapping_id_seq'::regclass);


--
-- Name: exchange_egress_did id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_egress_did ALTER COLUMN id SET DEFAULT nextval('public.exchange_egress_did_id_seq'::regclass);


--
-- Name: exchange_false_del id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_false_del ALTER COLUMN id SET DEFAULT nextval('public.exchange_false_del_id_seq'::regclass);


--
-- Name: exchange_finance id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_finance ALTER COLUMN id SET DEFAULT nextval('public.exchange_finance_id_seq'::regclass);


--
-- Name: exchange_finance_agent id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_finance_agent ALTER COLUMN id SET DEFAULT nextval('public.exchange_finance_agent_id_seq'::regclass);


--
-- Name: exchange_finance_agent_clients id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_finance_agent_clients ALTER COLUMN id SET DEFAULT nextval('public.exchange_finance_agent_clients_id_seq'::regclass);


--
-- Name: exchange_interpeering_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_interpeering_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_interpeering_log_id_seq'::regclass);


--
-- Name: exchange_job id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job ALTER COLUMN id SET DEFAULT nextval('public.exchange_job_id_seq'::regclass);


--
-- Name: exchange_job_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_list ALTER COLUMN id SET DEFAULT nextval('public.exchange_job_list_id_seq'::regclass);


--
-- Name: exchange_job_session id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session ALTER COLUMN id SET DEFAULT nextval('public.exchange_job_session_id_seq'::regclass);


--
-- Name: exchange_job_session_block_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session_block_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_job_session_block_log_id_seq'::regclass);


--
-- Name: exchange_job_session_buy_route_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session_buy_route_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_job_session_buy_route_log_id_seq'::regclass);


--
-- Name: exchange_job_session_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session_list ALTER COLUMN id SET DEFAULT nextval('public.exchange_job_session_list_id_seq'::regclass);


--
-- Name: exchange_job_session_remove_route_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session_remove_route_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_job_session_remove_route_log_id_seq'::regclass);


--
-- Name: exchange_mass_edit_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_mass_edit_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_mass_edit_log_id_seq'::regclass);


--
-- Name: exchange_member_egress_test id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_member_egress_test ALTER COLUMN id SET DEFAULT nextval('public.exchange_member_egress_test_id_seq'::regclass);


--
-- Name: exchange_my_route_download_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_my_route_download_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_my_route_download_log_id_seq'::regclass);


--
-- Name: exchange_opp_email id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_opp_email ALTER COLUMN id SET DEFAULT nextval('public.exchange_opp_email_id_seq'::regclass);


--
-- Name: exchange_par_account id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_account ALTER COLUMN id SET DEFAULT nextval('public.exchange_par_account_id_seq'::regclass);


--
-- Name: exchange_par_active_ips id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_active_ips ALTER COLUMN id SET DEFAULT nextval('public.exchange_par_active_ips_id_seq'::regclass);


--
-- Name: exchange_par_plan id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_plan ALTER COLUMN id SET DEFAULT nextval('public.exchange_par_plan_id_seq'::regclass);


--
-- Name: exchange_par_plan_record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_plan_record ALTER COLUMN id SET DEFAULT nextval('public.exchange_par_plan_record_id_seq'::regclass);


--
-- Name: exchange_par_port id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_port ALTER COLUMN id SET DEFAULT nextval('public.exchange_par_port_id_seq'::regclass);


--
-- Name: exchange_par_script id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_script ALTER COLUMN id SET DEFAULT nextval('public.exchange_par_script_id_seq'::regclass);


--
-- Name: exchange_par_switch_profiles id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_switch_profiles ALTER COLUMN id SET DEFAULT nextval('public.exchange_par_switch_profiles_id_seq'::regclass);


--
-- Name: exchange_par_system_parm id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_system_parm ALTER COLUMN id SET DEFAULT nextval('public.exchange_par_system_parm_id_seq'::regclass);


--
-- Name: exchange_product_copy_rate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_product_copy_rate_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_product_copy_rate_log_id_seq'::regclass);


--
-- Name: exchange_product_copy_route_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_product_copy_route_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_product_copy_route_log_id_seq'::regclass);


--
-- Name: exchange_product_copy_route_rate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_product_copy_route_rate_log ALTER COLUMN id SET DEFAULT nextval('public.exchange_product_copy_route_rate_log_id_seq'::regclass);


--
-- Name: exchange_product_user_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_product_user_list ALTER COLUMN id SET DEFAULT nextval('public.exchange_public_user_list_id_seq'::regclass);


--
-- Name: exchange_reg_country id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_reg_country ALTER COLUMN id SET DEFAULT nextval('public.exchange_reg_country_id_seq'::regclass);


--
-- Name: exchange_resource_private id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_resource_private ALTER COLUMN id SET DEFAULT nextval('public.exchange_resource_private_id_seq'::regclass);


--
-- Name: exchange_simple_session id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_simple_session ALTER COLUMN id SET DEFAULT nextval('public.exchange_simple_session_id_seq'::regclass);


--
-- Name: exchange_simple_session_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_simple_session_list ALTER COLUMN id SET DEFAULT nextval('public.exchange_simple_session_list_id_seq'::regclass);


--
-- Name: exchange_sys_module id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_module ALTER COLUMN id SET DEFAULT nextval('public.exchange_sys_module_id_seq'::regclass);


--
-- Name: exchange_sys_pri id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_pri ALTER COLUMN id SET DEFAULT nextval('public.exchange_sys_pri_id_seq'::regclass);


--
-- Name: exchange_sys_role role_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_role ALTER COLUMN role_id SET DEFAULT nextval('public.exchange_sys_role_role_id_seq'::regclass);


--
-- Name: exchange_sys_role_pri id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_role_pri ALTER COLUMN id SET DEFAULT nextval('public.exchange_sys_role_pri_id_seq'::regclass);


--
-- Name: exchange_vendor_test_number id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_vendor_test_number ALTER COLUMN id SET DEFAULT nextval('public.vendor_test_number_id_seq'::regclass);


--
-- Name: execution_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.execution_log ALTER COLUMN id SET DEFAULT nextval('public.execution_log_id_seq'::regclass);


--
-- Name: export_task_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.export_task_log ALTER COLUMN id SET DEFAULT nextval('public.export_task_log_id_seq'::regclass);


--
-- Name: fraud_detection id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_detection ALTER COLUMN id SET DEFAULT nextval('public.fraud_detection_id_seq'::regclass);


--
-- Name: fraud_detection_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_detection_log ALTER COLUMN id SET DEFAULT nextval('public.fraud_detection_log_id_seq'::regclass);


--
-- Name: fraud_detection_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_detection_log_detail ALTER COLUMN id SET DEFAULT nextval('public.fraud_detection_log_detail_id_seq'::regclass);


--
-- Name: ftp_cdr_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ftp_cdr_log ALTER COLUMN id SET DEFAULT nextval('public.ftp_cdr_log_id_seq'::regclass);


--
-- Name: ftp_cdr_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ftp_cdr_log_detail ALTER COLUMN id SET DEFAULT nextval('public.ftp_cdr_log_detail_id_seq'::regclass);


--
-- Name: ftp_conf id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ftp_conf ALTER COLUMN id SET DEFAULT nextval('public.ftp_conf_id_seq'::regclass);


--
-- Name: ftp_server_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ftp_server_log ALTER COLUMN id SET DEFAULT nextval('public.ftp_server_log_id_seq'::regclass);


--
-- Name: global_failover id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.global_failover ALTER COLUMN id SET DEFAULT nextval('public.global_failover_id_seq'::regclass);


--
-- Name: global_route_error id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.global_route_error ALTER COLUMN id SET DEFAULT nextval('public.global_route_error_id_seq'::regclass);


--
-- Name: hang_calls_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hang_calls_history ALTER COLUMN id SET DEFAULT nextval('public.hang_calls_history_id_seq'::regclass);


--
-- Name: hung_calls_detection_configuration id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hung_calls_detection_configuration ALTER COLUMN id SET DEFAULT nextval('public.hung_calls_detection_configuration_id_seq'::regclass);


--
-- Name: hung_calls_report_delete_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hung_calls_report_delete_log ALTER COLUMN id SET DEFAULT nextval('public.hung_calls_report_delete_log_id_seq'::regclass);


--
-- Name: import_code_constraints_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.import_code_constraints_log ALTER COLUMN id SET DEFAULT nextval('public.import_code_constraints_log_id_seq'::regclass);


--
-- Name: import_rate_file_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.import_rate_file_log ALTER COLUMN id SET DEFAULT nextval('public.import_rate_file_log_id_seq'::regclass);


--
-- Name: import_rate_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.import_rate_log ALTER COLUMN id SET DEFAULT nextval('public.import_rate_log_id_seq'::regclass);


--
-- Name: import_rate_status id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.import_rate_status ALTER COLUMN id SET DEFAULT nextval('public.import_rate_status_id_seq'::regclass);


--
-- Name: import_target_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.import_target_log ALTER COLUMN id SET DEFAULT nextval('public.import_target_log_id_seq'::regclass);


--
-- Name: ingress_test id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ingress_test ALTER COLUMN id SET DEFAULT nextval('public.ingress_test_id_seq'::regclass);


--
-- Name: invalid_detection_block_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_detection_block_log ALTER COLUMN id SET DEFAULT nextval('public.invalid_detection_block_log_id_seq'::regclass);


--
-- Name: invalid_number_detection id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_number_detection ALTER COLUMN id SET DEFAULT nextval('public.invalid_number_detection_id_seq'::regclass);


--
-- Name: invalid_number_detection_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_number_detection_log ALTER COLUMN id SET DEFAULT nextval('public.invalid_number_detection_log_id_seq'::regclass);


--
-- Name: invalid_number_detection_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_number_detection_log_detail ALTER COLUMN id SET DEFAULT nextval('public.invalid_number_detection_log_detail_id_seq'::regclass);


--
-- Name: invoice invoice_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice ALTER COLUMN invoice_id SET DEFAULT nextval('public.invoice_invoice_id_seq'::regclass);


--
-- Name: invoice_calls invoice_calls_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_calls ALTER COLUMN invoice_calls_id SET DEFAULT nextval('public.invoice_calls_invoice_calls_id_seq'::regclass);


--
-- Name: invoice_cdr_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_cdr_log ALTER COLUMN id SET DEFAULT nextval('public.invoice_cdr_log_id_seq'::regclass);


--
-- Name: invoice_credit_note id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_credit_note ALTER COLUMN id SET DEFAULT nextval('public.invoice_credit_note_id_seq'::regclass);


--
-- Name: invoice_daily_cost id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_daily_cost ALTER COLUMN id SET DEFAULT nextval('public.invoice_daily_cost_id_seq'::regclass);


--
-- Name: invoice_did id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_did ALTER COLUMN id SET DEFAULT nextval('public.invoice_did_id_seq'::regclass);


--
-- Name: invoice_email id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_email ALTER COLUMN id SET DEFAULT nextval('public.invoice_email_id_seq'::regclass);


--
-- Name: invoice_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_history ALTER COLUMN id SET DEFAULT nextval('public.invoice_history_id_seq'::regclass);


--
-- Name: invoice_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_log ALTER COLUMN id SET DEFAULT nextval('public.invoice_log_id_seq'::regclass);


--
-- Name: invoice_payment id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_payment ALTER COLUMN id SET DEFAULT nextval('public.invoice_payment_id_seq'::regclass);


--
-- Name: invoice_reconcile id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_reconcile ALTER COLUMN id SET DEFAULT nextval('public.invoice_reconcile_id_seq'::regclass);


--
-- Name: invoice_service_charge invoice_service_charge_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_service_charge ALTER COLUMN invoice_service_charge_id SET DEFAULT nextval('public.invoice_service_charge_invoice_service_charge_id_seq'::regclass);


--
-- Name: ip_modif_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ip_modif_log ALTER COLUMN id SET DEFAULT nextval('public.ip_modif_log_id_seq'::regclass);


--
-- Name: jurisdiction_country id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction_country ALTER COLUMN id SET DEFAULT nextval('public.jurisdiction_country_id_seq'::regclass);


--
-- Name: jurisdiction_update_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction_update_history ALTER COLUMN id SET DEFAULT nextval('public.jurisdiction_update_history_id_seq'::regclass);


--
-- Name: jurisdiction_update_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction_update_log ALTER COLUMN id SET DEFAULT nextval('public.jurisdiction_update_log_id_seq'::regclass);


--
-- Name: kill_pg_sql_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.kill_pg_sql_log ALTER COLUMN id SET DEFAULT nextval('public.kill_pg_sql_log_id_seq'::regclass);


--
-- Name: lcr_record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lcr_record ALTER COLUMN id SET DEFAULT nextval('public.lcr_record_id_seq'::regclass);


--
-- Name: lcr_reports id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lcr_reports ALTER COLUMN id SET DEFAULT nextval('public.lcr_reports_id_seq'::regclass);


--
-- Name: license_modification_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.license_modification_log ALTER COLUMN id SET DEFAULT nextval('public.license_modification_log_id_seq'::regclass);


--
-- Name: lnp_request id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lnp_request ALTER COLUMN id SET DEFAULT nextval('public.lnp_request_id_seq'::regclass);


--
-- Name: lnp_request_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lnp_request_detail ALTER COLUMN id SET DEFAULT nextval('public.lnp_request_detail_id_seq'::regclass);


--
-- Name: loop_detection id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loop_detection ALTER COLUMN id SET DEFAULT nextval('public.loop_detection_id_seq'::regclass);


--
-- Name: loop_detection_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loop_detection_detail ALTER COLUMN id SET DEFAULT nextval('public.loop_detection_detail_id_seq'::regclass);


--
-- Name: lrn lrn_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lrn ALTER COLUMN lrn_id SET DEFAULT nextval('public.lrn_lrn_id_seq'::regclass);


--
-- Name: lrn_groups id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lrn_groups ALTER COLUMN id SET DEFAULT nextval('public.lrn_groups_id_seq'::regclass);


--
-- Name: lrn_items id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lrn_items ALTER COLUMN id SET DEFAULT nextval('public.lrn_items_id_seq'::regclass);


--
-- Name: lrn_items_logs id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lrn_items_logs ALTER COLUMN id SET DEFAULT nextval('public.lrn_items_logs_id_seq'::regclass);


--
-- Name: lrn_servers id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lrn_servers ALTER COLUMN id SET DEFAULT nextval('public.lrn_servers_id_seq'::regclass);


--
-- Name: mail_cdr_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mail_cdr_log ALTER COLUMN id SET DEFAULT nextval('public.mail_cdr_log_id_seq'::regclass);


--
-- Name: mail_cdr_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mail_cdr_log_detail ALTER COLUMN id SET DEFAULT nextval('public.mail_cdr_log_detail_id_seq'::regclass);


--
-- Name: mail_sender id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mail_sender ALTER COLUMN id SET DEFAULT nextval('public.emails_id_seq'::regclass);


--
-- Name: modif_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.modif_log ALTER COLUMN id SET DEFAULT nextval('public.modif_log_id_seq'::regclass);


--
-- Name: mutual_transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mutual_transaction ALTER COLUMN id SET DEFAULT nextval('public.mutual_transaction_id_seq'::regclass);


--
-- Name: ocn_lata id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ocn_lata ALTER COLUMN id SET DEFAULT nextval('public.ocn_lata_id_seq'::regclass);


--
-- Name: opentact_balance id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.opentact_balance ALTER COLUMN id SET DEFAULT nextval('public.opentact_balance_id_seq'::regclass);


--
-- Name: options_of_record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.options_of_record ALTER COLUMN id SET DEFAULT nextval('public.options_of_record_id_seq'::regclass);


--
-- Name: order_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_code ALTER COLUMN id SET DEFAULT nextval('public.order_code_id_seq'::regclass);


--
-- Name: order_partern id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_partern ALTER COLUMN id SET DEFAULT nextval('public.order_partern_id_seq'::regclass);


--
-- Name: order_user id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_user ALTER COLUMN id SET DEFAULT nextval('public.order_user_id_seq'::regclass);


--
-- Name: order_user_alert id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_user_alert ALTER COLUMN id SET DEFAULT nextval('public.order_user_alert_id_seq'::regclass);


--
-- Name: order_user_finance id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_user_finance ALTER COLUMN id SET DEFAULT nextval('public.order_user_finance_id_seq'::regclass);


--
-- Name: order_user_qos id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_user_qos ALTER COLUMN id SET DEFAULT nextval('public.order_user_qos_id_seq'::regclass);


--
-- Name: order_user_rate_watch id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_user_rate_watch ALTER COLUMN id SET DEFAULT nextval('public.order_user_rate_watch_id_seq'::regclass);


--
-- Name: orig_invoice invoice_id; Type: DEFAULT; Schema: public; Owner: class4_user
--

ALTER TABLE ONLY public.orig_invoice ALTER COLUMN invoice_id SET DEFAULT nextval('public.orig_invoice_invoice_id_seq'::regclass);


--
-- Name: orig_log log_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.orig_log ALTER COLUMN log_id SET DEFAULT nextval('public.orig_log_log_id_seq'::regclass);


--
-- Name: origination_global_failover id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.origination_global_failover ALTER COLUMN id SET DEFAULT nextval('public.origination_global_failover_id_seq'::regclass);


--
-- Name: par_user id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.par_user ALTER COLUMN id SET DEFAULT nextval('public.par_user_id_seq'::regclass);


--
-- Name: partition_gateway_ref id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partition_gateway_ref ALTER COLUMN id SET DEFAULT nextval('public.partition_gateway_ref_id_seq'::regclass);


--
-- Name: partition_invoice id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partition_invoice ALTER COLUMN id SET DEFAULT nextval('public.partition_invoice_id_seq'::regclass);


--
-- Name: partner id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partner ALTER COLUMN id SET DEFAULT nextval('public.partner_id_seq'::regclass);


--
-- Name: payline_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payline_history ALTER COLUMN id SET DEFAULT nextval('public.payline_history_id_seq'::regclass);


--
-- Name: payment_invoice id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_invoice ALTER COLUMN id SET DEFAULT nextval('public.payment_invoice_id_seq'::regclass);


--
-- Name: pex_offer_pending_rate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pex_offer_pending_rate ALTER COLUMN id SET DEFAULT nextval('public.pex_offer_pending_rate_id_seq'::regclass);


--
-- Name: pex_offers id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pex_offers ALTER COLUMN id SET DEFAULT nextval('public.pex_offers_id_seq'::regclass);


--
-- Name: private_invite id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.private_invite ALTER COLUMN id SET DEFAULT nextval('public.private_invite_id_seq'::regclass);


--
-- Name: product_agents_ref id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_agents_ref ALTER COLUMN id SET DEFAULT nextval('public.product_agents_ref_id_seq'::regclass);


--
-- Name: product_clients_ref id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_clients_ref ALTER COLUMN id SET DEFAULT nextval('public.product_clients_ref_id_seq'::regclass);


--
-- Name: product_items_resource id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_items_resource ALTER COLUMN id SET DEFAULT nextval('public.product_items_resource_id_seq'::regclass);


--
-- Name: product_rout_rate_table id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_rout_rate_table ALTER COLUMN id SET DEFAULT nextval('public.product_rout_rate_table_id_seq'::regclass);


--
-- Name: product_route_rate_table id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_route_rate_table ALTER COLUMN id SET DEFAULT nextval('public.product_route_rate_table_id_seq'::regclass);


--
-- Name: quick_cdr id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.quick_cdr ALTER COLUMN id SET DEFAULT nextval('public.quick_cdr_id_seq'::regclass);


--
-- Name: random_ani_generation id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.random_ani_generation ALTER COLUMN id SET DEFAULT nextval('public.random_ani_generation_id_seq'::regclass);


--
-- Name: random_ani_populated_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.random_ani_populated_log ALTER COLUMN id SET DEFAULT nextval('public.random_ani_populated_log_id_seq'::regclass);


--
-- Name: random_ani_table id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.random_ani_table ALTER COLUMN id SET DEFAULT nextval('public.random_ani_table_id_seq'::regclass);


--
-- Name: rate_auto_create id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_auto_create ALTER COLUMN id SET DEFAULT nextval('public.rate_auto_create_id_seq'::regclass);


--
-- Name: rate_auto_create_interval id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_auto_create_interval ALTER COLUMN id SET DEFAULT nextval('public.rate_auto_create_interval_id_seq'::regclass);


--
-- Name: rate_auto_create_profit id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_auto_create_profit ALTER COLUMN id SET DEFAULT nextval('public.rate_auto_create_profit_id_seq'::regclass);


--
-- Name: rate_auto_diff id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_auto_diff ALTER COLUMN id SET DEFAULT nextval('public.rate_auto_diff_id_seq'::regclass);


--
-- Name: rate_bot_import_logs id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_bot_import_logs ALTER COLUMN id SET DEFAULT nextval('public.rate_bot_import_logs_seq'::regclass);


--
-- Name: rate_download_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_download_log ALTER COLUMN id SET DEFAULT nextval('public.rate_download_log_id_seq'::regclass);


--
-- Name: rate_email_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_email_template ALTER COLUMN id SET DEFAULT nextval('public.rate_email_template_id_seq'::regclass);


--
-- Name: rate_generate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generate ALTER COLUMN id SET DEFAULT nextval('public.rate_generate_id_seq'::regclass);


--
-- Name: rate_generation_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_history ALTER COLUMN id SET DEFAULT nextval('public.rate_generation_history_id_seq'::regclass);


--
-- Name: rate_generation_history_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_history_detail ALTER COLUMN id SET DEFAULT nextval('public.rate_generation_history_detail_id_seq'::regclass);


--
-- Name: rate_generation_rate generation_rate_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_rate ALTER COLUMN generation_rate_id SET DEFAULT nextval('public.rate_generation_rate_generation_rate_id_seq'::regclass);


--
-- Name: rate_generation_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_template ALTER COLUMN id SET DEFAULT nextval('public.rate_generation_template_id_seq'::regclass);


--
-- Name: rate_generation_template_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_template_detail ALTER COLUMN id SET DEFAULT nextval('public.rate_generation_template_detail_id_seq'::regclass);


--
-- Name: rate_generation_template_margin id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_template_margin ALTER COLUMN id SET DEFAULT nextval('public.rate_generation_template_margin_id_seq'::regclass);


--
-- Name: rate_handler id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_handler ALTER COLUMN id SET DEFAULT nextval('public.rate_handler_id_seq'::regclass);


--
-- Name: rate_import_error_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_import_error_log ALTER COLUMN id SET DEFAULT nextval('public.rate_import_error_log_id_seq'::regclass);


--
-- Name: rate_mail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_mail ALTER COLUMN id SET DEFAULT nextval('public.rate_mail_id_seq'::regclass);


--
-- Name: rate_mail_decks id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_mail_decks ALTER COLUMN id SET DEFAULT nextval('public.rate_mail_decks_id_seq'::regclass);


--
-- Name: rate_mail_decks_files id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_mail_decks_files ALTER COLUMN id SET DEFAULT nextval('public.rate_mail_decks_files_id_seq'::regclass);


--
-- Name: rate_management id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_management ALTER COLUMN id SET DEFAULT nextval('public.rate_management_id_seq'::regclass);


--
-- Name: rate_management_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_management_detail ALTER COLUMN id SET DEFAULT nextval('public.rate_management_detail_id_seq'::regclass);


--
-- Name: rate_management_option id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_management_option ALTER COLUMN id SET DEFAULT nextval('public.rate_management_option_id_seq'::regclass);


--
-- Name: rate_mass_edit_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_mass_edit_log ALTER COLUMN id SET DEFAULT nextval('public.rate_mass_edit_log_id_seq'::regclass);


--
-- Name: rate_send_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_send_log ALTER COLUMN id SET DEFAULT nextval('public.rate_send_log_id_seq'::regclass);


--
-- Name: rate_send_log_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_send_log_detail ALTER COLUMN id SET DEFAULT nextval('public.rate_send_log_detail_id_seq'::regclass);


--
-- Name: rate_send_logging id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_send_logging ALTER COLUMN id SET DEFAULT nextval('public.rate_send_logging_id_seq'::regclass);


--
-- Name: rate_send_rules id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_send_rules ALTER COLUMN id SET DEFAULT nextval('public.rate_send_rules_id_seq'::regclass);


--
-- Name: rate_upload_fail_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_upload_fail_log ALTER COLUMN id SET DEFAULT nextval('public.rate_upload_fail_log_id_seq'::regclass);


--
-- Name: rate_upload_queue id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_upload_queue ALTER COLUMN id SET DEFAULT nextval('public.rate_upload_queue_id_seq'::regclass);


--
-- Name: rate_upload_success_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_upload_success_log ALTER COLUMN id SET DEFAULT nextval('public.rate_upload_success_log_id_seq'::regclass);


--
-- Name: rate_upload_task id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_upload_task ALTER COLUMN id SET DEFAULT nextval('public.rate_upload_task_id_seq'::regclass);


--
-- Name: rate_upload_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_upload_template ALTER COLUMN id SET DEFAULT nextval('public.rate_upload_template_id_seq'::regclass);


--
-- Name: ratemail_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ratemail_history ALTER COLUMN id SET DEFAULT nextval('public.ratemail_history_id_seq'::regclass);


--
-- Name: real_cdr real_cdr_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.real_cdr ALTER COLUMN real_cdr_id SET DEFAULT nextval('public.real_cdr_real_cdr_id_seq'::regclass);


--
-- Name: redirect_carrier id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.redirect_carrier ALTER COLUMN id SET DEFAULT nextval('public.redirect_carrier_id_seq'::regclass);


--
-- Name: redirect_host id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.redirect_host ALTER COLUMN id SET DEFAULT nextval('public.redirect_host_id_seq'::regclass);


--
-- Name: register_of_record id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.register_of_record ALTER COLUMN id SET DEFAULT nextval('public.register_of_record_id_seq'::regclass);


--
-- Name: rerate_cdr_download_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rerate_cdr_download_log ALTER COLUMN id SET DEFAULT nextval('public.rerate_cdr_download_log_id_seq'::regclass);


--
-- Name: rerate_cdr_task id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rerate_cdr_task ALTER COLUMN id SET DEFAULT nextval('public.rerate_cdr_task_id_seq'::regclass);


--
-- Name: rerate_log rerate_log_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rerate_log ALTER COLUMN rerate_log_id SET DEFAULT nextval('public.rerate_log_rerate_log_id_seq'::regclass);


--
-- Name: rerate_report_exec_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rerate_report_exec_log ALTER COLUMN id SET DEFAULT nextval('public.rerate_report_exec_log_id_seq'::regclass);


--
-- Name: reseller id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reseller ALTER COLUMN id SET DEFAULT nextval('public.reseller_id_seq'::regclass);


--
-- Name: reseller_client id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reseller_client ALTER COLUMN id SET DEFAULT nextval('public.reseller_client_id_seq'::regclass);


--
-- Name: resource_auth id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_auth ALTER COLUMN id SET DEFAULT nextval('public.resource_auth_id_seq'::regclass);


--
-- Name: resource_block_group id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_block_group ALTER COLUMN id SET DEFAULT nextval('public.resource_block_group_id_seq'::regclass);


--
-- Name: resource_block_items id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_block_items ALTER COLUMN id SET DEFAULT nextval('public.resource_block_items_id_seq'::regclass);


--
-- Name: resource_capacity id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_capacity ALTER COLUMN id SET DEFAULT nextval('public.resource_capacity_id_seq'::regclass);


--
-- Name: resource_codecs_ref id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_codecs_ref ALTER COLUMN id SET DEFAULT nextval('public.resource_codecs_ref_id_seq'::regclass);


--
-- Name: resource_direction direction_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_direction ALTER COLUMN direction_id SET DEFAULT nextval('public.resource_direction_direction_id_seq'::regclass);


--
-- Name: resource_direction_template direction_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_direction_template ALTER COLUMN direction_id SET DEFAULT nextval('public.resource_direction_template_direction_id_seq'::regclass);


--
-- Name: resource_ip_limit limit_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_ip_limit ALTER COLUMN limit_id SET DEFAULT nextval('public.resource_ip_limit_limit_id_seq'::regclass);


--
-- Name: resource_lrn_action id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_lrn_action ALTER COLUMN id SET DEFAULT nextval('public.resource_lrn_action_id_seq'::regclass);


--
-- Name: resource_next_route_rule id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_next_route_rule ALTER COLUMN id SET DEFAULT nextval('public.resource_next_route_rule_id_seq'::regclass);


--
-- Name: resource_next_route_rule_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_next_route_rule_template ALTER COLUMN id SET DEFAULT nextval('public.resource_next_route_rule_template_id_seq'::regclass);


--
-- Name: resource_prefix id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_prefix ALTER COLUMN id SET DEFAULT nextval('public.resource_prefix_id_seq'::regclass);


--
-- Name: resource_rate id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_rate ALTER COLUMN id SET DEFAULT nextval('public.resource_rate_id_seq'::regclass);


--
-- Name: resource_replace_action id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_replace_action ALTER COLUMN id SET DEFAULT nextval('public.resource_replace_action_id_seq'::regclass);


--
-- Name: resource_replace_action_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_replace_action_template ALTER COLUMN id SET DEFAULT nextval('public.resource_replace_action_template_id_seq'::regclass);


--
-- Name: resource_template resource_template_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_template ALTER COLUMN resource_template_id SET DEFAULT nextval('public.resource_template_resource_template_id_seq'::regclass);


--
-- Name: resource_translation_ref ref_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_translation_ref ALTER COLUMN ref_id SET DEFAULT nextval('public.resource_translation_ref_ref_id_seq'::regclass);


--
-- Name: retrieve_password_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.retrieve_password_log ALTER COLUMN id SET DEFAULT nextval('public.retrieve_password_log_id_seq'::regclass);


--
-- Name: role role_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role ALTER COLUMN role_id SET DEFAULT nextval('public.role_role_id_seq'::regclass);


--
-- Name: role_privilege role_privilege_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role_privilege ALTER COLUMN role_privilege_id SET DEFAULT nextval('public.role_privilege_role_privilege_id_seq'::regclass);


--
-- Name: route route_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.route ALTER COLUMN route_id SET DEFAULT nextval('public.route_route_id_seq'::regclass);


--
-- Name: route_block id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.route_block ALTER COLUMN id SET DEFAULT nextval('public.route_block_id_seq'::regclass);


--
-- Name: route_strategy route_strategy_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.route_strategy ALTER COLUMN route_strategy_id SET DEFAULT nextval('public.route_strategy_route_strategy_id_seq'::regclass);


--
-- Name: routing_wizard_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.routing_wizard_list ALTER COLUMN id SET DEFAULT nextval('public.routing_wizard_list_id_seq'::regclass);


--
-- Name: scheduled_report id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scheduled_report ALTER COLUMN id SET DEFAULT nextval('public.scheduled_report_id_seq'::regclass);


--
-- Name: scheduled_report_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scheduled_report_log ALTER COLUMN id SET DEFAULT nextval('public.scheduled_report_log_id_seq'::regclass);


--
-- Name: scheduler id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scheduler ALTER COLUMN id SET DEFAULT nextval('public.shceduler_id_seq'::regclass);


--
-- Name: scheduler_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scheduler_log ALTER COLUMN id SET DEFAULT nextval('public.scheduler_log_id_seq'::regclass);


--
-- Name: search_logs id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.search_logs ALTER COLUMN id SET DEFAULT nextval('public.search_logs_id_seq'::regclass);


--
-- Name: sell_order id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sell_order ALTER COLUMN id SET DEFAULT nextval('public.sell_order_id_seq'::regclass);


--
-- Name: sell_order_response id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sell_order_response ALTER COLUMN id SET DEFAULT nextval('public.sell_order_response_id_seq'::regclass);


--
-- Name: send_mails id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.send_mails ALTER COLUMN id SET DEFAULT nextval('public.send_mails_id_seq'::regclass);


--
-- Name: send_rate_preserved_data id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.send_rate_preserved_data ALTER COLUMN id SET DEFAULT nextval('public.send_rate_preserved_data_id_seq'::regclass);


--
-- Name: send_rate_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.send_rate_template ALTER COLUMN id SET DEFAULT nextval('public.send_rate_template_id_seq'::regclass);


--
-- Name: service_charge service_charge_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.service_charge ALTER COLUMN service_charge_id SET DEFAULT nextval('public.service_charge_service_charge_id_seq'::regclass);


--
-- Name: service_charge_items id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.service_charge_items ALTER COLUMN id SET DEFAULT nextval('public.service_charge_items_id_seq'::regclass);


--
-- Name: signup id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.signup ALTER COLUMN id SET DEFAULT nextval('public.signup_id_seq'::regclass);


--
-- Name: signup_ip id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.signup_ip ALTER COLUMN id SET DEFAULT nextval('public.signup_ip_id_seq'::regclass);


--
-- Name: sip_registrations id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sip_registrations ALTER COLUMN id SET DEFAULT nextval('public.sip_registrations_id_seq'::regclass);


--
-- Name: sip_requests id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sip_requests ALTER COLUMN id SET DEFAULT nextval('public.sip_requests_id_seq'::regclass);


--
-- Name: spam_traffic_ip_record record_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.spam_traffic_ip_record ALTER COLUMN record_id SET DEFAULT nextval('public.spam_traffic_ip_record_record_id_seq1'::regclass);


--
-- Name: stats_buy_order id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stats_buy_order ALTER COLUMN id SET DEFAULT nextval('public.stats_buy_order_id_seq'::regclass);


--
-- Name: stats_sell_order id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stats_sell_order ALTER COLUMN id SET DEFAULT nextval('public.stats_sell_order_id_seq'::regclass);


--
-- Name: switch_profile id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.switch_profile ALTER COLUMN id SET DEFAULT nextval('public.switch_profile_id_seq'::regclass);


--
-- Name: sys_module id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sys_module ALTER COLUMN id SET DEFAULT nextval('public.sys_module_id_seq'::regclass);


--
-- Name: sys_pri id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sys_pri ALTER COLUMN id SET DEFAULT nextval('public.sys_pri_id_seq'::regclass);


--
-- Name: sys_role_pri id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sys_role_pri ALTER COLUMN id SET DEFAULT nextval('public.sys_role_pri_id_seq'::regclass);


--
-- Name: system_function system_function_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.system_function ALTER COLUMN system_function_id SET DEFAULT nextval('public.system_function_system_function_id_seq'::regclass);


--
-- Name: system_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.system_log ALTER COLUMN id SET DEFAULT nextval('public.system_log_id_seq'::regclass);


--
-- Name: system_mail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.system_mail ALTER COLUMN id SET DEFAULT nextval('public.system_mail_id_seq'::regclass);


--
-- Name: system_parameter sys_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.system_parameter ALTER COLUMN sys_id SET DEFAULT nextval('public.system_parameter_sys_id_seq'::regclass);


--
-- Name: task_manage id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.task_manage ALTER COLUMN id SET DEFAULT nextval('public.task_manage_id_seq'::regclass);


--
-- Name: termination_global_failover id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.termination_global_failover ALTER COLUMN id SET DEFAULT nextval('public.termination_global_failover_id_seq'::regclass);


--
-- Name: test_device test_device_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.test_device ALTER COLUMN test_device_id SET DEFAULT nextval('public.test_device_test_device_id_seq'::regclass);


--
-- Name: traffic_alert id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.traffic_alert ALTER COLUMN id SET DEFAULT nextval('public.traffic_alert_id_seq'::regclass);


--
-- Name: transaction id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction ALTER COLUMN id SET DEFAULT nextval('public.transaction_id_seq'::regclass);


--
-- Name: transaction_fee id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_fee ALTER COLUMN id SET DEFAULT nextval('public.transaction_fee_id_seq'::regclass);


--
-- Name: transaction_fee_items id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_fee_items ALTER COLUMN id SET DEFAULT nextval('public.transaction_fee_items_id_seq'::regclass);


--
-- Name: trouble_tickets_template id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.trouble_tickets_template ALTER COLUMN id SET DEFAULT nextval('public.trouble_tickets_template_id_seq'::regclass);


--
-- Name: trunk_group group_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.trunk_group ALTER COLUMN group_id SET DEFAULT nextval('public.trunk_group_group_id_seq'::regclass);


--
-- Name: trunk_pstn_header id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.trunk_pstn_header ALTER COLUMN id SET DEFAULT nextval('public.trunk_pstn_header_id_seq'::regclass);


--
-- Name: trunk_relation_route id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.trunk_relation_route ALTER COLUMN id SET DEFAULT nextval('public.trunk_relation_route_id_seq'::regclass);


--
-- Name: upload_ani_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.upload_ani_log ALTER COLUMN id SET DEFAULT nextval('public.upload_ani_log_id_seq'::regclass);


--
-- Name: us_export_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.us_export_log ALTER COLUMN id SET DEFAULT nextval('public.us_export_log_id_seq'::regclass);


--
-- Name: us_ocn_lata id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.us_ocn_lata ALTER COLUMN id SET DEFAULT nextval('public.us_ocn_lata_id_seq'::regclass);


--
-- Name: usage_report_delivery id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.usage_report_delivery ALTER COLUMN id SET DEFAULT nextval('public.usage_report_delivery_id_seq'::regclass);


--
-- Name: user_auth_ip id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_auth_ip ALTER COLUMN id SET DEFAULT nextval('public.user_auth_ip_id_seq'::regclass);


--
-- Name: users user_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users ALTER COLUMN user_id SET DEFAULT nextval('public.users_user_id_seq'::regclass);


--
-- Name: users_limit id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users_limit ALTER COLUMN id SET DEFAULT nextval('public.users_limit_id_seq'::regclass);


--
-- Name: vendor_invoice vendor_invoice_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendor_invoice ALTER COLUMN vendor_invoice_id SET DEFAULT nextval('public.vendor_invoice_id_seq'::regclass);


--
-- Name: vendor_invoice_detail id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendor_invoice_detail ALTER COLUMN id SET DEFAULT nextval('public.vendor_invoice_detail_id_seq'::regclass);


--
-- Name: vendor_invoice_dispute id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendor_invoice_dispute ALTER COLUMN id SET DEFAULT nextval('public.vendor_invoice_dispute_id_seq'::regclass);


--
-- Name: vendortest_code id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendortest_code ALTER COLUMN id SET DEFAULT nextval('public.vendortest_code_id_seq'::regclass);


--
-- Name: vendortest_number id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendortest_number ALTER COLUMN id SET DEFAULT nextval('public.vendortest_number_id_seq'::regclass);


--
-- Name: vendortest_number_summary id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendortest_number_summary ALTER COLUMN id SET DEFAULT nextval('public.vendortest_number_summary_id_seq'::regclass);


--
-- Name: vendortest_project id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendortest_project ALTER COLUMN id SET DEFAULT nextval('public.vendortest_project_id_seq'::regclass);


--
-- Name: vendortest_project_summary id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendortest_project_summary ALTER COLUMN id SET DEFAULT nextval('public.vendortest_project_summary_id_seq'::regclass);


--
-- Name: version_information id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.version_information ALTER COLUMN id SET DEFAULT nextval('public.version_information_id_seq'::regclass);


--
-- Name: voip_gateway id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.voip_gateway ALTER COLUMN id SET DEFAULT nextval('public.voip_gateway_id_seq'::regclass);


--
-- Name: web_session id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.web_session ALTER COLUMN id SET DEFAULT nextval('public.web_session_id_seq'::regclass);


--
-- Name: pga_exception pga_exception_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_exception
    ADD CONSTRAINT pga_exception_pkey PRIMARY KEY (jexid);


--
-- Name: pga_job pga_job_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_job
    ADD CONSTRAINT pga_job_pkey PRIMARY KEY (jobid);


--
-- Name: pga_jobagent pga_jobagent_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_jobagent
    ADD CONSTRAINT pga_jobagent_pkey PRIMARY KEY (jagpid);


--
-- Name: pga_jobclass pga_jobclass_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_jobclass
    ADD CONSTRAINT pga_jobclass_pkey PRIMARY KEY (jclid);


--
-- Name: pga_joblog pga_joblog_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_joblog
    ADD CONSTRAINT pga_joblog_pkey PRIMARY KEY (jlgid);


--
-- Name: pga_jobstep pga_jobstep_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_jobstep
    ADD CONSTRAINT pga_jobstep_pkey PRIMARY KEY (jstid);


--
-- Name: pga_jobsteplog pga_jobsteplog_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_jobsteplog
    ADD CONSTRAINT pga_jobsteplog_pkey PRIMARY KEY (jslid);


--
-- Name: pga_schedule pga_schedule_pkey; Type: CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_schedule
    ADD CONSTRAINT pga_schedule_pkey PRIMARY KEY (jscid);


--
-- Name: agent_client agent_client_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_client
    ADD CONSTRAINT agent_client_pkey PRIMARY KEY (id);


--
-- Name: agent_clients agent_clients_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_clients
    ADD CONSTRAINT agent_clients_pkey PRIMARY KEY (id);


--
-- Name: agent_commission_history_detail agent_commission_history_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_commission_history_detail
    ADD CONSTRAINT agent_commission_history_detail_pkey PRIMARY KEY (id);


--
-- Name: agent_commission_history agent_commission_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_commission_history
    ADD CONSTRAINT agent_commission_history_pkey PRIMARY KEY (history_id);


--
-- Name: agent_commission_payment agent_commission_payment_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_commission_payment
    ADD CONSTRAINT agent_commission_payment_pkey PRIMARY KEY (id);


--
-- Name: agent agent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent
    ADD CONSTRAINT agent_pkey PRIMARY KEY (agent_id);


--
-- Name: alert_rules_log_detail alert_rules_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_rules_log_detail
    ADD CONSTRAINT alert_rules_log_detail_pkey PRIMARY KEY (id);


--
-- Name: alert_rules_log alert_rules_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_rules_log
    ADD CONSTRAINT alert_rules_log_pkey PRIMARY KEY (id);


--
-- Name: alert_rules alert_rules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_rules
    ADD CONSTRAINT alert_rules_pkey PRIMARY KEY (id);


--
-- Name: alert_rules alert_rules_rule_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_rules
    ADD CONSTRAINT alert_rules_rule_name_key UNIQUE (rule_name);


--
-- Name: ani_blocking_log ani_blocking_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ani_blocking_log
    ADD CONSTRAINT ani_blocking_log_pkey PRIMARY KEY (id);


--
-- Name: api_log api_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.api_log
    ADD CONSTRAINT api_log_pkey PRIMARY KEY (id);


--
-- Name: automatic_rate automatic_rate_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.automatic_rate
    ADD CONSTRAINT automatic_rate_pkey PRIMARY KEY (id);


--
-- Name: balance_daily_reset_task balance_daily_reset_task_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.balance_daily_reset_task
    ADD CONSTRAINT balance_daily_reset_task_pkey PRIMARY KEY (id);


--
-- Name: balance_history_actual balance_history_actual_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.balance_history_actual
    ADD CONSTRAINT balance_history_actual_pkey PRIMARY KEY (id);


--
-- Name: balance_history balance_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.balance_history
    ADD CONSTRAINT balance_history_pkey PRIMARY KEY (id);


--
-- Name: balance_log balance_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.balance_log
    ADD CONSTRAINT balance_log_pkey PRIMARY KEY (id);


--
-- Name: block_ani block_ani_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_ani
    ADD CONSTRAINT block_ani_pkey PRIMARY KEY (id);


--
-- Name: block_log block_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_log
    ADD CONSTRAINT block_log_pkey PRIMARY KEY (log_id);


--
-- Name: block_ticket block_ticket_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_ticket
    ADD CONSTRAINT block_ticket_pkey PRIMARY KEY (id);


--
-- Name: block_trouble_ticket block_trouble_ticket_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_trouble_ticket
    ADD CONSTRAINT block_trouble_ticket_pkey PRIMARY KEY (id);


--
-- Name: c4_client_balance c4_client_balance_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.c4_client_balance
    ADD CONSTRAINT c4_client_balance_pkey PRIMARY KEY (id);


--
-- Name: c4_livecall_user c4_livecall_user_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.c4_livecall_user
    ADD CONSTRAINT c4_livecall_user_pkey PRIMARY KEY (id);


--
-- Name: c4_lrn c4_lrn_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.c4_lrn
    ADD CONSTRAINT c4_lrn_pkey PRIMARY KEY (id);


--
-- Name: call_monitor call_monitor_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.call_monitor
    ADD CONSTRAINT call_monitor_pkey PRIMARY KEY (id);


--
-- Name: captcha captcha_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.captcha
    ADD CONSTRAINT captcha_pkey PRIMARY KEY (captcha_id);


--
-- Name: carrier_group carrier_group_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carrier_group
    ADD CONSTRAINT carrier_group_pkey PRIMARY KEY (group_id);


--
-- Name: carrier_template carrier_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carrier_template
    ADD CONSTRAINT carrier_template_pkey PRIMARY KEY (id);


--
-- Name: cdr_export_log cdr_export_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_export_log
    ADD CONSTRAINT cdr_export_log_pkey PRIMARY KEY (id);


--
-- Name: cdr_list_export_log cdr_list_export_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_list_export_log
    ADD CONSTRAINT cdr_list_export_log_pkey PRIMARY KEY (id);


--
-- Name: cdr_report_regenerate_log cdr_report_regenerate_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_report_regenerate_log
    ADD CONSTRAINT cdr_report_regenerate_log_pkey PRIMARY KEY (id);


--
-- Name: exchange_ci_sessions ci_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_ci_sessions
    ADD CONSTRAINT ci_sessions_pkey PRIMARY KEY (session_id);


--
-- Name: digit_translation class4_digit_translation_translation_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.digit_translation
    ADD CONSTRAINT class4_digit_translation_translation_name UNIQUE (translation_name);


--
-- Name: invoice_log class4_fkey_invoice_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_log
    ADD CONSTRAINT class4_fkey_invoice_log_id PRIMARY KEY (id);


--
-- Name: ingress_test class4_pk_ingress_test_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ingress_test
    ADD CONSTRAINT class4_pk_ingress_test_id PRIMARY KEY (id);


--
-- Name: alert_action class4_pkey_alert_action_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_action
    ADD CONSTRAINT class4_pkey_alert_action_id PRIMARY KEY (id);


--
-- Name: alert_exec_log class4_pkey_alert_action_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_exec_log
    ADD CONSTRAINT class4_pkey_alert_action_log_id PRIMARY KEY (id);


--
-- Name: alert_condition class4_pkey_alert_condition_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_condition
    ADD CONSTRAINT class4_pkey_alert_condition_id PRIMARY KEY (id);


--
-- Name: alert_event class4_pkey_alert_event_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_event
    ADD CONSTRAINT class4_pkey_alert_event_id PRIMARY KEY (id);


--
-- Name: alert_mail class4_pkey_alert_mail_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_mail
    ADD CONSTRAINT class4_pkey_alert_mail_id PRIMARY KEY (id);


--
-- Name: alert_rule class4_pkey_alert_rule_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_rule
    ADD CONSTRAINT class4_pkey_alert_rule_id PRIMARY KEY (id);


--
-- Name: backup_clean class4_pkey_backup_clean_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.backup_clean
    ADD CONSTRAINT class4_pkey_backup_clean_id PRIMARY KEY (id);


--
-- Name: block_loop class4_pkey_block_loop_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_loop
    ADD CONSTRAINT class4_pkey_block_loop_id PRIMARY KEY (id);


--
-- Name: block_loop_log_calls class4_pkey_block_loop_log_calls_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_loop_log_calls
    ADD CONSTRAINT class4_pkey_block_loop_log_calls_id PRIMARY KEY (block_loop_log_id);


--
-- Name: block_loop_log class4_pkey_block_loop_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_loop_log
    ADD CONSTRAINT class4_pkey_block_loop_log_id PRIMARY KEY (id);


--
-- Name: buy_order class4_pkey_buy_order_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.buy_order
    ADD CONSTRAINT class4_pkey_buy_order_id PRIMARY KEY (id);


--
-- Name: buy_order_response class4_pkey_buy_order_response_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.buy_order_response
    ADD CONSTRAINT class4_pkey_buy_order_response_id PRIMARY KEY (id);


--
-- Name: capture class4_pkey_capture_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.capture
    ADD CONSTRAINT class4_pkey_capture_id PRIMARY KEY (capture_id);


--
-- Name: cdr_compare_cloud class4_pkey_cdr_compare_cloud_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_compare_cloud
    ADD CONSTRAINT class4_pkey_cdr_compare_cloud_id PRIMARY KEY (id);


--
-- Name: cdr_compare class4_pkey_cdr_compare_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_compare
    ADD CONSTRAINT class4_pkey_cdr_compare_id PRIMARY KEY (id);


--
-- Name: cdr_log class4_pkey_cdr_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_log
    ADD CONSTRAINT class4_pkey_cdr_log_id PRIMARY KEY (id);


--
-- Name: cdr_rerate class4_pkey_cdr_rerate_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cdr_rerate
    ADD CONSTRAINT class4_pkey_cdr_rerate_id PRIMARY KEY (id);


--
-- Name: client_balance class4_pkey_client_balance_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_balance
    ADD CONSTRAINT class4_pkey_client_balance_client_id PRIMARY KEY (client_id);


--
-- Name: client_cdr_delete_bak class4_pkey_client_cdr_delete_bak_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_cdr_delete_bak
    ADD CONSTRAINT class4_pkey_client_cdr_delete_bak_id PRIMARY KEY (id);


--
-- Name: client_commit_code class4_pkey_client_commit_code_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_commit_code
    ADD CONSTRAINT class4_pkey_client_commit_code_id PRIMARY KEY (id);


--
-- Name: client_commit_minutes class4_pkey_client_commit_minutes_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_commit_minutes
    ADD CONSTRAINT class4_pkey_client_commit_minutes_id PRIMARY KEY (id);


--
-- Name: client_finance_transaction class4_pkey_client_finance_transaction_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_finance_transaction
    ADD CONSTRAINT class4_pkey_client_finance_transaction_id PRIMARY KEY (id);


--
-- Name: client class4_pkey_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client
    ADD CONSTRAINT class4_pkey_client_id PRIMARY KEY (client_id);


--
-- Name: client_payment class4_pkey_client_payment_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_payment
    ADD CONSTRAINT class4_pkey_client_payment_id PRIMARY KEY (client_payment_id);


--
-- Name: code_deck class4_pkey_code_deck_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_deck
    ADD CONSTRAINT class4_pkey_code_deck_id PRIMARY KEY (code_deck_id);


--
-- Name: code class4_pkey_code_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code
    ADD CONSTRAINT class4_pkey_code_id PRIMARY KEY (code_id);


--
-- Name: code_stats class4_pkey_code_stats_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_stats
    ADD CONSTRAINT class4_pkey_code_stats_id PRIMARY KEY (id);


--
-- Name: codecs class4_pkey_codecs_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.codecs
    ADD CONSTRAINT class4_pkey_codecs_id PRIMARY KEY (id);


--
-- Name: contract_code class4_pkey_contract_code_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contract_code
    ADD CONSTRAINT class4_pkey_contract_code_id PRIMARY KEY (id);


--
-- Name: contract class4_pkey_contract_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contract
    ADD CONSTRAINT class4_pkey_contract_id PRIMARY KEY (id);


--
-- Name: credit_application class4_pkey_credit_application_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.credit_application
    ADD CONSTRAINT class4_pkey_credit_application_id PRIMARY KEY (id);


--
-- Name: currency class4_pkey_currency_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.currency
    ADD CONSTRAINT class4_pkey_currency_id PRIMARY KEY (currency_id);


--
-- Name: currency_updates class4_pkey_currency_updates_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.currency_updates
    ADD CONSTRAINT class4_pkey_currency_updates_id PRIMARY KEY (currency_updates_id);


--
-- Name: digit_translation class4_pkey_digit_translation_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.digit_translation
    ADD CONSTRAINT class4_pkey_digit_translation_id PRIMARY KEY (translation_id);


--
-- Name: direct_seller_enrollment class4_pkey_direct_seller_enrollment_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.direct_seller_enrollment
    ADD CONSTRAINT class4_pkey_direct_seller_enrollment_id PRIMARY KEY (id);


--
-- Name: dynamic_route class4_pkey_dynamic_route_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route
    ADD CONSTRAINT class4_pkey_dynamic_route_id PRIMARY KEY (dynamic_route_id);


--
-- Name: dynamic_route_items class4_pkey_dynamic_route_items_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_items
    ADD CONSTRAINT class4_pkey_dynamic_route_items_id PRIMARY KEY (id);


--
-- Name: dynamic_route_override class4_pkey_dynamic_route_override_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_override
    ADD CONSTRAINT class4_pkey_dynamic_route_override_id PRIMARY KEY (id);


--
-- Name: dynamic_route_pri class4_pkey_dynamic_route_pri_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_pri
    ADD CONSTRAINT class4_pkey_dynamic_route_pri_id PRIMARY KEY (id);


--
-- Name: dynamic_route_qos class4_pkey_dynamic_route_qos_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_qos
    ADD CONSTRAINT class4_pkey_dynamic_route_qos_id PRIMARY KEY (id);


--
-- Name: egress_test class4_pkey_egress_test_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.egress_test
    ADD CONSTRAINT class4_pkey_egress_test_id PRIMARY KEY (id);


--
-- Name: egress_test_result class4_pkey_egress_test_result_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.egress_test_result
    ADD CONSTRAINT class4_pkey_egress_test_result_id PRIMARY KEY (id);


--
-- Name: email_record class4_pkey_email_record_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.email_record
    ADD CONSTRAINT class4_pkey_email_record_id PRIMARY KEY (id);


--
-- Name: error_info class4_pkey_error_info_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.error_info
    ADD CONSTRAINT class4_pkey_error_info_id PRIMARY KEY (id);


--
-- Name: event_log class4_pkey_event_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.event_log
    ADD CONSTRAINT class4_pkey_event_log_id PRIMARY KEY (event_log_id);


--
-- Name: exchange_finance class4_pkey_exchange_finance_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_finance
    ADD CONSTRAINT class4_pkey_exchange_finance_id PRIMARY KEY (id);


--
-- Name: global_failover class4_pkey_global_failover_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.global_failover
    ADD CONSTRAINT class4_pkey_global_failover_id PRIMARY KEY (id);


--
-- Name: invoice_calls class4_pkey_invoice_calls_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_calls
    ADD CONSTRAINT class4_pkey_invoice_calls_id PRIMARY KEY (invoice_calls_id);


--
-- Name: invoice_credit_note class4_pkey_invoice_credit_note_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_credit_note
    ADD CONSTRAINT class4_pkey_invoice_credit_note_id PRIMARY KEY (id);


--
-- Name: invoice_daily_cost class4_pkey_invoice_daily_cost_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_daily_cost
    ADD CONSTRAINT class4_pkey_invoice_daily_cost_id PRIMARY KEY (id);


--
-- Name: invoice_did class4_pkey_invoice_did_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_did
    ADD CONSTRAINT class4_pkey_invoice_did_id PRIMARY KEY (id);


--
-- Name: invoice_email class4_pkey_invoice_email_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_email
    ADD CONSTRAINT class4_pkey_invoice_email_id PRIMARY KEY (id);


--
-- Name: invoice class4_pkey_invoice_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice
    ADD CONSTRAINT class4_pkey_invoice_id PRIMARY KEY (invoice_id);


--
-- Name: invoice_item class4_pkey_invoice_item_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_item
    ADD CONSTRAINT class4_pkey_invoice_item_id PRIMARY KEY (id);


--
-- Name: invoice_payment class4_pkey_invoice_payment_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_payment
    ADD CONSTRAINT class4_pkey_invoice_payment_id PRIMARY KEY (id);


--
-- Name: invoice_service_charge class4_pkey_invoice_service_charge_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_service_charge
    ADD CONSTRAINT class4_pkey_invoice_service_charge_id PRIMARY KEY (invoice_service_charge_id);


--
-- Name: jurisdiction_country class4_pkey_jurisdiction_country_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction_country
    ADD CONSTRAINT class4_pkey_jurisdiction_country_id PRIMARY KEY (id);


--
-- Name: jurisdiction class4_pkey_jurisdiction_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction
    ADD CONSTRAINT class4_pkey_jurisdiction_id PRIMARY KEY (id);


--
-- Name: jurisdiction_prefix class4_pkey_jurisdiction_prefix_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction_prefix
    ADD CONSTRAINT class4_pkey_jurisdiction_prefix_id PRIMARY KEY (id);


--
-- Name: lrn class4_pkey_lrn_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lrn
    ADD CONSTRAINT class4_pkey_lrn_id PRIMARY KEY (lrn_id);


--
-- Name: mail_tmplate class4_pkey_mail_tmplate_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mail_tmplate
    ADD CONSTRAINT class4_pkey_mail_tmplate_id PRIMARY KEY (id);


--
-- Name: online_users class4_pkey_online_users_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.online_users
    ADD CONSTRAINT class4_pkey_online_users_id PRIMARY KEY (online_id);


--
-- Name: order_code class4_pkey_order_code_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_code
    ADD CONSTRAINT class4_pkey_order_code_id PRIMARY KEY (id);


--
-- Name: order_partern class4_pkey_order_partern_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_partern
    ADD CONSTRAINT class4_pkey_order_partern_id PRIMARY KEY (id);


--
-- Name: order_user_alert class4_pkey_order_user_alert_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_user_alert
    ADD CONSTRAINT class4_pkey_order_user_alert_id PRIMARY KEY (id);


--
-- Name: order_user class4_pkey_order_user_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_user
    ADD CONSTRAINT class4_pkey_order_user_id PRIMARY KEY (id);


--
-- Name: order_user_rate_watch class4_pkey_order_user_rate_watch_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_user_rate_watch
    ADD CONSTRAINT class4_pkey_order_user_rate_watch_id PRIMARY KEY (id);


--
-- Name: partition_invoice class4_pkey_partition_invoice_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partition_invoice
    ADD CONSTRAINT class4_pkey_partition_invoice_id PRIMARY KEY (id);


--
-- Name: payment_term class4_pkey_payment_term_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_term
    ADD CONSTRAINT class4_pkey_payment_term_id PRIMARY KEY (payment_term_id);


--
-- Name: private_invite class4_pkey_private_invite_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.private_invite
    ADD CONSTRAINT class4_pkey_private_invite_id PRIMARY KEY (id);


--
-- Name: product class4_pkey_product_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product
    ADD CONSTRAINT class4_pkey_product_id PRIMARY KEY (product_id);


--
-- Name: product_items class4_pkey_product_items_item_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_items
    ADD CONSTRAINT class4_pkey_product_items_item_id PRIMARY KEY (item_id);


--
-- Name: product_items_resource class4_pkey_product_items_resource_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_items_resource
    ADD CONSTRAINT class4_pkey_product_items_resource_id PRIMARY KEY (id);


--
-- Name: rate_auto_create class4_pkey_rate_auto_create_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_auto_create
    ADD CONSTRAINT class4_pkey_rate_auto_create_id PRIMARY KEY (id);


--
-- Name: rate_auto_create_interval class4_pkey_rate_auto_create_interval_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_auto_create_interval
    ADD CONSTRAINT class4_pkey_rate_auto_create_interval_id PRIMARY KEY (id);


--
-- Name: rate class4_pkey_rate_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate
    ADD CONSTRAINT class4_pkey_rate_id PRIMARY KEY (rate_id);


--
-- Name: rate_table class4_pkey_rate_table_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_table
    ADD CONSTRAINT class4_pkey_rate_table_id PRIMARY KEY (rate_table_id);


--
-- Name: real_cdr class4_pkey_real_cdr_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.real_cdr
    ADD CONSTRAINT class4_pkey_real_cdr_id PRIMARY KEY (real_cdr_id);


--
-- Name: resource_block class4_pkey_resource_block_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_block
    ADD CONSTRAINT class4_pkey_resource_block_id PRIMARY KEY (res_block_id);


--
-- Name: resource_codecs_ref class4_pkey_resource_codecs_ref_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_codecs_ref
    ADD CONSTRAINT class4_pkey_resource_codecs_ref_id PRIMARY KEY (id);


--
-- Name: resource_direction class4_pkey_resource_direction_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_direction
    ADD CONSTRAINT class4_pkey_resource_direction_id PRIMARY KEY (direction_id);


--
-- Name: resource class4_pkey_resource_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource
    ADD CONSTRAINT class4_pkey_resource_id PRIMARY KEY (resource_id);


--
-- Name: resource_ip class4_pkey_resource_ip_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_ip
    ADD CONSTRAINT class4_pkey_resource_ip_id PRIMARY KEY (resource_ip_id);


--
-- Name: resource_ip_limit class4_pkey_resource_ip_limit_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_ip_limit
    ADD CONSTRAINT class4_pkey_resource_ip_limit_id PRIMARY KEY (limit_id);


--
-- Name: resource_lrn_action class4_pkey_resource_lrn_action_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_lrn_action
    ADD CONSTRAINT class4_pkey_resource_lrn_action_id PRIMARY KEY (id);


--
-- Name: resource_next_route_rule class4_pkey_resource_next_route_rule_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_next_route_rule
    ADD CONSTRAINT class4_pkey_resource_next_route_rule_id PRIMARY KEY (id);


--
-- Name: resource_prefix class4_pkey_resource_prefix_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_prefix
    ADD CONSTRAINT class4_pkey_resource_prefix_id PRIMARY KEY (id);


--
-- Name: resource_rate class4_pkey_resource_rate_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_rate
    ADD CONSTRAINT class4_pkey_resource_rate_id PRIMARY KEY (id);


--
-- Name: resource_replace_action class4_pkey_resource_replace_action_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_replace_action
    ADD CONSTRAINT class4_pkey_resource_replace_action_id PRIMARY KEY (id);


--
-- Name: resource_translation_ref class4_pkey_resource_translation_ref_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_translation_ref
    ADD CONSTRAINT class4_pkey_resource_translation_ref_id PRIMARY KEY (ref_id);


--
-- Name: role class4_pkey_role_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role
    ADD CONSTRAINT class4_pkey_role_id PRIMARY KEY (role_id);


--
-- Name: role_privilege class4_pkey_role_privilege_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role_privilege
    ADD CONSTRAINT class4_pkey_role_privilege_id PRIMARY KEY (role_privilege_id);


--
-- Name: route class4_pkey_route_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.route
    ADD CONSTRAINT class4_pkey_route_id PRIMARY KEY (route_id);


--
-- Name: route_strategy class4_pkey_route_strategy_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.route_strategy
    ADD CONSTRAINT class4_pkey_route_strategy_id PRIMARY KEY (route_strategy_id);


--
-- Name: sell_order class4_pkey_sell_order_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sell_order
    ADD CONSTRAINT class4_pkey_sell_order_id PRIMARY KEY (id);


--
-- Name: sell_order_response class4_pkey_sell_order_response_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sell_order_response
    ADD CONSTRAINT class4_pkey_sell_order_response_id PRIMARY KEY (id);


--
-- Name: server_platform class4_pkey_server_platform_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.server_platform
    ADD CONSTRAINT class4_pkey_server_platform_id PRIMARY KEY (server_id);


--
-- Name: service_charge class4_pkey_service_charge_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.service_charge
    ADD CONSTRAINT class4_pkey_service_charge_id PRIMARY KEY (service_charge_id);


--
-- Name: service_charge_items class4_pkey_service_charge_item_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.service_charge_items
    ADD CONSTRAINT class4_pkey_service_charge_item_id PRIMARY KEY (id);


--
-- Name: sip_error_code class4_pkey_sip_error_code_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sip_error_code
    ADD CONSTRAINT class4_pkey_sip_error_code_id PRIMARY KEY (sip_error_code_id);


--
-- Name: system_function class4_pkey_system_function_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.system_function
    ADD CONSTRAINT class4_pkey_system_function_id PRIMARY KEY (system_function_id);


--
-- Name: system_parameter class4_pkey_system_parameter; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.system_parameter
    ADD CONSTRAINT class4_pkey_system_parameter PRIMARY KEY (sys_id);


--
-- Name: task_manage class4_pkey_task_manage_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.task_manage
    ADD CONSTRAINT class4_pkey_task_manage_id PRIMARY KEY (id);


--
-- Name: test_device class4_pkey_test_device_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.test_device
    ADD CONSTRAINT class4_pkey_test_device_id PRIMARY KEY (test_device_id);


--
-- Name: time_profile class4_pkey_time_profile_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.time_profile
    ADD CONSTRAINT class4_pkey_time_profile_id PRIMARY KEY (time_profile_id);


--
-- Name: transaction_fee class4_pkey_transaction_fee_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_fee
    ADD CONSTRAINT class4_pkey_transaction_fee_id PRIMARY KEY (id);


--
-- Name: transaction_fee_items class4_pkey_transaction_fee_items_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_fee_items
    ADD CONSTRAINT class4_pkey_transaction_fee_items_id PRIMARY KEY (id);


--
-- Name: translation_item class4_pkey_translation_item_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.translation_item
    ADD CONSTRAINT class4_pkey_translation_item_id PRIMARY KEY (ref_id);


--
-- Name: users class4_pkey_users_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT class4_pkey_users_id PRIMARY KEY (user_id);


--
-- Name: web_session class4_pkey_web_session_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.web_session
    ADD CONSTRAINT class4_pkey_web_session_id PRIMARY KEY (id);


--
-- Name: agent_client_client class4_pr_agent_client_client_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_client_client
    ADD CONSTRAINT class4_pr_agent_client_client_client_id PRIMARY KEY (id);


--
-- Name: agent_client_client class4_pr_agent_client_client_uq_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_client_client
    ADD CONSTRAINT class4_pr_agent_client_client_uq_client_id UNIQUE (client_id);


--
-- Name: exchange_block_log class4_pr_exchange_block_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_block_log
    ADD CONSTRAINT class4_pr_exchange_block_log_id PRIMARY KEY (id);


--
-- Name: route_block class4_pr_route_block_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.route_block
    ADD CONSTRAINT class4_pr_route_block_id PRIMARY KEY (id);


--
-- Name: product_rout_rate_table class4_product_rout_rate_table_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_rout_rate_table
    ADD CONSTRAINT class4_product_rout_rate_table_id PRIMARY KEY (id);


--
-- Name: alert_action class4_uq_alert_action_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_action
    ADD CONSTRAINT class4_uq_alert_action_name UNIQUE (name);


--
-- Name: alert_condition class4_uq_alert_condition_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_condition
    ADD CONSTRAINT class4_uq_alert_condition_name UNIQUE (name);


--
-- Name: alert_rule class4_uq_alert_rule_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_rule
    ADD CONSTRAINT class4_uq_alert_rule_name UNIQUE (name);


--
-- Name: carrier_template class4_uq_carrier_template_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.carrier_template
    ADD CONSTRAINT class4_uq_carrier_template_name UNIQUE (template_name);


--
-- Name: client class4_uq_client_login; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client
    ADD CONSTRAINT class4_uq_client_login UNIQUE (login);


--
-- Name: client class4_uq_client_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client
    ADD CONSTRAINT class4_uq_client_name UNIQUE (name);


--
-- Name: code_country class4_uq_code_country_country; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_country
    ADD CONSTRAINT class4_uq_code_country_country UNIQUE (country);


--
-- Name: code_deck class4_uq_code_deck_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_deck
    ADD CONSTRAINT class4_uq_code_deck_client_id UNIQUE (client_id);


--
-- Name: code_deck class4_uq_code_deck_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code_deck
    ADD CONSTRAINT class4_uq_code_deck_name UNIQUE (name);


--
-- Name: codecs class4_uq_codecs_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.codecs
    ADD CONSTRAINT class4_uq_codecs_name UNIQUE (name);


--
-- Name: contract class4_uq_contract_order_number; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contract
    ADD CONSTRAINT class4_uq_contract_order_number UNIQUE (confirm_order_number);


--
-- Name: currency class4_uq_currency_code; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.currency
    ADD CONSTRAINT class4_uq_currency_code UNIQUE (code);


--
-- Name: dynamic_route class4_uq_dynamic_route_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route
    ADD CONSTRAINT class4_uq_dynamic_route_name UNIQUE (name);


--
-- Name: exchange_finance class4_uq_exchange_finance_number; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_finance
    ADD CONSTRAINT class4_uq_exchange_finance_number UNIQUE (action_number);


--
-- Name: global_failover class4_uq_global_failover; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.global_failover
    ADD CONSTRAINT class4_uq_global_failover UNIQUE (from_sip_code);


--
-- Name: invoice class4_uq_invoice_number; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice
    ADD CONSTRAINT class4_uq_invoice_number UNIQUE (invoice_number);


--
-- Name: jurisdiction class4_uq_jurisdiction_alias; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction
    ADD CONSTRAINT class4_uq_jurisdiction_alias UNIQUE (alias);


--
-- Name: jurisdiction class4_uq_jurisdiction_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction
    ADD CONSTRAINT class4_uq_jurisdiction_name UNIQUE (name);


--
-- Name: payment_term class4_uq_payment_term_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_term
    ADD CONSTRAINT class4_uq_payment_term_name UNIQUE (name);


--
-- Name: product_items class4_uq_product_item_pro_pre; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_items
    ADD CONSTRAINT class4_uq_product_item_pro_pre UNIQUE (product_id, digits);


--
-- Name: rate_table class4_uq_rate_table_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_table
    ADD CONSTRAINT class4_uq_rate_table_name UNIQUE (name);


--
-- Name: resource class4_uq_resource_alias; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource
    ADD CONSTRAINT class4_uq_resource_alias UNIQUE (alias);


--
-- Name: resource class4_uq_resource_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource
    ADD CONSTRAINT class4_uq_resource_name UNIQUE (name);


--
-- Name: resource_rate class4_uq_resource_rate; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_rate
    ADD CONSTRAINT class4_uq_resource_rate UNIQUE (code, ingress_id, egress_id);


--
-- Name: resource_next_route_rule class4_uq_resource_route_rule; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_next_route_rule
    ADD CONSTRAINT class4_uq_resource_route_rule UNIQUE (reponse_code, resource_id);


--
-- Name: role class4_uq_role_role_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role
    ADD CONSTRAINT class4_uq_role_role_name UNIQUE (role_name);


--
-- Name: route_strategy class4_uq_route_strategy_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.route_strategy
    ADD CONSTRAINT class4_uq_route_strategy_name UNIQUE (name);


--
-- Name: task_manage class4_uq_task_manage_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.task_manage
    ADD CONSTRAINT class4_uq_task_manage_name UNIQUE (name);


--
-- Name: time_profile class4_uq_time_profile_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.time_profile
    ADD CONSTRAINT class4_uq_time_profile_name UNIQUE (name);


--
-- Name: users class4_uq_users_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT class4_uq_users_name UNIQUE (name);


--
-- Name: cleanup cleanup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cleanup
    ADD CONSTRAINT cleanup_pkey PRIMARY KEY (id);


--
-- Name: client_balance_operation_action client_balance_operation_action_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_balance_operation_action
    ADD CONSTRAINT client_balance_operation_action_pkey PRIMARY KEY (id);


--
-- Name: client_low_balance_config client_low_balance_config_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_low_balance_config
    ADD CONSTRAINT client_low_balance_config_pkey PRIMARY KEY (client_id);


--
-- Name: client_transaction client_transaction_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_transaction
    ADD CONSTRAINT client_transaction_pkey PRIMARY KEY (id);


--
-- Name: credit_log credit_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.credit_log
    ADD CONSTRAINT credit_log_pkey PRIMARY KEY (id);


--
-- Name: current_dashboard_data current_dashboard_data_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.current_dashboard_data
    ADD CONSTRAINT current_dashboard_data_pkey PRIMARY KEY (id);


--
-- Name: daily_cdr_fields daily_cdr_fields_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.daily_cdr_fields
    ADD CONSTRAINT daily_cdr_fields_id PRIMARY KEY (id);


--
-- Name: email_log daily_email_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.email_log
    ADD CONSTRAINT daily_email_log_id PRIMARY KEY (id);


--
-- Name: dashboard_time_option dashboard_time_option_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dashboard_time_option
    ADD CONSTRAINT dashboard_time_option_pkey PRIMARY KEY (id);


--
-- Name: default_fields default_fields_report_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.default_fields
    ADD CONSTRAINT default_fields_report_name_key UNIQUE (report_name);


--
-- Name: dialer_detection dialer_detection_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dialer_detection
    ADD CONSTRAINT dialer_detection_pkey PRIMARY KEY (id);


--
-- Name: did_assign did_assign_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_assign
    ADD CONSTRAINT did_assign_pkey PRIMARY KEY (number);


--
-- Name: did_billing_brief did_billing_brief_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_billing_brief
    ADD CONSTRAINT did_billing_brief_pkey PRIMARY KEY (id);


--
-- Name: did_billing_plan did_billing_plan_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_billing_plan
    ADD CONSTRAINT did_billing_plan_pkey PRIMARY KEY (id);


--
-- Name: did_billing_rel did_billing_rel_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_billing_rel
    ADD CONSTRAINT did_billing_rel_pkey PRIMARY KEY (id);


--
-- Name: did_number_upload_task did_number_upload_task_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_number_upload_task
    ADD CONSTRAINT did_number_upload_task_pkey PRIMARY KEY (id);


--
-- Name: did_request_detail did_request_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_request_detail
    ADD CONSTRAINT did_request_detail_pkey PRIMARY KEY (id);


--
-- Name: did_request did_request_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_request
    ADD CONSTRAINT did_request_pkey PRIMARY KEY (id);


--
-- Name: did_special_code did_special_code_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_special_code
    ADD CONSTRAINT did_special_code_pkey PRIMARY KEY (id);


--
-- Name: rate_generate dnl_cloud_pkey_rate_generate_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generate
    ADD CONSTRAINT dnl_cloud_pkey_rate_generate_id PRIMARY KEY (id);


--
-- Name: egress_profile egress_profile_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.egress_profile
    ADD CONSTRAINT egress_profile_pkey PRIMARY KEY (id);


--
-- Name: mail_sender emails_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mail_sender
    ADD CONSTRAINT emails_pkey PRIMARY KEY (id);


--
-- Name: error_log error_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.error_log
    ADD CONSTRAINT error_log_pkey PRIMARY KEY (id);


--
-- Name: exchange_sys_module exchange sys module_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_module
    ADD CONSTRAINT "exchange sys module_id" PRIMARY KEY (id);


--
-- Name: exchange_agent_email_type exchange_agent_email_type_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_email_type
    ADD CONSTRAINT exchange_agent_email_type_id PRIMARY KEY (id);


--
-- Name: exchange_agent_exchange_push_list_result exchange_agent_exchange_push_list_result_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_exchange_push_list_result
    ADD CONSTRAINT exchange_agent_exchange_push_list_result_id PRIMARY KEY (id);


--
-- Name: exchange_agent_import_target_push exchange_agent_import_target_push_id_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_import_target_push
    ADD CONSTRAINT exchange_agent_import_target_push_id_pkey PRIMARY KEY (id);


--
-- Name: exchange_agent_mail_tmplate exchange_agent_mail_tmplate_id_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_mail_tmplate
    ADD CONSTRAINT exchange_agent_mail_tmplate_id_pkey PRIMARY KEY (id);


--
-- Name: exchange_agent_product_no_route exchange_agent_product_no_route_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_product_no_route
    ADD CONSTRAINT exchange_agent_product_no_route_id PRIMARY KEY (id);


--
-- Name: exchange_agent_send_mail_log exchange_agent_send_mail_log_id_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_send_mail_log
    ADD CONSTRAINT exchange_agent_send_mail_log_id_pkey PRIMARY KEY (id);


--
-- Name: exchange_client_user_list exchange_client_user_list_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_client_user_list
    ADD CONSTRAINT exchange_client_user_list_id PRIMARY KEY (id);


--
-- Name: exchange_finance_agent_clients exchange_finance_agent_clients_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_finance_agent_clients
    ADD CONSTRAINT exchange_finance_agent_clients_id PRIMARY KEY (id);


--
-- Name: exchange_finance_agent exchange_finance_agent_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_finance_agent
    ADD CONSTRAINT exchange_finance_agent_id PRIMARY KEY (id);


--
-- Name: exchange_job exchange_job_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job
    ADD CONSTRAINT exchange_job_id PRIMARY KEY (id);


--
-- Name: exchange_job_session_block_log exchange_job_session_block_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session_block_log
    ADD CONSTRAINT exchange_job_session_block_log_id PRIMARY KEY (id);


--
-- Name: exchange_job_session exchange_job_session_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session
    ADD CONSTRAINT exchange_job_session_id PRIMARY KEY (id);


--
-- Name: exchange_job_session_list exchange_job_session_list_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session_list
    ADD CONSTRAINT exchange_job_session_list_id PRIMARY KEY (id);


--
-- Name: exchange_my_route_download_log exchange_my_route_download_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_my_route_download_log
    ADD CONSTRAINT exchange_my_route_download_log_id PRIMARY KEY (id);


--
-- Name: exchange_opp_email exchange_opp_email_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_opp_email
    ADD CONSTRAINT exchange_opp_email_id PRIMARY KEY (id);


--
-- Name: exchange_par_account exchange_par_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_account
    ADD CONSTRAINT exchange_par_id PRIMARY KEY (id);


--
-- Name: exchange_par_plan_record exchange_par_plan_record_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_plan_record
    ADD CONSTRAINT exchange_par_plan_record_id PRIMARY KEY (id);


--
-- Name: exchange_par_system_parm exchange_par_system_parm_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_system_parm
    ADD CONSTRAINT exchange_par_system_parm_id PRIMARY KEY (id);


--
-- Name: exchange_product_copy_route_log exchange_product_copy_route_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_product_copy_route_log
    ADD CONSTRAINT exchange_product_copy_route_log_id PRIMARY KEY (id);


--
-- Name: exchange_product_user_list exchange_product_user_list_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_product_user_list
    ADD CONSTRAINT exchange_product_user_list_id PRIMARY KEY (id);


--
-- Name: exchange_reg_country exchange_reg_country_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_reg_country
    ADD CONSTRAINT exchange_reg_country_id PRIMARY KEY (id);


--
-- Name: exchange_resource_private exchange_resource_private_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_resource_private
    ADD CONSTRAINT exchange_resource_private_id PRIMARY KEY (id);


--
-- Name: exchange_simple_session exchange_simple_session_id_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_simple_session
    ADD CONSTRAINT exchange_simple_session_id_pkey PRIMARY KEY (id);


--
-- Name: exchange_simple_session_list exchange_simple_session_list_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_simple_session_list
    ADD CONSTRAINT exchange_simple_session_list_pkey PRIMARY KEY (id);


--
-- Name: exchange_sys_pri exchange_sys_pri_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_pri
    ADD CONSTRAINT exchange_sys_pri_id PRIMARY KEY (id);


--
-- Name: exchange_sys_pri exchange_sys_pri_pri_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_pri
    ADD CONSTRAINT exchange_sys_pri_pri_name_key UNIQUE (pri_name);


--
-- Name: exchange_sys_role exchange_sys_role_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_role
    ADD CONSTRAINT exchange_sys_role_pkey PRIMARY KEY (role_id);


--
-- Name: exchange_sys_role_pri exchange_sys_role_pri_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_role_pri
    ADD CONSTRAINT exchange_sys_role_pri_pkey PRIMARY KEY (id);


--
-- Name: execution_log execution_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.execution_log
    ADD CONSTRAINT execution_log_pkey PRIMARY KEY (id);


--
-- Name: export_task_log export_task_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.export_task_log
    ADD CONSTRAINT export_task_log_pkey PRIMARY KEY (id);


--
-- Name: fraud_detection_log_detail fraud_detection_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_detection_log_detail
    ADD CONSTRAINT fraud_detection_log_detail_pkey PRIMARY KEY (id);


--
-- Name: fraud_detection_log fraud_detection_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_detection_log
    ADD CONSTRAINT fraud_detection_log_pkey PRIMARY KEY (id);


--
-- Name: fraud_detection fraud_detection_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_detection
    ADD CONSTRAINT fraud_detection_pkey PRIMARY KEY (id);


--
-- Name: fraud_detection fraud_detection_rule_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_detection
    ADD CONSTRAINT fraud_detection_rule_name_key UNIQUE (rule_name);


--
-- Name: ftp_cdr_log_detail ftp_cdr_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ftp_cdr_log_detail
    ADD CONSTRAINT ftp_cdr_log_detail_pkey PRIMARY KEY (id);


--
-- Name: ftp_conf ftp_conf_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ftp_conf
    ADD CONSTRAINT ftp_conf_id PRIMARY KEY (id);


--
-- Name: ftp_server_log ftp_server_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ftp_server_log
    ADD CONSTRAINT ftp_server_log_pkey PRIMARY KEY (id);


--
-- Name: global_route_error global_route_error_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.global_route_error
    ADD CONSTRAINT global_route_error_pkey PRIMARY KEY (id);


--
-- Name: hang_calls_history hang_calls_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hang_calls_history
    ADD CONSTRAINT hang_calls_history_pkey PRIMARY KEY (id);


--
-- Name: hung_calls_detection_configuration hung_calls_detection_configuration_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hung_calls_detection_configuration
    ADD CONSTRAINT hung_calls_detection_configuration_pkey PRIMARY KEY (id);


--
-- Name: hung_calls_report_delete_log hung_calls_report_delete_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hung_calls_report_delete_log
    ADD CONSTRAINT hung_calls_report_delete_log_pkey PRIMARY KEY (id);


--
-- Name: task_schedule id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.task_schedule
    ADD CONSTRAINT id PRIMARY KEY (id);


--
-- Name: import_rate_status import_rate_status_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.import_rate_status
    ADD CONSTRAINT import_rate_status_id PRIMARY KEY (id);


--
-- Name: import_target_log import_target_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.import_target_log
    ADD CONSTRAINT import_target_log_id PRIMARY KEY (id);


--
-- Name: ingress_did_repository ingress_did_repository_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ingress_did_repository
    ADD CONSTRAINT ingress_did_repository_pkey PRIMARY KEY (number);


--
-- Name: invalid_detection_block_log invalid_detection_block_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_detection_block_log
    ADD CONSTRAINT invalid_detection_block_log_pkey PRIMARY KEY (id);


--
-- Name: invalid_number_detection invalid_number_detection_id_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_number_detection
    ADD CONSTRAINT invalid_number_detection_id_pkey PRIMARY KEY (id);


--
-- Name: invalid_number_detection_log_detail invalid_number_detection_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_number_detection_log_detail
    ADD CONSTRAINT invalid_number_detection_log_detail_pkey PRIMARY KEY (id);


--
-- Name: invalid_number_detection_log invalid_number_detection_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_number_detection_log
    ADD CONSTRAINT invalid_number_detection_log_pkey PRIMARY KEY (id);


--
-- Name: invoice_cdr_log invoice_cdr_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_cdr_log
    ADD CONSTRAINT invoice_cdr_log_pkey PRIMARY KEY (id);


--
-- Name: invoice_history invoice_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_history
    ADD CONSTRAINT invoice_history_pkey PRIMARY KEY (id);


--
-- Name: ip_modif_log ip_modif_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ip_modif_log
    ADD CONSTRAINT ip_modif_log_pkey PRIMARY KEY (id);


--
-- Name: jurisdiction_update_history jurisdiction_update_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction_update_history
    ADD CONSTRAINT jurisdiction_update_history_pkey PRIMARY KEY (id);


--
-- Name: jurisdiction_update_log jurisdiction_update_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction_update_log
    ADD CONSTRAINT jurisdiction_update_log_pkey PRIMARY KEY (id);


--
-- Name: kill_pg_sql_log kill_pg_sql_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.kill_pg_sql_log
    ADD CONSTRAINT kill_pg_sql_log_pkey PRIMARY KEY (id);


--
-- Name: lcr_record lcr_record_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lcr_record
    ADD CONSTRAINT lcr_record_pkey PRIMARY KEY (id);


--
-- Name: lcr_reports lcr_reports_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lcr_reports
    ADD CONSTRAINT lcr_reports_pkey PRIMARY KEY (id);


--
-- Name: license_modification_log license_modification_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.license_modification_log
    ADD CONSTRAINT license_modification_log_pkey PRIMARY KEY (id);


--
-- Name: lnp_request_detail lnp_request_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lnp_request_detail
    ADD CONSTRAINT lnp_request_detail_pkey PRIMARY KEY (id);


--
-- Name: lnp_request lnp_request_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lnp_request
    ADD CONSTRAINT lnp_request_pkey PRIMARY KEY (id);


--
-- Name: loop_detection_detail loop_detection_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loop_detection_detail
    ADD CONSTRAINT loop_detection_detail_pkey PRIMARY KEY (id);


--
-- Name: loop_detection loop_detection_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.loop_detection
    ADD CONSTRAINT loop_detection_pkey PRIMARY KEY (id);


--
-- Name: lrn_servers lrn_servers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lrn_servers
    ADD CONSTRAINT lrn_servers_pkey PRIMARY KEY (id);


--
-- Name: mail_cdr_log_detail mail_cdr_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mail_cdr_log_detail
    ADD CONSTRAINT mail_cdr_log_detail_pkey PRIMARY KEY (id);


--
-- Name: mail_cdr_log mail_cdr_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mail_cdr_log
    ADD CONSTRAINT mail_cdr_log_id PRIMARY KEY (id);


--
-- Name: modif_log modif_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.modif_log
    ADD CONSTRAINT modif_log_id PRIMARY KEY (id);


--
-- Name: ocn_lata ocn_lata_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ocn_lata
    ADD CONSTRAINT ocn_lata_pkey PRIMARY KEY (id);


--
-- Name: opentact_balance opentact_balance_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.opentact_balance
    ADD CONSTRAINT opentact_balance_pkey PRIMARY KEY (id);


--
-- Name: orig_invoice orig_invoice_pkey; Type: CONSTRAINT; Schema: public; Owner: class4_user
--

ALTER TABLE ONLY public.orig_invoice
    ADD CONSTRAINT orig_invoice_pkey PRIMARY KEY (invoice_id);


--
-- Name: orig_log orig_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.orig_log
    ADD CONSTRAINT orig_log_pkey PRIMARY KEY (log_id);


--
-- Name: par_user par_user_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.par_user
    ADD CONSTRAINT par_user_id PRIMARY KEY (id);


--
-- Name: payline_history payline_history_invoice_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payline_history
    ADD CONSTRAINT payline_history_invoice_id_key UNIQUE (invoice_id);


--
-- Name: payline_history payline_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payline_history
    ADD CONSTRAINT payline_history_pkey PRIMARY KEY (id);


--
-- Name: payment_invoice payment_invoice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_invoice
    ADD CONSTRAINT payment_invoice_pkey PRIMARY KEY (id);


--
-- Name: partner pri_partner_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partner
    ADD CONSTRAINT pri_partner_id PRIMARY KEY (id);


--
-- Name: pex_offers pri_pex_offers_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pex_offers
    ADD CONSTRAINT pri_pex_offers_id PRIMARY KEY (id);


--
-- Name: product_agents_ref product_agents_ref_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_agents_ref
    ADD CONSTRAINT product_agents_ref_pkey PRIMARY KEY (id);


--
-- Name: product_clients_ref product_clients_ref_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_clients_ref
    ADD CONSTRAINT product_clients_ref_pkey PRIMARY KEY (id);


--
-- Name: product_route_rate_table product_route_rate_table_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_route_rate_table
    ADD CONSTRAINT product_route_rate_table_pkey PRIMARY KEY (id);


--
-- Name: quick_cdr quick_cdr_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.quick_cdr
    ADD CONSTRAINT quick_cdr_pkey PRIMARY KEY (id);


--
-- Name: random_ani_populated_log random_ani_populated_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.random_ani_populated_log
    ADD CONSTRAINT random_ani_populated_log_pkey PRIMARY KEY (id);


--
-- Name: rate_bot_import_logs rate_bot_import_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_bot_import_logs
    ADD CONSTRAINT rate_bot_import_logs_pkey PRIMARY KEY (id);


--
-- Name: rate_download_log rate_download_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_download_log
    ADD CONSTRAINT rate_download_log_pkey PRIMARY KEY (id);


--
-- Name: rate_email_template rate_email_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_email_template
    ADD CONSTRAINT rate_email_template_pkey PRIMARY KEY (id);


--
-- Name: rate_generation_history_detail rate_generation_history_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_history_detail
    ADD CONSTRAINT rate_generation_history_detail_pkey PRIMARY KEY (id);


--
-- Name: rate_generation_history rate_generation_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_history
    ADD CONSTRAINT rate_generation_history_pkey PRIMARY KEY (id);


--
-- Name: rate_generation_rate rate_generation_rate_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_rate
    ADD CONSTRAINT rate_generation_rate_pkey PRIMARY KEY (generation_rate_id);


--
-- Name: rate_generation_template_detail rate_generation_template_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_template_detail
    ADD CONSTRAINT rate_generation_template_detail_pkey PRIMARY KEY (id);


--
-- Name: rate_generation_template_margin rate_generation_template_margin_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_template_margin
    ADD CONSTRAINT rate_generation_template_margin_pkey PRIMARY KEY (id);


--
-- Name: rate_generation_template rate_generation_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_template
    ADD CONSTRAINT rate_generation_template_pkey PRIMARY KEY (id);


--
-- Name: rate_handler rate_handler_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_handler
    ADD CONSTRAINT rate_handler_pkey PRIMARY KEY (id);


--
-- Name: rate_import_error_log rate_import_error_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_import_error_log
    ADD CONSTRAINT rate_import_error_log_pkey PRIMARY KEY (id);


--
-- Name: rate_mail_decks_files rate_mail_decks_files_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_mail_decks_files
    ADD CONSTRAINT rate_mail_decks_files_pkey PRIMARY KEY (id);


--
-- Name: rate_mail_decks rate_mail_decks_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_mail_decks
    ADD CONSTRAINT rate_mail_decks_pkey PRIMARY KEY (id);


--
-- Name: rate_mail rate_mail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_mail
    ADD CONSTRAINT rate_mail_pkey PRIMARY KEY (id);


--
-- Name: rate_management_option rate_management_option_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_management_option
    ADD CONSTRAINT rate_management_option_pkey PRIMARY KEY (id);


--
-- Name: rate_mass_edit_log rate_mass_edit_log_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_mass_edit_log
    ADD CONSTRAINT rate_mass_edit_log_id PRIMARY KEY (id);


--
-- Name: rate_send_log_detail rate_send_log_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_send_log_detail
    ADD CONSTRAINT rate_send_log_detail_pkey PRIMARY KEY (id);


--
-- Name: rate_send_log rate_send_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_send_log
    ADD CONSTRAINT rate_send_log_pkey PRIMARY KEY (id);


--
-- Name: rate_send_logging rate_send_logging_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_send_logging
    ADD CONSTRAINT rate_send_logging_id PRIMARY KEY (id);


--
-- Name: rate_send_rules rate_send_rules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_send_rules
    ADD CONSTRAINT rate_send_rules_pkey PRIMARY KEY (id);


--
-- Name: rate_upload_fail_log rate_upload_fail_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_upload_fail_log
    ADD CONSTRAINT rate_upload_fail_log_pkey PRIMARY KEY (id);


--
-- Name: rate_upload_queue rate_upload_queue_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_upload_queue
    ADD CONSTRAINT rate_upload_queue_pkey PRIMARY KEY (id);


--
-- Name: rate_upload_success_log rate_upload_success_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_upload_success_log
    ADD CONSTRAINT rate_upload_success_log_pkey PRIMARY KEY (id);


--
-- Name: rate_upload_task rate_upload_task_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_upload_task
    ADD CONSTRAINT rate_upload_task_pkey PRIMARY KEY (id);


--
-- Name: rate_upload_template rate_upload_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_upload_template
    ADD CONSTRAINT rate_upload_template_pkey PRIMARY KEY (id);


--
-- Name: ratemail_history ratemail_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ratemail_history
    ADD CONSTRAINT ratemail_history_pkey PRIMARY KEY (id);


--
-- Name: report_delivery_history report_delivery_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.report_delivery_history
    ADD CONSTRAINT report_delivery_history_pkey PRIMARY KEY (id);


--
-- Name: rerate_cdr_download_log rerate_cdr_download_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rerate_cdr_download_log
    ADD CONSTRAINT rerate_cdr_download_log_pkey PRIMARY KEY (id);


--
-- Name: rerate_cdr_task rerate_cdr_task_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rerate_cdr_task
    ADD CONSTRAINT rerate_cdr_task_pkey PRIMARY KEY (id);


--
-- Name: rerate_log rerate_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rerate_log
    ADD CONSTRAINT rerate_log_pkey PRIMARY KEY (rerate_log_id);


--
-- Name: rerate_report_exec_log rerate_report_exec_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rerate_report_exec_log
    ADD CONSTRAINT rerate_report_exec_log_pkey PRIMARY KEY (id);


--
-- Name: reseller_client reseller_client_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reseller_client
    ADD CONSTRAINT reseller_client_pkey PRIMARY KEY (id);


--
-- Name: reseller reseller_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reseller
    ADD CONSTRAINT reseller_pkey PRIMARY KEY (id);


--
-- Name: resource_block_group resource_block_group_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_block_group
    ADD CONSTRAINT resource_block_group_pkey PRIMARY KEY (id);


--
-- Name: resource_direction_template resource_direction_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_direction_template
    ADD CONSTRAINT resource_direction_template_pkey PRIMARY KEY (direction_id);


--
-- Name: resource_next_route_rule_template resource_next_route_rule_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_next_route_rule_template
    ADD CONSTRAINT resource_next_route_rule_template_pkey PRIMARY KEY (id);


--
-- Name: resource_replace_action_template resource_replace_action_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_replace_action_template
    ADD CONSTRAINT resource_replace_action_template_pkey PRIMARY KEY (id);


--
-- Name: resource_template resource_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_template
    ADD CONSTRAINT resource_template_pkey PRIMARY KEY (resource_template_id);


--
-- Name: retrieve_password_log retrieve_password_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.retrieve_password_log
    ADD CONSTRAINT retrieve_password_log_pkey PRIMARY KEY (id);


--
-- Name: routing_wizard_list routing_wizard_list_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.routing_wizard_list
    ADD CONSTRAINT routing_wizard_list_pkey PRIMARY KEY (id);


--
-- Name: scheduled_report_log scheduled_report_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scheduled_report_log
    ADD CONSTRAINT scheduled_report_log_pkey PRIMARY KEY (id);


--
-- Name: scheduled_report scheduled_report_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scheduled_report
    ADD CONSTRAINT scheduled_report_pkey PRIMARY KEY (id);


--
-- Name: scheduler_log scheduler_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scheduler_log
    ADD CONSTRAINT scheduler_log_pkey PRIMARY KEY (id);


--
-- Name: send_mails send_mails_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.send_mails
    ADD CONSTRAINT send_mails_pkey PRIMARY KEY (id);


--
-- Name: send_rate_preserved_data send_rate_preserved_data_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.send_rate_preserved_data
    ADD CONSTRAINT send_rate_preserved_data_pkey PRIMARY KEY (id);


--
-- Name: send_rate_template send_rate_template_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.send_rate_template
    ADD CONSTRAINT send_rate_template_id PRIMARY KEY (id);


--
-- Name: scheduler shceduler_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scheduler
    ADD CONSTRAINT shceduler_pkey PRIMARY KEY (id);


--
-- Name: signup_ip signup_ip_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.signup_ip
    ADD CONSTRAINT signup_ip_pkey PRIMARY KEY (id);


--
-- Name: signup signup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.signup
    ADD CONSTRAINT signup_pkey PRIMARY KEY (id);


--
-- Name: sip_registrations sip_registrations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sip_registrations
    ADD CONSTRAINT sip_registrations_pkey PRIMARY KEY (id);


--
-- Name: sip_requests sip_requests_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sip_requests
    ADD CONSTRAINT sip_requests_pkey PRIMARY KEY (id);


--
-- Name: spam_traffic_ip_record spam_traffic_ip_record_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.spam_traffic_ip_record
    ADD CONSTRAINT spam_traffic_ip_record_pkey PRIMARY KEY (record_id);


--
-- Name: switch_profile switch_profile_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.switch_profile
    ADD CONSTRAINT switch_profile_pkey PRIMARY KEY (id);


--
-- Name: sys_module sys_module_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sys_module
    ADD CONSTRAINT sys_module_pkey PRIMARY KEY (id);


--
-- Name: sys_pri sys_pri_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sys_pri
    ADD CONSTRAINT sys_pri_id PRIMARY KEY (id);


--
-- Name: sys_pri sys_pri_pri_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sys_pri
    ADD CONSTRAINT sys_pri_pri_name_key UNIQUE (pri_name);


--
-- Name: sys_role sys_role_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sys_role
    ADD CONSTRAINT sys_role_pkey PRIMARY KEY (role_id);


--
-- Name: traffic_alert traffic_alert_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.traffic_alert
    ADD CONSTRAINT traffic_alert_pkey PRIMARY KEY (id);


--
-- Name: trouble_tickets_template trouble_tickets_template_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.trouble_tickets_template
    ADD CONSTRAINT trouble_tickets_template_pkey PRIMARY KEY (id);


--
-- Name: trunk_group trunk_group_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.trunk_group
    ADD CONSTRAINT trunk_group_pkey PRIMARY KEY (group_id);


--
-- Name: trunk_pstn_header trunk_pstn_header_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.trunk_pstn_header
    ADD CONSTRAINT trunk_pstn_header_pkey PRIMARY KEY (id);


--
-- Name: dex unique_dex_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dex
    ADD CONSTRAINT unique_dex_name UNIQUE (dex_name);


--
-- Name: dex_resource_unactive unique_dex_resource_dein_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dex_resource_unactive
    ADD CONSTRAINT unique_dex_resource_dein_id UNIQUE (dex_id, dex_resource, ingress_id);


--
-- Name: dex_resource unique_dex_resource_id_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dex_resource
    ADD CONSTRAINT unique_dex_resource_id_id UNIQUE (dex_id, resource_id);


--
-- Name: order_partern unique_order_partern_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_partern
    ADD CONSTRAINT unique_order_partern_id UNIQUE (order_id, order_type, partern_id);


--
-- Name: partner unique_partner_client_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partner
    ADD CONSTRAINT unique_partner_client_id UNIQUE (client_id, partner_id);


--
-- Name: product_items_resource unique_product_items_id_resource_id; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_items_resource
    ADD CONSTRAINT unique_product_items_id_resource_id UNIQUE (item_id, resource_id);


--
-- Name: vendortest_project unique_project_name; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendortest_project
    ADD CONSTRAINT unique_project_name UNIQUE (project_name);


--
-- Name: transaction unique_transaction_client_id_date; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction
    ADD CONSTRAINT unique_transaction_client_id_date UNIQUE (client_id, date);


--
-- Name: CONSTRAINT unique_transaction_client_id_date ON transaction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON CONSTRAINT unique_transaction_client_id_date ON public.transaction IS 'client_idå’Œdateè”åˆå”¯ä¸€';


--
-- Name: vendortest_code unique_vendortest_code_code_proid; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendortest_code
    ADD CONSTRAINT unique_vendortest_code_code_proid UNIQUE (vendortest_project_id, code_name);


--
-- Name: upload_ani_log upload_ani_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.upload_ani_log
    ADD CONSTRAINT upload_ani_log_pkey PRIMARY KEY (id);


--
-- Name: us_export_log us_export_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.us_export_log
    ADD CONSTRAINT us_export_log_pkey PRIMARY KEY (id);


--
-- Name: us_ocn_lata us_ocn_lata_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.us_ocn_lata
    ADD CONSTRAINT us_ocn_lata_pkey PRIMARY KEY (id);


--
-- Name: usage_report_delivery usage_report_delivery_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.usage_report_delivery
    ADD CONSTRAINT usage_report_delivery_pkey PRIMARY KEY (id);


--
-- Name: users_limit users_limit_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users_limit
    ADD CONSTRAINT users_limit_pkey PRIMARY KEY (id);


--
-- Name: vendor_invoice_detail vendor_invoice_detail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendor_invoice_detail
    ADD CONSTRAINT vendor_invoice_detail_pkey PRIMARY KEY (id);


--
-- Name: vendor_invoice_dispute vendor_invoice_dispute_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendor_invoice_dispute
    ADD CONSTRAINT vendor_invoice_dispute_pkey PRIMARY KEY (id);


--
-- Name: vendor_invoice vendor_invoice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendor_invoice
    ADD CONSTRAINT vendor_invoice_pkey PRIMARY KEY (vendor_invoice_id);


--
-- Name: vendortest_code vendortest_code_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendortest_code
    ADD CONSTRAINT vendortest_code_pkey PRIMARY KEY (id);


--
-- Name: vendortest_number vendortest_number_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendortest_number
    ADD CONSTRAINT vendortest_number_pkey PRIMARY KEY (id);


--
-- Name: vendortest_project vendortest_project_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendortest_project
    ADD CONSTRAINT vendortest_project_pkey PRIMARY KEY (id);


--
-- Name: version_information version_information_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.version_information
    ADD CONSTRAINT version_information_pkey PRIMARY KEY (id);


--
-- Name: voip_gateway voip_gateway_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.voip_gateway
    ADD CONSTRAINT voip_gateway_pkey PRIMARY KEY (id);


--
-- Name: pga_exception_datetime; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE UNIQUE INDEX pga_exception_datetime ON pgagent.pga_exception USING btree (jexdate, jextime);


--
-- Name: pga_exception_jexscid; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE INDEX pga_exception_jexscid ON pgagent.pga_exception USING btree (jexscid);


--
-- Name: pga_jobclass_name; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE UNIQUE INDEX pga_jobclass_name ON pgagent.pga_jobclass USING btree (jclname);


--
-- Name: pga_joblog_jobid; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE INDEX pga_joblog_jobid ON pgagent.pga_joblog USING btree (jlgjobid);


--
-- Name: pga_jobschedule_jobid; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE INDEX pga_jobschedule_jobid ON pgagent.pga_schedule USING btree (jscjobid);


--
-- Name: pga_jobstep_jobid; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE INDEX pga_jobstep_jobid ON pgagent.pga_jobstep USING btree (jstjobid);


--
-- Name: pga_jobsteplog_jslid; Type: INDEX; Schema: pgagent; Owner: postgres
--

CREATE INDEX pga_jobsteplog_jslid ON pgagent.pga_jobsteplog USING btree (jsljlgid);


--
-- Name: alert_rules_log_detail_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX alert_rules_log_detail_time_idx ON public.alert_rules_log_detail USING btree ("time");


--
-- Name: alert_rules_log_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX alert_rules_log_time_idx ON public.alert_rules_log USING btree ("time");


--
-- Name: bad_number_detection_rules_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX bad_number_detection_rules_index ON public.bad_number_detection_rules USING btree (id);


--
-- Name: balance_log_client_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX balance_log_client_id_idx ON public.balance_log USING btree (client_id);


--
-- Name: balance_log_date_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX balance_log_date_idx ON public.balance_log USING btree (date);


--
-- Name: c4_agent_client_client_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_agent_client_client_record_id_idx ON public.agent_client_client_record USING btree (record_id);


--
-- Name: c4_allowed_sendto_ip_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_allowed_sendto_ip_record_id_idx ON public.allowed_sendto_ip_record USING btree (record_id);


--
-- Name: c4_balance_daily_reset_status_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_balance_daily_reset_status_idx ON public.balance_daily_reset_task USING btree (status);


--
-- Name: c4_balance_history_actual_date_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_balance_history_actual_date_idx ON public.balance_history_actual USING btree (date);


--
-- Name: c4_balance_history_date_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_balance_history_date_idx ON public.balance_history USING btree (date);


--
-- Name: c4_c4_lrn_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_c4_lrn_record_id_idx ON public.c4_lrn_record USING btree (record_id);


--
-- Name: c4_client_balance_create_client_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_client_balance_create_client_id_idx ON public.c4_client_balance USING btree (client_id);


--
-- Name: c4_client_balance_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_client_balance_record_id_idx ON public.c4_client_balance_record USING btree (record_id);


--
-- Name: c4_client_payment_payment_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_client_payment_payment_time_idx ON public.client_payment USING btree (payment_time);


--
-- Name: c4_client_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_client_record_id_idx ON public.client_record USING btree (record_id);


--
-- Name: c4_code_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_code_record_id_idx ON public.code_record USING btree (record_id);


--
-- Name: c4_currency_updates_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_currency_updates_record_id_idx ON public.currency_updates_record USING btree (record_id);


--
-- Name: c4_dynamic_route_items_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_dynamic_route_items_record_id_idx ON public.dynamic_route_items_record USING btree (record_id);


--
-- Name: c4_dynamic_route_override_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_dynamic_route_override_record_id_idx ON public.dynamic_route_override_record USING btree (record_id);


--
-- Name: c4_dynamic_route_pri_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_dynamic_route_pri_record_id_idx ON public.dynamic_route_pri_record USING btree (record_id);


--
-- Name: c4_dynamic_route_qos_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_dynamic_route_qos_record_id_idx ON public.dynamic_route_qos_record USING btree (record_id);


--
-- Name: c4_dynamic_route_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_dynamic_route_record_id_idx ON public.dynamic_route_record USING btree (record_id);


--
-- Name: c4_egress_profile_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_egress_profile_record_id_idx ON public.egress_profile_record USING btree (record_id);


--
-- Name: c4_exchange_finance_complete_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_exchange_finance_complete_time_idx ON public.exchange_finance USING btree (complete_time);


--
-- Name: c4_exchange_par_account_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_exchange_par_account_record_id_idx ON public.exchange_par_account_record USING btree (record_id);


--
-- Name: c4_global_route_error_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_global_route_error_record_id_idx ON public.global_route_error_record USING btree (record_id);


--
-- Name: c4_jurisdiction_prefix_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_jurisdiction_prefix_record_id_idx ON public.jurisdiction_prefix_record USING btree (record_id);


--
-- Name: c4_livecall_user_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_livecall_user_name_idx ON public.c4_livecall_user USING btree (name);


--
-- Name: c4_origination_global_failover_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_origination_global_failover_record_id_idx ON public.origination_global_failover_record USING btree (record_id);


--
-- Name: c4_partition_gateway_ref_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_partition_gateway_ref_record_id_idx ON public.partition_gateway_ref_record USING btree (record_id);


--
-- Name: c4_payment_term_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_payment_term_record_id_idx ON public.payment_term_record USING btree (record_id);


--
-- Name: c4_product_items_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_product_items_record_id_idx ON public.product_items_record USING btree (record_id);


--
-- Name: c4_product_items_resource_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_product_items_resource_record_id_idx ON public.product_items_resource_record USING btree (record_id);


--
-- Name: c4_product_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_product_record_id_idx ON public.product_record USING btree (record_id);


--
-- Name: c4_product_rout_rate_table_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_product_rout_rate_table_record_id_idx ON public.product_rout_rate_table_record USING btree (record_id);


--
-- Name: c4_random_ani_generation_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_random_ani_generation_record_id_idx ON public.random_ani_generation_record USING btree (record_id);


--
-- Name: c4_rate_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_rate_record_id_idx ON public.rate_record USING btree (record_id);


--
-- Name: c4_rate_table_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_rate_table_record_id_idx ON public.rate_table_record USING btree (record_id);


--
-- Name: c4_resource_block_items_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_block_items_record_id_idx ON public.resource_block_items_record USING btree (record_id);


--
-- Name: c4_resource_block_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_block_record_id_idx ON public.resource_block_record USING btree (record_id);


--
-- Name: c4_resource_capacity_egress_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_capacity_egress_id_idx ON public.resource_capacity USING btree (egress_id);


--
-- Name: c4_resource_capacity_ingress_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_capacity_ingress_id_idx ON public.resource_capacity USING btree (ingress_id);


--
-- Name: c4_resource_capacity_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_capacity_record_id_idx ON public.resource_capacity_record USING btree (record_id);


--
-- Name: c4_resource_codecs_ref_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_codecs_ref_record_id_idx ON public.resource_codecs_ref_record USING btree (record_id);


--
-- Name: c4_resource_direction_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_direction_record_id_idx ON public.resource_direction_record USING btree (record_id);


--
-- Name: c4_resource_ip_limit_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_ip_limit_record_id_idx ON public.resource_ip_limit_record USING btree (record_id);


--
-- Name: c4_resource_ip_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_ip_record_id_idx ON public.resource_ip_record USING btree (record_id);


--
-- Name: c4_resource_lrn_action_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_lrn_action_record_id_idx ON public.resource_lrn_action_record USING btree (record_id);


--
-- Name: c4_resource_next_route_rule_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_next_route_rule_record_id_idx ON public.resource_next_route_rule_record USING btree (record_id);


--
-- Name: c4_resource_prefix_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_prefix_record_id_idx ON public.resource_prefix_record USING btree (record_id);


--
-- Name: c4_resource_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_record_id_idx ON public.resource_record USING btree (record_id);


--
-- Name: c4_resource_replace_action_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_replace_action_record_id_idx ON public.resource_replace_action_record USING btree (record_id);


--
-- Name: c4_resource_translation_ref_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_resource_translation_ref_record_id_idx ON public.resource_translation_ref_record USING btree (record_id);


--
-- Name: c4_route_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_route_record_id_idx ON public.route_record USING btree (record_id);


--
-- Name: c4_service_charge_items_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_service_charge_items_record_id_idx ON public.service_charge_items_record USING btree (record_id);


--
-- Name: c4_sip_error_code_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_sip_error_code_record_id_idx ON public.sip_error_code_record USING btree (record_id);


--
-- Name: c4_sip_registrations_username_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_sip_registrations_username_idx ON public.sip_registrations USING btree (username);


--
-- Name: c4_spam_traffic_ip_idx_new; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_spam_traffic_ip_idx_new ON public.spam_traffic_ip USING btree (ip);


--
-- Name: c4_switch_profile_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_switch_profile_record_id_idx ON public.switch_profile_record USING btree (record_id);


--
-- Name: c4_system_configure_create_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_system_configure_create_time_idx ON public.system_configure USING btree (create_time);


--
-- Name: c4_system_configure_switch_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_system_configure_switch_name_idx ON public.system_configure USING btree (switch_name);


--
-- Name: c4_termination_global_failover_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_termination_global_failover_record_id_idx ON public.termination_global_failover_record USING btree (record_id);


--
-- Name: c4_time_profile_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_time_profile_record_id_idx ON public.time_profile_record USING btree (record_id);


--
-- Name: c4_transaction_fee_items_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_transaction_fee_items_record_id_idx ON public.transaction_fee_items_record USING btree (record_id);


--
-- Name: c4_translation_item_record_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_translation_item_record_id_idx ON public.translation_item_record USING btree (record_id);


--
-- Name: c4_trunk_pstn_header_egress_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_trunk_pstn_header_egress_id_idx ON public.trunk_pstn_header USING btree (egress_id);


--
-- Name: c4_trunk_pstn_header_ingress_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c4_trunk_pstn_header_ingress_id_idx ON public.trunk_pstn_header USING btree (ingress_id);


--
-- Name: cdr_list_export_log_client_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX cdr_list_export_log_client_id_idx ON public.cdr_list_export_log USING btree (client_id);


--
-- Name: class4_idx_client_rate_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_client_rate_id ON public.client_rate USING btree (client_id, rate_table_id);


--
-- Name: class4_idx_code_code_deck_prefix; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_code_code_deck_prefix ON public.code USING btree (code_deck_id, code);


--
-- Name: class4_idx_code_prefix; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_code_prefix ON public.code USING gist (code public.gist_prefix_range_ops);


--
-- Name: class4_idx_dashboard_time_option_admin_point_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_dashboard_time_option_admin_point_time ON public.dashboard_time_option USING btree (admin_point_time);


--
-- Name: class4_idx_dashboard_time_option_client_point_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_dashboard_time_option_client_point_time ON public.dashboard_time_option USING btree (client_point_time);


--
-- Name: class4_idx_dashboard_time_option_iden; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_dashboard_time_option_iden ON public.dashboard_time_option USING btree (iden);


--
-- Name: class4_idx_host_info_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_host_info_time ON public.host_info USING btree ("time");


--
-- Name: class4_idx_jurisdiction_prefix; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_jurisdiction_prefix ON public.jurisdiction_prefix USING gist (prefix public.gist_prefix_range_ops);


--
-- Name: class4_idx_lrn_report_ingress_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_lrn_report_ingress_id ON public.lrn_report USING btree (ingress_id);


--
-- Name: class4_idx_lrn_report_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_lrn_report_time ON public.lrn_report USING btree (report_time);


--
-- Name: class4_idx_order_code_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_order_code_code ON public.order_code USING gist (code public.gist_prefix_range_ops);


--
-- Name: class4_idx_order_code_order_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_order_code_order_id ON public.order_code USING btree (order_id, order_type);


--
-- Name: class4_idx_order_code_order_id_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_order_code_order_id_code ON public.order_code USING gist (code public.gist_prefix_range_ops, order_id, order_type);


--
-- Name: class4_idx_product_clients_ref_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_product_clients_ref_client_id ON public.product_clients_ref USING btree (client_id);


--
-- Name: class4_idx_product_clients_ref_product_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_product_clients_ref_product_id ON public.product_clients_ref USING btree (product_id);


--
-- Name: class4_idx_product_items_prefix; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_product_items_prefix ON public.product_items USING gist (digits public.gist_prefix_range_ops, product_id);


--
-- Name: class4_idx_qos_ip_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_ip_time ON public.qos_ip USING btree (report_time);


--
-- Name: class4_idx_qos_ip_time_ip; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_ip_time_ip ON public.qos_ip USING btree (report_time, ip_id);


--
-- Name: class4_idx_qos_resource_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_resource_time ON public.qos_resource USING btree (report_time);


--
-- Name: class4_idx_qos_resource_time_res; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_resource_time_res ON public.qos_resource USING btree (report_time, res_id);


--
-- Name: class4_idx_qos_route_report_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_route_report_resource_id ON public.qos_route_report USING btree (report_time, resource_id);


--
-- Name: class4_idx_qos_total_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_qos_total_time ON public.qos_total USING btree (report_time);


--
-- Name: class4_idx_rate_info_time; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_rate_info_time ON public.rate_info USING btree ("time");


--
-- Name: class4_idx_rate_table_id_code; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_rate_table_id_code ON public.rate USING gist (code public.gist_prefix_range_ops, rate_table_id);


--
-- Name: class4_idx_real_cdr_uuid_b; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_idx_real_cdr_uuid_b ON public.real_cdr USING btree (uuid_b);


--
-- Name: class4_pr_rate_table_code_ref_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_pr_rate_table_code_ref_index ON public.rate_table_code_ref USING btree (rate_table_id);


--
-- Name: class4_rate_end_date_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX class4_rate_end_date_idx ON public.rate USING btree (end_date);


--
-- Name: client_balance_operation_action_client_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX client_balance_operation_action_client_id_idx ON public.client_balance_operation_action USING btree (client_id);


--
-- Name: client_balance_operation_action_update_flag_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX client_balance_operation_action_update_flag_idx ON public.client_balance_operation_action USING btree (update_result);


--
-- Name: client_cdr_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX client_cdr_time_idx ON public.client_cdr USING btree ("time");


--
-- Name: did_billing_brief_did_number_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX did_billing_brief_did_number_idx ON public.did_billing_brief USING btree (did_number);


--
-- Name: dynamic_route_override_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX dynamic_route_override_record_tmp_idx ON public.dynamic_route_override_record_tmp USING btree (record_id);


--
-- Name: dynamic_route_pri_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX dynamic_route_pri_record_tmp_idx ON public.dynamic_route_pri_record_tmp USING btree (record_id);


--
-- Name: dynamic_route_qos_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX dynamic_route_qos_record_tmp_idx ON public.dynamic_route_qos_record_tmp USING btree (record_id);


--
-- Name: egress_profile_egress_ingress_profile_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX egress_profile_egress_ingress_profile_idx ON public.egress_profile USING btree (server_name, egress_id, ingress_id);


--
-- Name: fki_; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_ ON public.sys_role_pri USING btree (role_id);


--
-- Name: fki_class4_fkey_alert_mail_order_user_alert_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_alert_mail_order_user_alert_id ON public.alert_mail USING btree (user_alert_id);


--
-- Name: fki_class4_fkey_block_loop_log_calls_log_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_block_loop_log_calls_log_id ON public.block_loop_log_calls USING btree (block_loop_log_id);


--
-- Name: fki_class4_fkey_buy_order_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_buy_order_client_id ON public.buy_order USING btree (client_id);


--
-- Name: fki_class4_fkey_buy_order_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_buy_order_resource_id ON public.buy_order USING btree (resource_id);


--
-- Name: fki_class4_fkey_client_commit_code_contract_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_code_contract_id ON public.client_commit_code USING btree (contract_id);


--
-- Name: fki_class4_fkey_client_commit_code_egress_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_code_egress_id ON public.client_commit_code USING btree (egress_id);


--
-- Name: fki_class4_fkey_client_commit_code_ingress_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_code_ingress_id ON public.client_commit_code USING btree (ingress_id);


--
-- Name: fki_class4_fkey_client_commit_minutes_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_minutes_client_id ON public.client_commit_minutes USING btree (client_id);


--
-- Name: fki_class4_fkey_client_commit_minutes_contract_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_minutes_contract_id ON public.client_commit_minutes USING btree (contract_id);


--
-- Name: fki_class4_fkey_client_commit_minutes_ingress_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_commit_minutes_ingress_id ON public.client_commit_minutes USING btree (ingress_id);


--
-- Name: fki_class4_fkey_client_currency_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_currency_id ON public.client USING btree (currency_id);


--
-- Name: fki_class4_fkey_client_group_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_group_id ON public.client USING btree (group_id);


--
-- Name: fki_class4_fkey_client_orig_rate_table_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_orig_rate_table_id ON public.client USING btree (orig_rate_table_id);


--
-- Name: fki_class4_fkey_client_payment_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_payment_client_id ON public.client_payment USING btree (client_id);


--
-- Name: fki_class4_fkey_client_payment_invoice_number; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_payment_invoice_number ON public.client_payment USING btree (invoice_number);


--
-- Name: fki_class4_fkey_client_payment_term_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_payment_term_id ON public.client USING btree (payment_term_id);


--
-- Name: fki_class4_fkey_client_role_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_client_role_id ON public.client USING btree (role_id);


--
-- Name: fki_class4_fkey_code_code_deck_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_code_code_deck_id ON public.code USING btree (code_deck_id);


--
-- Name: fki_class4_fkey_contract_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_contract_client_id ON public.contract USING btree (client_id);


--
-- Name: fki_class4_fkey_contract_code_contract_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_contract_code_contract_id ON public.contract_code USING btree (contract_id);


--
-- Name: fki_class4_fkey_contract_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_contract_resource_id ON public.contract USING btree (resource_id);


--
-- Name: fki_class4_fkey_contract_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_contract_user_id ON public.contract USING btree (user_id);


--
-- Name: fki_class4_fkey_currency_updates_currency_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_currency_updates_currency_id ON public.currency_updates USING btree (currency_id);


--
-- Name: fki_class4_fkey_dynamic_route_items_dynamic_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_items_dynamic_route_id ON public.dynamic_route_items USING btree (dynamic_route_id);


--
-- Name: fki_class4_fkey_dynamic_route_items_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_items_resource_id ON public.dynamic_route_items USING btree (resource_id);


--
-- Name: fki_class4_fkey_dynamic_route_override_dynamic_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_override_dynamic_route_id ON public.dynamic_route_override USING btree (dynamic_route_id);


--
-- Name: fki_class4_fkey_dynamic_route_override_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_override_resource_id ON public.dynamic_route_override USING btree (resource_id);


--
-- Name: fki_class4_fkey_dynamic_route_pri_dynamic_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_pri_dynamic_route_id ON public.dynamic_route_pri USING btree (dynamic_route_id);


--
-- Name: fki_class4_fkey_dynamic_route_pri_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_pri_resource_id ON public.dynamic_route_pri USING btree (resource_id);


--
-- Name: fki_class4_fkey_dynamic_route_qos_dynamic_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_qos_dynamic_route_id ON public.dynamic_route_qos USING btree (dynamic_route_id);


--
-- Name: fki_class4_fkey_dynamic_route_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_dynamic_route_time_profile_id ON public.dynamic_route USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_invoice_calls_invoice_no; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_invoice_calls_invoice_no ON public.invoice_calls USING btree (invoice_no);


--
-- Name: fki_class4_fkey_invoice_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_invoice_client_id ON public.invoice USING btree (client_id);


--
-- Name: fki_class4_fkey_invoice_item_invoice_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_invoice_item_invoice_id ON public.invoice_item USING btree (invoice_id);


--
-- Name: fki_class4_fkey_jurisdiction_country_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_jurisdiction_country_id ON public.jurisdiction USING btree (jurisdiction_country_id);


--
-- Name: fki_class4_fkey_jurisdiction_prefix_country_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_jurisdiction_prefix_country_id ON public.jurisdiction_prefix USING btree (jurisdiction_country_id);


--
-- Name: fki_class4_fkey_jurisdiction_prefix_jurisdiction_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_jurisdiction_prefix_jurisdiction_id ON public.jurisdiction_prefix USING btree (jurisdiction_id);


--
-- Name: fki_class4_fkey_order_user_alert_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_order_user_alert_user_id ON public.order_user_alert USING btree (user_id);


--
-- Name: fki_class4_fkey_order_user_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_order_user_client_id ON public.order_user USING btree (client_id);


--
-- Name: fki_class4_fkey_order_user_rate_watch_alert_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_order_user_rate_watch_alert_id ON public.order_user_rate_watch USING btree (order_user_alert_id);


--
-- Name: fki_class4_fkey_product_items_product_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_product_items_product_id ON public.product_items USING btree (product_id);


--
-- Name: fki_class4_fkey_product_items_resource_item_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_product_items_resource_item_id ON public.product_items_resource USING btree (item_id);


--
-- Name: fki_class4_fkey_product_items_resource_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_product_items_resource_resource_id ON public.product_items_resource USING btree (resource_id);


--
-- Name: fki_class4_fkey_product_items_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_product_items_time_profile_id ON public.product_items USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_rate_auto_create_interval_rate_create_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_auto_create_interval_rate_create_id ON public.rate_auto_create_interval USING btree (rate_auto_create_id);


--
-- Name: fki_class4_fkey_rate_did_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_did_type ON public.rate USING btree (did_type);


--
-- Name: fki_class4_fkey_rate_rate_table_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_rate_table_id ON public.rate USING btree (rate_table_id);


--
-- Name: fki_class4_fkey_rate_table_code_deck_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_table_code_deck_id ON public.rate_table USING btree (code_deck_id);


--
-- Name: fki_class4_fkey_rate_table_currency_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_table_currency_id ON public.rate_table USING btree (currency_id);


--
-- Name: fki_class4_fkey_rate_table_jurisdiction_country_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_table_jurisdiction_country_id ON public.rate_table USING btree (jurisdiction_country_id);


--
-- Name: fki_class4_fkey_rate_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_rate_time_profile_id ON public.rate USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_reosurce_ip_limit_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_reosurce_ip_limit_time_profile_id ON public.resource_ip_limit USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_resource_block_engress_res_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_block_engress_res_id ON public.resource_block USING btree (engress_res_id);


--
-- Name: fki_class4_fkey_resource_block_ingress_res_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_block_ingress_res_id ON public.resource_block USING btree (ingress_res_id);


--
-- Name: fki_class4_fkey_resource_block_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_block_time_profile_id ON public.resource_block USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_resource_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_client_id ON public.resource USING btree (client_id);


--
-- Name: fki_class4_fkey_resource_codec_ref_codec_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_codec_ref_codec_id ON public.resource_codecs_ref USING btree (codec_id);


--
-- Name: fki_class4_fkey_resource_direction_template_resource_template_i; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_direction_template_resource_template_i ON public.resource_direction_template USING btree (resource_template_id);


--
-- Name: fki_class4_fkey_resource_direction_template_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_direction_template_time_profile_id ON public.resource_direction_template USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_resource_direction_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_direction_time_profile_id ON public.resource_direction USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_resource_ip_limit_ip_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_ip_limit_ip_id ON public.resource_ip_limit USING btree (ip_id);


--
-- Name: fki_class4_fkey_resource_ip_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_ip_resource_id ON public.resource_ip USING btree (resource_id);


--
-- Name: fki_class4_fkey_resource_prefix_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_prefix_resource_id ON public.resource_prefix USING btree (resource_id);


--
-- Name: fki_class4_fkey_resource_rate_table_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_rate_table_id ON public.resource USING btree (rate_table_id);


--
-- Name: fki_class4_fkey_resource_replace_action_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_replace_action_resource_id ON public.resource_replace_action USING btree (resource_id);


--
-- Name: fki_class4_fkey_resource_route_strategy_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_route_strategy_id ON public.resource USING btree (route_strategy_id);


--
-- Name: fki_class4_fkey_resource_translation_ref_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_translation_ref_resource_id ON public.resource_translation_ref USING btree (resource_id);


--
-- Name: fki_class4_fkey_resource_translation_ref_time_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_translation_ref_time_profile_id ON public.resource_translation_ref USING btree (time_profile_id);


--
-- Name: fki_class4_fkey_resource_translation_ref_translation_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_resource_translation_ref_translation_id ON public.resource_translation_ref USING btree (translation_id);


--
-- Name: fki_class4_fkey_role_privilege_role_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_role_privilege_role_id ON public.role_privilege USING btree (role_id);


--
-- Name: fki_class4_fkey_role_privilege_system_function_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_role_privilege_system_function_id ON public.role_privilege USING btree (system_function_id);


--
-- Name: fki_class4_fkey_route_dynamic_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_route_dynamic_route_id ON public.route USING btree (dynamic_route_id);


--
-- Name: fki_class4_fkey_route_route_strategy_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_route_route_strategy_id ON public.route USING btree (route_strategy_id);


--
-- Name: fki_class4_fkey_route_static_route_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_route_static_route_id ON public.route USING btree (static_route_id);


--
-- Name: fki_class4_fkey_sell_order_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_sell_order_resource_id ON public.sell_order USING btree (resource_id);


--
-- Name: fki_class4_fkey_sell_order_response_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_sell_order_response_client_id ON public.sell_order_response USING btree (client_id);


--
-- Name: fki_class4_fkey_sell_order_response_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_sell_order_response_resource_id ON public.sell_order_response USING btree (resource_id);


--
-- Name: fki_class4_fkey_sell_order_response_sell_order_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_sell_order_response_sell_order_id ON public.sell_order_response USING btree (sell_order_id);


--
-- Name: fki_class4_fkey_sell_order_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_sell_order_user_id ON public.sell_order USING btree (user_id);


--
-- Name: fki_class4_fkey_term_rate_table_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_term_rate_table_id ON public.client USING btree (term_rate_table_id);


--
-- Name: fki_class4_fkey_test_device_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_test_device_resource_id ON public.test_device USING btree (resource_id);


--
-- Name: fki_class4_fkey_translation_item; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_translation_item ON public.translation_item USING btree (translation_id);


--
-- Name: fki_class4_fkey_users_role_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_fkey_users_role_id ON public.users USING btree (role_id);


--
-- Name: fki_class4_key_sell_order_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_key_sell_order_client_id ON public.sell_order USING btree (client_id);


--
-- Name: fki_class4_pkey_buy_order_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_pkey_buy_order_user_id ON public.buy_order USING btree (user_id);


--
-- Name: fki_class4_resource_codecs_ref_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_resource_codecs_ref_resource_id ON public.resource_codecs_ref USING btree (resource_id);


--
-- Name: fki_class4_resource_direction_resource_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_class4_resource_direction_resource_id ON public.resource_direction USING btree (resource_id);


--
-- Name: fki_exchange_agent_import_target_push_job_import_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_import_target_push_job_import_id_pkey ON public.exchange_agent_import_target_push_job USING btree (import_id);


--
-- Name: fki_exchange_agent_send_email_log_list; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_send_email_log_list ON public.exchange_agent_send_mail_log_list USING btree (client_id);


--
-- Name: fki_exchange_agent_send_mail_log_email_template_fkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_send_mail_log_email_template_fkey ON public.exchange_agent_send_mail_log USING btree (email_template);


--
-- Name: fki_exchange_agent_send_mail_log_list_log_id_fkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_send_mail_log_list_log_id_fkey ON public.exchange_agent_send_mail_log_list USING btree (log_id);


--
-- Name: fki_exchange_agent_user_agent_client_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_user_agent_client_id_pkey ON public.exchange_agent_user USING btree (agent_client_id);


--
-- Name: fki_exchange_agent_user_role_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_agent_user_role_id_pkey ON public.exchange_agent_user USING btree (role_id);


--
-- Name: fki_exchange_false_del_resource_id_key; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_false_del_resource_id_key ON public.exchange_false_del USING btree (resource_id);


--
-- Name: fki_exchange_job_list_job_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_list_job_id ON public.exchange_job_list USING btree (job_id);


--
-- Name: fki_exchange_job_list_trunk_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_list_trunk_id ON public.exchange_job_list USING btree (trunk_id);


--
-- Name: fki_exchange_job_product_id_fkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_product_id_fkey ON public.exchange_job USING btree (product_id);


--
-- Name: fki_exchange_job_session_block_log_session_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_session_block_log_session_id ON public.exchange_job_session_block_log USING btree (session_id);


--
-- Name: fki_exchange_job_session_block_log_trunk_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_session_block_log_trunk_id ON public.exchange_job_session_block_log USING btree (trunk_id);


--
-- Name: fki_exchange_job_session_job_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_session_job_id ON public.exchange_job_session USING btree (job_id);


--
-- Name: fki_exchange_job_session_list_session_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_session_list_session_id ON public.exchange_job_session_list USING btree (session_id);


--
-- Name: fki_exchange_job_session_list_trunk_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_job_session_list_trunk_id ON public.exchange_job_session_list USING btree (trunk_id);


--
-- Name: fki_exchange_par_account_role_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_par_account_role_id_pkey ON public.exchange_par_account USING btree (role_id);


--
-- Name: fki_exchange_simple_session_list_session_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_simple_session_list_session_id_pkey ON public.exchange_simple_session_list USING btree (session_id);


--
-- Name: fki_exchange_simple_session_list_trunk_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_simple_session_list_trunk_pkey ON public.exchange_simple_session_list USING btree (trunk_id);


--
-- Name: fki_exchange_sys_role_pri_id_fkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_exchange_sys_role_pri_id_fkey ON public.exchange_sys_role_pri USING btree (pri_id);


--
-- Name: fki_order_user_role_id_pkey; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_order_user_role_id_pkey ON public.order_user USING btree (role_id);


--
-- Name: fki_sys_pri_pri_module_id_key; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_sys_pri_pri_module_id_key ON public.sys_pri USING btree (module_id);


--
-- Name: fki_voip_server_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fki_voip_server_id ON public.switch_profile USING btree (voip_gateway_id);


--
-- Name: fraud_detection_log_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX fraud_detection_log_time_idx ON public.fraud_detection_log USING btree ("time");


--
-- Name: hang_calls_history_start_time_end_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX hang_calls_history_start_time_end_time_idx ON public.hang_calls_history USING btree (start_time, end_time);


--
-- Name: hang_calls_list_hang_calls_history_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX hang_calls_list_hang_calls_history_id_idx ON public.hang_calls_list USING btree (hang_calls_history_id);


--
-- Name: hang_calls_list_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX hang_calls_list_time_idx ON public.hang_calls_list USING btree ("time");


--
-- Name: idx_logs_act_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_logs_act_type ON public.logs USING btree (act_type);


--
-- Name: idx_logs_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_logs_user_id ON public.logs USING btree (user_id);


--
-- Name: idx_prefix_info_search; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_prefix_info_search ON public.prefix_info USING btree ("time");


--
-- Name: idx_rate_log_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_rate_log_user_id ON public.rate_log USING btree (user_id);


--
-- Name: idx_search_logs_module; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_search_logs_module ON public.search_logs USING btree (module);


--
-- Name: idx_search_logs_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_search_logs_type ON public.search_logs USING btree (type);


--
-- Name: idx_transaction_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transaction_client_id ON public.transaction USING btree (client_id);


--
-- Name: idx_transaction_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_transaction_date ON public.transaction USING btree (date);


--
-- Name: invoice_history_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX invoice_history_client_id ON public.invoice_history USING btree (client_id);


--
-- Name: invoice_history_last_invoice_for; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX invoice_history_last_invoice_for ON public.invoice_history USING btree (last_invoice_for);


--
-- Name: jurisdiction_prefix_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX jurisdiction_prefix_record_tmp_idx ON public.jurisdiction_prefix_record_tmp USING btree (record_id);


--
-- Name: jurisdiction_update_history_task_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX jurisdiction_update_history_task_id_idx ON public.jurisdiction_update_history USING btree (task_id);


--
-- Name: opentact_balance_ingress_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX opentact_balance_ingress_id_idx ON public.opentact_balance USING btree (ingress_id);


--
-- Name: payline_history_invoice_id_keys; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX payline_history_invoice_id_keys ON public.payline_history USING btree (invoice_id);


--
-- Name: product_items_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX product_items_record_tmp_idx ON public.product_items_record_tmp USING btree (record_id);


--
-- Name: product_items_resource_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX product_items_resource_record_tmp_idx ON public.product_items_resource_record_tmp USING btree (record_id);


--
-- Name: qos_ip_server_ip_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX qos_ip_server_ip_index ON public.qos_ip USING btree (server_ip);


--
-- Name: qos_ip_server_port_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX qos_ip_server_port_index ON public.qos_ip USING btree (server_port);


--
-- Name: qos_resource_server_ip_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX qos_resource_server_ip_index ON public.qos_resource USING btree (server_ip);


--
-- Name: qos_resource_server_port_index; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX qos_resource_server_port_index ON public.qos_resource USING btree (server_port);


--
-- Name: qos_route_report_report_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX qos_route_report_report_time_idx ON public.qos_route_report USING btree (report_time);


--
-- Name: quick_cdr_user_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX quick_cdr_user_id_idx ON public.quick_cdr USING btree (user_id);


--
-- Name: random_ani_generation_ani_number_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX random_ani_generation_ani_number_idx ON public.random_ani_generation USING btree (ani_number);


--
-- Name: random_ani_generation_random_table_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX random_ani_generation_random_table_id_idx ON public.random_ani_generation USING btree (random_table_id);


--
-- Name: rate_generation_code_deck_tmplate_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_code_deck_tmplate_id_idx ON public.rate_generation_code_deck USING btree (rate_generation_template_id);


--
-- Name: rate_generation_history_status_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_history_status_idx ON public.rate_generation_history USING btree (status);


--
-- Name: rate_generation_rate_rate_generation_history_id_code_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_rate_rate_generation_history_id_code_idx ON public.rate_generation_rate USING btree (rate_generation_history_id, code);


--
-- Name: rate_generation_rate_rate_generation_history_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_rate_rate_generation_history_id_idx ON public.rate_generation_rate USING btree (rate_generation_history_id);


--
-- Name: rate_generation_template_detail_tmplate_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_template_detail_tmplate_id_idx ON public.rate_generation_template_detail USING btree (rate_generation_template_id);


--
-- Name: rate_generation_template_margin_tmplate_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_generation_template_margin_tmplate_id_idx ON public.rate_generation_template_margin USING btree (rate_generation_template_id);


--
-- Name: rate_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rate_record_tmp_idx ON public.rate_record_tmp USING btree (record_id);


--
-- Name: route_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX route_record_tmp_idx ON public.route_record_tmp USING btree (record_id);


--
-- Name: spam_traffic_ip_record_time_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX spam_traffic_ip_record_time_idx ON public.spam_traffic_ip_record USING btree ("time");


--
-- Name: translation_item_record_tmp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX translation_item_record_tmp_idx ON public.translation_item_record_tmp USING btree (record_id);


--
-- Name: unique_strategy_prefix_client_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX unique_strategy_prefix_client_id ON public.client_route_strategy USING btree (prefix, client_id);


--
-- Name: vendor_invoice_detail_vendor_invoice_id_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX vendor_invoice_detail_vendor_invoice_id_idx ON public.vendor_invoice_detail USING btree (vendor_invoice_id);


--
-- Name: version_information_program_switch_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX version_information_program_switch_name_idx ON public.version_information USING btree (program_name, switch_name);


--
-- Name: pga_exception pga_exception_trigger; Type: TRIGGER; Schema: pgagent; Owner: postgres
--

CREATE TRIGGER pga_exception_trigger AFTER INSERT OR DELETE OR UPDATE ON pgagent.pga_exception FOR EACH ROW EXECUTE PROCEDURE pgagent.pga_exception_trigger();


--
-- Name: TRIGGER pga_exception_trigger ON pga_exception; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TRIGGER pga_exception_trigger ON pgagent.pga_exception IS 'Update the job''s next run time whenever an exception changes';


--
-- Name: pga_job pga_job_trigger; Type: TRIGGER; Schema: pgagent; Owner: postgres
--

CREATE TRIGGER pga_job_trigger BEFORE UPDATE ON pgagent.pga_job FOR EACH ROW EXECUTE PROCEDURE pgagent.pga_job_trigger();


--
-- Name: TRIGGER pga_job_trigger ON pga_job; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TRIGGER pga_job_trigger ON pgagent.pga_job IS 'Update the job''s next run time.';


--
-- Name: pga_schedule pga_schedule_trigger; Type: TRIGGER; Schema: pgagent; Owner: postgres
--

CREATE TRIGGER pga_schedule_trigger AFTER INSERT OR DELETE OR UPDATE ON pgagent.pga_schedule FOR EACH ROW EXECUTE PROCEDURE pgagent.pga_schedule_trigger();


--
-- Name: TRIGGER pga_schedule_trigger ON pga_schedule; Type: COMMENT; Schema: pgagent; Owner: postgres
--

COMMENT ON TRIGGER pga_schedule_trigger ON pgagent.pga_schedule IS 'Update the job''s next run time whenever a schedule changes';


--
-- Name: c4_livecall_user c4_livecall_user_trig_record; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER c4_livecall_user_trig_record AFTER INSERT OR DELETE OR UPDATE ON public.c4_livecall_user FOR EACH ROW EXECUTE PROCEDURE public.c4_livecall_user_trigfun_record();


--
-- Name: host_based_report class4_trig_chost_based_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_chost_based_report_insert BEFORE INSERT ON public.host_based_report FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_host_based_report_insert();


--
-- Name: client_cdr class4_trig_client_cdr_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_client_cdr_insert BEFORE INSERT ON public.client_cdr FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_cdr_insert();


--
-- Name: cdr_report_detail class4_trig_client_report_detail_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_client_report_detail_insert BEFORE INSERT ON public.cdr_report_detail FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_report_detail_insert();


--
-- Name: cdr_report class4_trig_client_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_client_report_insert BEFORE INSERT ON public.cdr_report FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_report_insert();


--
-- Name: agent_client_client class4_trig_record_agent_client_client; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_agent_client_client AFTER INSERT OR DELETE OR UPDATE ON public.agent_client_client FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_agent_client_client();


--
-- Name: allowed_sendto_ip class4_trig_record_allowed_sendto_ip; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_allowed_sendto_ip AFTER INSERT OR DELETE OR UPDATE ON public.allowed_sendto_ip FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_allowed_sendto_ip();


--
-- Name: buy_order class4_trig_record_buy_order; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_buy_order AFTER INSERT OR DELETE OR UPDATE ON public.buy_order FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_buy_order();


--
-- Name: c4_lrn class4_trig_record_c4_lrn; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_c4_lrn AFTER INSERT OR DELETE OR UPDATE ON public.c4_lrn FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_c4_lrn();


--
-- Name: client class4_trig_record_client; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_client AFTER INSERT OR DELETE OR UPDATE ON public.client FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_client();


--
-- Name: client_commit_code class4_trig_record_client_commit_code; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_client_commit_code AFTER INSERT OR DELETE OR UPDATE ON public.client_commit_code FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_client_commit_code();


--
-- Name: client_commit_minutes class4_trig_record_client_commit_minutes; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_client_commit_minutes AFTER INSERT OR DELETE OR UPDATE ON public.client_commit_minutes FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_client_commit_minutes();


--
-- Name: code class4_trig_record_code; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_code AFTER INSERT OR DELETE OR UPDATE ON public.code FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_code();


--
-- Name: contract class4_trig_record_contract; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_contract AFTER INSERT OR DELETE OR UPDATE ON public.contract FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_contract();


--
-- Name: currency class4_trig_record_currency; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_currency AFTER INSERT OR DELETE OR UPDATE ON public.currency FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_currency();


--
-- Name: currency_updates class4_trig_record_currency_updates; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_currency_updates AFTER INSERT OR DELETE OR UPDATE ON public.currency_updates FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_currency_updates();


--
-- Name: dynamic_route class4_trig_record_dynamic_route; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_dynamic_route AFTER INSERT OR DELETE OR UPDATE ON public.dynamic_route FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_dynamic_route();


--
-- Name: dynamic_route_items class4_trig_record_dynamic_route_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_dynamic_route_items AFTER INSERT OR DELETE OR UPDATE ON public.dynamic_route_items FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_dynamic_route_items();


--
-- Name: dynamic_route_override class4_trig_record_dynamic_route_override; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_dynamic_route_override AFTER INSERT OR DELETE OR UPDATE ON public.dynamic_route_override FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_dynamic_route_override();


--
-- Name: dynamic_route_pri class4_trig_record_dynamic_route_pri; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_dynamic_route_pri AFTER INSERT OR DELETE OR UPDATE ON public.dynamic_route_pri FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_dynamic_route_pri();


--
-- Name: dynamic_route_qos class4_trig_record_dynamic_route_qos; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_dynamic_route_qos AFTER INSERT OR DELETE OR UPDATE ON public.dynamic_route_qos FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_dynamic_route_qos();


--
-- Name: egress_profile class4_trig_record_egress_profile; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_egress_profile AFTER INSERT OR DELETE OR UPDATE ON public.egress_profile FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_egress_profile();


--
-- Name: exchange_par_account class4_trig_record_exchange_par_account; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_exchange_par_account AFTER INSERT OR DELETE OR UPDATE ON public.exchange_par_account FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_exchange_par_account();


--
-- Name: global_route_error class4_trig_record_global_route_error; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_global_route_error AFTER INSERT OR DELETE OR UPDATE ON public.global_route_error FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_global_route_error();


--
-- Name: jurisdiction_prefix class4_trig_record_jurisdiction_prefix; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_jurisdiction_prefix AFTER INSERT OR DELETE OR UPDATE ON public.jurisdiction_prefix FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_jurisdiction_prefix();


--
-- Name: lrn_groups class4_trig_record_lrn_groups; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_lrn_groups AFTER INSERT OR DELETE OR UPDATE ON public.lrn_groups FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_lrn_groups();


--
-- Name: lrn_items class4_trig_record_lrn_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_lrn_items AFTER INSERT OR DELETE OR UPDATE ON public.lrn_items FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_lrn_items();


--
-- Name: origination_global_failover class4_trig_record_origination_global_failover; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_origination_global_failover AFTER INSERT OR DELETE OR UPDATE ON public.origination_global_failover FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_origination_global_failover();


--
-- Name: partition_gateway_ref class4_trig_record_partition_gateway_ref; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_partition_gateway_ref AFTER INSERT OR DELETE OR UPDATE ON public.partition_gateway_ref FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_partition_gateway_ref();


--
-- Name: payment_term class4_trig_record_payment_term; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_payment_term AFTER INSERT OR DELETE OR UPDATE ON public.payment_term FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_payment_term();


--
-- Name: product class4_trig_record_product; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_product AFTER INSERT OR DELETE OR UPDATE ON public.product FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_product();


--
-- Name: product_items class4_trig_record_product_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_product_items AFTER INSERT OR DELETE OR UPDATE ON public.product_items FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_product_items();


--
-- Name: product_items_resource class4_trig_record_product_items_resource; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_product_items_resource AFTER INSERT OR DELETE OR UPDATE ON public.product_items_resource FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_product_items_resource();


--
-- Name: product_rout_rate_table class4_trig_record_product_rout_rate_table; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_product_rout_rate_table AFTER INSERT OR DELETE OR UPDATE ON public.product_rout_rate_table FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_product_rout_rate_table();


--
-- Name: random_ani_generation class4_trig_record_random_ani_generation; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_random_ani_generation AFTER INSERT OR DELETE OR UPDATE ON public.random_ani_generation FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_random_ani_generation();


--
-- Name: rate class4_trig_record_rate; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_rate AFTER INSERT OR DELETE OR UPDATE ON public.rate FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_rate();


--
-- Name: rate_table class4_trig_record_rate_table; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_rate_table AFTER INSERT OR DELETE OR UPDATE ON public.rate_table FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_rate_table();


--
-- Name: resource class4_trig_record_resource; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource AFTER INSERT OR DELETE OR UPDATE ON public.resource FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource();


--
-- Name: resource_block class4_trig_record_resource_block; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_block AFTER INSERT OR DELETE OR UPDATE ON public.resource_block FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_block();


--
-- Name: resource_block_items class4_trig_record_resource_block_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_block_items AFTER INSERT OR DELETE OR UPDATE ON public.resource_block_items FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_block_items();


--
-- Name: resource_capacity class4_trig_record_resource_capacity; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_capacity AFTER INSERT OR DELETE OR UPDATE ON public.resource_capacity FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_capacity();


--
-- Name: resource_codecs_ref class4_trig_record_resource_codecs_ref; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_codecs_ref AFTER INSERT OR DELETE OR UPDATE ON public.resource_codecs_ref FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_codecs_ref();


--
-- Name: resource_direction class4_trig_record_resource_direction; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_direction AFTER INSERT OR DELETE OR UPDATE ON public.resource_direction FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_direction();


--
-- Name: resource_ip class4_trig_record_resource_ip; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_ip AFTER INSERT OR DELETE OR UPDATE ON public.resource_ip FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_ip();


--
-- Name: resource_ip_limit class4_trig_record_resource_ip_limit; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_ip_limit AFTER INSERT OR DELETE OR UPDATE ON public.resource_ip_limit FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_ip_limit();


--
-- Name: resource_lrn_action class4_trig_record_resource_lrn_action; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_lrn_action AFTER INSERT OR DELETE OR UPDATE ON public.resource_lrn_action FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_lrn_action();


--
-- Name: resource_next_route_rule class4_trig_record_resource_next_route_rule; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_next_route_rule AFTER INSERT OR DELETE OR UPDATE ON public.resource_next_route_rule FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_next_route_rule();


--
-- Name: resource_prefix class4_trig_record_resource_prefix; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_prefix AFTER INSERT OR DELETE OR UPDATE ON public.resource_prefix FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_prefix();


--
-- Name: resource_rate class4_trig_record_resource_rate; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_rate AFTER INSERT OR DELETE OR UPDATE ON public.resource_rate FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_rate();


--
-- Name: resource_replace_action class4_trig_record_resource_replace_action; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_replace_action AFTER INSERT OR DELETE OR UPDATE ON public.resource_replace_action FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_replace_action();


--
-- Name: resource_translation_ref class4_trig_record_resource_translation_ref; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_resource_translation_ref AFTER INSERT OR DELETE OR UPDATE ON public.resource_translation_ref FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_resource_translation_ref();


--
-- Name: route class4_trig_record_route; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_route AFTER INSERT OR DELETE OR UPDATE ON public.route FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_route();


--
-- Name: sell_order class4_trig_record_sell_order; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_sell_order AFTER INSERT OR DELETE OR UPDATE ON public.sell_order FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_sell_order();


--
-- Name: service_charge_items class4_trig_record_service_charge_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_service_charge_items AFTER INSERT OR DELETE OR UPDATE ON public.service_charge_items FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_service_charge_items();


--
-- Name: sip_error_code class4_trig_record_sip_error_code; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_sip_error_code AFTER INSERT OR DELETE OR UPDATE ON public.sip_error_code FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_sip_error_code();


--
-- Name: spam_traffic_ip class4_trig_record_spam_traffic_ip; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_spam_traffic_ip AFTER INSERT OR DELETE OR UPDATE ON public.spam_traffic_ip FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_spam_traffic_ip();


--
-- Name: switch_profile class4_trig_record_switch_profile; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_switch_profile AFTER INSERT OR DELETE OR UPDATE ON public.switch_profile FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_switch_profile();


--
-- Name: termination_global_failover class4_trig_record_termination_global_failover; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_termination_global_failover AFTER INSERT OR DELETE OR UPDATE ON public.termination_global_failover FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_termination_global_failover();


--
-- Name: time_profile class4_trig_record_time_profile; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_time_profile AFTER INSERT OR DELETE OR UPDATE ON public.time_profile FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_time_profile();


--
-- Name: transaction_fee_items class4_trig_record_transaction_fee_items; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_transaction_fee_items AFTER INSERT OR DELETE OR UPDATE ON public.transaction_fee_items FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_transaction_fee_items();


--
-- Name: translation_item class4_trig_record_translation_item; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_translation_item AFTER INSERT OR DELETE OR UPDATE ON public.translation_item FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_translation_item();


--
-- Name: trunk_pstn_header class4_trig_record_trunk_pstn_header; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trig_record_trunk_pstn_header AFTER INSERT OR DELETE OR UPDATE ON public.trunk_pstn_header FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_record_trunk_pstn_header();


--
-- Name: did_report class4_trigfun_did_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_did_report_insert BEFORE INSERT ON public.did_report FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_did_report_insert();


--
-- Name: us_frequent_number_report class4_trigfun_us_frequent_number_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_us_frequent_number_report_insert BEFORE INSERT ON public.us_frequent_number_report FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_us_frequent_number_report_insert();


--
-- Name: us_lcr_report class4_trigfun_us_lcr_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_us_lcr_report_insert BEFORE INSERT ON public.us_lcr_report FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_us_lcr_report_insert();


--
-- Name: us_lcr_vendor_report class4_trigfun_us_lcr_vendor_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_us_lcr_vendor_report_insert BEFORE INSERT ON public.us_lcr_vendor_report FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_us_lcr_vendor_report_insert();


--
-- Name: us_return_code_report class4_trigfun_us_return_code_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_us_return_code_report_insert BEFORE INSERT ON public.us_return_code_report FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_us_return_code_report_insert();


--
-- Name: us_termination_vendor_report class4_trigfun_us_termination_vendor_report_insert; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER class4_trigfun_us_termination_vendor_report_insert BEFORE INSERT ON public.us_termination_vendor_report FOR EACH ROW EXECUTE PROCEDURE public.class4_trigfun_us_termination_vendor_report_insert();


--
-- Name: product_rout_rate_table product_rout_rate_table_trig_record; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER product_rout_rate_table_trig_record AFTER INSERT OR DELETE OR UPDATE ON public.product_rout_rate_table FOR EACH ROW EXECUTE PROCEDURE public.product_rout_rate_table_trigfun_record();


--
-- Name: client_cdr t_opentact_balance_func; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER t_opentact_balance_func AFTER INSERT ON public.client_cdr FOR EACH ROW EXECUTE PROCEDURE public.opentact_balance_func();


--
-- Name: register_of_record t_opentact_egress_registration; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER t_opentact_egress_registration AFTER INSERT OR UPDATE ON public.register_of_record FOR EACH ROW EXECUTE PROCEDURE public.opentact_egress_registration();


--
-- Name: pga_exception pga_exception_jexscid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_exception
    ADD CONSTRAINT pga_exception_jexscid_fkey FOREIGN KEY (jexscid) REFERENCES pgagent.pga_schedule(jscid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: pga_job pga_job_jobagentid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_job
    ADD CONSTRAINT pga_job_jobagentid_fkey FOREIGN KEY (jobagentid) REFERENCES pgagent.pga_jobagent(jagpid) ON UPDATE RESTRICT ON DELETE SET NULL;


--
-- Name: pga_job pga_job_jobjclid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_job
    ADD CONSTRAINT pga_job_jobjclid_fkey FOREIGN KEY (jobjclid) REFERENCES pgagent.pga_jobclass(jclid) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- Name: pga_joblog pga_joblog_jlgjobid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_joblog
    ADD CONSTRAINT pga_joblog_jlgjobid_fkey FOREIGN KEY (jlgjobid) REFERENCES pgagent.pga_job(jobid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: pga_jobstep pga_jobstep_jstjobid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_jobstep
    ADD CONSTRAINT pga_jobstep_jstjobid_fkey FOREIGN KEY (jstjobid) REFERENCES pgagent.pga_job(jobid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: pga_jobsteplog pga_jobsteplog_jsljlgid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_jobsteplog
    ADD CONSTRAINT pga_jobsteplog_jsljlgid_fkey FOREIGN KEY (jsljlgid) REFERENCES pgagent.pga_joblog(jlgid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: pga_jobsteplog pga_jobsteplog_jsljstid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_jobsteplog
    ADD CONSTRAINT pga_jobsteplog_jsljstid_fkey FOREIGN KEY (jsljstid) REFERENCES pgagent.pga_jobstep(jstid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: pga_schedule pga_schedule_jscjobid_fkey; Type: FK CONSTRAINT; Schema: pgagent; Owner: postgres
--

ALTER TABLE ONLY pgagent.pga_schedule
    ADD CONSTRAINT pga_schedule_jscjobid_fkey FOREIGN KEY (jscjobid) REFERENCES pgagent.pga_job(jobid) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- Name: agent_client agent_client_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_client
    ADD CONSTRAINT agent_client_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agent(agent_id) ON DELETE CASCADE;


--
-- Name: agent_client agent_client_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_client
    ADD CONSTRAINT agent_client_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE CASCADE;


--
-- Name: agent_clients agent_clients_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_clients
    ADD CONSTRAINT agent_clients_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agent(agent_id) ON DELETE CASCADE;


--
-- Name: agent_clients agent_clients_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_clients
    ADD CONSTRAINT agent_clients_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE CASCADE;


--
-- Name: agent_commission_history agent_commission_history_agent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_commission_history
    ADD CONSTRAINT agent_commission_history_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.agent(agent_id) ON DELETE CASCADE;


--
-- Name: agent_commission_history_detail agent_commission_history_detail_history_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_commission_history_detail
    ADD CONSTRAINT agent_commission_history_detail_history_id_fkey FOREIGN KEY (history_id) REFERENCES public.agent_commission_history(history_id) ON DELETE CASCADE;


--
-- Name: agent_commission_payment agent_commission_payment_history_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.agent_commission_payment
    ADD CONSTRAINT agent_commission_payment_history_id_fkey FOREIGN KEY (history_id) REFERENCES public.agent_commission_history(history_id) ON DELETE CASCADE;


--
-- Name: alert_action alert_action_trouble_tickets_template_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_action
    ADD CONSTRAINT alert_action_trouble_tickets_template_fkey FOREIGN KEY (trouble_tickets_template) REFERENCES public.trouble_tickets_template(id);


--
-- Name: balance_history_actual balance_history_actual_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.balance_history_actual
    ADD CONSTRAINT balance_history_actual_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE CASCADE;


--
-- Name: balance_history balance_history_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.balance_history
    ADD CONSTRAINT balance_history_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE CASCADE;


--
-- Name: block_ani block_ani_action_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_ani
    ADD CONSTRAINT block_ani_action_id_fkey FOREIGN KEY (action_id) REFERENCES public.alert_action(id);


--
-- Name: alert_mail class4_fkey_alert_mail_order_user_alert_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.alert_mail
    ADD CONSTRAINT class4_fkey_alert_mail_order_user_alert_id FOREIGN KEY (user_alert_id) REFERENCES public.order_user_alert(id);


--
-- Name: block_loop_log_calls class4_fkey_block_loop_log_calls_log_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.block_loop_log_calls
    ADD CONSTRAINT class4_fkey_block_loop_log_calls_log_id FOREIGN KEY (block_loop_log_id) REFERENCES public.block_loop_log(id);


--
-- Name: buy_order class4_fkey_buy_order_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.buy_order
    ADD CONSTRAINT class4_fkey_buy_order_client_id FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE CASCADE;


--
-- Name: buy_order class4_fkey_buy_order_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.buy_order
    ADD CONSTRAINT class4_fkey_buy_order_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: client_commit_code class4_fkey_client_commit_code_contract_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_commit_code
    ADD CONSTRAINT class4_fkey_client_commit_code_contract_id FOREIGN KEY (contract_id) REFERENCES public.contract(id) ON DELETE CASCADE;


--
-- Name: client_commit_code class4_fkey_client_commit_code_egress_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_commit_code
    ADD CONSTRAINT class4_fkey_client_commit_code_egress_id FOREIGN KEY (egress_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: client_commit_code class4_fkey_client_commit_code_ingress_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_commit_code
    ADD CONSTRAINT class4_fkey_client_commit_code_ingress_id FOREIGN KEY (ingress_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: client_commit_minutes class4_fkey_client_commit_minutes_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_commit_minutes
    ADD CONSTRAINT class4_fkey_client_commit_minutes_client_id FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE CASCADE;


--
-- Name: client_commit_minutes class4_fkey_client_commit_minutes_contract_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_commit_minutes
    ADD CONSTRAINT class4_fkey_client_commit_minutes_contract_id FOREIGN KEY (contract_id) REFERENCES public.contract(id) ON DELETE CASCADE;


--
-- Name: client_commit_minutes class4_fkey_client_commit_minutes_ingress_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_commit_minutes
    ADD CONSTRAINT class4_fkey_client_commit_minutes_ingress_id FOREIGN KEY (ingress_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: client class4_fkey_client_currency_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client
    ADD CONSTRAINT class4_fkey_client_currency_id FOREIGN KEY (currency_id) REFERENCES public.currency(currency_id) ON DELETE SET NULL;


--
-- Name: client class4_fkey_client_group_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client
    ADD CONSTRAINT class4_fkey_client_group_id FOREIGN KEY (group_id) REFERENCES public.carrier_group(group_id) ON DELETE SET NULL;


--
-- Name: client_payment class4_fkey_client_payment_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_payment
    ADD CONSTRAINT class4_fkey_client_payment_client_id FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE SET NULL;


--
-- Name: client class4_fkey_client_payment_term_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client
    ADD CONSTRAINT class4_fkey_client_payment_term_id FOREIGN KEY (payment_term_id) REFERENCES public.payment_term(payment_term_id) ON DELETE SET NULL;


--
-- Name: code class4_fkey_code_code_deck_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.code
    ADD CONSTRAINT class4_fkey_code_code_deck_id FOREIGN KEY (code_deck_id) REFERENCES public.code_deck(code_deck_id) ON DELETE CASCADE;


--
-- Name: contract_code class4_fkey_contract_code_contract_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.contract_code
    ADD CONSTRAINT class4_fkey_contract_code_contract_id FOREIGN KEY (contract_id) REFERENCES public.contract(id) ON DELETE CASCADE;


--
-- Name: currency_updates class4_fkey_currency_updates_currency_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.currency_updates
    ADD CONSTRAINT class4_fkey_currency_updates_currency_id FOREIGN KEY (currency_id) REFERENCES public.currency(currency_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_items class4_fkey_dynamic_route_items_dynamic_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_items
    ADD CONSTRAINT class4_fkey_dynamic_route_items_dynamic_route_id FOREIGN KEY (dynamic_route_id) REFERENCES public.dynamic_route(dynamic_route_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_items class4_fkey_dynamic_route_items_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_items
    ADD CONSTRAINT class4_fkey_dynamic_route_items_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_override class4_fkey_dynamic_route_override_dynamic_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_override
    ADD CONSTRAINT class4_fkey_dynamic_route_override_dynamic_route_id FOREIGN KEY (dynamic_route_id) REFERENCES public.dynamic_route(dynamic_route_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_override class4_fkey_dynamic_route_override_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_override
    ADD CONSTRAINT class4_fkey_dynamic_route_override_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_pri class4_fkey_dynamic_route_pri_dynamic_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_pri
    ADD CONSTRAINT class4_fkey_dynamic_route_pri_dynamic_route_id FOREIGN KEY (dynamic_route_id) REFERENCES public.dynamic_route(dynamic_route_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_pri class4_fkey_dynamic_route_pri_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_pri
    ADD CONSTRAINT class4_fkey_dynamic_route_pri_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: dynamic_route_qos class4_fkey_dynamic_route_qos_dynamic_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route_qos
    ADD CONSTRAINT class4_fkey_dynamic_route_qos_dynamic_route_id FOREIGN KEY (dynamic_route_id) REFERENCES public.dynamic_route(dynamic_route_id) ON DELETE CASCADE;


--
-- Name: dynamic_route class4_fkey_dynamic_route_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.dynamic_route
    ADD CONSTRAINT class4_fkey_dynamic_route_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES public.time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: invoice class4_fkey_invoice_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice
    ADD CONSTRAINT class4_fkey_invoice_client_id FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE CASCADE;


--
-- Name: invoice_item class4_fkey_invoice_item_invoice_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_item
    ADD CONSTRAINT class4_fkey_invoice_item_invoice_id FOREIGN KEY (invoice_id) REFERENCES public.invoice(invoice_id) ON DELETE CASCADE;


--
-- Name: jurisdiction class4_fkey_jurisdiction_country_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jurisdiction
    ADD CONSTRAINT class4_fkey_jurisdiction_country_id FOREIGN KEY (jurisdiction_country_id) REFERENCES public.jurisdiction_country(id) ON DELETE CASCADE;


--
-- Name: order_user_rate_watch class4_fkey_order_user_rate_watch_alert_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_user_rate_watch
    ADD CONSTRAINT class4_fkey_order_user_rate_watch_alert_id FOREIGN KEY (order_user_alert_id) REFERENCES public.order_user_alert(id);


--
-- Name: product_items class4_fkey_product_items_product_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_items
    ADD CONSTRAINT class4_fkey_product_items_product_id FOREIGN KEY (product_id) REFERENCES public.product(product_id) ON DELETE CASCADE;


--
-- Name: product_items_resource class4_fkey_product_items_resource_item_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_items_resource
    ADD CONSTRAINT class4_fkey_product_items_resource_item_id FOREIGN KEY (item_id) REFERENCES public.product_items(item_id) ON DELETE CASCADE;


--
-- Name: product_items_resource class4_fkey_product_items_resource_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_items_resource
    ADD CONSTRAINT class4_fkey_product_items_resource_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: product_items class4_fkey_product_items_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_items
    ADD CONSTRAINT class4_fkey_product_items_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES public.time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: rate_auto_create_interval class4_fkey_rate_auto_create_interval_rate_create_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_auto_create_interval
    ADD CONSTRAINT class4_fkey_rate_auto_create_interval_rate_create_id FOREIGN KEY (rate_auto_create_id) REFERENCES public.rate_auto_create(id);


--
-- Name: rate class4_fkey_rate_rate_table_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate
    ADD CONSTRAINT class4_fkey_rate_rate_table_id FOREIGN KEY (rate_table_id) REFERENCES public.rate_table(rate_table_id) ON DELETE CASCADE;


--
-- Name: rate_table class4_fkey_rate_table_code_deck_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_table
    ADD CONSTRAINT class4_fkey_rate_table_code_deck_id FOREIGN KEY (code_deck_id) REFERENCES public.code_deck(code_deck_id) ON DELETE SET NULL;


--
-- Name: rate_table class4_fkey_rate_table_currency_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_table
    ADD CONSTRAINT class4_fkey_rate_table_currency_id FOREIGN KEY (currency_id) REFERENCES public.currency(currency_id) ON DELETE SET NULL;


--
-- Name: rate class4_fkey_rate_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate
    ADD CONSTRAINT class4_fkey_rate_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES public.time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource_ip_limit class4_fkey_reosurce_ip_limit_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_ip_limit
    ADD CONSTRAINT class4_fkey_reosurce_ip_limit_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES public.time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource_block class4_fkey_resource_block_ingress_res_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_block
    ADD CONSTRAINT class4_fkey_resource_block_ingress_res_id FOREIGN KEY (ingress_res_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource_block class4_fkey_resource_block_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_block
    ADD CONSTRAINT class4_fkey_resource_block_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES public.time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource class4_fkey_resource_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource
    ADD CONSTRAINT class4_fkey_resource_client_id FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE SET NULL;


--
-- Name: resource_codecs_ref class4_fkey_resource_codec_ref_codec_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_codecs_ref
    ADD CONSTRAINT class4_fkey_resource_codec_ref_codec_id FOREIGN KEY (codec_id) REFERENCES public.codecs(id) ON DELETE CASCADE;


--
-- Name: resource_codecs_ref class4_fkey_resource_codecs_ref_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_codecs_ref
    ADD CONSTRAINT class4_fkey_resource_codecs_ref_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource_direction class4_fkey_resource_direction_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_direction
    ADD CONSTRAINT class4_fkey_resource_direction_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource_direction_template class4_fkey_resource_direction_template_resource_template_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_direction_template
    ADD CONSTRAINT class4_fkey_resource_direction_template_resource_template_id FOREIGN KEY (resource_template_id) REFERENCES public.resource_template(resource_template_id) ON DELETE CASCADE;


--
-- Name: resource_direction_template class4_fkey_resource_direction_template_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_direction_template
    ADD CONSTRAINT class4_fkey_resource_direction_template_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES public.time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource_direction class4_fkey_resource_direction_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_direction
    ADD CONSTRAINT class4_fkey_resource_direction_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES public.time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource class4_fkey_resource_group_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource
    ADD CONSTRAINT class4_fkey_resource_group_id FOREIGN KEY (group_id) REFERENCES public.trunk_group(group_id) ON DELETE SET NULL;


--
-- Name: resource_ip_limit class4_fkey_resource_ip_limit_ip_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_ip_limit
    ADD CONSTRAINT class4_fkey_resource_ip_limit_ip_id FOREIGN KEY (ip_id) REFERENCES public.resource_ip(resource_ip_id) ON DELETE CASCADE;


--
-- Name: resource_ip class4_fkey_resource_ip_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_ip
    ADD CONSTRAINT class4_fkey_resource_ip_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource_prefix class4_fkey_resource_prefix_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_prefix
    ADD CONSTRAINT class4_fkey_resource_prefix_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource class4_fkey_resource_rate_table_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource
    ADD CONSTRAINT class4_fkey_resource_rate_table_id FOREIGN KEY (rate_table_id) REFERENCES public.rate_table(rate_table_id) ON DELETE SET NULL;


--
-- Name: resource_replace_action class4_fkey_resource_replace_action_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_replace_action
    ADD CONSTRAINT class4_fkey_resource_replace_action_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id);


--
-- Name: resource class4_fkey_resource_route_strategy_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource
    ADD CONSTRAINT class4_fkey_resource_route_strategy_id FOREIGN KEY (route_strategy_id) REFERENCES public.route_strategy(route_strategy_id) ON DELETE SET NULL;


--
-- Name: resource_translation_ref class4_fkey_resource_translation_ref_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_translation_ref
    ADD CONSTRAINT class4_fkey_resource_translation_ref_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: resource_translation_ref class4_fkey_resource_translation_ref_time_profile_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_translation_ref
    ADD CONSTRAINT class4_fkey_resource_translation_ref_time_profile_id FOREIGN KEY (time_profile_id) REFERENCES public.time_profile(time_profile_id) ON DELETE SET NULL;


--
-- Name: resource_translation_ref class4_fkey_resource_translation_ref_translation_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_translation_ref
    ADD CONSTRAINT class4_fkey_resource_translation_ref_translation_id FOREIGN KEY (translation_id) REFERENCES public.digit_translation(translation_id) ON DELETE CASCADE;


--
-- Name: role_privilege class4_fkey_role_privilege_role_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role_privilege
    ADD CONSTRAINT class4_fkey_role_privilege_role_id FOREIGN KEY (role_id) REFERENCES public.role(role_id);


--
-- Name: role_privilege class4_fkey_role_privilege_system_function_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role_privilege
    ADD CONSTRAINT class4_fkey_role_privilege_system_function_id FOREIGN KEY (system_function_id) REFERENCES public.system_function(system_function_id);


--
-- Name: route class4_fkey_route_dynamic_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.route
    ADD CONSTRAINT class4_fkey_route_dynamic_route_id FOREIGN KEY (dynamic_route_id) REFERENCES public.dynamic_route(dynamic_route_id) ON DELETE SET NULL;


--
-- Name: route class4_fkey_route_route_strategy_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.route
    ADD CONSTRAINT class4_fkey_route_route_strategy_id FOREIGN KEY (route_strategy_id) REFERENCES public.route_strategy(route_strategy_id) ON DELETE CASCADE;


--
-- Name: route class4_fkey_route_static_route_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.route
    ADD CONSTRAINT class4_fkey_route_static_route_id FOREIGN KEY (static_route_id) REFERENCES public.product(product_id) ON DELETE SET NULL;


--
-- Name: sell_order class4_fkey_sell_order_client_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sell_order
    ADD CONSTRAINT class4_fkey_sell_order_client_id FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE CASCADE;


--
-- Name: sell_order class4_fkey_sell_order_resource_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sell_order
    ADD CONSTRAINT class4_fkey_sell_order_resource_id FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: sell_order class4_fkey_sell_order_user_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sell_order
    ADD CONSTRAINT class4_fkey_sell_order_user_id FOREIGN KEY (user_id) REFERENCES public.order_user(id) ON DELETE CASCADE;


--
-- Name: signup_ip class4_fkey_signup_ip_signup_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.signup_ip
    ADD CONSTRAINT class4_fkey_signup_ip_signup_id FOREIGN KEY (signup_id) REFERENCES public.signup(id) ON DELETE CASCADE;


--
-- Name: translation_item class4_fkey_translation_item_translation_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.translation_item
    ADD CONSTRAINT class4_fkey_translation_item_translation_id FOREIGN KEY (translation_id) REFERENCES public.digit_translation(translation_id) ON DELETE CASCADE;


--
-- Name: buy_order class4_pkey_buy_order_user_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.buy_order
    ADD CONSTRAINT class4_pkey_buy_order_user_id FOREIGN KEY (user_id) REFERENCES public.order_user(id) ON DELETE CASCADE;


--
-- Name: resource_block class4_pkey_egress; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_block
    ADD CONSTRAINT class4_pkey_egress FOREIGN KEY (engress_res_id) REFERENCES public.resource(resource_id) ON DELETE SET NULL;


--
-- Name: client_low_balance_config client_low_balance_config_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.client_low_balance_config
    ADD CONSTRAINT client_low_balance_config_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE CASCADE;


--
-- Name: did_assign did_assign_egress_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_assign
    ADD CONSTRAINT did_assign_egress_id_fkey FOREIGN KEY (egress_id) REFERENCES public.resource(resource_id);


--
-- Name: did_request_detail did_request_detail_did_request_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_request_detail
    ADD CONSTRAINT did_request_detail_did_request_id_fkey FOREIGN KEY (did_request_id) REFERENCES public.did_request(id);


--
-- Name: did_request_detail did_request_detail_egress_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_request_detail
    ADD CONSTRAINT did_request_detail_egress_id_fkey FOREIGN KEY (egress_id) REFERENCES public.resource(resource_id);


--
-- Name: did_request_detail did_request_detail_number_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.did_request_detail
    ADD CONSTRAINT did_request_detail_number_fkey FOREIGN KEY (number) REFERENCES public.ingress_did_repository(number) ON DELETE CASCADE;


--
-- Name: egress_profile egress_profile_egress_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.egress_profile
    ADD CONSTRAINT egress_profile_egress_id_fkey FOREIGN KEY (egress_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: egress_profile egress_profile_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.egress_profile
    ADD CONSTRAINT egress_profile_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.switch_profile(id) ON DELETE CASCADE;


--
-- Name: exchange_agent_import_target_push_job exchange_agent_import_target_push_job_import_id_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_import_target_push_job
    ADD CONSTRAINT exchange_agent_import_target_push_job_import_id_pkey FOREIGN KEY (import_id) REFERENCES public.exchange_agent_import_target_push(id) ON DELETE CASCADE;


--
-- Name: exchange_agent_send_mail_log_list exchange_agent_send_email_log_list; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_send_mail_log_list
    ADD CONSTRAINT exchange_agent_send_email_log_list FOREIGN KEY (client_id) REFERENCES public.client(client_id) ON DELETE CASCADE;


--
-- Name: exchange_agent_send_mail_log exchange_agent_send_mail_log_email_template_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_send_mail_log
    ADD CONSTRAINT exchange_agent_send_mail_log_email_template_fkey FOREIGN KEY (email_template) REFERENCES public.exchange_agent_mail_tmplate(id) ON DELETE CASCADE;


--
-- Name: exchange_agent_send_mail_log_list exchange_agent_send_mail_log_list_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_send_mail_log_list
    ADD CONSTRAINT exchange_agent_send_mail_log_list_log_id_fkey FOREIGN KEY (log_id) REFERENCES public.exchange_agent_send_mail_log(id) ON DELETE CASCADE;


--
-- Name: exchange_agent_user exchange_agent_user_role_id_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_agent_user
    ADD CONSTRAINT exchange_agent_user_role_id_pkey FOREIGN KEY (role_id) REFERENCES public.exchange_sys_role(role_id);


--
-- Name: exchange_false_del exchange_false_del_resource_id_key; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_false_del
    ADD CONSTRAINT exchange_false_del_resource_id_key FOREIGN KEY (resource_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: exchange_job_list exchange_job_list_job_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_list
    ADD CONSTRAINT exchange_job_list_job_id FOREIGN KEY (job_id) REFERENCES public.exchange_job(id) ON DELETE CASCADE;


--
-- Name: exchange_job_list exchange_job_list_trunk_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_list
    ADD CONSTRAINT exchange_job_list_trunk_id FOREIGN KEY (trunk_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: exchange_job exchange_job_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job
    ADD CONSTRAINT exchange_job_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.product_rout_rate_table(id) ON DELETE CASCADE;


--
-- Name: exchange_job_session_block_log exchange_job_session_block_log; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session_block_log
    ADD CONSTRAINT exchange_job_session_block_log FOREIGN KEY (session_id) REFERENCES public.exchange_job_session(id) ON DELETE CASCADE;


--
-- Name: exchange_job_session_block_log exchange_job_session_block_log_trunk_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session_block_log
    ADD CONSTRAINT exchange_job_session_block_log_trunk_id FOREIGN KEY (trunk_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: exchange_job_session exchange_job_session_job_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session
    ADD CONSTRAINT exchange_job_session_job_id FOREIGN KEY (job_id) REFERENCES public.exchange_job(id) ON DELETE CASCADE;


--
-- Name: exchange_job_session_list exchange_job_session_list_session_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session_list
    ADD CONSTRAINT exchange_job_session_list_session_id FOREIGN KEY (session_id) REFERENCES public.exchange_job_session(id) ON DELETE CASCADE;


--
-- Name: exchange_job_session_list exchange_job_session_list_trunk_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_job_session_list
    ADD CONSTRAINT exchange_job_session_list_trunk_id FOREIGN KEY (trunk_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: exchange_par_account exchange_par_account_role_id_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_par_account
    ADD CONSTRAINT exchange_par_account_role_id_pkey FOREIGN KEY (role_id) REFERENCES public.exchange_sys_role(role_id);


--
-- Name: exchange_simple_session_list exchange_simple_session_list_session_id_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_simple_session_list
    ADD CONSTRAINT exchange_simple_session_list_session_id_pkey FOREIGN KEY (session_id) REFERENCES public.exchange_simple_session(id) ON DELETE CASCADE;


--
-- Name: exchange_simple_session_list exchange_simple_session_list_trunk_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_simple_session_list
    ADD CONSTRAINT exchange_simple_session_list_trunk_pkey FOREIGN KEY (trunk_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: exchange_sys_pri exchange_sys_pri_pri_module_id_key; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_pri
    ADD CONSTRAINT exchange_sys_pri_pri_module_id_key FOREIGN KEY (module_id) REFERENCES public.exchange_sys_module(id);


--
-- Name: exchange_sys_role_pri exchange_sys_role_pri_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_role_pri
    ADD CONSTRAINT exchange_sys_role_pri_id_fkey FOREIGN KEY (pri_id) REFERENCES public.exchange_sys_pri(id);


--
-- Name: exchange_sys_role_pri exchange_sys_role_pri_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.exchange_sys_role_pri
    ADD CONSTRAINT exchange_sys_role_pri_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.exchange_sys_role(role_id);


--
-- Name: product_agents_ref fkey_product_agent_agent_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_agents_ref
    ADD CONSTRAINT fkey_product_agent_agent_id FOREIGN KEY (agent_id) REFERENCES public.agent(agent_id) ON DELETE CASCADE;


--
-- Name: product_agents_ref fkey_product_agent_product_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_agents_ref
    ADD CONSTRAINT fkey_product_agent_product_id FOREIGN KEY (product_id) REFERENCES public.product_route_rate_table(id) ON DELETE CASCADE;


--
-- Name: fraud_detection_log_detail fraud_detection_log_detail_fraud_detection_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_detection_log_detail
    ADD CONSTRAINT fraud_detection_log_detail_fraud_detection_log_id_fkey FOREIGN KEY (fraud_detection_log_id) REFERENCES public.fraud_detection_log(id) ON DELETE CASCADE;


--
-- Name: fraud_detection_log fraud_detection_log_fraud_detection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fraud_detection_log
    ADD CONSTRAINT fraud_detection_log_fraud_detection_id_fkey FOREIGN KEY (fraud_detection_id) REFERENCES public.fraud_detection(id) ON DELETE CASCADE;


--
-- Name: hang_calls_list hang_calls_list_hang_calls_history_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.hang_calls_list
    ADD CONSTRAINT hang_calls_list_hang_calls_history_id_fkey FOREIGN KEY (hang_calls_history_id) REFERENCES public.hang_calls_history(id);


--
-- Name: ingress_did_repository ingress_did_repository_egress_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ingress_did_repository
    ADD CONSTRAINT ingress_did_repository_egress_id_fkey FOREIGN KEY (egress_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: ingress_did_repository ingress_did_repository_ingress_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ingress_did_repository
    ADD CONSTRAINT ingress_did_repository_ingress_id_fkey FOREIGN KEY (ingress_id) REFERENCES public.resource(resource_id) ON DELETE CASCADE;


--
-- Name: invalid_detection_block_log invalid_detection_block_log_rule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_detection_block_log
    ADD CONSTRAINT invalid_detection_block_log_rule_id_fkey FOREIGN KEY (rule_id) REFERENCES public.invalid_number_detection(id) ON DELETE CASCADE;


--
-- Name: invalid_number_detection_log_detail invalid_number_detection_log_detail_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_number_detection_log_detail
    ADD CONSTRAINT invalid_number_detection_log_detail_log_id_fkey FOREIGN KEY (log_id) REFERENCES public.invalid_number_detection_log(id) ON DELETE CASCADE;


--
-- Name: invalid_number_detection_log invalid_number_detection_log_detection_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invalid_number_detection_log
    ADD CONSTRAINT invalid_number_detection_log_detection_id_fkey FOREIGN KEY (detection_id) REFERENCES public.invalid_number_detection(id) ON DELETE CASCADE;


--
-- Name: invoice_calls_detail_by_trunk invoice_calls_detail_by_trunk_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_calls_detail_by_trunk
    ADD CONSTRAINT invoice_calls_detail_by_trunk_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES public.invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: invoice_calls_total_by_trunk invoice_calls_total_by_trunk_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_calls_total_by_trunk
    ADD CONSTRAINT invoice_calls_total_by_trunk_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES public.invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: invoice_show_code_100 invoice_show_code_100_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_show_code_100
    ADD CONSTRAINT invoice_show_code_100_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES public.invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: invoice_show_code_name invoice_show_code_name_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_show_code_name
    ADD CONSTRAINT invoice_show_code_name_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES public.invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: invoice_show_country invoice_show_country_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_show_country
    ADD CONSTRAINT invoice_show_country_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES public.invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: invoice_show_date invoice_show_date_invoice_no_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoice_show_date
    ADD CONSTRAINT invoice_show_date_invoice_no_fkey FOREIGN KEY (invoice_no) REFERENCES public.invoice(invoice_number) ON DELETE CASCADE;


--
-- Name: lnp_request_detail lnp_request_detail_request_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lnp_request_detail
    ADD CONSTRAINT lnp_request_detail_request_id_fkey FOREIGN KEY (request_id) REFERENCES public.lnp_request(id);


--
-- Name: mail_cdr_log_detail mail_cdr_log_detail_mail_cdr_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.mail_cdr_log_detail
    ADD CONSTRAINT mail_cdr_log_detail_mail_cdr_log_id_fkey FOREIGN KEY (mail_cdr_log_id) REFERENCES public.mail_cdr_log(id);


--
-- Name: ocn_lata ocn_lata_rate_table_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ocn_lata
    ADD CONSTRAINT ocn_lata_rate_table_id_fkey FOREIGN KEY (rate_table_id) REFERENCES public.rate_table(rate_table_id);


--
-- Name: order_user order_user_role_id_pkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_user
    ADD CONSTRAINT order_user_role_id_pkey FOREIGN KEY (role_id) REFERENCES public.exchange_sys_role(role_id);


--
-- Name: payment_invoice payment_invoice_invoice_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_invoice
    ADD CONSTRAINT payment_invoice_invoice_id_fkey FOREIGN KEY (invoice_id) REFERENCES public.invoice(invoice_id);


--
-- Name: payment_invoice payment_invoice_payment_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.payment_invoice
    ADD CONSTRAINT payment_invoice_payment_id_fkey FOREIGN KEY (payment_id) REFERENCES public.client_payment(client_payment_id);


--
-- Name: product_route_rate_table product_route_rate_table_rate_table_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_route_rate_table
    ADD CONSTRAINT product_route_rate_table_rate_table_id_fkey FOREIGN KEY (rate_table_id) REFERENCES public.rate_table(rate_table_id) ON DELETE CASCADE;


--
-- Name: product_route_rate_table product_route_rate_table_route_strategy_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_route_rate_table
    ADD CONSTRAINT product_route_rate_table_route_strategy_id_fkey FOREIGN KEY (route_strategy_id) REFERENCES public.route_strategy(route_strategy_id) ON DELETE CASCADE;


--
-- Name: rate_generation_code_deck rate_generation_code_deck_rate_generation_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_code_deck
    ADD CONSTRAINT rate_generation_code_deck_rate_generation_template_id_fkey FOREIGN KEY (rate_generation_template_id) REFERENCES public.rate_generation_template(id);


--
-- Name: rate_generation_history_detail rate_generation_history_detail_email_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_history_detail
    ADD CONSTRAINT rate_generation_history_detail_email_template_id_fkey FOREIGN KEY (email_template_id) REFERENCES public.rate_email_template(id) ON DELETE SET NULL;


--
-- Name: rate_generation_history_detail rate_generation_history_detail_rate_generation_history_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_history_detail
    ADD CONSTRAINT rate_generation_history_detail_rate_generation_history_id_fkey FOREIGN KEY (rate_generation_history_id) REFERENCES public.rate_generation_history(id) ON DELETE CASCADE;


--
-- Name: rate_generation_history rate_generation_history_rate_generation_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_history
    ADD CONSTRAINT rate_generation_history_rate_generation_template_id_fkey FOREIGN KEY (rate_generation_template_id) REFERENCES public.rate_generation_template(id) ON DELETE CASCADE;


--
-- Name: rate_generation_template_detail rate_generation_template_detai_rate_generation_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_template_detail
    ADD CONSTRAINT rate_generation_template_detai_rate_generation_template_id_fkey FOREIGN KEY (rate_generation_template_id) REFERENCES public.rate_generation_template(id) ON DELETE CASCADE;


--
-- Name: rate_generation_template_margin rate_generation_template_margi_rate_generation_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_generation_template_margin
    ADD CONSTRAINT rate_generation_template_margi_rate_generation_template_id_fkey FOREIGN KEY (rate_generation_template_id) REFERENCES public.rate_generation_template(id) ON DELETE CASCADE;


--
-- Name: rate_mail_decks_files rate_mail_decks_files_rate_mail_decks_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_mail_decks_files
    ADD CONSTRAINT rate_mail_decks_files_rate_mail_decks_id_fkey FOREIGN KEY (rate_mail_decks_id) REFERENCES public.rate_mail_decks(id);


--
-- Name: rate_management_option rate_management_option_rate_table_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_management_option
    ADD CONSTRAINT rate_management_option_rate_table_id_fkey FOREIGN KEY (rate_table_id) REFERENCES public.rate_table(rate_table_id) ON DELETE CASCADE;


--
-- Name: rate_send_log_detail rate_send_log_detail_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rate_send_log_detail
    ADD CONSTRAINT rate_send_log_detail_log_id_fkey FOREIGN KEY (log_id) REFERENCES public.rate_send_log(id) ON DELETE CASCADE;


--
-- Name: rerate_cdr_download_log rerate_cdr_download_log_task_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rerate_cdr_download_log
    ADD CONSTRAINT rerate_cdr_download_log_task_id_fkey FOREIGN KEY (task_id) REFERENCES public.rerate_cdr_task(id) ON DELETE SET NULL;


--
-- Name: rerate_report_exec_log rerate_report_exec_log_task_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.rerate_report_exec_log
    ADD CONSTRAINT rerate_report_exec_log_task_id_fkey FOREIGN KEY (task_id) REFERENCES public.rerate_cdr_task(id) ON DELETE SET NULL;


--
-- Name: reseller_client reseller_client_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reseller_client
    ADD CONSTRAINT reseller_client_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.client(client_id);


--
-- Name: reseller_client reseller_client_reseller_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reseller_client
    ADD CONSTRAINT reseller_client_reseller_id_fkey FOREIGN KEY (reseller_id) REFERENCES public.reseller(id);


--
-- Name: resource_next_route_rule_template resource_next_route_rule_template_resource_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_next_route_rule_template
    ADD CONSTRAINT resource_next_route_rule_template_resource_template_id_fkey FOREIGN KEY (resource_template_id) REFERENCES public.resource_template(resource_template_id) ON DELETE CASCADE;


--
-- Name: resource_replace_action_template resource_replace_action_template_resource_template_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.resource_replace_action_template
    ADD CONSTRAINT resource_replace_action_template_resource_template_id_fkey FOREIGN KEY (resource_template_id) REFERENCES public.resource_template(resource_template_id) ON DELETE CASCADE;


--
-- Name: sys_pri sys_pri_pri_module_id_key; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sys_pri
    ADD CONSTRAINT sys_pri_pri_module_id_key FOREIGN KEY (module_id) REFERENCES public.sys_module(id) ON DELETE CASCADE;


--
-- Name: sys_role_pri sys_role_pri_pri_name_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sys_role_pri
    ADD CONSTRAINT sys_role_pri_pri_name_fkey FOREIGN KEY (pri_name) REFERENCES public.sys_pri(pri_name) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: sys_role_pri sys_role_pri_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.sys_role_pri
    ADD CONSTRAINT sys_role_pri_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.sys_role(role_id);


--
-- Name: users_limit users_limit_client_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users_limit
    ADD CONSTRAINT users_limit_client_id_fkey FOREIGN KEY (client_id) REFERENCES public.client(client_id);


--
-- Name: users_limit users_limit_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users_limit
    ADD CONSTRAINT users_limit_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id);


--
-- Name: vendor_invoice_detail vendor_invoice_detail_vendor_invoice_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendor_invoice_detail
    ADD CONSTRAINT vendor_invoice_detail_vendor_invoice_id_fkey FOREIGN KEY (vendor_invoice_id) REFERENCES public.vendor_invoice(vendor_invoice_id) ON DELETE CASCADE;


--
-- Name: vendor_invoice_dispute vendor_invoice_dispute_vendor_invoice_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.vendor_invoice_dispute
    ADD CONSTRAINT vendor_invoice_dispute_vendor_invoice_id_fkey FOREIGN KEY (vendor_invoice_id) REFERENCES public.vendor_invoice(vendor_invoice_id) ON DELETE CASCADE;


--
-- Name: switch_profile voip_server_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.switch_profile
    ADD CONSTRAINT voip_server_id FOREIGN KEY (voip_gateway_id) REFERENCES public.voip_gateway(id);


--
-- PostgreSQL database dump complete
--

